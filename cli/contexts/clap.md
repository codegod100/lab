Project Path: clap

Source Tree:

```txt
clap
├── CHANGELOG.md
├── CITATION.cff
├── CONTRIBUTING.md
├── Cargo.lock
├── Cargo.toml
├── LICENSE-APACHE
├── LICENSE-MIT
├── Makefile
├── README.md
├── assets
│   └── clap.png
├── clap_bench
│   ├── Cargo.toml
│   ├── benches
│   │   ├── complex.rs
│   │   ├── empty.rs
│   │   ├── ripgrep.rs
│   │   ├── rustup.rs
│   │   └── simple.rs
│   └── src
│       └── lib.rs
├── clap_builder
│   ├── CONTRIBUTING.md
│   ├── Cargo.toml
│   ├── LICENSE-APACHE
│   ├── LICENSE-MIT
│   ├── README.md
│   └── src
│       ├── builder
│       │   ├── action.rs
│       │   ├── app_settings.rs
│       │   ├── arg.rs
│       │   ├── arg_group.rs
│       │   ├── arg_predicate.rs
│       │   ├── arg_settings.rs
│       │   ├── command.rs
│       │   ├── debug_asserts.rs
│       │   ├── ext.rs
│       │   ├── mod.rs
│       │   ├── os_str.rs
│       │   ├── possible_value.rs
│       │   ├── range.rs
│       │   ├── resettable.rs
│       │   ├── str.rs
│       │   ├── styled_str.rs
│       │   ├── styling.rs
│       │   ├── tests.rs
│       │   ├── value_hint.rs
│       │   └── value_parser.rs
│       ├── derive.rs
│       ├── error
│       │   ├── context.rs
│       │   ├── format.rs
│       │   ├── kind.rs
│       │   └── mod.rs
│       ├── lib.rs
│       ├── macros.rs
│       ├── mkeymap.rs
│       ├── output
│       │   ├── fmt.rs
│       │   ├── help.rs
│       │   ├── help_template.rs
│       │   ├── mod.rs
│       │   ├── textwrap
│       │   │   ├── core.rs
│       │   │   ├── mod.rs
│       │   │   ├── word_separators.rs
│       │   │   └── wrap_algorithms.rs
│       │   └── usage.rs
│       ├── parser
│       │   ├── arg_matcher.rs
│       │   ├── error.rs
│       │   ├── features
│       │   │   ├── mod.rs
│       │   │   └── suggestions.rs
│       │   ├── matches
│       │   │   ├── arg_matches.rs
│       │   │   ├── matched_arg.rs
│       │   │   ├── mod.rs
│       │   │   └── value_source.rs
│       │   ├── mod.rs
│       │   ├── parser.rs
│       │   └── validator.rs
│       └── util
│           ├── any_value.rs
│           ├── color.rs
│           ├── flat_map.rs
│           ├── flat_set.rs
│           ├── graph.rs
│           ├── id.rs
│           ├── mod.rs
│           └── str_to_bool.rs
├── clap_complete
│   ├── CHANGELOG.md
│   ├── CONTRIBUTING.md
│   ├── Cargo.toml
│   ├── LICENSE-APACHE
│   ├── LICENSE-MIT
│   ├── README.md
│   ├── examples
│   │   ├── completion-derive.rs
│   │   ├── completion.rs
│   │   ├── dynamic.rs
│   │   └── exhaustive.rs
│   ├── src
│   │   ├── aot
│   │   │   ├── generator
│   │   │   │   ├── mod.rs
│   │   │   │   └── utils.rs
│   │   │   ├── mod.rs
│   │   │   └── shells
│   │   │       ├── bash.rs
│   │   │       ├── elvish.rs
│   │   │       ├── fish.rs
│   │   │       ├── mod.rs
│   │   │       ├── powershell.rs
│   │   │       ├── shell.rs
│   │   │       └── zsh.rs
│   │   ├── engine
│   │   │   ├── candidate.rs
│   │   │   ├── complete.rs
│   │   │   ├── custom.rs
│   │   │   └── mod.rs
│   │   ├── env
│   │   │   ├── mod.rs
│   │   │   └── shells.rs
│   │   ├── lib.rs
│   │   └── macros.rs
│   └── tests
│       ├── examples.rs
│       ├── snapshots
│       │   ├── aliases.bash
│       │   ├── aliases.elvish
│       │   ├── aliases.fish
│       │   ├── aliases.ps1
│       │   ├── aliases.zsh
│       │   ├── basic.bash
│       │   ├── basic.elvish
│       │   ├── basic.fish
│       │   ├── basic.ps1
│       │   ├── basic.zsh
│       │   ├── custom_bin_name.bash
│       │   ├── custom_bin_name.elvish
│       │   ├── custom_bin_name.fish
│       │   ├── custom_bin_name.ps1
│       │   ├── custom_bin_name.zsh
│       │   ├── feature_sample.bash
│       │   ├── feature_sample.elvish
│       │   ├── feature_sample.fish
│       │   ├── feature_sample.ps1
│       │   ├── feature_sample.zsh
│       │   ├── home
│       │   │   ├── dynamic-env
│       │   │   │   └── exhaustive
│       │   │   │       ├── bash
│       │   │   │       ├── elvish
│       │   │   │       │   └── elvish
│       │   │   │       │       └── rc.elv
│       │   │   │       ├── fish
│       │   │   │       │   └── fish
│       │   │   │       │       ├── completions
│       │   │   │       │       │   └── exhaustive.fish
│       │   │   │       │       └── config.fish
│       │   │   │       └── zsh
│       │   │   │           └── zsh
│       │   │   │               └── _exhaustive
│       │   │   └── static
│       │   │       └── exhaustive
│       │   │           ├── bash
│       │   │           ├── elvish
│       │   │           │   └── elvish
│       │   │           │       └── rc.elv
│       │   │           ├── fish
│       │   │           │   └── fish
│       │   │           │       ├── completions
│       │   │           │       │   └── exhaustive.fish
│       │   │           │       └── config.fish
│       │   │           ├── powershell
│       │   │           │   └── powershell
│       │   │           │       └── Microsoft.PowerShell_profile.ps1
│       │   │           └── zsh
│       │   │               └── zsh
│       │   │                   └── _exhaustive
│       │   ├── quoting.bash
│       │   ├── quoting.elvish
│       │   ├── quoting.fish
│       │   ├── quoting.ps1
│       │   ├── quoting.zsh
│       │   ├── register_dynamic.fish
│       │   ├── register_minimal.bash
│       │   ├── special_commands.bash
│       │   ├── special_commands.elvish
│       │   ├── special_commands.fish
│       │   ├── special_commands.ps1
│       │   ├── special_commands.zsh
│       │   ├── sub_subcommands.bash
│       │   ├── sub_subcommands.elvish
│       │   ├── sub_subcommands.fish
│       │   ├── sub_subcommands.ps1
│       │   ├── sub_subcommands.zsh
│       │   ├── subcommand_last.bash
│       │   ├── subcommand_last.elvish
│       │   ├── subcommand_last.fish
│       │   ├── subcommand_last.ps1
│       │   ├── subcommand_last.zsh
│       │   ├── two_multi_valued_arguments.bash
│       │   ├── two_multi_valued_arguments.elvish
│       │   ├── two_multi_valued_arguments.fish
│       │   ├── two_multi_valued_arguments.ps1
│       │   ├── two_multi_valued_arguments.zsh
│       │   ├── value_hint.bash
│       │   ├── value_hint.elvish
│       │   ├── value_hint.fish
│       │   ├── value_hint.ps1
│       │   ├── value_hint.zsh
│       │   ├── value_terminator.bash
│       │   ├── value_terminator.elvish
│       │   ├── value_terminator.fish
│       │   ├── value_terminator.ps1
│       │   └── value_terminator.zsh
│       └── testsuite
│           ├── bash.rs
│           ├── common.rs
│           ├── elvish.rs
│           ├── engine.rs
│           ├── fish.rs
│           ├── general.rs
│           ├── main.rs
│           ├── powershell.rs
│           └── zsh.rs
├── clap_complete_nushell
│   ├── CHANGELOG.md
│   ├── Cargo.toml
│   ├── LICENSE-APACHE
│   ├── LICENSE-MIT
│   ├── README.md
│   ├── examples
│   │   ├── nushell_completion.rs
│   │   ├── sub_subcommands.rs
│   │   └── test.rs
│   ├── src
│   │   └── lib.rs
│   └── tests
│       ├── common.rs
│       ├── completion.rs
│       ├── nushell.rs
│       └── snapshots
│           ├── aliases.nu
│           ├── basic.nu
│           ├── feature_sample.nu
│           ├── home
│           │   └── static
│           │       └── test
│           │           └── nu
│           ├── quoting.nu
│           ├── special_commands.nu
│           ├── sub_subcommands.nu
│           └── value_hint.nu
├── clap_derive
│   ├── CONTRIBUTING.md
│   ├── Cargo.toml
│   ├── LICENSE-APACHE
│   ├── LICENSE-MIT
│   ├── README.md
│   └── src
│       ├── attr.rs
│       ├── derives
│       │   ├── args.rs
│       │   ├── into_app.rs
│       │   ├── mod.rs
│       │   ├── parser.rs
│       │   ├── subcommand.rs
│       │   └── value_enum.rs
│       ├── dummies.rs
│       ├── item.rs
│       ├── lib.rs
│       ├── macros.rs
│       └── utils
│           ├── doc_comments.rs
│           ├── error.rs
│           ├── mod.rs
│           ├── spanned.rs
│           └── ty.rs
├── clap_lex
│   ├── CHANGELOG.md
│   ├── CONTRIBUTING.md
│   ├── Cargo.toml
│   ├── LICENSE-APACHE
│   ├── LICENSE-MIT
│   ├── README.md
│   ├── src
│   │   ├── ext.rs
│   │   └── lib.rs
│   └── tests
│       └── testsuite
│           ├── lexer.rs
│           ├── main.rs
│           ├── parsed.rs
│           └── shorts.rs
├── clap_mangen
│   ├── CHANGELOG.md
│   ├── CONTRIBUTING.md
│   ├── Cargo.toml
│   ├── LICENSE-APACHE
│   ├── LICENSE-MIT
│   ├── README.md
│   ├── examples
│   │   └── man.rs
│   ├── src
│   │   ├── lib.rs
│   │   └── render.rs
│   └── tests
│       ├── snapshots
│       │   ├── aliases.bash.roff
│       │   ├── basic.bash.roff
│       │   ├── feature_sample.bash.roff
│       │   ├── help_headings.bash.roff
│       │   ├── hidden_option.bash.roff
│       │   ├── possible_values.bash.roff
│       │   ├── quoting.bash.roff
│       │   ├── special_commands.bash.roff
│       │   ├── sub_subcommand_help.roff
│       │   ├── sub_subcommands.bash.roff
│       │   ├── value_env.bash.roff
│       │   ├── value_hint.bash.roff
│       │   └── value_name_without_arg.bash.roff
│       └── testsuite
│           ├── common.rs
│           ├── main.rs
│           └── roff.rs
├── committed.toml
├── deny.toml
├── examples
│   ├── README.md
│   ├── cargo-example-derive.md
│   ├── cargo-example-derive.rs
│   ├── cargo-example.md
│   ├── cargo-example.rs
│   ├── demo.md
│   ├── demo.rs
│   ├── derive_ref
│   │   ├── augment_args.rs
│   │   ├── augment_subcommands.rs
│   │   ├── flatten_hand_args.rs
│   │   ├── hand_subcommand.rs
│   │   └── interop_tests.md
│   ├── escaped-positional-derive.md
│   ├── escaped-positional-derive.rs
│   ├── escaped-positional.md
│   ├── escaped-positional.rs
│   ├── find.md
│   ├── find.rs
│   ├── git-derive.md
│   ├── git-derive.rs
│   ├── git.md
│   ├── git.rs
│   ├── multicall-busybox.md
│   ├── multicall-busybox.rs
│   ├── multicall-hostname.md
│   ├── multicall-hostname.rs
│   ├── pacman.md
│   ├── pacman.rs
│   ├── repl-derive.rs
│   ├── repl.rs
│   ├── tutorial_builder
│   │   ├── 01_quick.md
│   │   ├── 01_quick.rs
│   │   ├── 02_app_settings.md
│   │   ├── 02_app_settings.rs
│   │   ├── 02_apps.md
│   │   ├── 02_apps.rs
│   │   ├── 02_crate.md
│   │   ├── 02_crate.rs
│   │   ├── 03_01_flag_bool.md
│   │   ├── 03_01_flag_bool.rs
│   │   ├── 03_01_flag_count.md
│   │   ├── 03_01_flag_count.rs
│   │   ├── 03_02_option.md
│   │   ├── 03_02_option.rs
│   │   ├── 03_02_option_mult.md
│   │   ├── 03_02_option_mult.rs
│   │   ├── 03_03_positional.md
│   │   ├── 03_03_positional.rs
│   │   ├── 03_03_positional_mult.md
│   │   ├── 03_03_positional_mult.rs
│   │   ├── 03_04_subcommands.md
│   │   ├── 03_04_subcommands.rs
│   │   ├── 03_05_default_values.md
│   │   ├── 03_05_default_values.rs
│   │   ├── 03_06_required.md
│   │   ├── 03_06_required.rs
│   │   ├── 04_01_enum.md
│   │   ├── 04_01_enum.rs
│   │   ├── 04_01_possible.md
│   │   ├── 04_01_possible.rs
│   │   ├── 04_02_parse.md
│   │   ├── 04_02_parse.rs
│   │   ├── 04_02_validate.md
│   │   ├── 04_02_validate.rs
│   │   ├── 04_03_relations.md
│   │   ├── 04_03_relations.rs
│   │   ├── 04_04_custom.md
│   │   ├── 04_04_custom.rs
│   │   └── 05_01_assert.rs
│   ├── tutorial_derive
│   │   ├── 01_quick.md
│   │   ├── 01_quick.rs
│   │   ├── 02_app_settings.md
│   │   ├── 02_app_settings.rs
│   │   ├── 02_apps.md
│   │   ├── 02_apps.rs
│   │   ├── 02_crate.md
│   │   ├── 02_crate.rs
│   │   ├── 03_01_flag_bool.md
│   │   ├── 03_01_flag_bool.rs
│   │   ├── 03_01_flag_count.md
│   │   ├── 03_01_flag_count.rs
│   │   ├── 03_02_option.md
│   │   ├── 03_02_option.rs
│   │   ├── 03_02_option_mult.md
│   │   ├── 03_02_option_mult.rs
│   │   ├── 03_03_positional.md
│   │   ├── 03_03_positional.rs
│   │   ├── 03_03_positional_mult.md
│   │   ├── 03_03_positional_mult.rs
│   │   ├── 03_04_subcommands.md
│   │   ├── 03_04_subcommands.rs
│   │   ├── 03_04_subcommands_alt.rs
│   │   ├── 03_05_default_values.md
│   │   ├── 03_05_default_values.rs
│   │   ├── 03_06_optional.md
│   │   ├── 03_06_optional.rs
│   │   ├── 04_01_enum.md
│   │   ├── 04_01_enum.rs
│   │   ├── 04_02_parse.md
│   │   ├── 04_02_parse.rs
│   │   ├── 04_02_validate.md
│   │   ├── 04_02_validate.rs
│   │   ├── 04_03_relations.md
│   │   ├── 04_03_relations.rs
│   │   ├── 04_04_custom.md
│   │   ├── 04_04_custom.rs
│   │   └── 05_01_assert.rs
│   ├── typed-derive.md
│   └── typed-derive.rs
├── release.toml
├── src
│   ├── _cookbook
│   │   ├── cargo_example.rs
│   │   ├── cargo_example_derive.rs
│   │   ├── escaped_positional.rs
│   │   ├── escaped_positional_derive.rs
│   │   ├── find.rs
│   │   ├── git.rs
│   │   ├── git_derive.rs
│   │   ├── mod.rs
│   │   ├── multicall_busybox.rs
│   │   ├── multicall_hostname.rs
│   │   ├── pacman.rs
│   │   ├── repl.rs
│   │   ├── repl_derive.rs
│   │   └── typed_derive.rs
│   ├── _derive
│   │   ├── _tutorial.rs
│   │   └── mod.rs
│   ├── _faq.rs
│   ├── _features.rs
│   ├── _tutorial.rs
│   ├── bin
│   │   └── stdio-fixture.rs
│   └── lib.rs
├── tests
│   ├── builder
│   │   ├── action.rs
│   │   ├── app_settings.rs
│   │   ├── arg_aliases.rs
│   │   ├── arg_aliases_short.rs
│   │   ├── arg_matches.rs
│   │   ├── borrowed.rs
│   │   ├── cargo.rs
│   │   ├── command.rs
│   │   ├── conflicts.rs
│   │   ├── default_missing_vals.rs
│   │   ├── default_vals.rs
│   │   ├── delimiters.rs
│   │   ├── derive_order.rs
│   │   ├── display_order.rs
│   │   ├── double_require.rs
│   │   ├── empty_values.rs
│   │   ├── env.rs
│   │   ├── error.rs
│   │   ├── flag_subcommands.rs
│   │   ├── flags.rs
│   │   ├── global_args.rs
│   │   ├── groups.rs
│   │   ├── help.rs
│   │   ├── help_env.rs
│   │   ├── hidden_args.rs
│   │   ├── ignore_errors.rs
│   │   ├── indices.rs
│   │   ├── main.rs
│   │   ├── multiple_occurrences.rs
│   │   ├── multiple_values.rs
│   │   ├── occurrences.rs
│   │   ├── opts.rs
│   │   ├── positionals.rs
│   │   ├── posix_compatible.rs
│   │   ├── possible_values.rs
│   │   ├── propagate_globals.rs
│   │   ├── require.rs
│   │   ├── subcommands.rs
│   │   ├── template_help.rs
│   │   ├── tests.rs
│   │   ├── unicode.rs
│   │   ├── unique_args.rs
│   │   ├── utf16.rs
│   │   ├── utf8.rs
│   │   ├── utils.rs
│   │   └── version.rs
│   ├── derive
│   │   ├── app_name.rs
│   │   ├── arguments.rs
│   │   ├── author_version_about.rs
│   │   ├── basic.rs
│   │   ├── boxed.rs
│   │   ├── custom_string_parsers.rs
│   │   ├── default_value.rs
│   │   ├── deny_warnings.rs
│   │   ├── doc_comments_help.rs
│   │   ├── explicit_name_no_renaming.rs
│   │   ├── flags.rs
│   │   ├── flatten.rs
│   │   ├── generic.rs
│   │   ├── groups.rs
│   │   ├── help.rs
│   │   ├── issues.rs
│   │   ├── macros.rs
│   │   ├── main.rs
│   │   ├── markdown.rs
│   │   ├── naming.rs
│   │   ├── nested_subcommands.rs
│   │   ├── non_literal_attributes.rs
│   │   ├── occurrences.rs
│   │   ├── options.rs
│   │   ├── privacy.rs
│   │   ├── raw_bool_literal.rs
│   │   ├── raw_idents.rs
│   │   ├── rename_all_env.rs
│   │   ├── skip.rs
│   │   ├── snapshots
│   │   │   ├── blocks.term.svg
│   │   │   ├── headers.term.svg
│   │   │   ├── html.term.svg
│   │   │   ├── inline_styles.term.svg
│   │   │   ├── links.term.svg
│   │   │   ├── lists.term.svg
│   │   │   └── paragraphs.term.svg
│   │   ├── subcommands.rs
│   │   ├── type_alias_regressions.rs
│   │   ├── utf8.rs
│   │   ├── utils.rs
│   │   └── value_enum.rs
│   ├── derive_ui
│   │   ├── bool_value_enum.rs
│   │   ├── bool_value_enum.stderr
│   │   ├── clap_empty_attr.rs
│   │   ├── clap_empty_attr.stderr
│   │   ├── default_value_t_invalid.rs
│   │   ├── default_value_t_invalid.stderr
│   │   ├── default_values_t_invalid.rs
│   │   ├── default_values_t_invalid.stderr
│   │   ├── enum_flatten.rs
│   │   ├── enum_flatten.stderr
│   │   ├── enum_variant_not_args.rs
│   │   ├── enum_variant_not_args.stderr
│   │   ├── external_subcommand_misuse.rs
│   │   ├── external_subcommand_misuse.stderr
│   │   ├── external_subcommand_wrong_type.rs
│   │   ├── external_subcommand_wrong_type.stderr
│   │   ├── flatten_and_methods.rs
│   │   ├── flatten_and_methods.stderr
│   │   ├── flatten_enum_in_struct.rs
│   │   ├── flatten_enum_in_struct.stderr
│   │   ├── flatten_struct_in_enum.rs
│   │   ├── flatten_struct_in_enum.stderr
│   │   ├── group_name_attribute.rs
│   │   ├── group_name_attribute.stderr
│   │   ├── multiple_external_subcommand.rs
│   │   ├── multiple_external_subcommand.stderr
│   │   ├── non_existent_attr.rs
│   │   ├── non_existent_attr.stderr
│   │   ├── rename_all_wrong_casing.rs
│   │   ├── rename_all_wrong_casing.stderr
│   │   ├── skip_flatten.rs
│   │   ├── skip_flatten.stderr
│   │   ├── skip_subcommand.rs
│   │   ├── skip_subcommand.stderr
│   │   ├── skip_with_other_options.rs
│   │   ├── skip_with_other_options.stderr
│   │   ├── skip_without_default.rs
│   │   ├── skip_without_default.stderr
│   │   ├── struct_subcommand.rs
│   │   ├── struct_subcommand.stderr
│   │   ├── subcommand_and_flatten.rs
│   │   ├── subcommand_and_flatten.stderr
│   │   ├── subcommand_and_methods.rs
│   │   ├── subcommand_and_methods.stderr
│   │   ├── subcommand_on_struct.rs
│   │   ├── subcommand_on_struct.stderr
│   │   ├── subcommand_opt_opt.rs
│   │   ├── subcommand_opt_opt.stderr
│   │   ├── subcommand_opt_vec.rs
│   │   ├── subcommand_opt_vec.stderr
│   │   ├── tuple_struct.rs
│   │   ├── tuple_struct.stderr
│   │   ├── value_enum_non_unit.rs
│   │   ├── value_enum_non_unit.stderr
│   │   ├── value_enum_on_struct.rs
│   │   ├── value_enum_on_struct.stderr
│   │   ├── value_parser_unsupported.rs
│   │   └── value_parser_unsupported.stderr
│   ├── derive_ui.rs
│   ├── examples.rs
│   ├── macros.rs
│   ├── ui
│   │   ├── V_flag_stdout.toml
│   │   ├── arg_required_else_help_stderr.toml
│   │   ├── error_stderr.toml
│   │   ├── h_flag_stdout.toml
│   │   ├── help_cmd_stdout.toml
│   │   ├── help_flag_stdout.toml
│   │   └── version_flag_stdout.toml
│   └── ui.rs
└── typos.toml

```

`clap/CHANGELOG.md`:

```md
# Change Log
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/)
and this project adheres to [Semantic Versioning](http://semver.org/).

## 5.0.0 - TBD

*available through `unstable-v5` feature flag*

### Breaking Changes

- Made `ArgPredicate` `non_exhaustive`
- *(help)* Change default `Command::term_width` to "source format"
- *(help)* Change default `Command::max_term_width` to 100
- *(derive)* `Vec<Vec<T>>` types are now assuming to capture occurrences

### Features

- *(derive)* Group values by their occurrence with `Vec<Vec<T>>`

<!-- next-header -->
## [Unreleased] - ReleaseDate

## [4.5.36] - 2025-04-11

### Fixes

- *(help)* Revert 4.5.35's "Don't leave space for shorts if there are none" for now

## [4.5.35] - 2025-04-01

### Fixes

- *(help)* Align positionals and flags when put in the same `help_heading`
- *(help)* Don't leave space for shorts if there are none

## [4.5.34] - 2025-03-27

### Fixes

- *(help)* Don't add extra blank lines with `flatten_help(true)` and subcommands without arguments

## [4.5.33] - 2025-03-26

### Fixes

- *(error)* When showing the usage of a suggestion for an unknown argument, don't show the group

## [4.5.32] - 2025-03-10

### Features

- Add `Error::remove`

### Documentation

- *(cookbook)* Switch from `humantime` to `jiff`
- *(tutorial)* Better cover required vs optional

### Internal

- Update `pulldown-cmark`

## [4.5.31] - 2025-02-24

### Features

- Add `ValueParserFactory` for `Saturating<T>`

## [4.5.30] - 2025-02-17

### Fixes

- *(assert)* Allow `num_args(0..=1)` to be used with `SetTrue`
- *(assert)* Clean up rendering of `takes_values` assertions

## [4.5.29] - 2025-02-11

### Fixes

- Change `ArgMatches::args_present` so not-present flags are considered not-present (matching the documentation)

## [4.5.28] - 2025-02-03

### Features

- *(derive)* Unstable support for full markdown syntax for doc comments, enabled with `unstable-markdown`

## [4.5.27] - 2025-01-20

### Documentation

- Iterate on tutorials and reference based on feedback

## [4.5.26] - 2025-01-09

### Fixes

- *(error)* Reduce binary size with the `suggestions` feature

## [4.5.25] - 2025-01-09

### Fixes

- *(help)* Reduce binary size

## [4.5.24] - 2025-01-07

### Fixes

- *(parser)* Correctly handle defaults with `ignore_errors(true)` and when a suggestion is provided for an unknown argument

## [4.5.23] - 2024-12-05

### Fixes

- *(parser)* When check `allow_negative_numbers`, allow `E` again

## [4.5.22] - 2024-12-03

### Fixes

- *(assert)* Catch bugs with arguments requiring themself

## [4.5.21] - 2024-11-13

### Fixes

- *(parser)* Ensure defaults are filled in on error with `ignore_errors(true)`

## [4.5.20] - 2024-10-08

### Features

- *(unstable)* Add `CommandExt`

## [4.5.19] - 2024-10-01

### Internal

- Update dependencies

## [4.5.18] - 2024-09-20

### Features

- *(builder)* Expose `Arg::get_display_order` and `Command::get_display_order`

## [4.5.17] - 2024-09-04

### Fixes

- *(help)* Style required argument groups
- *(derive)* Improve error messages when unsupported fields are used

## [4.5.16] - 2024-08-15

### Fixes

- *(derive)* Improve error messages when `derive` feature is missing

## [4.5.15] - 2024-08-10

### Compatiblity

- *(unstable-ext)* `Arg::remove` changed return types

### Fixes

- *(unstable-ext)* Make `Arg::remove` return the removed item

## [4.5.14] - 2024-08-08

### Features

- *(unstable-ext)* Added `Arg::add` for attaching arbitrary state, like completion hints, to `Arg` without `Arg` knowing about it

## [4.5.13] - 2024-07-31

### Fixes

- *(derive)* Improve error message when `#[flatten]`ing an optional `#[group(skip)]`
- *(help)* Properly wrap long subcommand descriptions in help

## [4.5.12] - 2024-07-31

## [4.5.11] - 2024-07-25

## [4.5.10] - 2024-07-23

## [4.5.9] - 2024-07-09

### Fixes

- *(error)* When defining a custom help flag, be sure to suggest it like we do the built-in one

## [4.5.8] - 2024-06-28

### Fixes

- Reduce extra flushes

## [4.5.7] - 2024-06-10

### Fixes

- Clean up error message when too few arguments for `num_args`

## [4.5.6] - 2024-06-06

## [4.5.5] - 2024-06-06

### Fixes

- Allow `exclusive` to override `required_unless_present`, `required_unless_present_any`, `required_unless_present_all`

## [4.5.4] - 2024-03-25

### Fixes

- *(derive)* Allow non-literal `#[arg(id)]` attributes again

## [4.5.3] - 2024-03-15

### Internal

- *(derive)* Update `heck`

## [4.5.2] - 2024-03-06

### Fixes

- *(macros)* Silence a warning

## [4.5.1] - 2024-02-16

### Fixes

- *(error)* Include suggestion to add `--` even if there is a "did you mean" so long as `last` or `trailing_var_arg` is used

## [4.5.0] - 2024-02-08

### Compatibility

- Update MSRV to 1.74

## [4.4.18] - 2024-01-16

### Fixes

- *(error)* When lacking `usage` feature, ensure the list of required arguments is unique

## [4.4.17] - 2024-01-15

### Fixes

- Fix `panic!` when mixing `args_conflicts_with_subcommands` with `ArgGroup` (which is implicit with `derive`) introduced in 4.4.15

## [4.4.16] - 2024-01-12

### Fixes

- Ensure invalid escape sequences in user-defined strings are correctly stripped when terminal doesn't support color

## [4.4.15] - 2024-01-11

### Fixes

- Improve error for `args_conflicts_with_subcommands`
- Ensure we error for `args_conflicts_with_subcommands` when using subcommand short and long flags

## [4.4.14] - 2024-01-08

### Documentation

- Fix `find` cookbook entry to allow repeats of flags/options

### Features

- Allow `num_args(0)` on options which allows making them emulate being a flag for position-tracking flags

## [4.4.13] - 2024-01-04

### Documentation

- Fix link to structopt migration guide

## [4.4.12] - 2023-12-28

### Performance

- Only ask `TypedValueParser` for possible values if needed

## [4.4.11] - 2023-12-04

### Features

- Add `Command::mut_group`

## [4.4.10] - 2023-11-28

### Documentation

- Link out to changelog
- Cross link derive's attribute reference to derive tutorial

## [4.4.9] - 2023-11-27

### Fixes

- *(help)* Show correct `Command::about` under flattened headings
- *(help)* Respect `hide` when flattening subcommands

## [4.4.8] - 2023-11-10

### Features

- Add `Command::flatten_help` to allow `git stash -h` like help for subcommands

## [4.4.7] - 2023-10-24

### Performance

- Reduced code size

## [4.4.6] - 2023-09-28

### Internal

- Upgrade `anstream`

## [4.4.5] - 2023-09-25

### Fixes

- *(parser)* When inferring subcommand `name` or `long_flag`, allow ambiguous-looking matches that unambiguously map back to the same command
- *(parser)* When inferring subcommand `long_flag`, don't panic
- *(assert)* Clarify what action is causing a positional that doesn't set values which is especially useful for derive users

## [4.4.4] - 2023-09-18

### Internal

- Update `terminal_size` to 0.3

## [4.4.3] - 2023-09-12

### Documentation

- *(derive)* Clarify use of attributes within the tutorial
- Split sections in the builder and derive tutorials into separate modules

## [4.4.2] - 2023-08-31

### Performance

- Improve build times by removing `once_cell` dependency

## [4.4.1] - 2023-08-28

### Features

- Stabilize `Command::styles`

## [4.4.0] - 2023-08-24

### compatibility

- update msrv to 1.70.0

## [4.3.24] - 2023-08-23

### Fixes

- Ensure column padding is preserved in `--help` with custom templates

## [4.3.23] - 2023-08-18

### Fixes

- Fixed `UnknownArgumentValueParser` to not error on flag's absence

## [4.3.22] - 2023-08-17

### Features

- Add `UnknownArgumentValueParser` for injecting errors for improving the experience with errors

## [4.3.21] - 2023-08-08

### Features

- Expose `TryMapValueParser` so the type can be named

## [4.3.20] - 2023-08-08

### Features

- `Command::mut_args` for modifying all arguments en masse

## [4.3.19] - 2023-07-21

### Fixes

- *(parse)* Respect `value_terminator` even in the presence of later multiple-value positional arguments

## [4.3.18] - 2023-07-21

### Fixes

- *(parse)* Suggest `--` in fewer places where it won't work

## [4.3.17] - 2023-07-19

### Fixes

- *(help)* Address a regression in wrapping `PossibleValue` descriptions in `--help`

## [4.3.16] - 2023-07-18

### Fixes

- Don't assert when stateful value parsers fail on defaults (e.g. checking if a path exists)

## [4.3.15] - 2023-07-18

### Features

- *(unstable-styles)* Re-export `anstyle`

### Documentation

- *(unstable-styles)* Provide more examples

## [4.3.14] - 2023-07-17

### Features

- `ArgAction::HelpShort` and `ArgAction::HelpLong` for explicitly specifying which style of help to display

### Fixes

- Skip `[OPTIONS]` in usage if a help or version `ArgAction` is used

## [4.3.13] - 2023-07-17

## [4.3.12] - 2023-07-14

### Fixes

- *(derive)* Don't error on enum variant field attributes

## [4.3.11] - 2023-07-05

### Features

- *(derive)* Support fields wrapped in `num::Wrapping`, `Box`, or `Arc`
- *(derive)* Support `Box<str>`, `Box<OsStr>`, and `Box<Path>`

## [4.3.10] - 2023-06-30

### Performance

- Drop a dependency, reducing binary size by 1.3 KiB

## [4.3.9] - 2023-06-28

### Fixes

- `Command::ignore_errors` no longer masks help/version

## [4.3.8] - 2023-06-23

### Fixes

- Error on ambiguity with `infer_long_arg`, rather than arbitrarily picking one, matching the documentation and subcommand's behavior

## [4.3.7] - 2023-06-23

### Documentation

- Further clarify magic behavior in derive tutorial
- Further clarify derive API's relationship to builder within the tutorial

## [4.3.6] - 2023-06-23

### Documentation

- Suggest `clio`

## [4.3.5] - 2023-06-20

- `ColorChoice::possible_values` is added to simplify things for builder users

### Fixes

- `ColorChoice::to_possible_value` no longer includes descriptions, encouraging shorter help where possible

## [4.3.4] - 2023-06-14

### Features

- Add `Error::exit_code`

## [4.3.3] - 2023-06-09

### Features

- `Command::defer` for delayed initialization of subcommands to reduce startup times of large applications like deno

## [4.3.2] - 2023-06-05

### Fixes

- *(derive)* Don't produce `unused_equalifications` warnings when someone brings a clap type into scope

## [4.3.1] - 2023-06-02

### Performance

- *(derive)* Reduce the amount of generated code

## [4.3.0] - 2023-05-19

### Fixes

- *(assert)* Allow multiple, value-terminated, positional arguments
- *(assert)* Clear up language on `last` assertion
- *(parser)* Correctly assign values to arguments when using multiple, value-termianted, positional arguments
- *(parser)* Ensure `value_terminator` has higher precedence than `allow_hyphen_values`
- *(help)* Only use next-line-help on subcommand list when explicitly specified, not just with `--help`
- *(help)* Correctly align possible values list
- *(help)* Don't waste code, vertical space in moving possible value descriptions to next line

## [4.2.7] - 2023-05-02

### Fixes

- Correctly track remaining length for iterators provided by `ArgMatches`

## [4.2.6] - 2023-05-02

### Features

- `impl Eq<std::any::TypeId> for clap_builder::util::AnyValueId`

## [4.2.5] - 2023-04-27

### Fixes

- Improve panic when a group requires a non-existent ID

## [4.2.4] - 2023-04-19

### Documentation

- Corrected docs for `Command::style`

## [4.2.3] - 2023-04-18

### Features

- `Command::styles` for theming help/errors (behind `unstable-styles`)

## [4.2.2] - 2023-04-13

### Internal

- Update dependencies

## [4.2.1] - 2023-03-28

### Fixes

- Don't highlight uninteresting parts of the error message

## [4.2.0] - 2023-03-28

### Compatibility

- Removed the languishing `unstable-replace` feature (open to discussion at [#2836](https://github.com/clap-rs/clap/issues/2836))
- Removed the stablized `unstable-grouped` feature

### Features

- Allow any `StyledStr` to accept text styled with ANSI escape codes
- Respect `CLICOLOR`, `CLICOLOR_FORCE`

### Fixes

- Lighten the tone for "unexpected argument" errors (open to discussion at [#4638](https://github.com/clap-rs/clap/issues/4638))

## [4.1.14] - 2023-03-28

### Features

- *(derive)* `#[group]` raw attribute support

### Performance

- *(derive)* `clap_builder` was pulled out of `clap` so it could build in parallel to `clap_derive`
- `os_str_bytes` dependency was removed for faster builds and smaller binaries

## [4.1.13] - 2023-03-18

### Performance

- Reduce repeated alloc calls when building a `Command`
- Reduce duplicate dependencies for faster builds

## [4.1.12] - 2023-03-18

### Internal

- *(derive)* Update to `syn` v2

### Performance

- *(derive)* Faster build times by dropping `proc-macro-error` dependency

## [4.1.11] - 2023-03-17

### Internal

- Update `bitflags`

## [4.1.10] - 2023-03-17

### Fixes

- *(help)* On Windows, avoid underlined text artifacts

## [4.1.9] - 2023-03-16

### Fixes

- *(assert)* Improve the assert when using the wrong action with `get_count` / `get_flag`

## [4.1.8] - 2023-02-27

### Fixes

- *(derive)* Don't `deny` lints on the users behalf

## [4.1.7] - 2023-02-27

### Fixes

- *(derive)* Hide some nightly clippy warnings

## [4.1.6] - 2023-02-15

### Fixes

- *(help)* Don't show long help for `--help` just because hidden possible values include a description

## [4.1.5] - 2023-02-15

### Fixes

- *(help)* Don't show long help for `--help` just because a hidden arg has a possible value with a description

## [4.1.4] - 2023-01-24

### Fixes

- *(help)* Respect `disable_colored_help` when using `arg_required_else_help`

### Performance

- Speed up compiling `arg!` macro

## [4.1.3] - 2023-01-23

### Fixes

- *(error)* Improve suggested flag/value/subcommand when two share a long preifx
- *(error)* When suggesting one of several subcommands, use the plural `subcommands`, rather than `subcommand`

## [4.1.2] - 2023-01-23

### Fixes

- In documentation, refer to `get_flag`, rather than `get_one::<bool>`

## [4.1.1] - 2023-01-14

### Fixes

- *(error)* Small softening attempt for "unexpected argument" error

## [4.1.0] - 2023-01-13

### Compatibility

MSRV changed to 1.64.0

For apps with custom `--help` and `--version` flags:
- Descriptions for `--help` and `--version` changed

When apps have errors imitating clap's error style:
- Error message style was changed, including
  - Moving away from "did you mean" to tips
  - Leading letter is lower case
  - "For more" added some punctuation

### Features

- `ArgMatches::get_occurrences` support for argument values to be grouped by their occurrence

### Fixes

- *(derive)* Allow `upgrade_from` when arguments / subcommands are explicitly marked as required
- *(help)* Try be more clearer and succinct with `--help` and `--version` (also helps with overflow)
- *(error)* Try to be more clearer and succinct with error messages
- *(error)* Officially adopt [an error style guide](https://rustc-dev-guide.rust-lang.org/diagnostics.html#suggestion-style-guide)

## [4.0.32] - 2022-12-22

### Fixes

- *(parser)* When overriding `required(true)`, consider args that conflict with its group

## [4.0.31] - 2022-12-22

### Performance

- Speed up parsing when a lot of different flags are present (100 unique flags)

## [4.0.30] - 2022-12-21

### Fixes

- *(error)* Improve error for `args_conflicts_with_subcommand`

## [4.0.29] - 2022-11-29

## [4.0.28] - 2022-11-29

### Fixes

- Fix wasm support which was broken in 4.0.27

## [4.0.27] - 2022-11-24

### Features

- Have `Arg::value_parser` accept `Vec<impl Into<PossibleValue>>`
- Implement `Display` and `FromStr` for `ColorChoice`

### Fixes

- Remove soundness issue by switching from `atty` to `is-terminal`

## [4.0.26] - 2022-11-16

### Fixes

- *(error)* Fix typos in `ContextKind::as_str`

## [4.0.25] - 2022-11-15

### Features

- *(error)* Report available subcommands when required subcommand is missing

## [4.0.24] - 2022-11-14

### Fixes

- Avoid panic when printing an argument that isn't built

## [4.0.23] - 2022-11-11

### Fixes

- Don't panic on reporting invalid-long errors when followed by invalid UTF8
- *(help)* Clarified argument to `help` subcommand

## [4.0.22] - 2022-11-07

### Fixes

- *(help)* Don't overflow into next-line-help early due to stale (pre-v4) padding calculations

## [4.0.21] - 2022-11-07

### Features

- *(derive)* `long_about` and `long_help` attributes, without a value, force using doc comment (before it wouldn't be set if there wasn't anything different than the short help)

## [4.0.20] - 2022-11-07

### Fixes

- *(derive)*  Allow defaulted value parser for '()' fields

## [4.0.19] - 2022-11-04

### Features

- `ColorChoice` now implements `ValueEnum`

## [4.0.18] - 2022-10-20

### Fixes

- *(derive)* Allow `#[command(skip)]` to also work with enum variants with a value

## [4.0.17] - 2022-10-18

### Fixes

- Allow using `Arg::last(true)` with `Arg::value_hint(ValueHint::CommandWithArguments)`

## [4.0.16] - 2022-10-18

### Fixes

- `Arg::exclusive(true)` should not be exclusive with the argument's own `ArgGroup`

## [4.0.15] - 2022-10-13

### Fixes

- *(error)* Don't suggest `--` when it doesn't help
- *(error)* Be more consistent in quoting, punctuation, and indentation in errors

## [4.0.14] - 2022-10-12

### Fixes

- Only put `ArgGroup` in `ArgMatches` when explicitly specified, fixing derives handling of option-flattened fields (#4375)

## [4.0.13] - 2022-10-11

### Features

- *(derive)* Allow `()` for fields to mean "don't read" (#4371)

## [4.0.12] - 2022-10-10

### Features

- Added `TypedValueParser::try_map` for when adapting an existing `TypedValueParser` can fail
- *(error)* Create errors like clap with `Error::new`, `Error::with_cmd`, and `Error::insert`

## [4.0.11] - 2022-10-09

### Fixes

- *(help)* Fix wrapping calculations with ANSI escape codes

## [4.0.10] - 2022-10-05

### Features

- *(derive)* Support `#[arg(flatten)]` on `Option` types (#4211, #4350)

## [4.0.9] - 2022-10-03

### Fixes

- *(derive)* Process doc comments for `#[command(subcommand)]` like in clap v3

## [4.0.8] - 2022-10-01

### Fixes

- *(derive)* Remove a low-value assert preventing defaulting `Help` and `Version` actions

## [4.0.7] - 2022-09-30

### Features

- *(derive)* Populate implicit ArgGroup (#3165)

### Fixes

- *(derive)* Support `#[group(skip)]` on `Parser` derive
- *(derive)* Tell users about implicit arg groups when running into group name conflicts
- *(error)* Don't report unrelated groups in conflict or requires errors

## [4.0.6] - 2022-09-30

### Features

- *(derive)* Support `#[group(skip)]` (#4279, #4301)

## [4.0.5] - 2022-09-30

## [4.0.4] - 2022-09-29

### Fixes

- *(error)* Specialize the self-conflict error to look like clap v3

## [4.0.3] - 2022-09-29

### Fixes

- *(error)* Quote literals consistently
- *(error)* Stylize escape (`--`) suggestions
- *(error)* Format help flag as a literal

## [4.0.2] - 2022-09-28

### Fixes

- *(parser)* `SetFalse` should conflict with itself like `SetTrue` and `Set`
- *(parser)* Allow one-off overrides

## [4.0.1] - 2022-09-28

### Fixes

- *(derive)* Ensure `#[clap(...)]` attribute still works

## [4.0.0] - 2022-09-28

### Highlights

**`Arg::num_args(range)`**

Clap has had several ways for controlling how many values will be captured without always being clear on how they interacted, including
- `Arg::multiple_values(true)`
- `Arg::number_of_values(4)`
- `Arg::min_values(2)`
- `Arg::max_values(20)`
- `Arg::takes_value(true)`

These have now all been collapsed into `Arg::num_args` which accepts both
single values and ranges of values.  `num_args` controls how many raw arguments
on the command line will be captured as values per occurrence and independent
of value delimiters.

See [Issue 2688](https://github.com/clap-rs/clap/issues/2688) for more background.

**Polishing Help**

Clap strives to give a polished CLI experience out of the box with little
ceremony.  With some feedback that has accumulated over time, we took this
release as an opportunity to re-evaluate our `--help` output to make sure it is
meeting that goal.

In doing this evaluation, we wanted to keep in mind:
- Whether other CLIs had ideas that make sense to apply
- Providing an experience that fits within the rest of applications and works across all shells

Before:
```
git
A fictional versioning CLI

USAGE:
    git <SUBCOMMAND>

OPTIONS:
    -h, --help    Print help information

SUBCOMMANDS:
    add      adds things
    clone    Clones repos
    help     Print this message or the help of the given subcommand(s)
    push     pushes things
    stash
```

After:
```
A fictional versioning CLI

Usage: git <COMMAND>

Commands:
  clone  Clones repos
  push   pushes things
  add    adds things
  stash
  help   Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help information
```
- name/version header was removed because we couldn't justify the space it occupied when
  - Usage already includes the name
  - `--version` is available for showing the same thing (if the program has a version set)
- Usage was dropped to one line to save space
- Focus is put on the subcommands
- Headings are now Title case
- The more general term "command" is used rather than being explicit about being "subcommands"
- The output is more dense with the expectation that it won't affect legibility but will allow more content
- We've moved to a more neutral palette for highlighting elements (not highlighted above)

In talking to users, we found some that liked clap's `man`-like experience.
When deviating from this, we are making the assumption that those are more
power users and that the majority of users wouldn't look as favorably on being
consistent with `man`.

See [Issue 4132](https://github.com/clap-rs/clap/issues/4132) for more background.

**More Dynamicism**

Clap's API has focused on `&str` for performance but this can make
dealing with owned data difficult, like `#[arg(default_value_t)]` generating a
String from the default value.

Additionally, to avoid `ArgMatches` from borrowing (and for some features we
decided to forgo), clap took the `&str` argument IDs and hashed them.  This
prevented us from providing a usable API for iterating over existing arguments.

Now clap has switched to a string newtype that gives us the flexibility to
decide whether to use `&'static str`, `Cow<'static, str>` for fast dynamic behavior, or
`Box<str>` for dynamic behavior with small binary size.

As an extension of that work, you can now call `ArgMatches::ids` to iterate
over the arguments and groups that were found when parsing.  The newtype `Id`
was used to prevent some classes of bugs and to make it easier to understand
when opaque Ids are used vs user-visible strings.

**Clearing Out Deprecations**

Instead of doing all development on clap 4.0.0, we implemented a lot of new features during clap 3's development, deprecating the old API while introducing the new API, including:
- Replacing the implicit behavior for args when parsing them with `ArgAction`
- Replacing various one-off forms of value validation with the `ValueParser` API
  - Allowing derives to automatically do the right thing for `PathBuf` (allowing invalid UTF-8)
- Replacing `AppSettings` and `ArgSettings` enums with getters/setters
- Clarifying terms and making them more consistent

### Migrating

Steps:

0. [Upgrade to v3](https://github.com/clap-rs/clap/blob/v3-master/CHANGELOG.md#migrating) if you haven't already
1. Add CLI tests (including example below), `-h` and `--help` output at a minimum (recommendation: [trycmd](https://docs.rs/trycmd/) for snapshot testing)
2. *If using Builder API*: Explicitly set the `arg.action(ArgAction::...)` on each argument (`StoreValue` for options and `IncOccurrences` for flags)
3. Run `cargo check --features clap/deprecated` and resolve all deprecation warnings
4. Upgrade to v4
5. Update feature flags
  - *If `default-features = false`*, run `cargo add clap -F help,usage,error-context`
  -  Run `cargo add clap -F wrap_help` unless you want to hard code line wraps
6. Resolve compiler errors
7. Resolve behavior changes (see "subtle changes" under BREAKING CHANGES)
8. *At your leisure:* resolve new deprecation notices

Example test (derive):
```rust
#[derive(clap::Parser)]
struct Cli {
    ...
}

#[test]
fn verify_cli() {
    use clap::CommandFactory;
    Cli::command().debug_assert()
}
```

Example test (builder):
```rust
fn cli() -> clap::Command {
    ...
}

#[test]
fn verify_cli() {
    cli().debug_assert();
}
```

Note: the idiomatic / recommended way of specifying different types of args in the Builder API has changed:

Before
```rust
.arg(Arg::new("flag").long("flag"))  # --flag
.arg(Arg::new("option").long("option").takes_value(true))  # --option <option>
```
After:
```rust
.arg(Arg::new("flag").long("flag").action(ArgAction::SetTrue))  # --flag
.arg(Arg::new("option").long("option"))  # --option <option>
```
In particular, `num_args` (the replacement for `takes_value`) will default appropriately
from the `ArgAction` and generally only needs to be set explicitly for the
other `num_args` use cases.

### Breaking Changes

Subtle changes (i.e. compiler won't catch):

- `arg!` now sets one of (#3795):
  - `ArgAction::SetTrue`, requiring `ArgMatches::get_flag` instead of `ArgMatches::is_present`
  - `ArgAction::Count`, requiring `ArgMatches::get_count` instead of `ArgMatches::occurrences_of`
  - `ArgAction::Set`, requiring `ArgMatches::get_one` instead of `ArgMatches::value_of`
  - `ArgAction::Append`, requiring `ArgMatches::get_many` instead of `ArgMatches::values_of`
- `ArgAction::Set`, `ArgAction::SetTrue`, and `Arg::Action::SetFalse` now
  conflict by default to be like `ArgAction::StoreValue` and
  `ArgAction::IncOccurrences`, requiring `cmd.args_override_self(true)` to override instead (#4261)
- By default, an `Arg`s default action is `ArgAction::Set`, rather than `ArgAction::IncOccurrence` to reduce confusing magic through consistency (#2687, #4032, see also #3977)
- `mut_arg` can no longer be used to customize help and version arguments, instead disable them (`Command::disable_help_flag`, `Command::disable_version_flag`) and provide your own (#4056)
- Removed lifetimes from `Command`, `Arg`, `ArgGroup`, and `PossibleValue`, assuming `'static`.  `string` feature flag will enable support for `String`s (#1041, #2150, #4223)
- `arg!(--flag <value>)` is now optional, instead of required.  Add `.required(true)` at the end to restore the original behavior (#4206)
- Added default feature flags, `help`, `usage` and `error-context`, requiring adding them back in if `default-features = false` (#4236)
- *(parser)* Always fill in `""` argument for external subcommands to make it easier to distinguish them from built-in commands (#3263)
- *(parser)* Short flags now have higher precedence than hyphen values with `Arg::allow_hyphen_values`, to be consistent with `Command::allow_hyphen_values` (#4187)
- *(parser)* `Arg::value_terminator` must be its own argument on the CLI rather than being in a delimited list (#4025)
- *(help)* Line wrapping of help is now behind the existing `wrap_help` feature flag, either enable it or hard code your wraps (#4258)
- *(help)* Make `DeriveDisplayOrder` the default and removed the setting.  To sort help, set `next_display_order(None)` (#2808)
- *(help)* Subcommand display order respects `Command::next_display_order` instead of `DeriveDisplayOrder` and using its own initial display order value (#2808)
- *(help)* Subcommands are now listed before arguments.  To get the old behavior, see `Command::help_template` (#4132)
- *(help)* Help headings are now title cased, making any user-provided help headings inconsistent.  To get the old behavior, see `Command::help_template`, `Arg::help_heading`, and `Command::subcommand_help_heading` (#4132)
- *(help)* "Command" is used as the section heading for subcommands and `COMMAND` for the value name.  To get the old behavior, see  `Command::subcommand_help_heading` and `Arg::subcommand_value_name` (#4132, #4155)
- *(help)* Whitespace in help output is now trimmed to ensure consistency regardless of how well a template matches the users needs. (#4132, #4156)
- *(help)* name/version/author are removed by default from help output.  To get the old behavior, see `Command::help_template`. (#4132, #4160)
- *(help)* Indentation for second-line usage changed. (#4132, #4188)
- *(env)* Parse `--help` and `--version` like any `ArgAction::SetTrue` flag (#3776)
- *(derive)* Leave `Arg::id` as `verbatim` casing, requiring updating of string references to other args like in `conflicts_with` or `requires` (#3282)
- *(derive)* Doc comments for `ValueEnum` variants will now show up in `--help` (#3312)
- *(derive)* When deriving `Args`, and `ArgGroup` is created using the type's name, reserving it for future use (#2621, #4209)
- *(derive)* `next_help_heading` can now leak out of a `#[clap(flatten)]`, like all other command settings (#4222)

Easier to catch changes:

- Looking up a group in `ArgMatches` now returns the arg `Id`s, rather than the values to reduce overhead and offer more flexibility. (#4072)
- Changed `Arg::number_of_values` (average-across-occurrences) to `Arg::num_args` (per-occurrence) (raw CLI args, not parsed values) (#2688, #4023)
  - `num_args(0)` no longer implies `takes_value(true).multiple_values(true)` (#4023)
  - `num_args(1)` no longer implies `multiple_values(true)` (#4023)
  - Does not check default or env values, only what the user explicitly passes in (#4025)
  - No longer terminates on delimited values (#4025)
- Replace `Arg::min_values` (across all occurrences) with `Arg::num_args(N..)` (per occurrence) to reduce confusion over different value count APIs (#4023)
- Replace `Arg::max_values` (across all occurrences) with `Arg::num_args(1..=M)` (per occurrence) to reduce confusion over different value count APIs  (#4023)
- Replace `Arg::multiple_values(true)` with `Arg::num_args(1..)` and `Arg::multiple_values(false)` with `Arg::num_args(0)` to reduce confusion over different value count APIs  (#4023)
- Replace `Arg::takes_value(true)` with `Arg::num_args(1)` and `Arg::takes_value(false)` with `Arg::num_args(0)` to reduce confusion over different value count APIs
- Remove `Arg::require_value_delimiter`, either users could use `Arg::value_delimiter` or implement a custom parser with `TypedValueParser` as it was mostly to make `multiple_values(true)` act like `multiple_values(false)` and isn't needed anymore (#4026)
- `Arg::new("help")` and `Arg::new("version")` no longer implicitly disable the
  built-in flags and be copied to all subcommands, instead disable
  the built-in flags (`Command::disable_help_flag`,
  `Command::disable_version_flag`) and mark the custom flags as `global(true)`. (#4056)
- `Arg::short('h')` no longer implicitly disables the short flag for help,
  instead disable
  the built-in flags (`Command::disable_help_flag`,
  `Command::disable_version_flag`) provide your own `Arg::new("help").long("help").action(ArgAction::Help).global(true)`. (#4056)
- `ArgAction::SetTrue` and `ArgAction::SetFalse` now prioritize `Arg::default_missing_value` over their standard behavior (#4000)
- Changed `Arg::requires_ifs` and `Arg::default_value*_ifs*` to taking an `ArgPredicate`, removing ambiguity with `None` when accepting owned and borrowed types (#4084)
- Removed `PartialEq` and `Eq` from `Command` so we could change external subcommands to use a `ValueParser` (#3990)
- Various `Arg`, `Command`, and `ArgGroup` calls were switched from accepting `&[]` to `[]` via `IntoIterator` to be more flexible (#4072)
- `Arg::short_aliases` and other builder functions that took `&[]` need the `&` dropped (#4081)
- `ErrorKind` and `Result` moved into the `error` module
- `ErrorKind::EmptyValue` replaced with `ErrorKind::InvalidValue` to remove an unnecessary special case (#3676, #3968)
- `ErrorKind::UnrecognizedSubcommand` replaced with `ErrorKind::InvalidSubcommand` to remove an unnecessary special case (#3676)
- Changed the default type of `allow_external_subcommands` from `String` to `OsString` as that is less likely to cause bugs in user applications (#3990)
- *(help)* `Command::render_usage` now returns a `StyledStr` (#4248)
- *(derive)* Changed the default for arguments from `parse` to `value_parser`, removing `parse` support (#3827, #3981)
  - `#[clap(value_parser)]` and `#[clap(action)]` are now redundant
- *(derive)* `subcommand_required(true).arg_required_else_help(true)` is set instead of `SubcommandRequiredElseHelp` to give more meaningful errors when subcommands are missing and to reduce redundancy (#3280)
- *(derive)* Remove `arg_enum` attribute in favor of `value_enum` to match the new name (we didn't have support in v3 to mark it deprecated) (#4127)
- *(parser)* Assert when the CLI looksup an unknown args when external subcommand support is enabled to help catch bugs (#3703)
- *(assert)* Sometimes `Arg::default_missing_value` didn't require `num_args(0..=N)`, now it does (#4023)
- *(assert)* Leading dashes in `Arg::long` are no longer allowed (#3691)
- *(assert)* Disallow more `value_names` than `num_args` (#2695)
- *(assert)* Always enforce that version is specified when the `ArgAction::Version` is used
- *(assert)* Add missing `#[track_caller]`s to make it easier to debug asserts
- *(assert)* Ensure `overrides_with` IDs are valid
- *(assert)* Ensure no self-`overrides_with` now that Actions replace it
- *(assert)* Ensure subcommand names are not duplicated
- *(assert)* Assert on `mut_arg` receiving an invalid arg ID or `mut_subcommand` receiving an invalid command name

### Compatibility

MSRV is now 1.60.0

Deprecated
- `Arg::use_value_delimiter` in favor of `Arg::value_delimiter` to avoid having multiple ways of doing the same thing
- `Arg::requires_all` in favor of `Arg::requires_ifs` now that it takes an `ArgPredicate` to avoid having multiple ways of doing the same thing
- `Arg::number_of_values` in favor of `Arg::num_args` to clarify semantic differences
- `default_value_os`, `default_values_os`, `default_value_if_os`, and `default_value_ifs_os` as the non `_os` variants now accept either a `str` or an `OsStr` (#4141)
- `Arg::env_os` in favor of `Arg::env`
- `Command::dont_collapse_args_in_usage` is now the default (#4151)
- `Command::trailing_var_arg` in favor of `Arg::trailing_var_arg` to make it clearer which arg it is meant to apply to (#4187)
- `Command::allow_hyphen_values` in favor of `Arg::allow_hyphen_values` to make it clearer which arg it is meant to apply to (#4187)
- `Command::allow_negative_numbers` in favor of `Arg::allow_negative_numbers` to make it clearer which arg it is meant to apply to (#4187)
- *(help)* Deprecated `Command::write_help` and `Command::write_long_help` in favor of `Command::render_help` and `Command::render_long_help` (#4248)
- *(derive)* `structopt` and `clap` attributes in favor of the more specific `command`, `arg`, and `value` to open the door for [more features](https://github.com/clap-rs/clap/issues/1807) and [clarify relationship to the builder](https://github.com/clap-rs/clap/discussions/4090) (#1807, #4180)
- *(derive)* `#[clap(value_parser)]` and `#[clap(action)]` defaulted attributes (its the default) (#3976)

Behavior Changes
- *(help)* With `wrap_help` feature, if the terminal size cannot be determined, `LINES` and `COLUMNS` variables are used (#4186)

### Features

- `Arg::num_args` now accepts ranges, allowing setting both the minimum and maximum number of values per occurrence (#2688, #4023)
- Allow non-bool `value_parser`s for `ArgAction::SetTrue` / `ArgAction::SetFalse` (#4092)
- Add `From<&OsStr>`, `From<OsString>`, `From<&str>`, and `From<String>` to `value_parser!` (#4257)
- Allow resetting most builder methods
- Can now pass runtime generated data to `Command`, `Arg`, `ArgGroup`, `PossibleValue`, etc without managing lifetimes with the `string` feature flag (#2150, #4223)
- New default `error-context`, `help` and `usage` feature flags that can be turned off for smaller binaries (#4236)
- Added `StyledStr::ansi()` to `Display` with ANSI escape codes (#4248)
- *(error)* `Error::apply` for changing the formatter for dropping binary size (#4111)
- *(error)* `Error::render`for formatting the error into a `StyledStr`
- *(help)* Show `PossibleValue::help` in long help (`--help`) (#3312)
- *(help)* New `{tab}` variable for `Command::help_template` (#4161)
- *(help)* `Command::render_help` and `Command::render_long_help` for formatting the error into a `StyledStr` (#3873, #4248)
- *(help)* `Command::render_usage` now returns a `StyledStr` (#4248)

### Fixes

- Verify `required` is not used with conditional required settings (#3660)
- Replaced `cmd.allow_invalid_for_utf8_external_subcommands` with `cmd.external_subcommand_value_parser` (#3733)
- `Arg::default_missing_value` now applies per occurrence rather than if a value is missing across all occurrences (#3998)
- `arg!(--long [value])` to accept `0..=1` per occurrence rather than across all occurrences, making it safe to use with `ArgAction::Append` (#4001)
- Allow `OsStr`s for `Arg::{required_if_eq,required_if_eq_any,required_if_eq_all}` (#4084)
- *(help)* With `wrap_help` feature, if the terminal size cannot be determined, `LINES` and `COLUMNS` variables are used (#4186)
- *(help)* Use `Command::display_name` in the help title rather than `Command::bin_name`
- *(help)* Show when a flag is `ArgAction::Count` by adding an `...` (#4003)
- *(help)* Use a more neutral palette for coloring (#4132, #4117)
- *(help)* Don't rely on ALL CAPS for help headers (#4132, #4123)
- *(help)* List subcommands first, focusing the emphasis on them (#4132, #4125)
- *(help)* Do not include global args in `cmd help help` (#4131)
- *(help)* Use `[positional]` in list when relevant (#4144)
- *(help)* Show all `[positional]` in usage (#4151)
- *(help)* Polish up subcommands by referring to them as commands (#4132, #4155)
- *(help)* Trim extra whitespace to avoid artifacts from different uses of templates (#4132, #4156)
- *(help)* Hint to the user the difference between `-h` / `--help` when applicable (#4132, #4159)
- *(help)* Shorten help by eliding name/version/author (#4132, #4160)
- *(help)* When short help is long enough to activate `next_line_help`, don't add blank lines (#4132, #4190)
- *(help)* Make help output more dense (reducing horizontal whitespace) (#4132, #4192)
- *(help)* Separate subcommand flags with "," like option flags (#4232, #4235)
- *(help)* Quote the suggested help flag (#4220)
- *(version)* Use `Command::display_name` rather than `Command::bin_name` (#3966)
- *(parser)* Always fill in `""` argument for external subcommands (#3263)
- *(parser)* Short flags now have higher precedence than hyphen values with `Arg::allow_hyphen_values`, like `Command::allow_hyphen_values` (#4187)
- *(parser)* Prefer `InvalidSubcommand` over `UnknownArgument` in more cases (#4219)
- *(derive)* Detect escaped external subcommands that look like built-in subcommands (#3703)
- *(derive)* Leave `Arg::id` as `verbatim` casing (#3282)
- *(derive)* Default to `#[clap(value_parser, action)]` instead of `#[clap(parse)]` (#3827)

## [3.2.18] - 2022-08-29

### Fixes

- *(help)* `Command::print_help` now respects `Command::colored_help`
- *(derive)* Improved error messages

## [3.2.17] - 2022-08-12

### Fixes

- *(derive)* Expose `#[clap(id = ...)]` attribute to match Arg's latest API

## [3.2.16] - 2022-07-30

### Fixes

- Ensure required arguments appear in errors when they are also members of a group (#4004)

## [3.2.15] - 2022-07-25

### Features

- *(derive)* New `default_values_t` and `default_values_os_t` attributes

## [3.2.14] - 2022-07-21

### Fixes

- A `multiple_values` positional followed by another positional now works with multiple flags

## [3.2.13] - 2022-07-19

### Documentation

- Pulled in tutorials, cookbook, and derive reference into rustdoc

## [3.2.12] - 2022-07-14

### Fixes

- Allow an arg to declare a conflict with a group

## [3.2.11] - 2022-07-13

### Features

- Added `Arg::get_all_short_aliaes` and `Arg::get_all_aliases`

## [3.2.10] - 2022-07-12

### Fixes

- Loosen lifetime on `Command::mut_subcommand`

## [3.2.8] - 2022-06-30

### Features

- Added `Command::mut_subcommand` to mirror `Command::mut_arg`

## [3.2.7] - 2022-06-28

### Fixes

- Global arguments should override env-sourced arguments

## [3.2.6] - 2022-06-21

### Fixes

- Don't panic when parsing `--=`

## [3.2.5] - 2022-06-15

### Fixes

- *(derive)* Fix regression with `#[clap(default_value_os_t ...)]` introduced in v3.2.3

## [3.2.4] - 2022-06-14

### Fixes

- *(derive)* Provide more clearer deprecation messages for `#[clap(parse)]` attribute (#3832)

## [3.2.3] - 2022-06-14

### Fixes

- Moved deprecations to be behind the `deprecated` Cargo.toml feature (#3830)
  - For now, it is disabled by default though we are considering enabling it by
    default as we release the next major version to help draw attention to the
    deprecation migration path

## [3.2.2] - 2022-06-14

### Fixes

- *(derive)* Improve the highlighted code for deprecation warnings

**gated behind `unstable-v4`**
- *(derive)* Default to `#[clap(value_parser, action)]` instead of `#[clap(parse)]` (#3827)

## [3.2.1] - 2022-06-13

## [3.2.0] - 2022-06-13

### Compatibility

MSRV is now 1.56.0 (#3732)

Behavior
- Defaults no longer satisfy `required` and its variants (#3793)
- When misusing `ArgMatches::value_of` and friends, debug asserts were turned into panics

Moving (old location deprecated)
- `clap::{PossibleValue, ValueHint}` to `clap::builder::{PossibleValue, ValueHint}`
- `clap::{Indices, OsValues, ValueSource, Values}` to `clap::parser::{Indices, OsValues, ValueSource, Values}`
- `clap::ArgEnum` to `clap::ValueEnum` (#3799)

Replaced
- `Arg::allow_invalid_utf8` with `Arg::value_parser(value_parser!(PathBuf))` (#3753)
- `Arg::validator` / `Arg::validator_os` with `Arg::value_parser` (#3753)
- `Arg::validator_regex` with users providing their own `builder::TypedValueParser` (#3756)
- `Arg::forbid_empty_values` with `builder::NonEmptyStringValueParser` / `builder::PathBufValueParser` (#3753)
- `Arg::possible_values` with `Arg::value_parser([...])`, `builder::PossibleValuesParser`, or `builder::EnumValueParser` (#3753)
- `Arg::max_occurrences` with `arg.action(ArgAction::Count).value_parser(value_parser!(u8).range(..N))` for flags (#3797)
- `Arg::multiple_occurrences` with `ArgAction::Append` or `ArgAction::Count` though positionals will need `Arg::multiple_values` (#3772, #3797)
- `Command::args_override_self` with `ArgAction::Set` (#2627, #3797)
- `AppSettings::NoAutoVersion` with `ArgAction` or `Command::disable_version_flag` (#3800)
- `AppSettings::NoHelpVersion` with `ArgAction` or `Command::disable_help_flag` / `Command::disable_help_subcommand` (#3800)
- `ArgMatches::{value_of, value_of_os, value_of_os_lossy, value_of_t}` with `ArgMatches::{get_one,remove_one}` (#3753)
- `ArgMatches::{values_of, values_of_os, values_of_os_lossy, values_of_t}` with `ArgMatches::{get_many,remove_many}` (#3753)
- `ArgMatches::is_valid_arg` with `ArgMatches::{try_get_one,try_get_many}` (#3753)
- `ArgMatches::occurrences_of` with `ArgMatches::value_source` or `ArgAction::Count` (#3797)
- `ArgMatches::is_present` with `ArgMatches::contains_id` or `ArgAction::SetTrue` (#3797)
- `ArgAction::StoreValue` with `ArgAction::Set` or `ArgAction::Append` (#3797)
- `ArgAction::IncOccurrences` with `ArgAction::SetTrue` or `ArgAction::Count` (#3797)
- *(derive)* `#[clap(parse(...))]` replaced with: (#3589, #3794)
  - For default parsers (no `parse` attribute), deprecation warnings can be
    silenced by opting into the new behavior by adding either `#[clap(action)]`
    or `#[clap(value_parser)]` (ie requesting the default behavior for these
    attributes).  Alternatively, the `unstable-v4` feature changes the default
    away from `parse` to `action`/`value_parser`.
  - For `#[clap(parse(from_flag))]` replaced with `#[clap(action = ArgAction::SetTrue)]` (#3794)
  - For `#[clap(parse(from_occurrences))]` replaced with `#[clap(action = ArgAction::Count)]` though the field's type must be `u8` (#3794)
  - For `#[clap(parse(from_os_str)]` for `PathBuf`, replace it with
    `#[clap(value_parser)]` (as mentioned earlier this will call
    `value_parser!(PathBuf)` which will auto-select the right `ValueParser`
    automatically).
  - For `#[clap(parse(try_from_str = ...)]`, replace it with `#[clap(value_parser = ...)]`
  - For most other cases, a type implementing `TypedValueParser` will be needed and specify it with `#[clap(value_parser = ...)]`

### Features

- Parsed, typed arguments via `Arg::value_parser` / `ArgMatches::{get_one,get_many}` (#2683, #3732)
  - Several built-in `TypedValueParser`s available with an API open for expansion
  - `value_parser!(T)` macro for selecting a parser for a given type (#3732) and open to expansion via the `ValueParserFactory` trait (#3755)
  - `[&str]` is implicitly a value parser for possible values
  - All `ArgMatches` getters do not assume required arguments (#2505)
  - Add `ArgMatches::remove_*` variants to transfer ownership
  - Add `ArgMatches::try_*` variants to avoid panics for developer errors (#3621)
  - Add a `get_raw` to access the underlying `OsStr`s
  - `PathBuf` value parsers imply `ValueHint::AnyPath` for completions (#3732)
- Explicit control over parsing via `Arg::action` (#3774)
  - `ArgAction::StoreValue`: existing `takes_value(true)` behavior
  - `ArgAction::IncOccurrences`: existing `takes_value(false)` behavior
  - `ArgAction::Help`: existing `--help` behavior
  - `ArgAction::Version`: existing `--version` behavior
  - `ArgAction::Set`: Overwrite existing values (like `Arg::multiple_occurrences` mixed with `Command::args_override_self`) (#3777)
  - `ArgAction::Append`: like `Arg::multiple_occurrences` (#3777)
  - `ArgAction::SetTrue`: Treat `--flag` as `--flag=true` (#3775)
    - Implies `Arg::default_value("false")` (#3786)
    - Parses `Arg::env` via `Arg::value_parser`
  - `ArgAction::SetFalse`: Treat `--flag` as `--flag=false` (#3775)
    - Implies `Arg::default_value("true")` (#3786)
    - Parses `Arg::env` via `Arg::value_parser`
  - `ArgAction::Count`: Treat `--flag --flag --flag` as `--flag=1 --flag=2 --flag=3` (#3775)
    - Implies `Arg::default_value("0")` (#3786)
    - Parses `Arg::env` via `Arg::value_parser`
- *(derive)* Opt-in to new `Arg::value_parser` / `Arg::action` with either `#[clap(value_parser)]` (#3589, #3742) / `#[clap(action)]` attributes (#3794)
  - Default `ValueParser` is determined by `value_parser!` (#3199, #3496)
  - Default `ArgAction` is determine by a hard-coded lookup on the type (#3794)
- `Command::multicall` is now stable for busybox-like programs and REPLs (#2861, #3684)
- `ArgMatches::{try_,}contains_id` for checking if there are values for an argument that mirrors the new `get_{one,many}` API

### Fixes

- Don't correct argument id in `default_value_ifs_os`(#3815)

*parser*
- Set `ArgMatches::value_source` and `ArgMatches::occurrences_of` for external subcommands (#3732)
- Use value delimiter for `Arg::default_missing_values` (#3761, #3765)
- Split`Arg::default_value` / `Arg::env` on value delimiters independent of whether `--` was used (#3765)
- Allow applying defaults to flags (#3294, 3775)
- Defaults no longer satisfy `required` and its variants (#3793)

## [3.1.18] - 2022-05-10

### Fixes

- Fix deprecated `arg_enum!` for users migrating to clap3 (#3717)
- Verify all `required_unless_present_all` arguments exist
- Verify group members exist before processing group members (#3711)
- *(help)* Use `...` when not enough `value_names` are supplied

**gated behind `unstable-v4`**
- Verify `required` is not used with conditional required settings (#3660)
- Disallow more `value_names` than `number_of_values` (#2695)
- *(parser)* Assert on unknown args when using external subcommands (#3703)
- *(parser)* Always fill in `""` argument for external subcommands (#3263)
- *(derive)* Detect escaped external subcommands that look like built-in subcommands (#3703)
- *(derive)* Leave `Arg::id` as `verbatim` casing (#3282)

## [3.1.17] - 2022-05-06

### Fixes

- Allow value names for `arg!` macro to have dashes when quoted, like longs

## [3.1.16] - 2022-05-06

### Fixes

- *(parser)* `Arg::exclusive` overrides `Arg::required`, like other conflicts
- *(error)* Don't duplicate arguments in usage
- *(error)* Don't show hidden arguments in conflict error usage
- *(help)* New `help_template` variable `{name}` to fix problems with `{bin}`
- *(help)* Don't wrap URLs

**gated behind `unstable-v4`**
- Leading dashes in `Arg::long` are no longer allowed
- *(help)* Use `Command::display_name` in the help title rather than `Command::bin_name`

## [3.1.15] - 2022-05-02

### Fixes

- *(error)* Render actual usage for unrecognized subcommands
- *(multicall)* Improve bad command error
- *(multicall)* Always require a multicall command
- *(multicall)* Disallow arguments on multicall parent command
- *(multicall)* More consistent with rest of clap errors


## [3.1.14] - 2022-05-01

### Fixes

- Panic when calling `Command::build` with a required positional argument nested several layers in subcommands

## [3.1.13] - 2022-04-30

### Fixes

- Help subcommand and `Command::write_help` now report required arguments in usage in more circumstances
- Unknown subcommand for help subcommand flag now reports an error with more context
- More details reported when using `debug` feature
- Allow disabling `color` feature with `debug` feature enabled

## [3.1.12] - 2022-04-22

### Fixes

- Regression in 3.1.11 where the (output) streams were crossed

## [3.1.11] - 2022-04-22

### Fixes

- Implied conflicts override `Arg::required`, making the behavior consistent with how we calculate conflicts for error reporting
- Members of a mutually exclusive `ArgGroup`  override `Arg::required`, making the behavior consistent with how we calculate conflicts for error reporting
- `Arg::overrides_with` always override `Arg::required`, not just when the parser processes an override

## [3.1.10] - 2022-04-19

### Features

- Expose `Command::build` for custom help generation or other command introspection needs

## [3.1.9] - 2022-04-15

### Fixes

- Pin the `clap_derive` version so a compatible version is always used with `clap`

## [3.1.8] - 2022-04-01

### Fixes

- Add `Debug` impls to more types

## [3.1.7] - 2022-03-31

### Fixes

- *(derive)* Abort, rather than ignore, when deriving `ArgEnum` with non-unit unskipped variants

## [3.1.6] - 2022-03-07

### Fixes

- Don't panic when validating delimited defaults (#3541)
- Make it clearer that `cargo` feature is needed
- Documentation improvements

## [3.1.5] - 2022-03-02

### Fixes

- Dependency upgrade

## [3.1.4] - 2022-03-02

### Features

- *(help)* Show `PossibleValue::help` in long help (`--help`)  **(gated behind `unstable-v4`)** (#3312)

## [3.1.3] - 2022-02-28

### Fixes

- Don't panic when validating delimited defaults (#3514)

## [3.1.2] - 2022-02-23

### Fixes

- *(derive)* Allow other attribute with a subcommand that has subcommands

### Documentation

- *(examples)* List example topics
- *(derive)* Clarify syntax and relation to builder API

## [3.1.1] - 2022-02-21

### Fixes

- Track caller for `ArgMatches` assertions so the user more easily sees where they need to fix the call

## [3.1.0] - 2022-02-16

### Compatibility

Changes in behavior of note that are not guaranteed to be compatible across releases:

- *(help)* `help` subcommand shows long help like `--help`, rather than short help (`-h`), deprecated `clap::AppSettings::UseLongFormatForHelpSubcommand` (#3440)
- *(help)* Pacman-style subcommands are now ordered the same as usage errors (#3470)
- *(help)* Pacman-style subcommands use standard alternate syntax in usage (#3470)

### Deprecations

- `clap::Command` is now preferred over `clap::App` (#3089 in #3472)
  - `clap::command!` is now preferred over `clap::app_from_crate` (#3089 in #3474)
  - `clap::CommandFactory::command` is now preferred over `clap::IntoApp::into_app` (#3089 in #3473)
- *(help)* `help` subcommand shows long help like `--help`, rather than short help (`-h`), deprecated `clap::AppSettings::UseLongFormatForHelpSubcommand` (#3440)
- *(error)* Deprecate `clap::AppSettings::WaitOnError`, leaving it to the user to implement
- *(validation)* `clap::Command::subcommand_required(true).arg_required_else_help(true)` is now preferred over `clap::AppSettings::SubcommandRequiredElseHelp` (#3280)
- *(builder)* `clap::AppSettings` are nearly all deprecated and replaced with builder methods and getters (#2717)
- *(builder)* `clap::ArgSettings` is deprecated and replaced with builder methods and getters (#2717)
- *(builder)* `clap::Arg::id` and `clap::ArgGroup::id` are now preferred over `clap::Arg::name` and `clap::ArgGroup::name` (#3335)
- *(help)* `clap::Command::next_help_heading` is now preferred over `clap::Command::help_heading` (#1807, #1553)
- *(error)* `clap::error::ErrorKind` is now preferred over `clap::ErrorKind` (#3395)
- *(error)* `clap::Error::kind()` is now preferred over `clap::Error::kind`
- *(error)* `clap::Error::context()` is now preferred over `clap::Error::info` (#2628)

Note: All items deprecated in 3.0.0 are now hidden in the documentation. (#3458)

### Features

- *(matches)* Add `clap::ArgMatches::value_source` to determine what insert the value (#1345)
- *(help)* Override derived display order with `clap::Command::next_display_order` (#1807)
- *(error)* Show possible values when an argument doesn't have a value (#3320)
- *(error)* New `clap::Error::context` API to open the door for fully-custom error messages (#2628)
  - *(error)* `clap::error::ErrorKind` now implements `Display`

### Fixes

- *(builder)* Some functions were renamed for consistency and fixing spelling issues
- *(builder)* Allow `clap::Command::color` to override previous calls (#3449)
- *(parse)* Propagate globals with multiple subcommands (#3428)
- *(validation)* Give `ArgRequiredElseHelp` precedence over `SubcommandRequired` (#3456)
- *(validation)* Default values no longer count as "present" for conflicts, requires, `clap::Command::arg_required_else_help`, etc (#3076, #1264)
- *(assert)* Report invalid defaults (#3202)
- *(help)* Clarify how to handle `-h` conflicts (#3403)
- *(help)* Make it easier to debug the addition of help flags (#3425)
- *(help)* Pacman-style subcommands are now separated with spaces (#3470)
- *(help)* Pacman-style subcommands are now ordered the same as usage errors (#3470)
- *(help)* Pacman-style subcommands use standard alternate syntax in usage (#3470)
- *(error)* Be consistent in showing of required attributes between errors / usage (#3390)
- *(error)* Show user's order of possible values, like in `--help` (#1549)
- *(error)* Allow customizing error type in `clap::error::Result` (#3395)

### Performance

- *(error)* Reduced stack size of `clap::Error` (#3395)

### Documentation

- *(builder)* Correct data take accepted for `clap::Arg::validator`
- *(derive)* Clarify `parse` attribute
- *(tutorial)* Demonstrate custom parsing
- *(example)* Consistently list out required feature flags (#3448)

## [3.0.14] - 2022-02-01

### Features

- Added `ArgMatches::args_present()` to check if any args are present
- Added `Error::kind()` as we work to deprecate direct member access for `Error`
- Added `App::get_version`
- Added `App::get_long_version`
- Added `App::get_author`
- Added `App::get_subcommand_help_heading`
- Added `App::get_subcommand_value_name`
- Added `App::get_after_help`
- Added `App::get_after_long_help`

### Performance

- Misc binary size reductions

## [3.0.13] - 2022-01-26

### Fixes

- Show optional flag values wrapped in `[]`

## [3.0.12] - 2022-01-24

### Features

- *(derive)* Support for `default_value_os_t`

## [3.0.11] - 2022-01-24

### Fixes

- Ensure conflicts work when they target a group with a default value

## [3.0.10] - 2022-01-18

### Fixes

- Resolve `panic!` from v3.0.8 when using `global_setting(PropagateVersion)`.

## [3.0.9] - 2022-01-17

### Features

- Added `App::find_subcommand_mut`

## [3.0.8] - 2022-01-17

### Fixes

- Respected `DisableColoredHelp` on `cmd help help`
- Provide a little more context when completing arguments for `cmd help`
- Provide more context for some asserts
- Small documentation improvements

## [3.0.7] - 2022-01-12

### Fixes

- Shift more asserts from parsing to `App` building (ie will now run in `App::debug_assert`)

**derive**
- Documentation fixes

## [3.0.6] - 2022-01-10

### Fixes

**derive**
- Don't assume user does `use clap::ArgEnum` (#3277)
- Documentation fixes

## [3.0.5] - 2022-01-05

### Fixes

- Provide hack to workaround [inability to detect external subcommands aliasing when escaped](https://github.com/clap-rs/clap/issues/3263) (#3264)

**docs:**
- Cleaned up code blocks in tutorials (#3261)
- Clean up quotes in `ArgMatches` asserts
- List correct replacement for deprecated `Parser::from_clap` (#3257)

## [3.0.4] - 2022-01-04

### Features

- For very limited cases, like `cargo`, expose `ArgMatches::is_valid_arg` to avoid panicing on undefined arguments

## [3.0.3] - 2022-01-04

### Fixes

- Specify cause of debug assert failure

## [3.0.2] - 2022-01-04

### Fixes

- Ignore `Last` when checking hyphen values (see #3249 for details)
- Help catch bugs with `#[must_use]`

## [3.0.1] - 2022-01-03

### Fixes

- Don't panic when getting number of values (#3241)
- Don't warn when using `default_value_t` derive attribute with a `Subcommand` (#3245)

Documentation
- Added `name` attribute to `ArgEnum` variant derive reference

## [3.0.0] - 2021-12-31

**Note:** clap v3 has been in development for several years and has changed
hands multiple times.  Unfortunately, our changelog might be incomplete,
whether in changes or their motivation.

### Highlights

A special thanks to the maintainers, contributors, beta users, and sponsors who
have helped along this journey, especially kbknapp.

**[StructOpt](https://docs.rs/structopt/) Integration**

[StructOpt](https://docs.rs/structopt/) provides a serde-like declarative
approach to defining your parser.  The main benefits we've seen so far from integrating are:
- Tighter feedback between the design of clap and the derives
- More universal traits.  Crates exist for common CLI patterns
  ([example](https://github.com/rust-cli/clap-verbosity-flag))
  and we've re-designed the `StructOpt` traits so crates built on clap3 can be
  reused not just with other derives but also people using the builder API.
  People can even hand implement these so people using the builder API won't
  have the pay the cost for derives.

**Custom Help Headings**

Previously, clap automatically grouped arguments in the help as either
`ARGS`, `FLAGS`, `OPTIONS`, and `SUBCOMMANDS`.

You can now override the default group with `Arg::help_heading` and
`App::subcommand_help_heading`.  To apply a heading to a series of arguments,
you can set `App::help_heading`.

**Deprecations**

While a lot of deprecations have been added to clean up the API (overloaded
meaning of `Arg::multiple`) or make things more consistent, some particular
highlights are:
- `clap_app!` has been deprecated in favor of the builder API with `arg!` ([clap-rs/clap#2835](https://github.com/clap-rs/clap/issues/2835))
- `Arg::from_usage` has been deprecated in favor of `arg!` ([clap-rs/clap#3087](https://github.com/clap-rs/clap/issues/3087))
  - [Porting example](https://github.com/clap-rs/clap/commit/4c4a2b86a08ef9e2d63010aab4909dd5a013dfb0) 
- The YAML API has been deprecated in favor the builder or derive APIs ([clap-rs/clap#3087](https://github.com/clap-rs/clap/issues/3087))

### Migrating

**From clap v2**

1. Add CLI tests, `-h` and `--help` output at a minimum (recommendation: [trycmd](https://docs.rs/trycmd/) for snapshot testing)
2. Update your dependency
    1. *If you use `no-default-features`:* add the `std` feature
3. Resolve compiler errors
4. Resolve behavior changes
    1. Refactor your `App` creation to a function and add a test similar to the one below, resolving any of its assertions
    2. Look over the "subtle changes" under BREAKING CHANGES
    3. *If using builder:* test your application under various circumstances to see if `ArgMatches` asserts regarding `AllowInvalidUtf8`.
5. *At your leisure:* resolve deprecation notices

Example test:
```rust
fn app() -> clap::App<'static> {
    ...
}

#[test]
fn verify_app() {
    app().debug_assert();
}
```

**From structopt 0.3.25**
<a name="migrate-structopt"></a>

1. Add CLI tests, `-h` and `--help` output at a minimum (recommendation: [trycmd](https://docs.rs/trycmd/) for snapshot testing)
2. Replace your dependency from `structopt = "..."` to `clap = { version = "3.0", features = ["derive"] }`
    1. *If you use `no-default-features`:* add the `std` feature
3. Resolve compiler errors, including
    1. Update your `use` statements from `structopt` and `structopt::clap` to `clap`
4. Resolve behavior changes
    1. Add a test similar to the one below, resolving any of its assertions
    2. Look over the "subtle changes" under BREAKING CHANGES
5. *At your leisure:* resolve deprecation notices

Example test:
```rust
#[derive(clap::StructOpt)]
struct Args {
    ...
}

#[test]
fn verify_app() {
    use clap::IntoApp;
    Args::into_app().debug_assert()
}
```

**From clap v3.0.0-beta.5**

1. Add CLI tests, `-h` and `--help` output at a minimum (recommendation: [trycmd](https://docs.rs/trycmd/) for snapshot testing)
2. Update your dependency
    1. Add in `derive`, `env`, `cargo`, or `unicode` feature flags as needed
3. Resolve compiler errors
    1. *If you use `yaml`, `clap_app!`, or usage parser:* revert any changes you made for clap3
    2. Change `Arg::about` `Arg::long_about` back to `help` and `long_help` and change `PossibleValue::about` to `help` ([clap-rs/clap#3075](https://github.com/clap-rs/clap/issues/3075))
    3. Change `AppSettings::HelpRequired` to `AppSettings::HelpExpected`
    4. Change `PossibleValue::hidden` to `PossibleValue::hide`
    5. Change `App::subcommand_placeholder` to `App::subcommand_value_name` / `App::subcommand_help_heading`
4. Resolve behavior changes
    1. Add the above listed test appropriate for your application and resolve any problems it reports
    2. *If using `derive`:* see the structopt breaking changes section for `Vec` changes
    3. *If using builder:* test your application under various circumstances to see if `ArgMatches` asserts regarding `AllowInvalidUtf8`.
5. *At your leisure:* resolve deprecation notices

### BREAKING CHANGES

**From clap 2**

Subtle changes (i.e. compiler won't catch):
- `AppSettings::UnifiedHelpMessage` is now default behaviour
  - `{flags}` and `{unified}` will assert if present in `App::help_template`
  - See [clap-rs/clap#2807](https://github.com/clap-rs/clap/issues/2807)
- `AppSettings::EnableColoredHelp` is now the default behavior but can be
  opted-out with `AppSettings::DisableColoredHelp`
  ([clap-rs/clap#2806](https://github.com/clap-rs/clap/issues/2806))
- `App::override_usage` no longer implies a leading `\t`, allowing multi lined usages
- `Arg::require_equals` no longer implies `ArgSettings::ForbidEmptyValues` ([#2233](https://github.com/clap-rs/clap/issues/2233))
- `Arg::require_delimiter` no longer implies `ArgSettings::TakesValue` and `ArgSettings::UseValueDelimiter` ([#2233](https://github.com/clap-rs/clap/issues/2233))
- `Arg::env`, `Arg::env_os`, `Arg::last`, `Arg::require_equals`, `Arg::allow_hyphen_values`,
  `Arg::hide_possible_values`, `Arg::hide_default_value`, `Arg::hide_env_values`,
  `Arg::case_insensitive` and `Arg::multiple_values` no longer imply `ArgSettings::TakesValue` ([#2233](https://github.com/clap-rs/clap/issues/2233))
- `ArgMatches::is_present` no longer checks subcommand names
- Some env variable values are now considered false for flags, not just "not-present" ([clap-rs/clap#2539](https://github.com/clap-rs/clap/issues/2539))
- Changed `...`s meaning in usage parser.  Before, it always meant `multiple` which is still true for `--option [val]...`.  Now `[name]... --option [val]` results in `ArgSettings::MultipleOccurrences`.
- Usage exit code changed from `1` to `2` ([clap-rs/clap#1327](https://github.com/clap-rs/clap/issues/1327))
- Reject `--foo=bar` when `takes_value(false)` ([clap-rs/clap#1543](https://github.com/clap-rs/clap/issues/1543))
- No longer accept an arbitrary number of `-` for long arguments (`-----long`)

Easier to catch changes:
- When using `no-default-features`, you now have to specify the `std` feature (reserved for future work)
- Gated env support behind `env` feature flag
  - Impacts `Arg::env`, `Arg::env_os`, `Arg::hide_env_values`, `ArgSettings::HideEnvValues`
  - See [clap-rs/clap#2694](https://github.com/clap-rs/clap/pull/2694)
- Gated crate information behind `cargo` feature flag
  - Impacts `crate_name!`, `crate_version!`, `crate_authors!`, `crate_description!`, `app_from_crate!`
- `AppSettings::StrictUtf8` is now default behaviour and asserts if
  `AppSettings::AllowInvalidUtf8ForExternalSubcommands` and
  `ArgSettings::AllowInvalidUtf8` and `ArgMatches::value_of_os` aren't used
  together
  - `AppSettings::AllowInvalidUtf8` has been removed
  - [clap-rs/clap#751](https://github.com/clap-rs/clap/issues/751)
- `Arg::short` and `Arg::value_delimiter` now take a `char` instead of a `&str`
- `ArgMatches` panics on unknown arguments
- Removed `VersionlessSubcommands`, making it the default (see [clap-rs/clap#2812](https://github.com/clap-rs/clap/issues/2812))
- Completion generation has been split out into [clap_complete](./clap_complete).
- Removed `ArgSettings::EmptyValues` in favor of `ArgSettings::ForbidEmptyValues`
- Validator signatures have been loosed:
  - `Arg::validator` now takes first argument as `Fn(&str) -> Result<O, E: ToString>` instead of
    `Fn(String) -> Result<(), String>`
  - `Arg::validator_os` now takes first argument as `Fn(&OsStr) -> Result<O, OsString>` instead of
    `Fn(&OsStr) -> Result<(), OsString>`
- `Arg::value_name` now sets, rather than appends (see [clap-rs/clap#2634](https://github.com/clap-rs/clap/issues/2634))
- Upgrade `yaml-rust` from 0.3 to 0.4
- Replaced `ArgGroup::from(BTreeMap)` to `ArgGroup::from(yaml)`
- Replaced `ArgMatches::usage` with `App::generate_usage`
- Replaced `Arg::settings` with `Arg::setting(Setting1 | Setting2)`
- `App` and `Arg` now need only one lifetime
- Removed deprecated `App::with_defaults`, replaced with `app_from_crate`
- Removed deprecated `AppSettings::PropagateGlobalValuesDown` (now the default)
- Some `App` functions, like `App::write_help` now take `&mut self` instead of `&self`
- `Error::message` is now private, use `Error::to_string`
- `Arg::default_value_if`, `Arg::default_value_if_os`, `Arg::default_value_ifs`,
  `Arg::default_value_ifs_os` now takes the default value parameter as an option ([clap-rs/clap#1406](https://github.com/clap-rs/clap/issues/1406))
- Changed `App::print_help` & `App::print_long_help` to now return `std::io::Result`
- Changed `App::write_help` & `App::write_long_help` to now return `std::io::Result`
- Changed `Arg::index`, `Arg::number_of_values`, `Arg::min_values`, `Arg::max_values` to taking `usize` instead of u64
- Changed `Error::info` to type `Vec<String>` instead of `Option<Vec<String>>`
- Changed `ArgMatches::subcommand` to now return `Option<(&str, &ArgMatches)>`
- Renamed `ErrorKind::MissingArgumentOrSubcommand` to `ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand`
- Renamed `ErrorKind::HelpDisplayed` to `ErrorKind::DisplayHelp`
- Renamed `ErrorKind::VersionDisplayed` to `ErrorKind::DisplayVersion`
- Added `#[non_exhaustive]` to `clap::{ValueHint, ErrorKind, AppSettings, ArgSettings}` ([clap-rs/clap#3167](https://github.com/clap-rs/clap/pull/3167))

**From structopt 0.3.25**

- By default, the `App` isn't initialized with crate information anymore.  Now opt-in via `#[clap(author)]`, `#[clap(about)]`, `#[clap(version)]` ([clap-rs/clap#3034](https://github.com/clap-rs/clap/issues/3034))
- `#[clap(default_value)]` is replaced with `#[clap(default_value_t)]` ([clap-rs/clap#1694](https://github.com/clap-rs/clap/issues/1694))
- Subcommands nested under subcommands now needs a `#[clap(subcommand)]` attribute ([clap-rs/clap#2587](https://github.com/clap-rs/clap/pull/2587))
- `Vec<_>` and `Option<Vec<_>>` have changed from `multiple` to `multiple_occurrences`

On top of the clap 2 changes

### Performance

**From clap 2**

- Split out non-default `unicode` feature flag for faster builds and smaller binaries for ASCII-only CLIs.
- Split out non-default `env` feature flag  for faster builds and smaller binaries.

### Features

**From clap 2**

- Integration of `structopt::StructOpt` via `clap::Parser` (requires `derive` feature flag)
- Custom help headings
  - `App::help_heading` (apply to all future args)
  - `Arg::help_heading` (apply to current arg)
  - `App::subcommand_help_heading` along with `App::subcommand_value_name` (apply to subcommands)
  - See [clap-rs/clap#805](https://github.com/clap-rs/clap/issues/805)
  - `AppSettings::UnifiedHelpMessage` is now default behaviour ([clap-rs/clap#2807](https://github.com/clap-rs/clap/issues/2807))
- Deriving of `ArgEnum` for generating `Arg::possible_values` (requires `derive` feature flag)
- Disable built-in help/version behavior with `AppSettings::NoAutoHelp` and `AppSettings::NoAutoVersion`
- Change an existing arg with new builder method `mut_arg` (particularly helpful for `--help` and `--version`)
- Provide extra context in long help messages (`--help`) with `before_long_help` and `after_long_help` ([clap-rs/clap#1903](https://github.com/clap-rs/clap/issues/1903))
- Detect missing help descriptions via debug asserts by enabling `AppSettings::HelpExpected`
- Aliases for short flags ([clap-rs/clap#1896](https://github.com/clap-rs/clap/issues/1896))
- Validate UTF-8 values, rather than panicing during `ArgMatches::value_of` thanks to `AppSettings::AllowInvalidUtf8ForExternalSubcommands` and `ArgSettings::AllowInvalidUtf8`
  - Debug builds will assert when the `ArgMatches` calls do not match the UTF-8 setting.
  - See [clap-rs/clap#751](https://github.com/clap-rs/clap/issues/751)
- `clap::PossibleValue` to allow
  - Hiding ([clap-rs/clap#2756](https://github.com/clap-rs/clap/issues/2756))
  - Completion help for possible values for args ([clap-rs/clap#2731](https://github.com/clap-rs/clap/issues/2731))
- Allow arguments to conflict with all others via `Arg::exclusive` ([clap-rs/clap#1583](https://github.com/clap-rs/clap/issues/1583))
- Validate arguments with a regex (required `regex` feature flag)
  - See [clap-rs/clap](https://github.com/clap-rs/clap/issues/1968)
- `Arg::default_missing_value` for cases like `--color[=<WHEN>]` ([clap-rs/clap#1587](https://github.com/clap-rs/clap/pull/1587))
- `clap::App::color` / `clap::ColorChoice` to specify color setting for the app
- Custom error reporting with `App::error`
- `App::debug_assert` test helper
- Replace `Arg::multiple(bool)` with `Arg::multiple_values` / `Arg::multiple_occurrences`
  - Positionals can be either
- Added support for flag subcommands like pacman ([clap-rs/clap#1361](https://github.com/clap-rs/clap/issues/1361))
- Partial parsing via `AppSettings::IgnoreErrors` ([clap-rs/clap#1880](https://github.com/clap-rs/clap/issues/1880))
- Enable `cmd help` to print long help (`--help` instead of `-h`) with `AppSettings::UseLongFormatForHelpSubcommand` ([clap-rs/clap#2435](https://github.com/clap-rs/clap/issues/2435))
- Allow long arg abbreviations like we do with subcommands via `AppSettings::InferLongArgs` ([clap-rs/clap#2435](https://github.com/clap-rs/clap/issues/2435))
- Detect subcommands among positional arguments with `AppSettings::SubcommandPrecedenceOverArg`
- Give completion scripts hints with `Arg::value_hint` ([clap-rs/clap#1793](https://github.com/clap-rs/clap/pull/1793))
- Allow unsetting defaults with
- `Arg::default_value_if`, `Arg::default_value_if_os`, `Arg::default_value_ifs`,
  `Arg::default_value_ifs_os` ([clap-rs/clap#1406](https://github.com/clap-rs/clap/issues/1406))
- Interpret some env variable values as `false` for flags, in addition to "not-present" ([clap-rs/clap#2539](https://github.com/clap-rs/clap/issues/2539))
  - `n`, `no`, `f`, `false`, `off`, `0`
- Added `arg!` macro for creating an `Arg` from a compile-time usage parser

- *(Experimental)* Busybox-like multi-call support
  - See `AppSettings::Multicall` behind `unstable-multicall` feature flag
  - See [clap-rs/clap#1120](https://github.com/clap-rs/clap/issues/1120)
- *(Experimental)* Alias an argument to anything group of arguments
  - See `App::replace` behind `unstable-replace` feature flag
  - See [clap-rs#1603](https://github.com/clap-rs/clap/issues/1603)
- *(Experimental)* Grouping of multiple values within multiple occurrences
  - See `ArgMatches::grouped_values_of` behind `unstable-grouped` feature flag
  - See [clap-rs/clap#1026](https://github.com/clap-rs/clap/issues/1026)

**From structopt 0.3.25**

- Allow defaulting with native types via new `default_value_t [= <expr>]` attribute ([clap-rs/clap#1694](https://github.com/clap-rs/clap/issues/1694))
- New `update` API
- New `arg_enum` attribute for integrating with `ArgEnum` trait

On top of the clap 2 changes

### Fixes

**From clap 2**

- Correctly handle colored output on Windows
- Only generate version flags when `App::version`, `App::long_version` are set
  (see [clap-rs/clap#2812](https://github.com/clap-rs/clap/issues/2812))
- General completion script improvements
- Limited default help text wrapping to 100 when `wrap_help` feature is not enabled
- Be more specific than `Arg::multiple` with `Arg::multiple_values` and `Arg::multiple_occurrences`
- `app_from_crate!` defaults to separating multiple authors with `", "`
- Ensure all examples work
- `IgnoreCase` is now unicode aware (requires `unicode` feature flag)
- Always respect `ColorChoice::Never`, even if that means we skip colors in some cases
- `ArgMatches` panics on unknown arguments
- Gracefully handle empty `authors` field in `Cargo.toml` with `app_from_crate`
- Do not show `--help` in `cmd help` with `DisableHelpFlag` ([clap-rs/clap#3169](https://github.com/clap-rs/clap/pull/3169))
- Do not show `--help` in `cmd help help` that doesn't work ([clap-rs/clap#3169](https://github.com/clap-rs/clap/pull/3169))

**From structopt 0.3.25**

- Support `SubcommandsNegateReqs` by allowing required `Option<_>`s ([clap-rs/clap#2255](https://github.com/clap-rs/clap/issues/2255))
- Infer `AllowInvalidUtf8` based on parser ([clap-rs/clap#751](https://github.com/clap-rs/clap/issues/2255))
- Gracefully handle empty `authors` field in `Cargo.toml`
- Don't panic with `default_value_os` but treat it like `default_value` ([clap-rs/clap#3031](https://github.com/clap-rs/clap/issues/3031))
- When using `flatten` and `subcommand`, ensure our doc comment always overrides the nested container's doc comment, whether it has only `about` or `about` and `long_about` ([clap-rs/clap#3175](]https://github.com/clap-rs/clap/pull/3175))

On top of the clap 2 changes

### Minimum Required Rust

- As of this release, `clap` requires `rustc 1.54.0` or greater.

## [2.34.0] - 2021-11-30

- Updates to Rust 2018 edition and bumps the MSRV to Rust 1.46

## [2.33.4] - 2021-11-29

### Bug Fixes

* **prevents `panic`:**  swallows broken pipe errors on error output ([7a729bc4](https://github.com/kbknapp/clap-rs/commit/7a729bc4df2646b05f6bf15f001124cd39d076ce))

## [2.33.3] - 2020-08-13

### Improvements

* Suppress deprecation warnings when using `crate_*` macros.

## [2.33.2] - 2020-08-5

#### Documentation

* Fixed links to `2.x` examples. Now they point to the right place.

## [2.33.1] - 2020-05-11

### Bug Fixes

* Windows: Prevent some panics when parsing invalid Unicode on Windows ([922c645](https://github.com/clap-rs/clap/commit/922c64508389170c9c77f1c8a4e597d14d3ed2f0), closes [#1905](https://github.com/clap-rs/clap/issues/1905))

### Documentation

*   fixes versions referenced in the README ([d307466a](https://github.com/kbknapp/clap-rs/commit/d307466af1013f172b8ec0252f01a473e2192d6b))
* **README.md:**
  *  cuts down the number of examples to reduce confusion ([6e508ee0](https://github.com/kbknapp/clap-rs/commit/6e508ee09e7153de4adf4e88b0aa6418a537dadd))

### Improvements

* **Deps:**  doesnt compile ansi_term on Windows since its not used ([b57ee946](https://github.com/kbknapp/clap-rs/commit/b57ee94609da3ddc897286cfba968f26ff961491), closes [#1155](https://github.com/kbknapp/clap-rs/issues/1155))

### Minimum Required Rust

* As of this release, `clap` requires `rustc 1.36.0` or greater.

## [2.33.0] - 2019-04-06

#### New Sponsor

*   Stephen Oats is now a sponsor \o/ ([823457c0](https://github.com/clap-rs/clap/commit/823457c0ef5e994ed7080cf62addbfe1aa3b1833))
* **SPONSORS.md:**  fixes Josh Triplett's info in the sponsor document ([24cb5740](https://github.com/clap-rs/clap/commit/24cb574090a11159b48bba105d5ec2dfb0a20e4e))

#### Features

* **Completions:**  adds completion support for Elvish. ([e9d0562a](https://github.com/clap-rs/clap/commit/e9d0562a1dc5dfe731ed7c767e6cee0af08f0cf9))
* There is a new setting to disable automatic building of `--help` and `-h` flags (`AppSettings::DisableAutoHelp`)

#### Improvements

* **arg_matches.rs:**  add Debug implementations ([47192b7a](https://github.com/clap-rs/clap/commit/47192b7a2d84ec716b81ae4af621e008a8762dc9))
* **macros:**  Support shorthand syntax for ArgGroups ([df9095e7](https://github.com/clap-rs/clap/commit/df9095e75bb1e7896415251d0d4ffd8a0ebcd559))

#### Documentation

*   Refer to macOS rather than OSX. ([ab0d767f](https://github.com/clap-rs/clap/commit/ab0d767f3a5a57e2bbb97d0183c2ef63c8c77a6c))
* **README.md:**  use https for all links ([96a7639a](https://github.com/clap-rs/clap/commit/96a7639a36bcb184c3f45348986883115ef1ab3a))

#### Bug Fixes

*   add debug assertion for missing args in subcommand ArgGroup ([2699d9e5](https://github.com/clap-rs/clap/commit/2699d9e51e7eadc258ba64c4e347c5d1fef61343))
*   Restore compat with Rust 1.21 ([6b263de1](https://github.com/clap-rs/clap/commit/6b263de1d42ede692ec5ee55019ad2fc6386f92e))
*   Don't mention unused subcommands ([ef92e2b6](https://github.com/clap-rs/clap/commit/ef92e2b639ed305bdade4741f60fa85cb0101c5a))
* **OsValues:**  Add `ExactSizeIterator` implementation ([356c69e5](https://github.com/clap-rs/clap/commit/356c69e508fd25a9f0ea2d27bf80ae1d9a8d88f4))
* **arg_enum!:**
  *  Fix comma position for valid values. ([1f1f9ff3](https://github.com/clap-rs/clap/commit/1f1f9ff3fa38a43231ef8be9cfea89a32e53f518))
  *  Invalid expansions of some trailing-comma patterns ([7023184f](https://github.com/clap-rs/clap/commit/7023184fca04e852c270341548d6a16207d13862))
* **completions:**  improve correctness of completions when whitespace is involved ([5a08ff29](https://github.com/clap-rs/clap/commit/5a08ff295b2aa6ce29420df6252a0e3ff4441bdc))
* **help message:**  Unconditionally uses long description for subcommands ([6acc8b6a](https://github.com/clap-rs/clap/commit/6acc8b6a621a765cbf513450188000d943676a30), closes [#897](https://github.com/clap-rs/clap/issues/897))
* **macros:**  fixes broken pattern which prevented calling multi-argument Arg methods ([9e7a352e](https://github.com/clap-rs/clap/commit/9e7a352e13aaf8025d80f2bac5c47fb32528672b))
* **parser:**  Better interaction between AllowExternalSubcommands and SubcommandRequired ([9601c95a](https://github.com/clap-rs/clap/commit/9601c95a03d2b82bf265c328b4769238f1b79002))

#### Minimum Required Rust

* As of this release, `clap` requires `rustc 1.31.0` or greater.

## v2.32.0 (2018-06-26)

#### Minimum Required Rust

* As of this release, `clap` requires `rustc 1.21.0` or greater.


#### Features

* **Completions:**  adds completion support for Elvish. ([e9d0562a](https://github.com/clap-rs/clap/commit/e9d0562a1dc5dfe731ed7c767e6cee0af08f0cf9))

#### Improvements

* **macros:**  Support shorthand syntax for ArgGroups ([df9095e7](https://github.com/clap-rs/clap/commit/df9095e75bb1e7896415251d0d4ffd8a0ebcd559))

#### Bug Fixes

* **OsValues:**  Add `ExactSizeIterator` implementation ([356c69e5](https://github.com/clap-rs/clap/commit/356c69e508fd25a9f0ea2d27bf80ae1d9a8d88f4))
* **arg_enum!:**  Invalid expansions of some trailing-comma patterns ([7023184f](https://github.com/clap-rs/clap/commit/7023184fca04e852c270341548d6a16207d13862))
* **help message:**  Unconditionally uses long description for subcommands ([6acc8b6a](https://github.com/clap-rs/clap/commit/6acc8b6a621a765cbf513450188000d943676a30), closes [#897](https://github.com/clap-rs/clap/issues/897))

#### Documentation

*   Refer to macOS rather than OSX. ([ab0d767f](https://github.com/clap-rs/clap/commit/ab0d767f3a5a57e2bbb97d0183c2ef63c8c77a6c))



## v2.31.2 (2018-03-19)

#### Bug Fixes

* **Fish Completions:**  fixes a bug that only allowed a single completion in in Fish Shell ([e8774a8](https://github.com/clap-rs/clap/pull/1214/commits/e8774a84ee4a319c888036e7c595ab46451d8e48), closes [#1212](https://github.com/clap-rs/clap/issues/1212))
* **AllowExternalSubcommands**: fixes a bug where external subcommands would be blocked by a similarly named subcommand (suggestions were getting in the way). ([a410e85](https://github.com/clap-rs/clap/pull/1215/commits/a410e855bcd82b05f9efa73fa8b9774dc8842c6b))

#### Documentation

* Fixes some typos in the `README.md` ([c8e685d7](https://github.com/clap-rs/clap/commit/c8e685d76adee2a3cc06cac6952ffcf6f9548089))

## v2.31.1 (2018-03-06)


#### Improvements

* **AllowMissingPositional:**  improves the ability of AllowMissingPositional to allow 'skipping' to the last positional arg with '--' ([df20e6e2](https://github.com/clap-rs/clap/commit/df20e6e24b4e782be0b423b484b9798e3e2efe2f))


## v2.31.0 (2018-03-04)


#### Features

* **Arg Indices:**  adds the ability to query argument value indices ([f58d0576](https://github.com/clap-rs/clap/commit/f58d05767ec8133c8eb2de117cb642b9ae29ccbc))
* **Indices:**  implements an Indices<Item=&usize> iterator ([1e67be44](https://github.com/clap-rs/clap/commit/1e67be44f0ccf161cc84c4e6082382072e89c302))
* **Raw Args** adds a convenience function to `Arg` that allows implying all of `Arg::last` `Arg::allow_hyphen_values` and `Arg::multiple(true)` ([66a78f29](https://github.com/clap-rs/clap/commit/66a78f2972786f5fe7c07937a1ac23da2542afd2))

#### Documentation

*   Fix some typos and markdown issues. ([935ba0dd](https://github.com/clap-rs/clap/commit/935ba0dd547a69c3f636c5486795012019408794))
* **Arg Indices:**  adds the documentation for the arg index querying methods ([50bc0047](https://github.com/clap-rs/clap/commit/50bc00477afa64dc6cdc5de161d3de3ba1d105a7))
* **CONTRIBUTING.md:**  fix url to clippy upstream repo to point to https://github.com/rust-lang-nursery/rust-clippy instead of https://github.com/Manishearth/rust-clippy ([42407d7f](https://github.com/clap-rs/clap/commit/42407d7f21d794103cda61f49d2615aae0a4bcd9))
* **Values:**  improves the docs example of the Values iterator ([74075d65](https://github.com/clap-rs/clap/commit/74075d65e8db1ddb5e2a4558009a5729d749d1b6))
* Updates readme to hint that the `wrap_help` feature is a thing ([fc7ab227](https://github.com/clap-rs/clap/commit/66a78f2972786f5fe7c07937a1ac23da2542afd2))

### Improvements

*  Cargo.toml: use codegen-units = 1 in release and bench profiles ([19f425ea](https://github.com/clap-rs/clap/commit/66a78f2972786f5fe7c07937a1ac23da2542afd2))
*  Adds WASM support (clap now compiles on WASM!) ([689949e5](https://github.com/clap-rs/clap/commit/689949e57d390bb61bc69f3ed91f60a2105738d0))
*  Uses the short help tool-tip for PowerShell completion scripts ([ecda22ce](https://github.com/clap-rs/clap/commit/ecda22ce7210ce56d7b2d1a5445dd1b8a2959656))


## v2.30.0 (2018-02-13)

#### Bug Fixes

* **YAML:** Adds a missing conversion from  `Arg::last` when instantiating from a YAML file ([aab77c81a5](https://github.com/clap-rs/clap/pull/1175/commits/aab77c81a519b045f95946ae0dd3e850f9b93070), closes [#1160](https://github.com/clap-rs/clap/issues/1173))

#### Improvements

* **Bash Completions:**  instead of completing a generic option name, all bash completions fall back to file completions UNLESS `Arg::possible_values` was used ([872f02ae](https://github.com/clap-rs/clap/commit/872f02aea900ffa376850a279eb164645e1234fa))
* **Deps:**  No longer needlessly compiles `ansi_term` on Windows since its not used ([b57ee946](https://github.com/clap-rs/clap/commit/b57ee94609da3ddc897286cfba968f26ff961491), closes [#1155](https://github.com/clap-rs/clap/issues/1155))
* **Help Message:** changes the `[values: foo bar baz]` array to `[possible values: foo bar baz]` for consistency with the API ([414707e4e97](https://github.com/clap-rs/clap/pull/1176/commits/414707e4e979d07bfe555247e5d130c546673708), closes [#1160](https://github.com/clap-rs/clap/issues/1160))


## v2.29.4 (2018-02-06)


#### Bug Fixes

* **Overrides Self:**  fixes a bug where options with multiple values couldn't ever have multiple values ([d95907cf](https://github.com/clap-rs/clap/commit/d95907cff6d011a901fe35fa00b0f4e18547a1fb))



## v2.29.3 (2018-02-05)


#### Improvements

* **Overrides:**  clap now supports arguments which override with themselves ([6c7a0010](https://github.com/clap-rs/clap/commit/6c7a001023ca1eac1cc6ffe6c936b4c4a2aa3c45), closes [#976](https://github.com/clap-rs/clap/issues/976))

#### Bug Fixes

* **Requirements:**  fixes an issue where conflicting args would still show up as required ([e06cefac](https://github.com/clap-rs/clap/commit/e06cefac97083838c0a4e1444dcad02a5c3f911e), closes [#1158](https://github.com/clap-rs/clap/issues/1158))
* Fixes a bug which disallows proper nesting of `--` ([73993fe](https://github.com/clap-rs/clap/commit/73993fe30d135f682e763ec93dcb0814ed518011), closes [#1161](https://github.com/clap-rs/clap/issues/1161))

#### New Settings

* **AllArgsOverrideSelf:**  adds a new convenience setting to allow all args to override themselves ([4670325d](https://github.com/clap-rs/clap/commit/4670325d1bf0369addec2ae2bcb56f1be054c924))



## v2.29.2 (2018-01-16)


#### Features

* **completions/zsh.rs:**
  *  Escape possible values for options ([25561dec](https://github.com/clap-rs/clap/commit/25561decf147d329b64634a14d9695673c2fc78f))
  *  Implement positional argument possible values completion ([f3b0afd2](https://github.com/clap-rs/clap/commit/f3b0afd2bef8b7be97162f8a7802ddf7603dff36))
  *  Complete positional arguments properly ([e39aeab8](https://github.com/clap-rs/clap/commit/e39aeab8487596046fbdbc6a226e5c8820585245))

#### Bug Fixes

* **completions/zsh.rs:**
  *  Add missing autoload for is-at-least ([a6522607](https://github.com/clap-rs/clap/commit/a652260795d1519f6ec2a7a09ccc1258499cad7b))
  *  Don't pass -S to _arguments if Zsh is too old ([16b4f143](https://github.com/clap-rs/clap/commit/16b4f143ff466b7ef18a267bc44ade0f9639109b))
  *  Maybe fix completions with mixed positionals and subcommands ([1146f0da](https://github.com/clap-rs/clap/commit/1146f0da154d6796fbfcb09db8efa3593cb0d898))
* **completions/zsh.zsh:**  Remove redundant code from output ([0e185b92](https://github.com/clap-rs/clap/commit/0e185b922ed1e0fd653de00b4cd8d567d72ff68e), closes [#1142](https://github.com/clap-rs/clap/issues/1142))



### 2.29.1 (2018-01-09)


#### Documentation

*   fixes broken links. ([56e734b8](https://github.com/clap-rs/clap/commit/56e734b839303d733d2e5baf7dac39bd7b97b8e4))
*   updates contributors list ([e1313a5a](https://github.com/clap-rs/clap/commit/e1313a5a0f69d8f4016f73b860a63af8318a6676))

#### Performance

*   further debloating by removing generics from error cases ([eb8d919e](https://github.com/clap-rs/clap/commit/eb8d919e6f3443db279ba0c902f15d76676c02dc))
*   debloats clap by deduplicating logic and refactors ([03e413d7](https://github.com/clap-rs/clap/commit/03e413d7175d35827cd7d8908d47dbae15a849a3))

#### Bug Fixes

*   fixes the ripgrep benchmark by adding a value to a flag that expects it ([d26ab2b9](https://github.com/clap-rs/clap/commit/d26ab2b97cf9c0ea675b440b7b0eaf6ac3ad01f4))
* **bash completion:**  Change the bash completion script code generation to support hyphens. ([ba7f1d18](https://github.com/clap-rs/clap/commit/ba7f1d18eba7a07ce7f57e0981986f66c994b639))
* **completions/zsh.rs:**  Fix completion of long option values ([46365cf8](https://github.com/clap-rs/clap/commit/46365cf8be5331ba04c895eb183e2f230b5aad51))


## 2.29.0 (2017-12-02)


#### API Additions

* **Arg:**  adds Arg::hide_env_values(bool) which allows one to hide any current env values and display only the key in help messages ([fb41d062](https://github.com/clap-rs/clap/commit/fb41d062eedf37cb4f805c90adca29909bd197d7))



## 2.28.0 (2017-11-28)

The minimum required Rust is now 1.20. This was done to start using bitflags 1.0 and having >1.0 deps is a *very good* thing!

#### Documentation

*   changes the demo version to 2.28 to stay in sync ([ce6ca492](https://github.com/clap-rs/clap/commit/ce6ca492c7510ab6474075806360b96081b021a9))
*   Fix URL path to github hosted files ([ce72aada](https://github.com/clap-rs/clap/commit/ce72aada56a9581d4a6cb4bf9bdb861c3906f8df), closes [#1106](https://github.com/clap-rs/clap/issues/1106))
*   fix typo ([002b07fc](https://github.com/clap-rs/clap/commit/002b07fc98a1c85acb66296b1eec0b2aba906125))
* **README.md:**  updates the readme and pulls out some redundant sections ([db6caf86](https://github.com/clap-rs/clap/commit/db6caf8663747e679d2f4ed3bd127f33476754aa))

#### Improvements

*   adds '[SUBCOMMAND]' to usage strings with only AppSettings::AllowExternalSubcommands is used with no other subcommands ([e78bb757](https://github.com/clap-rs/clap/commit/e78bb757a3df16e82d539e450c06767a6bfcf859), closes [#1093](https://github.com/clap-rs/clap/issues/1093))

#### API Additions

*   Adds Arg::case_insensitive(bool) which allows matching Arg::possible_values without worrying about ASCII case ([1fec268e](https://github.com/clap-rs/clap/commit/1fec268e51736602e38e67c76266f439e2e0ef12), closes [#1118](https://github.com/clap-rs/clap/issues/1118))
*   Adds the traits to be used with the clap-derive crate to be able to use Custom Derive ([6f4c3412](https://github.com/clap-rs/clap/commit/6f4c3412415e882f5ca2cc3fbd6d4dce79440828))

#### Bug Fixes

*   Fixes a regression where --help couldn't be overridden ([a283d69f](https://github.com/clap-rs/clap/commit/a283d69fc08aa016ae1bf9ba010012abecc7ba69), closes [#1112](https://github.com/clap-rs/clap/issues/1112))
*   fixes a bug that allowed options to pass parsing when no value was provided ([2fb75821](https://github.com/clap-rs/clap/commit/2fb758219c7a60d639da67692e100b855a8165ac), closes [#1105](https://github.com/clap-rs/clap/issues/1105))
*   ignore PropagateGlobalValuesDown deprecation warning ([f61ce3f5](https://github.com/clap-rs/clap/commit/f61ce3f55fe65e16b3db0bd4facdc4575de22767), closes [#1086](https://github.com/clap-rs/clap/issues/1086))

#### Deps

*  Updates `bitflags` to 1.0



## v2.27.1 (2017-10-24)


#### Bug Fixes

* Adds `term_size` as an optional dependency (with feature `wrap_help`) to fix compile bug

## v2.27.0 (2017-10-24)

** This release raises the minimum required version of Rust to 1.18 **

** This release also contains a very minor breaking change to fix a bug **

The only CLIs affected will be those using unrestrained multiple values and subcommands where the
subcommand name can coincide with one of the multiple values.

See the commit [0c223f54](https://github.com/clap-rs/clap/commit/0c223f54ed46da406bc8b43a5806e0b227863b31) for full details.


#### Bug Fixes

*   Values from global args are now propagated UP and DOWN!
*   fixes a bug where using AppSettings::AllowHyphenValues would allow invalid arguments even when there is no way for them to be valid ([77ed4684](https://github.com/clap-rs/clap/commit/77ed46841fc0263d7aa32fcc5cc49ef703b37c04), closes [#1066](https://github.com/clap-rs/clap/issues/1066))
*   when an argument requires a value and that value happens to match a subcommand name, its parsed as a value ([0c223f54](https://github.com/clap-rs/clap/commit/0c223f54ed46da406bc8b43a5806e0b227863b31), closes [#1031](https://github.com/clap-rs/clap/issues/1031), breaks [#](https://github.com/clap-rs/clap/issues/), [#](https://github.com/clap-rs/clap/issues/))
*   fixes a bug that prevented number_of_values and default_values to be used together ([5eb342a9](https://github.com/clap-rs/clap/commit/5eb342a99dde07b0f011048efde3e283bc1110fc), closes [#1050](https://github.com/clap-rs/clap/issues/1050), [#1056](https://github.com/clap-rs/clap/issues/1056))
*   fixes a bug that didn't allow args with default values to have conflicts ([58b5b4be](https://github.com/clap-rs/clap/commit/58b5b4be315280888d50d9b15119b91a9028f050), closes [#1071](https://github.com/clap-rs/clap/issues/1071))
*   fixes a panic when using global args and calling App::get_matches_from_safe_borrow multiple times ([d86ec797](https://github.com/clap-rs/clap/commit/d86ec79742c77eb3f663fb30e225954515cf25bb), closes [#1076](https://github.com/clap-rs/clap/issues/1076))
*   fixes issues and potential regressions with global args values not being propagated properly or at all ([a43f9dd4](https://github.com/clap-rs/clap/commit/a43f9dd4aaf1864dd14a3c28dec89ccdd70c61e5), closes [#1010](https://github.com/clap-rs/clap/issues/1010), [#1061](https://github.com/clap-rs/clap/issues/1061), [#978](https://github.com/clap-rs/clap/issues/978))
*   fixes a bug where default values are not applied if the option supports zero values ([9c248cbf](https://github.com/clap-rs/clap/commit/9c248cbf7d8a825119bc387c23e9a1d1989682b0), closes [#1047](https://github.com/clap-rs/clap/issues/1047))

#### Documentation

*   adds additional blurbs about using multiples with subcommands ([03455b77](https://github.com/clap-rs/clap/commit/03455b7751a757e7b2f6ffaf2d16168539c99661))
*   updates the docs to reflect changes to global args and that global args values can now be propagated back up the stack ([ead076f0](https://github.com/clap-rs/clap/commit/ead076f03ada4c322bf3e34203925561ec496d87))
*   add html_root_url attribute ([e67a061b](https://github.com/clap-rs/clap/commit/e67a061bcf567c6518d6c2f58852e01f02764b22))
*   sync README version numbers with crate version ([5536361b](https://github.com/clap-rs/clap/commit/5536361bcda29887ed86bb68e43d0b603cbc423f))

#### Improvements

*   args that have require_delimiter(true) is now reflected in help and usage strings ([dce61699](https://github.com/clap-rs/clap/commit/dce616998ed9bd95e8ed3bec1f09a4883da47b85), closes [#1052](https://github.com/clap-rs/clap/issues/1052))
*   if all subcommands are hidden, the subcommands section of the help message is no longer displayed ([4ae7b046](https://github.com/clap-rs/clap/commit/4ae7b0464750bc07ec80ece38e43f003fdd1b8ae), closes [#1046](https://github.com/clap-rs/clap/issues/1046))

#### Breaking Changes

*   when an argument requires a value and that value happens to match a subcommand name, its parsed as a value ([0c223f54](https://github.com/clap-rs/clap/commit/0c223f54ed46da406bc8b43a5806e0b227863b31), closes [#1031](https://github.com/clap-rs/clap/issues/1031), breaks [#](https://github.com/clap-rs/clap/issues/), [#](https://github.com/clap-rs/clap/issues/))

#### Deprecations

* **AppSettings::PropagateGlobalValuesDown:**  this setting is no longer required to propagate values down or up ([2bb5ddce](https://github.com/clap-rs/clap/commit/2bb5ddcee61c791ca1aaca494fbeb4bd5e277488))



## v2.26.2 (2017-09-14)


#### Improvements

*   if all subcommands are hidden, the subcommands section of the help message is no longer displayed ([4ae7b046](https://github.com/clap-rs/clap/commit/4ae7b0464750bc07ec80ece38e43f003fdd1b8ae), closes [#1046](https://github.com/clap-rs/clap/issues/1046))

#### Bug Fixes

*   fixes a bug where default values are not applied if the option supports zero values ([9c248cbf](https://github.com/clap-rs/clap/commit/9c248cbf7d8a825119bc387c23e9a1d1989682b0), closes [#1047](https://github.com/clap-rs/clap/issues/1047))



## v2.26.1 (2017-09-14)


#### Bug Fixes

*   fixes using require_equals(true) and min_values(0) together ([10ae208f](https://github.com/clap-rs/clap/commit/10ae208f68518eff6e98166724065745f4083174), closes [#1044](https://github.com/clap-rs/clap/issues/1044))
*   escape special characters in zsh and fish completions ([87e019fc](https://github.com/clap-rs/clap/commit/87e019fc84ba6193a8c4ddc26c61eb99efffcd25))
*   avoid panic generating default help msg if term width set to 0 due to bug in textwrap 0.7.0 ([b3eadb0d](https://github.com/clap-rs/clap/commit/b3eadb0de516106db4e08f078ad32e8f6d6e7a57))
*   Change `who's` -> `whose` ([53c1ffe8](https://github.com/clap-rs/clap/commit/53c1ffe87f38b05d8804a0f7832412a952845349))
*   adds a debug assertion to ensure all args added to groups actually exist ([7ad123e2](https://github.com/clap-rs/clap/commit/7ad123e2c02577e3ca30f7e205181e896b157d11), closes [#917](https://github.com/clap-rs/clap/issues/917))
*   fixes a bug where args that allow values to start with a hyphen couldn't contain a double hyphen -- as a value ([ab2f4c9e](https://github.com/clap-rs/clap/commit/ab2f4c9e563e36ec739a4b55d5a5b76fdb9e9fa4), closes [#960](https://github.com/clap-rs/clap/issues/960))
*   fixes a bug where positional argument help text is misaligned ([54c16836](https://github.com/clap-rs/clap/commit/54c16836dea4651806a2cfad53146a83fa3abf21))
* **Help Message:**  fixes long_about not being usable ([a8257ea0](https://github.com/clap-rs/clap/commit/a8257ea0ffb812e552aca256c4a3d2aebfd8065b), closes [#1043](https://github.com/clap-rs/clap/issues/1043))
* **Suggestions:**  output for flag after subcommand ([434ea5ba](https://github.com/clap-rs/clap/commit/434ea5ba71395d8c1afcf88e69f0b0d8339b01a1))



## v2.26.0 (2017-07-29)

Minimum version of Rust is now v1.13.0 (Stable)


#### Improvements

*   bumps unicode-segmentation to v1.2 ([cd7b40a2](https://github.com/clap-rs/clap/commit/cd7b40a21c77bae17ba453c5512cb82b7d1ce474))


#### Performance

*   update textwrap to version 0.7.0 ([c2d4e637](https://github.com/clap-rs/clap/commit/c2d4e63756a6f070e38c16dff846e9b0a53d6f93))




## v2.25.1 (2017-07-21)

#### Improvements

* impl Default for Values + OsValues for any lifetime. ([fb7d6231f1](https://github.com/clap-rs/clap/commit/fb7d6231f13a2f79f411e62dca210b7dc9994c18))

#### Documentation

* Various documentation typos and grammar fixes

## v2.25.0 (2017-06-20)


#### Features

*   use textwrap crate for wrapping help texts ([b93870c1](https://github.com/clap-rs/clap/commit/b93870c10ae3bd90d233c586a33e086803117285))

#### Improvements

* **Suggestions:**  suggests to use flag after subcommand when applicable ([2671ca72](https://github.com/clap-rs/clap/commit/2671ca7260119d4311d21c4075466aafdd9da734))
* Bumps bitflags crate to v0.9

#### Documentation

*   Change `who's` -> `whose` ([53c1ffe8](https://github.com/clap-rs/clap/commit/53c1ffe87f38b05d8804a0f7832412a952845349))

#### Documentation

* **App::template:**  adds details about the necessity to use AppSettings::UnifiedHelpMessage when using {unified} tags in the help template ([cbea3d5a](https://github.com/clap-rs/clap/commit/cbea3d5acf3271a7a734498c4d99c709941c331e), closes [#949](https://github.com/clap-rs/clap/issues/949))
* **Arg::allow_hyphen_values:**  updates the docs to include warnings for allow_hyphen_values and multiple(true) used together ([f9b0d657](https://github.com/clap-rs/clap/commit/f9b0d657835d3f517f313d70962177dc30acf4a7))
* **README.md:**
  *  added a warning about using ~ deps ([821929b5](https://github.com/clap-rs/clap/commit/821929b51bd60213955705900a436c9a64fcb79f), closes [#964](https://github.com/clap-rs/clap/issues/964))
* **clap_app!:**  adds using the @group specifier to the macro docs ([826048cb](https://github.com/clap-rs/clap/commit/826048cb3cbc0280169303f1498ff0a2b7395883), closes [#932](https://github.com/clap-rs/clap/issues/932))



## v2.24.2 (2017-05-15)


#### Bug Fixes

*   adds a debug assertion to ensure all args added to groups actually exist ([14f6b8f3](https://github.com/clap-rs/clap/commit/14f6b8f3a2f6df73aeeec9c54a54909b1acfc158), closes [#917](https://github.com/clap-rs/clap/issues/917))
*   fixes a bug where args that allow values to start with a hyphen couldn't contain a double hyphen -- as a value ([ebf73a09](https://github.com/clap-rs/clap/commit/ebf73a09db6f3c03c19cdd76b1ba6113930e1643), closes [#960](https://github.com/clap-rs/clap/issues/960))
*   fixes a bug where positional argument help text is misaligned ([54c16836](https://github.com/clap-rs/clap/commit/54c16836dea4651806a2cfad53146a83fa3abf21))

#### Documentation

* **App::template:**  adds details about the necessity to use AppSettings::UnifiedHelpMessage when using {unified} tags in the help template ([cf569438](https://github.com/clap-rs/clap/commit/cf569438f309c199800bb8e46c9f140187de69d7), closes [#949](https://github.com/clap-rs/clap/issues/949))
* **Arg::allow_hyphen_values:**  updates the docs to include warnings for allow_hyphen_values and multiple(true) used together ([ded5a2f1](https://github.com/clap-rs/clap/commit/ded5a2f15474d4a5bd46a67b130ccb8b6781bd01))
* **clap_app!:**  adds using the @group specifier to the macro docs ([fe85fcb1](https://github.com/clap-rs/clap/commit/fe85fcb1772b61f13b20b7ea5290e2437a76190c), closes [#932](https://github.com/clap-rs/clap/issues/932))



## v2.24.0 (2017-05-07)


#### Bug Fixes

*   fixes a bug where args with last(true) and required(true) set were not being printed in the usage string ([3ac533fe](https://github.com/clap-rs/clap/commit/3ac533fedabf713943eedf006f830a5a486bbe80), closes [#944](https://github.com/clap-rs/clap/issues/944))
*   fixes a bug that was printing the arg name, instead of value name when Arg::last(true) was used ([e1fe8ac3](https://github.com/clap-rs/clap/commit/e1fe8ac3bc1f9cf4e36df0d881f8419755f1787b), closes [#940](https://github.com/clap-rs/clap/issues/940))
*   fixes a bug where flags were parsed as flags AND positional values when specific combinations of settings were used ([20f83292](https://github.com/clap-rs/clap/commit/20f83292d070038b8cee2a6b47e91f6b0a2f7871), closes [#946](https://github.com/clap-rs/clap/issues/946))



## v2.24.0 (2017-05-05)


#### Documentation

* **README.md:**  fix some typos ([fa34deac](https://github.com/clap-rs/clap/commit/fa34deac079f334c3af97bb7fb151880ba8887f8))

#### API Additions

* **Arg:**  add `default_value_os` ([d5ef8955](https://github.com/clap-rs/clap/commit/d5ef8955414b1587060f7218385256105b639c88))
* **arg_matches.rs:**  Added a Default implementation for Values and OsValues iterators. ([0a4384e3](https://github.com/clap-rs/clap/commit/0a4384e350eed74c2a4dc8964c203f21ac64897f))


## v2.23.2 (2017-04-19)


#### Bug Fixes

* **PowerShell Completions:**  fixes a bug where powershells completions cant be used if no subcommands are defined ([a8bce558](https://github.com/clap-rs/clap/commit/a8bce55837dc4e0fb187dc93180884a40ae09c6f), closes [#931](https://github.com/clap-rs/clap/issues/931))

#### Improvements

*   bumps term_size to take advantage of better terminal dimension handling ([e05100b7](https://github.com/clap-rs/clap/commit/e05100b73d74066a90876bf38f952adf5e8ee422))
* **PowerShell Completions:**  massively dedups subcommand names in the generate script to make smaller scripts that are still functionally equiv ([85b0e1cc](https://github.com/clap-rs/clap/commit/85b0e1cc4b9755dda75a93d898d79bc38631552b))

#### Documentation

*   Fix a typo the minimum rust version required ([71dabba3](https://github.com/clap-rs/clap/commit/71dabba3ea0a17c88b0e2199c9d99f0acbf3bc17))

## v2.23.1 (2017-04-05)


#### Bug Fixes

*   fixes a missing newline character in the autogenerated help and version messages in some instances ([5ae9007d](https://github.com/clap-rs/clap/commit/5ae9007d984ae94ae2752df51bcbaeb0ec89bc15))


## v2.23.0 (2017-04-05)


#### API Additions

* `App::long_about`
* `App::long_version`
* `App::print_long_help`
* `App::write_long_help`
* `App::print_long_version`
* `App::write_long_version`
* `Arg::long_help`

#### Features

*   allows distinguishing between short and long version messages (-V/short or --version/long) ([59272b06](https://github.com/clap-rs/clap/commit/59272b06cc213289dc604dbc694cb95d383a5d68))
*   allows distinguishing between short and long help with subcommands in the same manner as args ([6b371891](https://github.com/clap-rs/clap/commit/6b371891a1702173a849d1e95f9fecb168bf6fc4))
*   allows specifying a short help vs a long help (i.e. varying levels of detail depending on if -h or --help was used) ([ef1b24c3](https://github.com/clap-rs/clap/commit/ef1b24c3a0dff2f58c5e2e90880fbc2b69df20ee))
* **clap_app!:**  adds support for arg names with hyphens similar to longs with hyphens ([f7a88779](https://github.com/clap-rs/clap/commit/f7a8877978c8f90e6543d4f0d9600c086cf92cd7), closes [#869](https://github.com/clap-rs/clap/issues/869))

#### Bug Fixes

*   fixes a bug that wasn't allowing help and version to be properly overridden ([8b2ceb83](https://github.com/clap-rs/clap/commit/8b2ceb8368bcb70689fadf1c7f4b9549184926c1), closes [#922](https://github.com/clap-rs/clap/issues/922))

#### Documentation

* **clap_app!:**  documents the `--("some-arg")` method for using args with hyphens inside them ([bc08ef3e](https://github.com/clap-rs/clap/commit/bc08ef3e185393073d969d301989b6319c616c1f), closes [#919](https://github.com/clap-rs/clap/issues/919))



## v2.22.2 (2017-03-30)


#### Bug Fixes

* **Custom Usage Strings:**  fixes the usage string regression when using help templates ([0e4fd96d](https://github.com/clap-rs/clap/commit/0e4fd96d74280d306d09e60ac44f938a82321769))



## v2.22.1 (2017-03-24)


#### Bug Fixes

* **usage:**  fixes a big regression with custom usage strings ([2c41caba](https://github.com/clap-rs/clap/commit/2c41caba3c7d723a2894e315d04da796b0e97759))

## v2.22.0 (2017-03-23)

#### API Additions

* **App::name:**  adds the ability to change the name of the App instance after creation ([d49e8292](https://github.com/clap-rs/clap/commit/d49e8292b026b06e2b70447cd9f08299f4fcba76), closes [#908](https://github.com/clap-rs/clap/issues/908))
* **Arg::hide_default_value:**  adds ability to hide the default value of an argument from the help string ([89e6ea86](https://github.com/clap-rs/clap/commit/89e6ea861e16a1ad56757ca12f6b32d02253e44a), closes [#902](https://github.com/clap-rs/clap/issues/902))


## v2.21.3 (2017-03-23)

#### Bug Fixes

* **yaml:**  adds support for loading author info from yaml ([e04c390c](https://github.com/clap-rs/clap/commit/e04c390c597a55fa27e724050342f16c42f1c5c9))


## v2.21.2 (2017-03-17)


#### Improvements

*   add fish subcommand help support ([f8f68cf8](https://github.com/clap-rs/clap/commit/f8f68cf8251669aef4539a25a7c1166f0ac81ea6))
*   options that use `require_equals(true)` now display the equals sign in help messages, usage strings, and errors" ([c8eb0384](https://github.com/clap-rs/clap/commit/c8eb0384d394d2900ccdc1593099c97808a3fa05), closes [#903](https://github.com/clap-rs/clap/issues/903))


#### Bug Fixes

*  setting the max term width now correctly propagates down through child subcommands



## v2.21.1 (2017-03-12)


#### Bug Fixes

* **ArgRequiredElseHelp:**  fixes the precedence of this error to prioritize over other error messages ([74b751ff](https://github.com/clap-rs/clap/commit/74b751ff2e3631e337b7946347c1119829a41c53), closes [#895](https://github.com/clap-rs/clap/issues/895))
* **Positionals:**  fixes some regression bugs resulting from old asserts in debug mode. ([9a3bc98e](https://github.com/clap-rs/clap/commit/9a3bc98e9b55e7514b74b73374c5ac8b6e5e0508), closes [#896](https://github.com/clap-rs/clap/issues/896))



## v2.21.0 (2017-03-09)

#### Performance

*   doesn't run `arg_post_processing` on multiple values anymore ([ec516182](https://github.com/clap-rs/clap/commit/ec5161828729f6a53f0fccec8648f71697f01f78))
*   changes internal use of `VecMap` to `Vec` for matched values of `Arg`s ([22bf137a](https://github.com/clap-rs/clap/commit/22bf137ac581684c6ed460d2c3c640c503d62621))
*   vastly reduces the amount of cloning when adding non-global args minus when they're added from `App::args` which is forced to clone ([8da0303b](https://github.com/clap-rs/clap/commit/8da0303bc02db5fe047cfc0631a9da41d9dc60f7))
*   refactor to remove unneeded vectors and allocations and checks for significant performance increases ([0efa4119](https://github.com/clap-rs/clap/commit/0efa4119632f134fc5b8b9695b007dd94b76735d))

#### Documentation

*   Fix examples link in CONTRIBUTING.md ([60cf875d](https://github.com/clap-rs/clap/commit/60cf875d67a252e19bb85054be57696fac2c57a1))

#### Improvements

*   when `AppSettings::SubcommandsNegateReqs` and `ArgsNegateSubcommands` are used, a new more accurate double line usage string is shown ([50f02300](https://github.com/clap-rs/clap/commit/50f02300d81788817acefef0697e157e01b6ca32), closes [#871](https://github.com/clap-rs/clap/issues/871))

#### API Additions

* **Arg::last:**  adds the ability to mark a positional argument as 'last' which means it should be used with `--` syntax and can be accessed early ([6a7aea90](https://github.com/clap-rs/clap/commit/6a7aea9043b83badd9ab038b4ecc4c787716147e), closes [#888](https://github.com/clap-rs/clap/issues/888))
*   provides `default_value_os` and `default_value_if[s]_os` ([0f2a3782](https://github.com/clap-rs/clap/commit/0f2a378219a6930748d178ba350fe5925be5dad5), closes [#849](https://github.com/clap-rs/clap/issues/849))
*   provides `App::help_message` and `App::version_message` which allows one to override the auto-generated help/version flag associated help ([389c413](https://github.com/clap-rs/clap/commit/389c413b7023dccab8c76aa00577ea1d048e7a99), closes [#889](https://github.com/clap-rs/clap/issues/889))

#### New Settings

* **InferSubcommands:**  adds a setting to allow one to infer shortened subcommands or aliases (i.e. for subcommmand "test", "t", "te", or "tes" would be allowed assuming no other ambiguities) ([11602032](https://github.com/clap-rs/clap/commit/11602032f6ff05881e3adf130356e37d5e66e8f9), closes [#863](https://github.com/clap-rs/clap/issues/863))

#### Bug Fixes

*   doesn't print the argument sections in the help message if all args in that section are hidden ([ce5ee5f5](https://github.com/clap-rs/clap/commit/ce5ee5f5a76f838104aeddd01c8ec956dd347f50))
*   doesn't include the various [ARGS] [FLAGS] or [OPTIONS] if the only ones available are hidden ([7b4000af](https://github.com/clap-rs/clap/commit/7b4000af97637703645c5fb2ac8bb65bd546b95b), closes [#882](https://github.com/clap-rs/clap/issues/882))
*   now correctly shows subcommand as required in the usage string when AppSettings::SubcommandRequiredElseHelp is used ([8f0884c1](https://github.com/clap-rs/clap/commit/8f0884c1764983a49b45de52a1eddf8d721564d8))
*   fixes some memory leaks when an error is detected and clap exits ([8c2dd287](https://github.com/clap-rs/clap/commit/8c2dd28718262ace4ae0db98563809548e02a86b))
*   fixes a trait that's marked private accidentally, but should be crate internal public ([1ae21108](https://github.com/clap-rs/clap/commit/1ae21108015cea87e5360402e1747025116c7878))
* **Completions:**   fixes a bug that tried to propagate global args multiple times when generating multiple completion scripts ([5e9b9cf4](https://github.com/clap-rs/clap/commit/5e9b9cf4dd80fa66a624374fd04e6545635c1f94), closes [#846](https://github.com/clap-rs/clap/issues/846))

#### Features

* **Options:**  adds the ability to require the equals syntax with options --opt=val ([f002693d](https://github.com/clap-rs/clap/commit/f002693dec6a6959c4e9590cb7b7bfffd6d6e5bc), closes [#833](https://github.com/clap-rs/clap/issues/833))



## v2.20.5 (2017-02-18)


#### Bug Fixes

* **clap_app!:**   fixes a critical bug of a missing fragment specifier when using `!property` style tags. ([5635c1f94](https://github.com/clap-rs/clap/commit/5e9b9cf4dd80fa66a624374fd04e6545635c1f94))


## v2.20.4 (2017-02-15)


#### Bug Fixes

* **Completions:**   fixes a bug that tried to propagate global args multiple times when generating multiple completion scripts ([5e9b9cf4](https://github.com/clap-rs/clap/commit/5e9b9cf4dd80fa66a624374fd04e6545635c1f94), closes [#846](https://github.com/clap-rs/clap/issues/846))

#### Documentation

*   Fix examples link in CONTRIBUTING.md ([60cf875d](https://github.com/clap-rs/clap/commit/60cf875d67a252e19bb85054be57696fac2c57a1))


## v2.20.3 (2017-02-03)


#### Documentation

* **Macros:**  adds a warning about changing values in Cargo.toml not triggering a rebuild automatically ([112aea3e](https://github.com/clap-rs/clap/commit/112aea3e42ae9e0c0a2d33ebad89496dbdd95e5d), closes [#838](https://github.com/clap-rs/clap/issues/838))

#### Bug Fixes

*   fixes a println->debugln typo ([279aa62e](https://github.com/clap-rs/clap/commit/279aa62eaf08f56ce090ba16b937bc763cbb45be))
*   fixes bash completions for commands that have an underscore in the name ([7f5cfa72](https://github.com/clap-rs/clap/commit/7f5cfa724f0ac4e098f5fe466c903febddb2d994), closes [#581](https://github.com/clap-rs/clap/issues/581))
*   fixes a bug where ZSH completions would panic if the binary name had an underscore in it ([891a2a00](https://github.com/clap-rs/clap/commit/891a2a006f775e92c556dda48bb32fac9807c4fb), closes [#581](https://github.com/clap-rs/clap/issues/581))
*   allow final word to be wrapped in wrap_help ([564c5f0f](https://github.com/clap-rs/clap/commit/564c5f0f1730f4a2c1cdd128664f1a981c31dcd4), closes [#828](https://github.com/clap-rs/clap/issues/828))
* fixes a bug where global args weren't included in the generated completion scripts ([9a1e006e](https://github.com/clap-rs/clap/commit/9a1e006eb75ad5a6057ebd119aa90f7e06c0ace8), closes [#841](https://github.com/clap-rs/clap/issues/841))



## v2.20.2 (2017-02-03)

#### Bug Fixes

*   fixes a critical bug where subcommand settings were being propagated too far ([74648c94](https://github.com/clap-rs/clap/commit/74648c94b893df542bfa5bb595e68c7bb8167e36), closes [#832](https://github.com/clap-rs/clap/issues/832))


#### Improvements

*   adds ArgGroup::multiple to the supported YAML fields for building ArgGroups from YAML ([d8590037](https://github.com/clap-rs/clap/commit/d8590037ce07dafd8cd5b26928aa4a9fd3018288), closes [#840](https://github.com/clap-rs/clap/issues/840))

## v2.20.1 (2017-01-31)

#### Bug Fixes

*   allow final word to be wrapped in wrap_help ([564c5f0f](https://github.com/clap-rs/clap/commit/564c5f0f1730f4a2c1cdd128664f1a981c31dcd4), closes [#828](https://github.com/clap-rs/clap/issues/828))
*   actually show character in debug output ([84d8c547](https://github.com/clap-rs/clap/commit/84d8c5476de95b7f37d61888bc4f13688b712434))
*   include final character in line length ([aff4ba18](https://github.com/clap-rs/clap/commit/aff4ba18da8147e1259b04b0bfbc1fcb5c78a3c0))

#### Improvements

*   updates libc and term_size deps for the libc version conflict ([6802ac4a](https://github.com/clap-rs/clap/commit/6802ac4a59c142cda9ec55ca0c45ae5cb9a6ab55))

#### Documentation

*   fix link from app_from_crate! to crate_authors! (#822) ([5b29be9b](https://github.com/clap-rs/clap/commit/5b29be9b073330ab1f7227cdd19fe4aab39d5dcb))
*   fix spelling of "guaranteed" ([4f30a65b](https://github.com/clap-rs/clap/commit/4f30a65b9c03eb09607eb91a929a6396637dc105))


#### New Settings

* **ArgsNegateSubcommands:**  disables args being allowed between subcommands ([5e2af8c9](https://github.com/clap-rs/clap/commit/5e2af8c96adb5ab75fa2d1536237ebcb41869494), closes [#793](https://github.com/clap-rs/clap/issues/793))
* **DontCollapseArgsInUsage:** disables the collapsing of positional args into `[ARGS]` in the usage string  ([c2978afc](https://github.com/clap-rs/clap/commit/c2978afc61fb46d5263ab3b2d87ecde1c9ce1553), closes [#769](https://github.com/clap-rs/clap/issues/769))
* **DisableHelpSubcommand:**  disables building the `help` subcommand  ([a10fc859](https://github.com/clap-rs/clap/commit/a10fc859ee20159fbd9ff4337be59b76467a64f2))
* **AllowMissingPositional:**  allows one to implement `$ prog [optional] <required>` style CLIs where the second positional argument is required, but the first is optional ([1110fdc7](https://github.com/clap-rs/clap/commit/1110fdc7a345c108820dc45783a9bf893fa4c214), closes [#636](https://github.com/clap-rs/clap/issues/636))
* **PropagateGlobalValuesDown:**  automatically propagats global arg's values down through *used* subcommands ([985536c8](https://github.com/clap-rs/clap/commit/985536c8ebcc09af98aac835f42a8072ad58c262), closes [#694](https://github.com/clap-rs/clap/issues/694))

#### API Additions

##### Arg

* **Arg::value_terminator:**  adds the ability to terminate multiple values with a given string or char ([be64ce0c](https://github.com/clap-rs/clap/commit/be64ce0c373efc106384baca3f487ea99fe7b8cf), closes [#782](https://github.com/clap-rs/clap/issues/782))
* **Arg::default_value_if[s]:**  adds new methods for *conditional* default values (such as a particular value from another argument was used) ([eb4010e7](https://github.com/clap-rs/clap/commit/eb4010e7b21724447ef837db11ac441915728f22))
* **Arg::requires_if[s]:**  adds the ability to *conditionally* require additional args (such as if a particular value was used) ([198449d6](https://github.com/clap-rs/clap/commit/198449d64393c265f0bc327aaeac23ec4bb97226))
* **Arg::required_if[s]:**  adds the ability for an arg to be *conditionally* required (i.e. "arg X is only required if arg Y was used with value Z") ([ee9cfddf](https://github.com/clap-rs/clap/commit/ee9cfddf345a6b5ae2af42ba72aa5c89e2ca7f59))
* **Arg::validator_os:**  adds ability to validate values which may contain invalid UTF-8 ([47232498](https://github.com/clap-rs/clap/commit/47232498a813db4f3366ccd3e9faf0bff56433a4))

##### Macros

* **crate_description!:** Uses the `Cargo.toml` description field to fill in the `App::about` method at compile time ([4d9a82db](https://github.com/clap-rs/clap/commit/4d9a82db8e875e9b64a9c2a5c6e22c25afc1279d), closes [#778](https://github.com/clap-rs/clap/issues/778))
* **crate_name!:** Uses the `Cargo.toml` name field to fill in the `App::new` method at compile time ([4d9a82db](https://github.com/clap-rs/clap/commit/4d9a82db8e875e9b64a9c2a5c6e22c25afc1279d), closes [#778](https://github.com/clap-rs/clap/issues/778))
* **app_from_crate!:** Combines `crate_version!`, `crate_name!`, `crate_description!`, and `crate_authors!` into a single macro call to build a default `App` instance from the `Cargo.toml` fields ([4d9a82db](https://github.com/clap-rs/clap/commit/4d9a82db8e875e9b64a9c2a5c6e22c25afc1279d), closes [#778](https://github.com/clap-rs/clap/issues/778))


#### Features

* **no_cargo:**  adds a `no_cargo` feature to disable Cargo-env-var-dependent macros for those *not* using `cargo` to build their crates (#786) ([6fdd2f9d](https://github.com/clap-rs/clap/commit/6fdd2f9d693aaf1118fc61bd362273950703f43d))

#### Bug Fixes

* **Options:**  fixes a critical bug where options weren't forced to have a value ([5a5f2b1e](https://github.com/clap-rs/clap/commit/5a5f2b1e9f598a0d0280ef3e98abbbba2bc41132), closes [#665](https://github.com/clap-rs/clap/issues/665))
*   fixes a bug where calling the help of a subcommand wasn't ignoring required args of parent commands ([d3d34a2b](https://github.com/clap-rs/clap/commit/d3d34a2b51ef31004055b0ab574f766d801c3adf), closes [#789](https://github.com/clap-rs/clap/issues/789))
* **Help Subcommand:**  fixes a bug where the help subcommand couldn't be overridden ([d34ec3e0](https://github.com/clap-rs/clap/commit/d34ec3e032d03e402d8e87af9b2942fe2819b2da), closes [#787](https://github.com/clap-rs/clap/issues/787))
* **Low Index Multiples:**  fixes a bug which caused combinations of LowIndexMultiples and `Arg::allow_hyphen_values` to fail parsing ([26c670ca](https://github.com/clap-rs/clap/commit/26c670ca16d2c80dc26d5c1ce83380ace6357318))

#### Improvements

* **Default Values:**  improves the error message when default values are involved ([1f33de54](https://github.com/clap-rs/clap/commit/1f33de545036e7fd2f80faba251fca009bd519b8), closes [#774](https://github.com/clap-rs/clap/issues/774))
* **YAML:**  adds conditional requirements and conditional default values to YAML ([9a4df327](https://github.com/clap-rs/clap/commit/9a4df327893486adb5558ffefba790c634ccdc6e), closes [#764](https://github.com/clap-rs/clap/issues/764))
*  Support `--("some-arg-name")` syntax for defining long arg names when using `clap_app!` macro ([f41ec962](https://github.com/clap-rs/clap/commit/f41ec962c243a5ffff8b1be1ae2ad63970d3d1d4))
*  Support `("some app name")` syntax for defining app names when using `clap_app!` macro ([9895b671](https://github.com/clap-rs/clap/commit/9895b671cff784f35cf56abcd8270f7c2ba09699), closes [#759](https://github.com/clap-rs/clap/issues/759))
* **Help Wrapping:**  long app names (with spaces), authors, and descriptions are now wrapped appropriately ([ad4691b7](https://github.com/clap-rs/clap/commit/ad4691b71a63e951ace346318238d8834e04ad8a), closes [#777](https://github.com/clap-rs/clap/issues/777))


#### Documentation

* **Conditional Default Values:**  fixes the failing doc tests of Arg::default_value_ifs ([4ef09101](https://github.com/clap-rs/clap/commit/4ef091019c083b4db1a0c13f1c1e95ac363259f2))
* **Conditional Requirements:**  adds docs for Arg::requires_ifs ([7f296e29](https://github.com/clap-rs/clap/commit/7f296e29db7d9036e76e5dbcc9c8b20dfe7b25bd))
* **README.md:**  fix some typos ([f22c21b4](https://github.com/clap-rs/clap/commit/f22c21b422d5b287d1a1ac183a379ee02eebf54f))
* **src/app/mod.rs:**  fix some typos ([5c9b0d47](https://github.com/clap-rs/clap/commit/5c9b0d47ca78dea285c5b9dec79063d24c3e451a))

## v2.19.3 (2016-12-28)


#### Bug Fixes

*   fixes a bug where calling the help of a subcommand wasn't ignoring required args of parent commands ([a0ee4993](https://github.com/clap-rs/clap/commit/a0ee4993015ea97b06b5bc9f378d8bcb18f1c51c), closes [#789](https://github.com/clap-rs/clap/issues/789))



## v2.19.2 (2016-12-08)

#### Bug Fixes

* **ZSH Completions:**  escapes square brackets in ZSH completions ([7e17d5a3](https://github.com/clap-rs/clap/commit/7e17d5a36b2cc2cc77e7b15796b14d639ed3cbf7), closes [#771](https://github.com/clap-rs/clap/issues/771))

#### Documentation

* **Examples:**  adds subcommand examples ([0e0f3354](https://github.com/clap-rs/clap/commit/0e0f33547a6901425afc1d9fbe19f7ae3832d9a4), closes [#766](https://github.com/clap-rs/clap/issues/766))
* **README.md:**  adds guidance on when to use ~ in version pinning, and clarifies breaking change policy ([591eaefc](https://github.com/clap-rs/clap/commit/591eaefc7319142ba921130e502bb0729feed907), closes [#765](https://github.com/clap-rs/clap/issues/765))



## v2.19.1 (2016-12-01)


#### Bug Fixes

* **Help Messages:**  fixes help message alignment when specific settings are used on options ([cd94b318](https://github.com/clap-rs/clap/commit/cd94b3188d63b63295a319e90e826bca46befcd2), closes [#760](https://github.com/clap-rs/clap/issues/760))

#### Improvements

* **Bash Completion:**  allows bash completion to fall back to traditional bash completion upon no matching completing function ([b1b16d56](https://github.com/clap-rs/clap/commit/b1b16d56d8fddf819bdbe24b3724bb6a9f3fa613)))


## v2.19.0 (2016-11-21)

#### Features

*   allows specifying AllowLeadingHyphen style values, but only for specific args vice command wide ([c0d70feb](https://github.com/clap-rs/clap/commit/c0d70febad9996a77a54107054daf1914c50d4ef), closes [#742](https://github.com/clap-rs/clap/issues/742))

#### Bug Fixes

* **Required Unless:**  fixes a bug where having required_unless set doesn't work when conflicts are also set ([d20331b6](https://github.com/clap-rs/clap/commit/d20331b6f7940ac3a4e919999f8bb4780875125d), closes [#753](https://github.com/clap-rs/clap/issues/753))
* **ZSH Completions:**  fixes an issue where zsh completions caused panics if there were no subcommands ([49e7cdab](https://github.com/clap-rs/clap/commit/49e7cdab76dd1ccc07221e360f07808ec62648aa), closes [#754](https://github.com/clap-rs/clap/issues/754))

#### Improvements

* **Validators:**  improves the error messages for validators ([65eb3385](https://github.com/clap-rs/clap/commit/65eb33859d3ff53e7d3277f02a9d3fd9038a9dfb), closes [#744](https://github.com/clap-rs/clap/issues/744))

#### Documentation

*   updates the docs landing page ([01e1e33f](https://github.com/clap-rs/clap/commit/01e1e33f377934099a4a725fab5cd6c5ff50eaa2))
*   adds the macro version back to the readme ([45eb9bf1](https://github.com/clap-rs/clap/commit/45eb9bf130329c3f3853aba0342c2fe3c64ff80f))
*   fix broken docs links ([808e7cee](https://github.com/clap-rs/clap/commit/808e7ceeb86d4a319bdc270f51c23a64621dbfb3))
* **Compatibility Policy:**  adds an official compatibility policy to ([760d66dc](https://github.com/clap-rs/clap/commit/760d66dc17310b357f257776624151da933cd25d), closes [#740](https://github.com/clap-rs/clap/issues/740))
* **Contributing:**  updates the readme to improve the readability and contributing sections ([eb51316c](https://github.com/clap-rs/clap/commit/eb51316cdfdc7258d287ba13b67ef2f42bd2b8f6))

## v2.18.0 (2016-11-05)


#### Features

* **Completions:**  adds completion support for PowerShell. ([cff82c88](https://github.com/clap-rs/clap/commit/cff82c880e21064fca63351507b80350df6caadf), closes [#729](https://github.com/clap-rs/clap/issues/729))



## v2.17.1 (2016-11-02)


#### Bug Fixes

* **Low Index Multiples:**  fixes a bug where using low index multiples was propagated to subcommands ([33924e88](https://github.com/clap-rs/clap/commit/33924e884461983c4e6b5ea1330fecc769a4ade7), closes [#725](https://github.com/clap-rs/clap/issues/725))



## v2.17.0 (2016-11-01)


#### Features

* **Positional Args:**  allows specifying the second to last positional argument as multiple(true) ([1ced2a74](https://github.com/clap-rs/clap/commit/1ced2a7433ea8937a1b260ea65d708f32ca7c95e), closes [#725](https://github.com/clap-rs/clap/issues/725))



## v2.16.4 (2016-10-31)


#### Improvements

* **Error Output:**  conflicting errors are now symmetrical, meaning more consistent and less confusing ([3d37001d](https://github.com/clap-rs/clap/commit/3d37001d1dc647d73cc597ff172f1072d4beb80d), closes [#718](https://github.com/clap-rs/clap/issues/718))

#### Documentation

*   Fix typo in example `13a_enum_values_automatic` ([c22fbc07](https://github.com/clap-rs/clap/commit/c22fbc07356e556ffb5d1a79ec04597d149b915e))
* **README.md:**  fixes failing yaml example (#715) ([21fba9e6](https://github.com/clap-rs/clap/commit/21fba9e6cd8c163012999cd0ce271ec8780c5695))

#### Bug Fixes

* **ZSH Completions:**  fixes bug that caused panic on subcommands with aliases ([5c70e1a0](https://github.com/clap-rs/clap/commit/5c70e1a01bc977e44c10015d18bb8e215c32dfc8), closes [#714](https://github.com/clap-rs/clap/issues/714))
* **debug:**  fixes the debug feature (#716) ([6c11ccf4](https://github.com/clap-rs/clap/commit/6c11ccf443d46258d51f7cda33fbcc81e7fe8e90))



## v2.16.3 (2016-10-28)


#### Bug Fixes

*   Derive display order after propagation ([9cb6facf](https://github.com/clap-rs/clap/commit/9cb6facf507aff7cddd124b8c29714d2b0e7bd13), closes [#706](https://github.com/clap-rs/clap/issues/706))
* **yaml-example:**  inconsistent args ([847f7199](https://github.com/clap-rs/clap/commit/847f7199219ead5065561d91d64780d99ae4b587))



## v2.16.2 (2016-10-25)


#### Bug Fixes

* **Fish Completions:**  fixes a bug where single quotes are not escaped ([780b4a18](https://github.com/clap-rs/clap/commit/780b4a18281b6f7f7071e1b9db2290fae653c406), closes [#704](https://github.com/clap-rs/clap/issues/704))


## v2.16.1 (2016-10-24)


#### Bug Fixes

* **Help Message:**  fixes a regression bug where args with multiple(true) threw off alignment ([ebddac79](https://github.com/clap-rs/clap/commit/ebddac791f3ceac193d5ad833b4b734b9643a7af), closes [#702](https://github.com/clap-rs/clap/issues/702))



## v2.16.0 (2016-10-23)


#### Features

* **Completions:**  adds ZSH completion support ([3e36b0ba](https://github.com/clap-rs/clap/commit/3e36b0bac491d3f6194aee14604caf7be26b3d56), closes [#699](https://github.com/clap-rs/clap/issues/699))



## v2.15.0 (2016-10-21)


#### Features

* **AppSettings:**  adds new setting `AppSettings::AllowNegativeNumbers` ([ab064546](https://github.com/clap-rs/clap/commit/ab06454677fb6aa9b9f804644fcca2168b1eaee3), closes [#696](https://github.com/clap-rs/clap/issues/696))

#### Documentation

* **app/settings.rs:**  moves variants to roughly alphabetical order ([9ed4d4d7](https://github.com/clap-rs/clap/commit/9ed4d4d7957a23357aef60081e45639ab9e3905f))


## v2.14.1 (2016-10-20)


#### Documentation

*   Improve documentation around features ([4ee85b95](https://github.com/clap-rs/clap/commit/4ee85b95d2d16708a016a3ba4e6e2c93b89b7fad))
*   reword docs for ErrorKind and app::Settings ([3ccde7a4](https://github.com/clap-rs/clap/commit/3ccde7a4b8f7a2ea8b916a5415c04a8ff4b5cb7a))
*   fix tests that fail when the "suggestions" feature is disabled ([996fc381](https://github.com/clap-rs/clap/commit/996fc381763a48d125c7ea8a58fed057fd0b4ac6))
*   fix the OsString-using doc-tests ([af9e1a39](https://github.com/clap-rs/clap/commit/af9e1a393ce6cdda46a03c8a4f48df222b015a24))
*   tag non-rust code blocks as such instead of ignoring them ([0ba9f4b1](https://github.com/clap-rs/clap/commit/0ba9f4b123f281952581b6dec948f7e51dd22890))
* **ErrorKind:**  improve some errors about subcommands ([9f6217a4](https://github.com/clap-rs/clap/commit/9f6217a424da823343d7b801b9c350dee3cd1906))
* **yaml:**  make sure the doc-tests don't fail before "missing file" ([8c0f5551](https://github.com/clap-rs/clap/commit/8c0f55516f4910c78c9f8a2bdbd822729574f95b))

#### Improvements

*   Stabilize clap_app! ([cd516006](https://github.com/clap-rs/clap/commit/cd516006e35c37b005f329338560a0a53d1f3e00))
* **with_defaults:**  Deprecate App::with_defaults() ([26085409](https://github.com/clap-rs/clap/commit/2608540940c8bb66e517b65706bc7dea55510682), closes [#638](https://github.com/clap-rs/clap/issues/638))

#### Bug Fixes

*   fixes a bug that made determining when to auto-wrap long help messages inconsistent ([468baadb](https://github.com/clap-rs/clap/commit/468baadb8398fc1d37897b0c49374aef4cf97dca), closes [#688](https://github.com/clap-rs/clap/issues/688))
* **Completions:**  fish completions for nested subcommands ([a61eaf8a](https://github.com/clap-rs/clap/commit/a61eaf8aade76cfe90ccc0f7125751ebf60e3254))
* **features:**  Make lints not enable other nightly-requiring features ([835f75e3](https://github.com/clap-rs/clap/commit/835f75e3ba20999117363ed9f916464d777f36ef))



## v2.14.0 (2016-10-05)


#### Features

* **arg_aliases:**  Ability to alias arguments ([33b5f6ef](https://github.com/clap-rs/clap/commit/33b5f6ef2c9612ecabb31f96b824793e46bfd3dd), closes [#669](https://github.com/clap-rs/clap/issues/669))
* **flag_aliases:**  Ability to alias flags ([40d6dac9](https://github.com/clap-rs/clap/commit/40d6dac973927dded6ab423481634ef47ee7bfd7))

#### Bug Fixes

* **UsageParser:**  Handle non-ascii names / options. ([1d6a7c6e](https://github.com/clap-rs/clap/commit/1d6a7c6e7e6aadc527346aa822f19d8587f714f3), closes [#664](https://github.com/clap-rs/clap/issues/664))

#### Documentation

*   typo ([bac417fa](https://github.com/clap-rs/clap/commit/bac417fa1cea3d32308334c7cccfcf54546cd9d8))


## v2.13.0 (2016-09-18)


#### Documentation

*   updates README.md with new website information and updated video tutorials info ([0c19c580](https://github.com/clap-rs/clap/commit/0c19c580cf50f1b82ff32f70b36708ae2bcac132))
*   updates the docs about removing implicit value_delimiter(true) ([c81bc722](https://github.com/clap-rs/clap/commit/c81bc722ebb8a86d22be89b5aec98df9fe222a08))
* **Default Values:**  adds better examples on using default values ([57a8d9ab](https://github.com/clap-rs/clap/commit/57a8d9abb2f973c235a8a14f8fc031673d7a7460), closes [#418](https://github.com/clap-rs/clap/issues/418))

#### Bug Fixes

* **Value Delimiters:**  fixes the confusion around implicitly setting value delimiters. (default is now `false`) ([09d4d0a9](https://github.com/clap-rs/clap/commit/09d4d0a9038d7ce2df55c2aec95e16f36189fcee), closes [#666](https://github.com/clap-rs/clap/issues/666))



## v2.12.1 (2016-09-13)


#### Bug Fixes

* **Help Wrapping:**  fixes a regression-bug where the old {n} newline char stopped working ([92ac353b](https://github.com/clap-rs/clap/commit/92ac353b48b7caa2511ad2a046d94da93c236cf6), closes [#661](https://github.com/clap-rs/clap/issues/661))



## v2.12.0 (2016-09-13)


#### Features

* **Help:**  adds ability to hide the possible values on a per argument basis ([9151ef73](https://github.com/clap-rs/clap/commit/9151ef739871f2e74910c342299c0de196b95dec), closes [#640](https://github.com/clap-rs/clap/issues/640))
* **help:**  allow for limiting detected terminal width ([a43e28af](https://github.com/clap-rs/clap/commit/a43e28af85c9a9deaedd5ef735f4f13008daab29), closes [#653](https://github.com/clap-rs/clap/issues/653))

#### Documentation

* **Help Wrapping:**  removes the verbage about using `'{n}'` to insert newlines in help text ([c5a2b352](https://github.com/clap-rs/clap/commit/c5a2b352ca600f5b802290ad945731066cd53611))
* **Value Delimiters:**  updates the docs for the Arg::multiple method WRT value delimiters and default settings ([f9d17a06](https://github.com/clap-rs/clap/commit/f9d17a060aa53f10d0a6e1a7eed5d989d1a59533))
* **appsettings:**  Document AppSetting::DisableVersion ([94501965](https://github.com/clap-rs/clap/commit/945019654d2ca67eb2b1d6014fdf80b84d528d30), closes [#589](https://github.com/clap-rs/clap/issues/589))

#### Bug Fixes

* **AllowLeadingHyphen:**  fixes a bug where valid args aren't recognized with this setting ([a9699e4d](https://github.com/clap-rs/clap/commit/a9699e4d7cdc9a06e73b845933ff1fe6d76f016a), closes [#588](https://github.com/clap-rs/clap/issues/588))

#### Improvements

* **Help Wrapping:**
  *  clap now ignores hard newlines in help messages and properly re-aligns text, but still wraps if the term width is too small ([c7678523](https://github.com/clap-rs/clap/commit/c76785239fd42adc8ca04f9202b6fec615aa9f14), closes [#617](https://github.com/clap-rs/clap/issues/617))
  *  makes some minor changes to when next line help is automatically used ([01cae799](https://github.com/clap-rs/clap/commit/01cae7990a33167ac35103fb36c811b4fe6eb98f))
* **Value Delimiters:**  changes the default value delimiter rules ([f9e69254](https://github.com/clap-rs/clap/commit/f9e692548e8c94de15f909432de301407d6bb834), closes [#655](https://github.com/clap-rs/clap/issues/655))
* **YAML:**  supports setting Arg::require_delimiter from YAML ([b9b55a39](https://github.com/clap-rs/clap/commit/b9b55a39dfebcdbdc05dca2692927e503db50816))

#### Performance

* **help:**  fix redundant contains() checks ([a8afed74](https://github.com/clap-rs/clap/commit/a8afed7428bf0733f8e93bb11ad6c00d9e970fcc))



## v2.11.3 (2016-09-07)


#### Documentation

* **Help Wrapping:**  removes the verbage about using `'{n}'` to insert newlines in help text ([c5a2b352](https://github.com/clap-rs/clap/commit/c5a2b352ca600f5b802290ad945731066cd53611))

#### Improvements

* **Help Wrapping:**
  *  clap now ignores hard newlines in help messages and properly re-aligns text, but still wraps if the term width is too small ([c7678523](https://github.com/clap-rs/clap/commit/c76785239fd42adc8ca04f9202b6fec615aa9f14), closes [#617](https://github.com/clap-rs/clap/issues/617))
  *  makes some minor changes to when next line help is automatically used ([01cae799](https://github.com/clap-rs/clap/commit/01cae7990a33167ac35103fb36c811b4fe6eb98f))
* **YAML:**  supports setting Arg::require_delimiter from YAML ([b9b55a39](https://github.com/clap-rs/clap/commit/b9b55a39dfebcdbdc05dca2692927e503db50816))




## v2.11.2 (2016-09-06)

#### Improvements

* **Help Wrapping:**  makes some minor changes to when next line help is automatically used ([5658b117](https://github.com/clap-rs/clap/commit/5658b117aec3e03adff9c8c52a4c4bc1fcb4e1ff))


## v2.11.1 (2016-09-05)


#### Bug Fixes

* **Settings:**  fixes an issue where settings weren't propagated down through grandchild subcommands ([b3efc107](https://github.com/clap-rs/clap/commit/b3efc107515d78517b20798ff3890b8a2b04498e), closes [#638](https://github.com/clap-rs/clap/issues/638))

#### Features

* **Errors:**  Errors with custom description ([58512f2f](https://github.com/clap-rs/clap/commit/58512f2fcb430745f1ee6ee8f1c67f62dc216c73))

#### Improvements

* **help:**  use term_size instead of home-grown solution ([fc7327e9](https://github.com/clap-rs/clap/commit/fc7327e9dcf4258ef2baebf0a8714d9c0622855b))



## v2.11.0 (2016-08-28)


#### Bug Fixes

* **Groups:**  fixes some usage strings that contain both args in groups and ones that conflict with each other ([3d782def](https://github.com/clap-rs/clap/commit/3d782def57725e2de26ca5a5bc5cc2e40ddebefb), closes [#616](https://github.com/clap-rs/clap/issues/616))

#### Documentation

*   moves docs to docs.rs ([03209d5e](https://github.com/clap-rs/clap/commit/03209d5e1300906f00bafec1869c2047a92e5071), closes [#634](https://github.com/clap-rs/clap/issues/634))

#### Improvements

* **Completions:**  uses standard conventions for bash completion files, namely '{bin}.bash-completion' ([27f5bbfb](https://github.com/clap-rs/clap/commit/27f5bbfbcc9474c2f57c2b92b1feb898ae46ee70), closes [#567](https://github.com/clap-rs/clap/issues/567))
* **Help:**  automatically moves help text to the next line and wraps when term width is determined to be too small, or help text is too long ([150964c4](https://github.com/clap-rs/clap/commit/150964c4e7124d54476c9d9b4b3f2406f0fd00e5), closes [#597](https://github.com/clap-rs/clap/issues/597))
* **YAML Errors:**  vastly improves error messages when using YAML ([f43b7c65](https://github.com/clap-rs/clap/commit/f43b7c65941c53adc0616b8646a21dc255862eb2), closes [#574](https://github.com/clap-rs/clap/issues/574))

#### Features

*   adds App::with_defaults to automatically use crate_authors! and crate_version! macros ([5520bb01](https://github.com/clap-rs/clap/commit/5520bb012c127dfd299fd55699443c744d8dcd5b), closes [#600](https://github.com/clap-rs/clap/issues/600))



## v2.10.4 (2016-08-25)


#### Bug Fixes

* **Help Wrapping:**  fixes a bug where help is wrapped incorrectly and causing a panic with some non-English characters ([d0b442c7](https://github.com/clap-rs/clap/commit/d0b442c7beeecac9764406bc3bd171ced0b8825e), closes [#626](https://github.com/clap-rs/clap/issues/626))



## v2.10.3 (2016-08-25)

#### Features

* **Help:**  adds new short hand way to use source formatting and ignore term width in help messages ([7dfdaf20](https://github.com/clap-rs/clap/commit/7dfdaf200ebb5c431351a045b48f5e0f0d3f31db), closes [#625](https://github.com/clap-rs/clap/issues/625))

#### Documentation

* **Term Width:**  adds details about set_term_width(0) ([00b8205d](https://github.com/clap-rs/clap/commit/00b8205d22639d1b54b9c453c55c785aace52cb2))

#### Bug Fixes

* **Unicode:**  fixes two bugs where non-English characters were stripped or caused a panic with help wrapping ([763a5c92](https://github.com/clap-rs/clap/commit/763a5c920e23efc74d190af0cb8b5dd714b2d67a), closes [#626](https://github.com/clap-rs/clap/issues/626))



## v2.10.2 (2016-08-22)


#### Bug Fixes

*   fixes a bug where the help is printed twice ([a643fb28](https://github.com/clap-rs/clap/commit/a643fb283acd9905dc727c4579c5c9fa2ceaa7e7), closes [#623](https://github.com/clap-rs/clap/issues/623))



## v2.10.1 (2016-08-21)


#### Bug Fixes

* **Help Subcommand:**  fixes misleading usage string when using multi-level subcommmands ([e203515e](https://github.com/clap-rs/clap/commit/e203515e3ac495b405dbba4f78fb6af148fd282e), closes [#618](https://github.com/clap-rs/clap/issues/618))

#### Features

* **YAML:**  allows using lists or single values with arg declarations ([9ade2cd4](https://github.com/clap-rs/clap/commit/9ade2cd4b268d6d7fe828319ce6a523c641b9c38), closes [#614](https://github.com/clap-rs/clap/issues/614), [#613](https://github.com/clap-rs/clap/issues/613))



## v2.10.0 (2016-07-29)


#### Features

* **Completions:**  one can generate a basic fish completions script at compile time ([1979d2f2](https://github.com/clap-rs/clap/commit/1979d2f2f3216e57d02a97e624a8a8f6cf867ed9))

#### Bug Fixes

* **parser:**  preserve external subcommand name ([875df243](https://github.com/clap-rs/clap/commit/875df24316c266920a073c13bbefbf546bc1f635))

#### Breaking Changes

* **parser:**  preserve external subcommand name ([875df243](https://github.com/clap-rs/clap/commit/875df24316c266920a073c13bbefbf546bc1f635))

#### Documentation

* **YAML:**  fixes example 17's incorrect reference to arg_groups instead of groups ([b6c99e13](https://github.com/clap-rs/clap/commit/b6c99e1377f918e78c16c8faced70a71607da931), closes [#601](https://github.com/clap-rs/clap/issues/601))



### 2.9.3 (2016-07-24)


#### Bug Fixes

*   fixes bug where only first arg in list of required_unless_one is recognized ([1fc3b55b](https://github.com/clap-rs/clap/commit/1fc3b55bd6c8653b02e7c4253749c6b77737d2ac), closes [#575](https://github.com/clap-rs/clap/issues/575))
* **Settings:**  fixes typo subcommandsrequired->subcommandrequired ([fc72cdf5](https://github.com/clap-rs/clap/commit/fc72cdf591d30f5d9375d0b5cc2a2ff3e812f9f6), closes [#593](https://github.com/clap-rs/clap/issues/593))

#### Features

* **Completions:**  adds the ability to generate completions to io::Write object ([9f62cf73](https://github.com/clap-rs/clap/commit/9f62cf7378ba5acb5ce8c5bac89b4aa60c30755f))
* **Settings:**  Add unset_setting and unset_settings fns to App (#598) ([0ceba231](https://github.com/clap-rs/clap/commit/0ceba231c6767cd6d88fdb1feeeea41deadf77ff), closes [#590](https://github.com/clap-rs/clap/issues/590))


### 2.9.2 (2016-07-03)


#### Documentation

* **Completions:**  fixes the formatting of the Cargo.toml excerpt in the completions example ([722f2607](https://github.com/clap-rs/clap/commit/722f2607beaef56b6a0e433db5fd09492d9f028c))

#### Bug Fixes

* **Completions:**  fixes bug where --help and --version short weren't added to the completion list ([e9f2438e](https://github.com/clap-rs/clap/commit/e9f2438e2ce99af0ae570a2eaf541fc7f55b771b), closes [#536](https://github.com/clap-rs/clap/issues/536))



### 2.9.1 (2016-07-02)


#### Improvements

* **Completions:**  allows multiple completions to be built by namespacing with bin name ([57484b2d](https://github.com/clap-rs/clap/commit/57484b2daeaac01c1026e8c84efc8bf099e0eb31))


## v2.9.0 (2016-07-01)


#### Documentation

* **Completions:**
  *  fixes some errors in the completion docs ([9b359bf0](https://github.com/clap-rs/clap/commit/9b359bf06255d3dad8f489308044b60a9d1e6a87))
  *  adds documentation for completion scripts ([c6c519e4](https://github.com/clap-rs/clap/commit/c6c519e40efd6c4533a9ef5efe8e74fd150391b7))

#### Features

* **Completions:**
  *  one can now generate a bash completions script at compile time! ([e75b6c7b](https://github.com/clap-rs/clap/commit/e75b6c7b75f729afb9eb1d2a2faf61dca7674634), closes [#376](https://github.com/clap-rs/clap/issues/376))
  *  completions now include aliases to subcommands, including all subcommand options ([0ab9f840](https://github.com/clap-rs/clap/commit/0ab9f84052a8cf65b5551657f46c0c270841e634), closes [#556](https://github.com/clap-rs/clap/issues/556))
  *  completions now continue completing even after first completion ([18fc2e5b](https://github.com/clap-rs/clap/commit/18fc2e5b5af63bf54a94b72cec5e1223d49f4806))
  *  allows matching on possible values in options ([89cc2026](https://github.com/clap-rs/clap/commit/89cc2026ba9ac69cf44c5254360bbf99236d4f89), closes [#557](https://github.com/clap-rs/clap/issues/557))

#### Bug Fixes

* **AllowLeadingHyphen:**  fixes an issue where  isn't ignored like it should be with this setting ([96c24c9a](https://github.com/clap-rs/clap/commit/96c24c9a8fa1f85e06138d3cdd133e51659e19d2), closes [#558](https://github.com/clap-rs/clap/issues/558))

## v2.8.0 (2016-06-30)


#### Features

* **Arg:**  adds new setting `Arg::require_delimiter` which requires val delimiter to parse multiple values ([920b5595](https://github.com/clap-rs/clap/commit/920b5595ed72abfb501ce054ab536067d8df2a66))

#### Bug Fixes

*   Declare term::Winsize as repr(C) ([5d663d90](https://github.com/clap-rs/clap/commit/5d663d905c9829ce6e7a164f1f0896cdd70236dd))

#### Documentation

* **Arg:**  adds docs for ([49af4e38](https://github.com/clap-rs/clap/commit/49af4e38a5dae2ab0a7fc3b4147e2c053d532484))



## v2.7.1 (2016-06-29)


#### Bug Fixes

* **Options:**
  *  options with multiple values and using delimiters no longer parse additional values after a trailing space ([cdc500bd](https://github.com/clap-rs/clap/commit/cdc500bdde6abe238c36ade406ddafc2bafff583))
  *  using options with multiple values and with an = no longer parse args after the trailing space as values ([290f61d0](https://github.com/clap-rs/clap/commit/290f61d07177413cf082ada55526d83405f6d011))



## v2.7.0 (2016-06-28)


#### Documentation

*   fix typos ([43b3d40b](https://github.com/clap-rs/clap/commit/43b3d40b8c38b1571da75af86b5088be96cccec2))
* **ArgGroup:**  vastly improves ArgGroup docs by adding better examples ([9e5f4f5d](https://github.com/clap-rs/clap/commit/9e5f4f5d734d630bca5535c3a0aa4fd4f9db3e39), closes [#534](https://github.com/clap-rs/clap/issues/534))

#### Features

* **ArgGroup:**  one can now specify groups which require AT LEAST one of the args ([33689acc](https://github.com/clap-rs/clap/commit/33689acc689b217a8c0ee439f1b1225590c38355), closes [#533](https://github.com/clap-rs/clap/issues/533))

#### Bug Fixes

* **App:**  using `App::print_help` now prints the same as would have been printed by `--help` or the like ([e84cc018](https://github.com/clap-rs/clap/commit/e84cc01836bbe0527e97de6db9889bd9e0fd6ba1), closes [#536](https://github.com/clap-rs/clap/issues/536))
* **Help:**
  *  prevents invoking <cmd> help help and displaying incorrect help message ([e3d2893f](https://github.com/clap-rs/clap/commit/e3d2893f377942a2d4cf3c6ff04524d0346e6fdb), closes [#538](https://github.com/clap-rs/clap/issues/538))
  *  subcommand help messages requested via <cmd> help <sub> now correctly match <cmd> <sub> --help ([08ad1cff](https://github.com/clap-rs/clap/commit/08ad1cff4fec57224ea957a2891a057b323c01bc), closes [#539](https://github.com/clap-rs/clap/issues/539))

#### Improvements

* **ArgGroup:**  Add multiple ArgGroups per Arg ([902e182f](https://github.com/clap-rs/clap/commit/902e182f7a58aff11ff01e0a452abcdbdb2262aa), closes [#426](https://github.com/clap-rs/clap/issues/426))
* **Usage Strings:**  `[FLAGS]` and `[ARGS]` are no longer blindly added to usage strings ([9b2e45b1](https://github.com/clap-rs/clap/commit/9b2e45b170aff567b038d8b3368880b6046c10c6), closes [#537](https://github.com/clap-rs/clap/issues/537))
* **arg_enum!:**  allows using meta items like repr(C) with arg_enum!s ([edf9b233](https://github.com/clap-rs/clap/commit/edf9b2331c17a2cbcc13f961add4c55c2778e773), closes [#543](https://github.com/clap-rs/clap/issues/543))



## v2.6.0 (2016-06-14)


#### Improvements

*   removes extra newline from help output ([86e61d19](https://github.com/clap-rs/clap/commit/86e61d19a748fb9870fcf1175308984e51ca1115))
*   allows printing version to any io::Write object ([921f5f79](https://github.com/clap-rs/clap/commit/921f5f7916597f1d028cd4a65bfe76a01c801724))
*   removes extra newline when printing version ([7e2e2cbb](https://github.com/clap-rs/clap/commit/7e2e2cbb4a8a0f050bb8072a376f742fc54b8589))
* **Aliases:**  improves readability of asliases in help messages ([ca511de7](https://github.com/clap-rs/clap/commit/ca511de71f5b8c2ac419f1b188658e8c63b67846), closes [#526](https://github.com/clap-rs/clap/issues/526), [#529](https://github.com/clap-rs/clap/issues/529))
* **Usage Strings:**  improves the default usage string when only a single positional arg is present ([ec86f2da](https://github.com/clap-rs/clap/commit/ec86f2dada1545a63fc72355e22fcdc4c466c215), closes [#518](https://github.com/clap-rs/clap/issues/518))

#### Features

* **Help:**  allows wrapping at specified term width (Even on Windows!) ([1761dc0d](https://github.com/clap-rs/clap/commit/1761dc0d27d0d621229d792be40c36fbf65c3014), closes [#451](https://github.com/clap-rs/clap/issues/451))
* **Settings:**
  *  adds new setting to stop delimiting values with -- or TrailingVarArg ([fc3e0f5a](https://github.com/clap-rs/clap/commit/fc3e0f5afda6d24cdb3c4676614beebe13e1e870), closes [#511](https://github.com/clap-rs/clap/issues/511))
  *  one can now set an AppSetting which is propagated down through child subcommands ([e2341835](https://github.com/clap-rs/clap/commit/e23418351a3b98bf08dfd7744bc14377c70d59ee), closes [#519](https://github.com/clap-rs/clap/issues/519))
* **Subcommands:**  adds support for visible aliases ([7b10e7f8](https://github.com/clap-rs/clap/commit/7b10e7f8937a07fdb8d16a6d8df79ce78d080cd3), closes [#522](https://github.com/clap-rs/clap/issues/522))

#### Bug Fixes

*   fixes bug where args are printed out of order with templates ([05abb534](https://github.com/clap-rs/clap/commit/05abb534864764102031a0d402e64ac65867aa87))
*   fixes bug where one can't override version or help flags ([90d7d6a2](https://github.com/clap-rs/clap/commit/90d7d6a2ea8240122dd9bf8d82d3c4f5ebb5c703), closes [#514](https://github.com/clap-rs/clap/issues/514))
*   fixes issue where before_help wasn't printed ([b3faff60](https://github.com/clap-rs/clap/commit/b3faff6030f76a23f26afcfa6a90169002ed7106))
* **Help:**  `App::before_help` and `App::after_help` now correctly wrap ([1f4da767](https://github.com/clap-rs/clap/commit/1f4da7676e6e71aa8dda799f3eeefad105a47819), closes [#516](https://github.com/clap-rs/clap/issues/516))
* **Settings:**  fixes bug where new color settings couldn't be converted from strs ([706a7c11](https://github.com/clap-rs/clap/commit/706a7c11b0900be594de6d5a3121938eff197602))
* **Subcommands:**  subcommands with aliases now display help of the aliased subcommand ([5354d14b](https://github.com/clap-rs/clap/commit/5354d14b51f189885ba110e01e6b76cca3752992), closes [#521](https://github.com/clap-rs/clap/issues/521))
* **Windows:**  fixes a failing windows build ([01e7dfd6](https://github.com/clap-rs/clap/commit/01e7dfd6c07228c0be6695b3c7bf9370d82860d4))
* **YAML:**  adds missing YAML methods for App and Arg ([e468faf3](https://github.com/clap-rs/clap/commit/e468faf3f05950fd9f72d84b69aa2061e91c6c64), closes [#528](https://github.com/clap-rs/clap/issues/528))



## v2.5.2 (2016-05-31)


#### Improvements

*   removes extra newline from help output ([86e61d19](https://github.com/clap-rs/clap/commit/86e61d19a748fb9870fcf1175308984e51ca1115))
*   allows printing version to any io::Write object ([921f5f79](https://github.com/clap-rs/clap/commit/921f5f7916597f1d028cd4a65bfe76a01c801724))
*   removes extra newline when printing version ([7e2e2cbb](https://github.com/clap-rs/clap/commit/7e2e2cbb4a8a0f050bb8072a376f742fc54b8589))

#### Bug Fixes

*   fixes bug where args are printed out of order with templates ([3935431d](https://github.com/clap-rs/clap/commit/3935431d5633f577c0826ae2142794b301f4b8ca))
*   fixes bug where one can't override version or help flags ([90d7d6a2](https://github.com/clap-rs/clap/commit/90d7d6a2ea8240122dd9bf8d82d3c4f5ebb5c703), closes [#514](https://github.com/clap-rs/clap/issues/514))
*   fixes issue where before_help wasn't printed ([b3faff60](https://github.com/clap-rs/clap/commit/b3faff6030f76a23f26afcfa6a90169002ed7106))

#### Documentation

*   inter-links all types and pages ([3312893d](https://github.com/clap-rs/clap/commit/3312893ddaef3f44d68d8d26ed3d08010be50d97), closes [#505](https://github.com/clap-rs/clap/issues/505))
*   makes all publicly available types viewable in docs ([52ca6505](https://github.com/clap-rs/clap/commit/52ca6505b4fec7b5c2d53d160c072d395eb21da6))

## v2.5.1 (2016-05-11)


#### Bug Fixes

* **Subcommand Aliases**: fixes lifetime issue when setting multiple aliases at once ([ac42f6cf0](https://github.com/clap-rs/clap/commit/ac42f6cf0de6c4920f703807d63061803930b18d))

## v2.5.0 (2016-05-10)


#### Improvements

* **SubCommand Aliases:**  adds feature to yaml configs too ([69592195](https://github.com/clap-rs/clap/commit/695921954dde46dfd483399dcdef482c9dd7f34a))

#### Features

* **SubCommands:**  adds support for subcommand aliases ([66b4dea6](https://github.com/clap-rs/clap/commit/66b4dea65c44d8f77ff522238a9237aed1bcab6d), closes [#469](https://github.com/clap-rs/clap/issues/469))


## v2.4.3 (2016-05-10)


#### Bug Fixes

* **Usage Strings:**
  *  now properly dedups args that are also in groups ([3ca0947c](https://github.com/clap-rs/clap/commit/3ca0947c166b4f8525752255e3a4fa6565eb9689), closes [#498](https://github.com/clap-rs/clap/issues/498))
  *  removes duplicate groups from usage strings ([f574fb8a](https://github.com/clap-rs/clap/commit/f574fb8a7cde4d4a2fa4c4481d59be2d0f135427))

#### Improvements

* **Groups:**  formats positional args in groups in a better way ([fef11154](https://github.com/clap-rs/clap/commit/fef11154fb7430d1cbf04a672aabb366e456a368))
* **Help:**
  *  moves positionals to standard <> formatting ([03dfe5ce](https://github.com/clap-rs/clap/commit/03dfe5ceff1d63f172788ff688567ddad9fe119b))
  *  default help subcommand string has been shortened ([5b7fe8e4](https://github.com/clap-rs/clap/commit/5b7fe8e4161e43ab19e2e5fcf55fbe46791134e9), closes [#494](https://github.com/clap-rs/clap/issues/494))

## v2.4.3 (2016-05-10)

* Ghost Release

## v2.4.3 (2016-05-10)

* Ghost Release

## v2.4.0 (2016-05-02)


#### Features

* **Help:**  adds support for displaying info before help message ([29fbfa3b](https://github.com/clap-rs/clap/commit/29fbfa3b963f2f3ca7704bf5d3e1201531baa373))
* **Required:**  adds allowing args that are required unless certain args are present ([af1f7916](https://github.com/clap-rs/clap/commit/af1f79168390ea7da4074d0d9777de458ea64971))

#### Documentation

*   hides formatting from docs ([cb708093](https://github.com/clap-rs/clap/commit/cb708093a7cd057f08c98b7bd1ed54c2db86ae7e))
* **required_unless:**  adds docs and examples for required_unless ([ca727b52](https://github.com/clap-rs/clap/commit/ca727b52423b9883acd88b2f227b2711bc144573))

#### Bug Fixes

* **Required Args:**  fixes issue where missing required args are sometimes duplicated in error messages ([3beebd81](https://github.com/clap-rs/clap/commit/3beebd81e7bc2faa4115ac109cf570e512c5477f), closes [#492](https://github.com/clap-rs/clap/issues/492))


## v2.3.0 (2016-04-18)


#### Improvements

* **macros.rs:**  Added write_nspaces macro (a new version of write_spaces) ([9d757e86](https://github.com/clap-rs/clap/commit/9d757e8678e334e5a740ac750c76a9ed4e785cba))
* **parser.rs:**
  *  Provide a way to create a usage string without the USAGE: title ([a91d378b](https://github.com/clap-rs/clap/commit/a91d378ba0c91b5796457f8c6e881b13226ab735))
  *  Make Parser's create_usage public allowing to have function outside the parser to generate the help ([d51945f8](https://github.com/clap-rs/clap/commit/d51945f8b82ebb0963f4f40b384a9e8335783091))
  *  Expose Parser's flags, opts and positionals argument as iterators ([9b23e7ee](https://github.com/clap-rs/clap/commit/9b23e7ee40e51f7a823644c4496be955dc6c9d3a))
* **src/args:**  Exposes argument display order by introducing a new Trait ([1321630e](https://github.com/clap-rs/clap/commit/1321630ef56955f152c73376d4d85cceb0bb4a12))
* **srs/args:**  Added longest_filter to AnyArg trait ([65b3f667](https://github.com/clap-rs/clap/commit/65b3f667532685f854c699ddd264d326599cf7e5))

#### Features

* **Authors Macro:**  adds a crate_authors macro ([38fb59ab](https://github.com/clap-rs/clap/commit/38fb59abf480eb2b6feca269097412f8b00b5b54), closes [#447](https://github.com/clap-rs/clap/issues/447))
* **HELP:**
  *  implements optional colored help messages ([abc8f669](https://github.com/clap-rs/clap/commit/abc8f669c3c8193ffc3a3b0ac6c3ac2198794d4f), closes [#483](https://github.com/clap-rs/clap/issues/483))
  *  Add a Templated Help system. ([81e121ed](https://github.com/clap-rs/clap/commit/81e121edd616f7285593f11120c63bcccae0d23e))

#### Bug Fixes

* **HELP:**  Adjust Help to semantic changes introduced in 6933b84 ([8d23806b](https://github.com/clap-rs/clap/commit/8d23806bd67530ad412c34a1dcdcb1435555573d))

## v2.2.6 (2016-04-11)

#### Bug Fixes

* **Arg Groups**: fixes bug where arg name isn't printed properly ([3019a685](https://github.com/clap-rs/clap/commit/3019a685eee747ccbe6be09ad5dddce0b1d1d4db), closes [#476](https://github.com/clap-rs/clap/issues/476))


## v2.2.5 (2016-04-03)


#### Bug Fixes

* **Empty Values:**  fixes bug where empty values weren't stored ([885d166f](https://github.com/clap-rs/clap/commit/885d166f04eb3fb581898ae5818c6c8032e5a686), closes [#470](https://github.com/clap-rs/clap/issues/470))
* **Help Message:**  fixes bug where arg name is printed twice ([71acf1d5](https://github.com/clap-rs/clap/commit/71acf1d576946658b8bbdb5ae79e6716c43a030f), closes [#472](https://github.com/clap-rs/clap/issues/472))


## v2.2.4 (2016-03-30)


#### Bug Fixes

*   fixes compiling with debug cargo feature ([d4b55450](https://github.com/clap-rs/clap/commit/d4b554509928031ac0808076178075bb21f8c1da))
* **Empty Values:**  fixes bug where empty values weren't stored ([885d166f](https://github.com/clap-rs/clap/commit/885d166f04eb3fb581898ae5818c6c8032e5a686), closes [#470](https://github.com/clap-rs/clap/issues/470))



## v2.2.3 (2016-03-28)


#### Bug Fixes

* **Help Subcommand:**  fixes issue where help and version flags weren't properly displayed ([205b07bf](https://github.com/clap-rs/clap/commit/205b07bf2e6547851f1290f8cd6b169145e144f1), closes [#466](https://github.com/clap-rs/clap/issues/466))

## v2.2.2 (2016-03-27)


#### Bug Fixes

* **Help Message:**  fixes bug with wrapping in the middle of a unicode sequence ([05365ddc](https://github.com/clap-rs/clap/commit/05365ddcc252e4b49e7a75e199d6001a430bd84d), closes [#456](https://github.com/clap-rs/clap/issues/456))
* **Usage Strings:**  fixes small bug where -- would appear needlessly in usage strings ([6933b849](https://github.com/clap-rs/clap/commit/6933b8491c2a7e28cdb61b47dcf10caf33c2f78a), closes [#461](https://github.com/clap-rs/clap/issues/461))


### 2.2.1 (2016-03-16)


#### Features

* **Help Message:**  wraps and aligns the help message of subcommands ([813d75d0](https://github.com/clap-rs/clap/commit/813d75d06fbf077c65762608c0fa5e941cfc393c), closes [#452](https://github.com/clap-rs/clap/issues/452))

#### Bug Fixes

* **Help Message:**  fixes a bug where small terminal sizes causing a loop ([1d73b035](https://github.com/clap-rs/clap/commit/1d73b0355236923aeaf6799abc759762ded7e1d0), closes [#453](https://github.com/clap-rs/clap/issues/453))


## v2.2.0 (2016-03-15)


#### Features

* **Help Message:**  can auto wrap and aligning help text to term width ([e36af026](https://github.com/clap-rs/clap/commit/e36af0266635f23e85e951b9088d561e9a5d1bf6), closes [#428](https://github.com/clap-rs/clap/issues/428))
* **Help Subcommand:**  adds support passing additional subcommands to help subcommand ([2c12757b](https://github.com/clap-rs/clap/commit/2c12757bbdf34ce481f3446c074e24c09c2e60fd), closes [#416](https://github.com/clap-rs/clap/issues/416))
* **Opts and Flags:**  adds support for custom ordering in help messages ([9803b51e](https://github.com/clap-rs/clap/commit/9803b51e799904c0befaac457418ee766ccc1ab9))
* **Settings:**  adds support for automatically deriving custom display order of args ([ad86e433](https://github.com/clap-rs/clap/commit/ad86e43334c4f70e86909689a088fb87e26ff95a), closes [#444](https://github.com/clap-rs/clap/issues/444))
* **Subcommands:**  adds support for custom ordering in help messages ([7d2a2ed4](https://github.com/clap-rs/clap/commit/7d2a2ed413f5517d45988eef0765cdcd663b6372), closes [#442](https://github.com/clap-rs/clap/issues/442))

#### Bug Fixes

* **From Usage:**  fixes a bug where adding empty lines weren't ignored ([c5c58c86](https://github.com/clap-rs/clap/commit/c5c58c86b9c503d8de19da356a5a5cffb59fbe84))

#### Documentation

* **Groups:**  explains required ArgGroups better ([4ff0205b](https://github.com/clap-rs/clap/commit/4ff0205b85a45151b59bbaf090a89df13438380f), closes [#439](https://github.com/clap-rs/clap/issues/439))

## v2.1.2 (2016-02-24)

#### Bug Fixes

* **Nightly:**  fixes failing nightly build ([d752c170](https://github.com/clap-rs/clap/commit/d752c17029598b19037710f204b7943f0830ae75), closes [#434](https://github.com/clap-rs/clap/issues/434))


## v2.1.1 (2016-02-19)


#### Documentation

* **AppSettings:**  clarifies that AppSettings do not propagate ([3c8db0e9](https://github.com/clap-rs/clap/commit/3c8db0e9be1d24edaad364359513cbb02abb4186), closes [#429](https://github.com/clap-rs/clap/issues/429))
* **Arg Examples:**  adds better examples ([1e79cccc](https://github.com/clap-rs/clap/commit/1e79cccc12937bc0e7cd2aad8e404410798e9fff))

#### Improvements

* **Help:**  adds setting for next line help by arg ([066df748](https://github.com/clap-rs/clap/commit/066df7486e684cf50a8479a356a12ba972c34ce1), closes [#427](https://github.com/clap-rs/clap/issues/427))


## v2.1.0 (2016-02-10)


#### Features

* **Default Values:**  adds support for default values in args ([73211952](https://github.com/clap-rs/clap/commit/73211952964a79d97b434dd567e6d7d34be7feb5), closes [#418](https://github.com/clap-rs/clap/issues/418))

#### Documentation

* **Default Values:**  adds better examples and notes for default values ([9facd74f](https://github.com/clap-rs/clap/commit/9facd74f843ef3807c5d35259558a344e6c25905))


## v2.0.6 (2016-02-09)


#### Improvements

* **Positional Arguments:**  now displays value name if appropriate ([f0a99916](https://github.com/clap-rs/clap/commit/f0a99916c59ce675515c6dcdfe9a40b130510908), closes [#420](https://github.com/clap-rs/clap/issues/420))


## v2.0.5 (2016-02-05)


#### Bug Fixes

* **Multiple Values:**  fixes bug where number_of_values wasn't respected ([72c387da](https://github.com/clap-rs/clap/commit/72c387da0bb8a6f526f863770f08bb8ca0d3de03))


## v2.0.4 (2016-02-04)


#### Bug Fixes

*   adds support for building ArgGroups from standalone YAML ([fcbc7e12](https://github.com/clap-rs/clap/commit/fcbc7e12f5d7b023b8f30cba8cad28a01cf6cd26))
*   Stop lonely hyphens from causing panic ([85b11468](https://github.com/clap-rs/clap/commit/85b11468b0189d5cc15f1cfac5db40d17a0077dc), closes [#410](https://github.com/clap-rs/clap/issues/410))
* **AppSettings:**  fixes bug where subcmds didn't receive parent ver ([a62e4527](https://github.com/clap-rs/clap/commit/a62e452754b3b0e3ac9a15aa8b5330636229ead1))

## v2.0.3 (2016-02-02)


#### Improvements

* **values:**  adds support for up to u64::max values per arg ([c7abf7d7](https://github.com/clap-rs/clap/commit/c7abf7d7611e317b0d31d97632e3d2e13570947c))
* **occurrences:**  Allow for more than 256 occurrences of an argument. ([3731ddb3](https://github.com/clap-rs/clap/commit/3731ddb361163f3d6b86844362871e48c80fa530))

#### Features

* **AppSettings:**  adds HidePossibleValuesInHelp to skip writing those values ([cdee7a0e](https://github.com/clap-rs/clap/commit/cdee7a0eb2beeec723cb98acfacf03bf629c1da3))

#### Bug Fixes

* **value_t_or_exit:**  fixes typo which causes value_t_or_exit to return a Result ([ee96baff](https://github.com/clap-rs/clap/commit/ee96baffd306cb8d20ddc5575cf739bb1a6354e8))


## v2.0.2 (2016-01-31)


#### Improvements

* **arg_enum:**  enum declared with arg_enum returns [&'static str; #] instead of Vec ([9c4b8a1a](https://github.com/clap-rs/clap/commit/9c4b8a1a6b12949222f17d1074578ad7676b9c0d))

#### Bug Fixes

*   clap_app! should be gated by unstable, not nightly feature ([0c8b84af](https://github.com/clap-rs/clap/commit/0c8b84af6161d5baf683688eafc00874846f83fa))
* **SubCommands:**  fixed where subcmds weren't recognized after mult args ([c19c17a8](https://github.com/clap-rs/clap/commit/c19c17a8850602990e24347aeb4427cf43316223), closes [#405](https://github.com/clap-rs/clap/issues/405))
* **Usage Parser:**  fixes a bug where literal single quotes weren't allowed in help strings ([0bcc7120](https://github.com/clap-rs/clap/commit/0bcc71206478074769e311479b34a9f74fe80f5c), closes [#406](https://github.com/clap-rs/clap/issues/406))


## v2.0.1 (2016-01-30)


#### Bug Fixes

*   fixes cargo features to NOT require nightly with unstable features ([dcbcc60c](https://github.com/clap-rs/clap/commit/dcbcc60c9ba17894be636472ea4b07a82d86a9db), closes [#402](https://github.com/clap-rs/clap/issues/402))


## v2.0.0 (2016-01-28)


#### Improvements

* **From Usage:**  vastly improves the usage parser ([fa3a2f86](https://github.com/clap-rs/clap/commit/fa3a2f86bd674c5eb07128c95098fab7d1437247), closes [#350](https://github.com/clap-rs/clap/issues/350))

#### Features

*   adds support for external subcommands ([177fe5cc](https://github.com/clap-rs/clap/commit/177fe5cce745c2164a8e38c23be4c4460d2d7211), closes [#372](https://github.com/clap-rs/clap/issues/372))
*   adds support values with a leading hyphen ([e4d429b9](https://github.com/clap-rs/clap/commit/e4d429b9d52e95197bd0b572d59efacecf305a59), closes [#385](https://github.com/clap-rs/clap/issues/385))
*   adds support for turning off the value delimiter ([508db850](https://github.com/clap-rs/clap/commit/508db850a87c2e251cf6b6ddead9ad56b29f9e57), closes [#352](https://github.com/clap-rs/clap/issues/352))
*   adds support changing the value delimiter ([dafeae8a](https://github.com/clap-rs/clap/commit/dafeae8a526162640f6a68da434370c64d190889), closes [#353](https://github.com/clap-rs/clap/issues/353))
*   adds support for comma separated values ([e69da6af](https://github.com/clap-rs/clap/commit/e69da6afcd2fe48a3c458ca031db40997f860eda), closes [#348](https://github.com/clap-rs/clap/issues/348))
*   adds support with options with optional values ([4555736c](https://github.com/clap-rs/clap/commit/4555736cad01441dcde4ea84a285227e0844c16e), closes [#367](https://github.com/clap-rs/clap/issues/367))
* **UTF-8:**  adds support for invalid utf8 in values ([c5c59dec](https://github.com/clap-rs/clap/commit/c5c59dec0bc33b86b2e99d30741336f17ec84282), closes [#269](https://github.com/clap-rs/clap/issues/269))
* **v2:**  implementing the base of 2.x ([a3536054](https://github.com/clap-rs/clap/commit/a3536054512ba833533dc56615ce3663d884381c))

#### Bug Fixes

*   fixes nightly build with new lints ([17599195](https://github.com/clap-rs/clap/commit/175991956c37dc83ba9c49396e927a1cb65c5b11))
*   fixes Windows build for 2x release ([674c9b48](https://github.com/clap-rs/clap/commit/674c9b48c7c92079cb180cc650a9e39f34781c32), closes [#392](https://github.com/clap-rs/clap/issues/392))
*   fixes yaml build for 2x base ([adceae64](https://github.com/clap-rs/clap/commit/adceae64c8556d00ab715677377b216f9f468ad7))

#### Documentation

*   updates examples for 2x release ([1303b360](https://github.com/clap-rs/clap/commit/1303b3607468f362ab1b452d5614c1a064dc69b4), closes [#394](https://github.com/clap-rs/clap/issues/394))
*   updates examples for 2x release ([0a011f31](https://github.com/clap-rs/clap/commit/0a011f3142aec338d388a6c8bfe22fa7036021bb), closes [#394](https://github.com/clap-rs/clap/issues/394))
*   updates documentation for v2 release ([8d51724e](https://github.com/clap-rs/clap/commit/8d51724ef73dfde5bb94fb9466bc5463a1cc1502))
*   updating docs for 2x release ([576d0e0e](https://github.com/clap-rs/clap/commit/576d0e0e2c7b8f386589179bbf7419b93abacf1c))
* **README.md:**
  *  updates readme for v2 release ([acaba01a](https://github.com/clap-rs/clap/commit/acaba01a353c12144b9cd9a3ce447400691849b0), closes [#393](https://github.com/clap-rs/clap/issues/393))
  *  fix typo and make documentation conspicuous ([07b9f614](https://github.com/clap-rs/clap/commit/07b9f61495d927f69f7abe6c0d85253f0f4e6107))

#### BREAKING CHANGES

* **Fewer lifetimes! Yay!**
 * `App<'a, 'b, 'c, 'd, 'e, 'f>` => `App<'a, 'b>`
 * `Arg<'a, 'b, 'c, 'd, 'e, 'f>` => `Arg<'a, 'b>`
 * `ArgMatches<'a, 'b>` => `ArgMatches<'a>`
* **Simply Renamed**
 * `App::arg_group` => `App::group`
 * `App::arg_groups` => `App::groups`
 * `ArgGroup::add` => `ArgGroup::arg`
 * `ArgGroup::add_all` => `ArgGroup::args`
 * `ClapError` => `Error`
  * struct field `ClapError::error_type` => `Error::kind`
 * `ClapResult` => `Result`
 * `ClapErrorType` => `ErrorKind`
* **Removed Deprecated Functions and Methods**
 * `App::subcommands_negate_reqs`
 * `App::subcommand_required`
 * `App::arg_required_else_help`
 * `App::global_version(bool)`
 * `App::versionless_subcommands`
 * `App::unified_help_messages`
 * `App::wait_on_error`
 * `App::subcommand_required_else_help`
 * `SubCommand::new`
 * `App::error_on_no_subcommand`
 * `Arg::new`
 * `Arg::mutually_excludes`
 * `Arg::mutually_excludes_all`
 * `Arg::mutually_overrides_with`
 * `simple_enum!`
* **Renamed Error Variants**
 * `InvalidUnicode` => `InvalidUtf8`
 * `InvalidArgument` => `UnknownArgument`
* **Usage Parser**
 * Value names can now be specified inline, i.e. `-o, --option <FILE> <FILE2> 'some option which takes two files'`
 * **There is now a priority of order to determine the name** - This is perhaps the biggest breaking change. See the documentation for full details. Prior to this change, the value name took precedence. **Ensure your args are using the proper names (i.e. typically the long or short and NOT the value name) throughout the code**
* `ArgMatches::values_of` returns an `Values` now which implements `Iterator` (should not break any code)
* `crate_version!` returns `&'static str` instead of `String`
* Using the `clap_app!` macro requires compiling with the `unstable` feature because the syntax could change slightly in the future


## v1.5.5 (2016-01-04)


#### Bug Fixes

*   fixes an issue where invalid short args didn't cause an error ([c9bf7e44](https://github.com/clap-rs/clap/commit/c9bf7e4440bd2f9b524ea955311d433c40a7d1e0))
*   prints the name in version and help instead of binary name ([8f3817f6](https://github.com/clap-rs/clap/commit/8f3817f665c0cab6726bc16c56a53b6a61e44448), closes [#368](https://github.com/clap-rs/clap/issues/368))
*   fixes an intentional panic issue discovered via clippy ([ea83a3d4](https://github.com/clap-rs/clap/commit/ea83a3d421ea8856d4cac763942834d108b71406))


## v1.5.4 (2015-12-18)


#### Examples

* **17_yaml:**  conditinonally compile 17_yaml example ([575de089](https://github.com/clap-rs/clap/commit/575de089a3e240c398cb10e6cf5a5c6b68662c01))

#### Improvements

*   clippy improvements ([99cdebc2](https://github.com/clap-rs/clap/commit/99cdebc23da3a45a165f14b27bebeb2ed828a2ce))

#### Bug Fixes


* **errors:**  return correct error type in WrongNumValues error builder ([5ba8ba9d](https://github.com/clap-rs/clap/commit/5ba8ba9dcccdfa74dd1c44260e64b359bbb36be6))
*   ArgRequiredElseHelp setting now takes precedence over missing required args ([faad83fb](https://github.com/clap-rs/clap/commit/faad83fbef6752f3093b6e98fca09a9449b830f4), closes [#362](https://github.com/clap-rs/clap/issues/362))


## v1.5.3 (2015-11-20)


#### Bug Fixes

* **Errors:**  fixes some instances when errors are missing a final newline ([c4d2b171](https://github.com/clap-rs/clap/commit/c4d2b1711994479ad64ee52b6b49d2ceccbf2118))




## v1.5.2 (2015-11-14)


#### Bug Fixes

* **Errors:**  fixes a compiling bug when built on Windows or without the color feature ([a35f7634](https://github.com/clap-rs/clap/commit/a35f76346fe6ecc88dda6a1eb13627186e7ce185))



## v1.5.1 (2015-11-13)


#### Bug Fixes

* **Required Args:**  fixes a bug where required args are not correctly accounted for ([f03b88a9](https://github.com/clap-rs/clap/commit/f03b88a9766b331a63879bcd747687f2e5a2661b), closes [#343](https://github.com/clap-rs/clap/issues/343))



## v1.5.0 (2015-11-13)


#### Bug Fixes

*   fixes a bug with required positional args in usage strings ([c6858f78](https://github.com/clap-rs/clap/commit/c6858f78755f8e860204323c828c8355a066dc83))

#### Documentation

* **FAQ:**  updates readme with slight changes to FAQ ([a4ef0fab](https://github.com/clap-rs/clap/commit/a4ef0fab73c8dc68f1b138965d1340459c113398))

#### Improvements

*   massive errors overhaul ([cdc29175](https://github.com/clap-rs/clap/commit/cdc29175bc9c53e5b4aec86cbc04c1743154dae6))
* **ArgMatcher:**  huge refactor and deduplication of code ([8988853f](https://github.com/clap-rs/clap/commit/8988853fb8825e8f841fde349834cc12cdbad081))
* **Errors:**  errors have been vastly improved ([e59bc0c1](https://github.com/clap-rs/clap/commit/e59bc0c16046db156a88ba71a037db05028e995c))
* **Traits:**  refactoring some configuration into traits ([5800cdec](https://github.com/clap-rs/clap/commit/5800cdec6dce3def4242b9f7bd136308afb19685))

#### Performance

* **App:**
  *  more BTreeMap->Vec, Opts and SubCmds ([bc4495b3](https://github.com/clap-rs/clap/commit/bc4495b32ec752b6c4b29719e831c043ef2a26ce))
  *  changes flags BTreeMap->Vec ([d357640f](https://github.com/clap-rs/clap/commit/d357640fab55e5964fe83efc3c771e53aa3222fd))
  *  removed unneeded BTreeMap ([78971fd6](https://github.com/clap-rs/clap/commit/78971fd68d7dc5c8e6811b4520cdc54e4188f733))
  *  changes BTreeMap to VecMap in some instances ([64b921d0](https://github.com/clap-rs/clap/commit/64b921d087fdd03775c95ba0bcf65d3f5d36f812))
  *  removed excess clones ([ec0089d4](https://github.com/clap-rs/clap/commit/ec0089d42ed715d293fb668d3a90b0db0aa3ec39))



## v1.4.7 (2015-11-03)


#### Documentation

*   Clarify behavior of Arg::multiple with options. ([434f497a](https://github.com/clap-rs/clap/commit/434f497ab6d831f8145cf09278c97ca6ee6c6fe7))
*   Fix typos and improve grammar. ([c1f66b5d](https://github.com/clap-rs/clap/commit/c1f66b5de7b5269fbf8760a005ef8c645edd3229))

#### Bug Fixes

* **Error Status:**  fixes bug where --help and --version return non-zero exit code ([89b51fdf](https://github.com/clap-rs/clap/commit/89b51fdf8b1ab67607567344e2317ff1a757cb12))



## v1.4.6 (2015-10-29)


#### Features

*   allows parsing without a binary name for daemons and interactive CLIs ([aff89d57](https://github.com/clap-rs/clap/commit/aff89d579b5b85c3dc81b64f16d5865299ec39a2), closes [#318](https://github.com/clap-rs/clap/issues/318))

#### Bug Fixes

* **Errors:**  tones down quoting in some error messages ([34ce59ed](https://github.com/clap-rs/clap/commit/34ce59ede53bfa2eef722c74881cdba7419fd9c7), closes [#309](https://github.com/clap-rs/clap/issues/309))
* **Help and Version:**  only builds help and version once ([e3be87cf](https://github.com/clap-rs/clap/commit/e3be87cfc095fc41c9811adcdc6d2b079f237d5e))
* **Option Args:**  fixes bug with args and multiple values ([c9a9548a](https://github.com/clap-rs/clap/commit/c9a9548a8f96cef8a3dd9a980948325fbbc1b91b), closes [#323](https://github.com/clap-rs/clap/issues/323))
* **POSIX Overrides:**  fixes bug where required args are overridden ([40ed2b50](https://github.com/clap-rs/clap/commit/40ed2b50c3a9fe88bfdbaa43cef9fd6493ecaa8e))
* **Safe Matches:**  using 'safe' forms of the get_matches family no longer exit the process ([c47025dc](https://github.com/clap-rs/clap/commit/c47025dca2b3305dea0a0acfdd741b09af0c0d05), closes [#256](https://github.com/clap-rs/clap/issues/256))
* **Versionless SubCommands:**  fixes a bug where the -V flag was needlessly built ([27df8b9d](https://github.com/clap-rs/clap/commit/27df8b9d98d13709dad3929a009f40ebff089a1a), closes [#329](https://github.com/clap-rs/clap/issues/329))

#### Documentation

*   adds comparison in readme ([1a8bf31e](https://github.com/clap-rs/clap/commit/1a8bf31e7a6b87ce48a66af2cde1645b2dd5bc95), closes [#325](https://github.com/clap-rs/clap/issues/325))



## v1.4.5 (2015-10-06)


#### Bug Fixes

*   fixes crash on invalid arg error ([c78ce128](https://github.com/clap-rs/clap/commit/c78ce128ebbe7b8f730815f8176c29d76f4ade8c))



## v1.4.4 (2015-10-06)


#### Documentation

*   clean up some formatting ([b7df92d7](https://github.com/clap-rs/clap/commit/b7df92d7ea25835701dd22ddff984b9749f48a00))
*   move the crate-level docs to top of the lib.rs file ([d7233bf1](https://github.com/clap-rs/clap/commit/d7233bf122dbf80ba8fc79e5641be2df8af10e7a))
*   changes doc comments to rustdoc comments ([34b601be](https://github.com/clap-rs/clap/commit/34b601be5fdde76c1a0859385b359b96d66b8732))
*   fixes panic in 14_groups example ([945b00a0](https://github.com/clap-rs/clap/commit/945b00a0c27714b63bdca48d003fe205fcfdc578), closes [#295](https://github.com/clap-rs/clap/issues/295))
*   avoid suggesting star dependencies. ([d33228f4](https://github.com/clap-rs/clap/commit/d33228f40b5fefb84cf3dd51546bfb340dcd9f5a))
* **Rustdoc:**  adds portions of the readme to main rustdoc page ([6f9ee181](https://github.com/clap-rs/clap/commit/6f9ee181e69d90bd4206290e59d6f3f1e8f0cbb2), closes [#293](https://github.com/clap-rs/clap/issues/293))

#### Bug Fixes

*   grammar error in some conflicting option errors ([e73b07e1](https://github.com/clap-rs/clap/commit/e73b07e19474323ad2260da66abbf6a6d4ecbd4f))
* **Unified Help:**  sorts both flags and options as a unified category ([2a223dad](https://github.com/clap-rs/clap/commit/2a223dad82901fa2e74baad3bfc4c7b94509300f))
* **Usage:**  fixes a bug where required args aren't filtered properly ([72b453dc](https://github.com/clap-rs/clap/commit/72b453dc170af3050bb123d35364f6da77fc06d7), closes [#277](https://github.com/clap-rs/clap/issues/277))
* **Usage Strings:**  fixes a bug ordering of elements in usage strings ([aaf0d6fe](https://github.com/clap-rs/clap/commit/aaf0d6fe7aa2403e76096c16204d254a9ee61ee2), closes [#298](https://github.com/clap-rs/clap/issues/298))

#### Features

*   supports -aValue style options ([0e3733e4](https://github.com/clap-rs/clap/commit/0e3733e4fec2015c2d566a51432dcd92cb69cad3))
* **Trailing VarArg:**  adds opt-in setting for final arg being vararg ([27018b18](https://github.com/clap-rs/clap/commit/27018b1821a4bcd5235cfe92abe71b3c99efc24d), closes [#278](https://github.com/clap-rs/clap/issues/278))



## v1.4.3 (2015-09-30)


#### Features

*   allows accessing arg values by group name ([c92a4b9e](https://github.com/clap-rs/clap/commit/c92a4b9eff2d679957f61c0c41ff404b40d38a91))

#### Documentation

*   use links to examples instead of plain text ([bb4fe237](https://github.com/clap-rs/clap/commit/bb4fe237858535627271465147add537e4556b43))

#### Bug Fixes

* **Help Message:**  required args no longer double list in usage ([1412e639](https://github.com/clap-rs/clap/commit/1412e639e0a79df84936d1101a837f90077d1c83), closes [#277](https://github.com/clap-rs/clap/issues/277))
* **Possible Values:**  possible value validation is restored ([f121ae74](https://github.com/clap-rs/clap/commit/f121ae749f8f4bfe754ef2e8a6dfc286504b5b75), closes [#287](https://github.com/clap-rs/clap/issues/287))



## v1.4.2 (2015-09-23)


#### Bug Fixes

* **Conflicts:**  fixes bug with conflicts not removing required args ([e17fcec5](https://github.com/clap-rs/clap/commit/e17fcec53b3216ad047a13dddc6f740473fad1a1), closes [#271](https://github.com/clap-rs/clap/issues/271))



## v1.4.1 (2015-09-22)


#### Examples

*   add clap_app quick example ([4ba6249c](https://github.com/clap-rs/clap/commit/4ba6249c3cf4d2e083370d1fe4dcc7025282c28a))

#### Features

* **Unicode:**  allows non-panicking on invalid unicode characters ([c5bf7ddc](https://github.com/clap-rs/clap/commit/c5bf7ddc8cfb876ec928a5aaf5591232bbb32e5d))

#### Documentation

*   properly names Examples section for rustdoc ([87ba5445](https://github.com/clap-rs/clap/commit/87ba54451d7ec7b1c9b9ef134f90bbe39e6fac69))
*   fixes various typos and spelling ([f85640f9](https://github.com/clap-rs/clap/commit/f85640f9f6d8fd3821a40e9b8b7a34fabb789d02))
* **Arg:**  unhides fields of the Arg struct ([931aea88](https://github.com/clap-rs/clap/commit/931aea88427edf43a3da90d5a500c1ff2b2c3614))

#### Bug Fixes

*   flush the buffer in App::print_version() ([cbc42a37](https://github.com/clap-rs/clap/commit/cbc42a37d212d84d22b1777d08e584ff191934e7))
*   Macro benchmarks ([13712da1](https://github.com/clap-rs/clap/commit/13712da1d36dc7614eec3a10ad488257ba615751))



## v1.4.0 (2015-09-09)


#### Features

*   allows printing help message by library consumers ([56b95f32](https://github.com/clap-rs/clap/commit/56b95f320875c62dda82cb91b29059671e120ed1))
*   allows defining hidden args and subcmds ([2cab4d03](https://github.com/clap-rs/clap/commit/2cab4d0334ea3c2439a1d4bfca5bf9905c7ea9ac), closes [#231](https://github.com/clap-rs/clap/issues/231))
*   Builder macro to assist with App/Arg/Group/SubCommand building ([443841b0](https://github.com/clap-rs/clap/commit/443841b012a8d795cd5c2bd69ae6e23ef9b16477))
* **Errors:**  allows consumers to write to stderr and exit on error ([1e6403b6](https://github.com/clap-rs/clap/commit/1e6403b6a863574fa3cb6946b1fb58f034e8664c))



## v1.3.2 (2015-09-08)


#### Documentation

*   fixed ErrorKind docs ([dd057843](https://github.com/clap-rs/clap/commit/dd05784327fa070eb6ce5ce89a8507e011d8db94))
* **ErrorKind:**  changed examples content ([b9ca2616](https://github.com/clap-rs/clap/commit/b9ca261634b89613bbf3d98fd74d55cefbb31a8c))

#### Bug Fixes

*   fixes a bug where the help subcommand wasn't overridable ([94003db4](https://github.com/clap-rs/clap/commit/94003db4b5eebe552ca337521c1c001295822745))

#### Features

*   adds ability not consume self when parsing matches and/or exit on help ([94003db4](https://github.com/clap-rs/clap/commit/94003db4b5eebe552ca337521c1c001295822745))
* **App:**  Added ability for users to handle errors themselves ([934e6fbb](https://github.com/clap-rs/clap/commit/934e6fbb643b2385efc23444fe6fce31494dc288))



## v1.3.1 (2015-09-04)


#### Examples

* **17_yaml:**  fixed example ([9b848622](https://github.com/clap-rs/clap/commit/9b848622296c8c5c7b9a39b93ddd41f51df790b5))

#### Performance

*   changes ArgGroup HashSets to Vec ([3cb4a48e](https://github.com/clap-rs/clap/commit/3cb4a48ebd15c20692f4f3a2a924284dc7fd5e10))
*   changes BTreeSet for Vec in some instances ([baab2e3f](https://github.com/clap-rs/clap/commit/baab2e3f4060e811abee14b1654cbcd5cf3b5fea))



## v1.3.0 (2015-09-01)


#### Features

* **YAML:**  allows building a CLI from YAML files ([86cf4c45](https://github.com/clap-rs/clap/commit/86cf4c45626a36b8115446952f9069f73c1debc3))
* **ArgGroups:**  adds support for building ArgGroups from yaml ([ecf88665](https://github.com/clap-rs/clap/commit/ecf88665cbff367018b29161a1b75d44a212707d))
* **Subcommands:**  adds support for subcommands from yaml ([e415cf78](https://github.com/clap-rs/clap/commit/e415cf78ba916052d118a8648deba2b9c16b1530))

#### Documentation

* **YAML:**  adds examples for using YAML to build a CLI ([ab41d7f3](https://github.com/clap-rs/clap/commit/ab41d7f38219544750e6e1426076dc498073191b))
* **Args from YAML:**  fixes doc examples ([19b348a1](https://github.com/clap-rs/clap/commit/19b348a10050404cd93888dbbbe4f396681b67d0))
* **Examples:**  adds better usage examples instead of having unused variables ([8cbacd88](https://github.com/clap-rs/clap/commit/8cbacd8883004fe71a8ea036ec4391c7dd8efe94))

#### Examples

*   Add AppSettings example ([12705079](https://github.com/clap-rs/clap/commit/12705079ca96a709b4dd94f7ddd20a833b26838c))

#### Bug Fixes

* **Unified Help Messages:**  fixes a crash from this setting and no opts ([169ffec1](https://github.com/clap-rs/clap/commit/169ffec1003d58d105d7ef2585b3425e57980000), closes [#210](https://github.com/clap-rs/clap/issues/210))



## v1.2.5 (2015-08-27)


#### Examples

*   add custom validator example ([b9997d1f](https://github.com/clap-rs/clap/commit/b9997d1fca74d4d8f93971f2a01bdf9798f913d5))
*   fix indentation ([d4f1b740](https://github.com/clap-rs/clap/commit/d4f1b740ede410fd2528b9ecd89592c2fd8b1e20))

#### Features

* **Args:**  allows opts and args to define a name for help and usage msgs ([ad962ec4](https://github.com/clap-rs/clap/commit/ad962ec478da999c7dba0afdb84c266f4d09b1bd))



## v1.2.4 (2015-08-26)


#### Bug Fixes

* **Possible Values:**  fixes a bug where suggestions aren't made when using --long=value format ([3d5e9a6c](https://github.com/clap-rs/clap/commit/3d5e9a6cedb26668839b481c9978e2fbbab8be6f), closes [#192](https://github.com/clap-rs/clap/issues/192))



## v1.2.3 (2015-08-24)


#### Bug Fixes

* **App, Args:**  fixed subcommand reqs negation ([b41afa8c](https://github.com/clap-rs/clap/commit/b41afa8c3ded3d1be12f7a2f8ea06cc44afc9458), closes [#188](https://github.com/clap-rs/clap/issues/188))



## v1.2.2 (2015-08-23)


#### Bug Fixes

*   fixed confusing error message, also added test for it ([fc7a31a7](https://github.com/clap-rs/clap/commit/fc7a31a745efbf1768ee2c62cd3bb72bfe30c708))
* **App:**  fixed requirmets overriding ([9c135eb7](https://github.com/clap-rs/clap/commit/9c135eb790fa16183e5bdb2009ddc3cf9e25f99f))



## v1.2.1 (2015-08-20)


#### Documentation

* **README.md:**  updates for new features ([16cf9245](https://github.com/clap-rs/clap/commit/16cf9245fb5fc4cf6face898e358368bf9961cbb))

#### Features

*   implements posix compatible conflicts for long args ([8c2d48ac](https://github.com/clap-rs/clap/commit/8c2d48acf5473feebd721a9049a9c9b7051e70f9))
*   added overrides to support conflicts in POSIX compatible manner ([0b916a00](https://github.com/clap-rs/clap/commit/0b916a00de26f6941538f6bc5f3365fa302083c1))
* **Args:**  allows defining POSIX compatible argument conflicts ([d715646e](https://github.com/clap-rs/clap/commit/d715646e69759ccd95e01f49b04f489827ecf502))

#### Bug Fixes

*   fixed links in cargo and license buttons ([6d9837ad](https://github.com/clap-rs/clap/commit/6d9837ad9a9e006117cd7372fdc60f9a3889c7e2))

#### Performance

* **Args and Apps:**  changes HashSet->Vec in some instances for increased performance ([d0c3b379](https://github.com/clap-rs/clap/commit/d0c3b379700757e0a9b0c40af709f8af1f5b4949))



## v1.2.0 (2015-08-15)


#### Bug Fixes

*   fixed misspell and enum name ([7df170d7](https://github.com/clap-rs/clap/commit/7df170d7f4ecff06608317655d1e0c4298f62076))
*   fixed use for clap crate ([dc3ada73](https://github.com/clap-rs/clap/commit/dc3ada738667d4b689678f79d14251ee82004ece))

#### Documentation

*   updates docs for new features ([03496547](https://github.com/clap-rs/clap/commit/034965471782d872ca495045b58d34b31807c5b1))
*   fixed docs for previous changes ([ade36778](https://github.com/clap-rs/clap/commit/ade367780c366425de462506d256e0f554ed3b9c))

#### Improvements

* **AppSettings:**  adds ability to add multiple settings at once ([4a00e251](https://github.com/clap-rs/clap/commit/4a00e2510d0ca8d095d5257d51691ba3b61c1374))

#### Features

*   Replace application level settings with enum variants ([618dc4e2](https://github.com/clap-rs/clap/commit/618dc4e2c205bf26bc43146164e65eb1f6b920ed))
* **Args:**  allows for custom argument value validations to be defined ([84ae2ddb](https://github.com/clap-rs/clap/commit/84ae2ddbceda34b5cbda98a6959edaa52fde2e1a), closes [#170](https://github.com/clap-rs/clap/issues/170))



## v1.1.6 (2015-08-01)


#### Bug Fixes

*   fixes two bugs in App when printing newlines in help and subcommands required error ([d63c0136](https://github.com/clap-rs/clap/commit/d63c0136310db9dd2b1c7b4745938311601d8938))



## v1.1.5 (2015-07-29)

#### Performance

*   removes some unneeded allocations ([93e915df](https://github.com/clap-rs/clap/commit/93e915dfe300f7b7d6209ca93323c6a46f89a8c1))

## v1.1.4 (2015-07-20)


#### Improvements

* **Usage Strings**  displays a [--] when it may be helpful ([86c3be85](https://github.com/clap-rs/clap/commit/86c3be85fb6f77f83b5a6d2df40ae60937486984))

#### Bug Fixes

* **Macros**  fixes a typo in a macro generated error message ([c9195c5f](https://github.com/clap-rs/clap/commit/c9195c5f92abb8cd6a37b4f4fbb2f1fee2a8e368))
* **Type Errors**  fixes formatting of error output when failed type parsing ([fe5d95c6](https://github.com/clap-rs/clap/commit/fe5d95c64f3296e6eddcbec0cb8b86659800145f))



## v1.1.3 (2015-07-18)


#### Documentation

*   updates README.md to include lack of color support on Windows ([52f81e17](https://github.com/clap-rs/clap/commit/52f81e17377b18d2bd0f34693b642b7f358998ee))

#### Bug Fixes

*   fixes formatting bug which prevented compiling on windows ([9cb5dceb](https://github.com/clap-rs/clap/commit/9cb5dceb3e5fe5e0e7b24619ff77e5040672b723), closes [#163](https://github.com/clap-rs/clap/issues/163))



## v1.1.2 (2015-07-17)


#### Bug Fixes

*   fixes a bug when parsing multiple {n} newlines inside help strings ([6d214b54](https://github.com/clap-rs/clap/commit/6d214b549a9b7e189a94e5fa2b7c92cc333ca637))



## v1.1.1 (2015-07-17)


#### Bug Fixes

*   fixes a logic bug and allows setting Arg::number_of_values() < 2 ([42b6d1fc](https://github.com/clap-rs/clap/commit/42b6d1fc3c519c92dfb3af15276e7d3b635e6cfe), closes [#161](https://github.com/clap-rs/clap/issues/161))



## v1.1.0 (2015-07-16)


#### Features

*   allows creating unified help messages, a la docopt or getopts ([52bcd892](https://github.com/clap-rs/clap/commit/52bcd892ea51564ce463bc5865acd64f8fe91cb1), closes [#158](https://github.com/clap-rs/clap/issues/158))
*   allows stating all subcommands should *not* have --version flags ([336c476f](https://github.com/clap-rs/clap/commit/336c476f631d512b54ac56fdca6f29ebdc2c00c5), closes [#156](https://github.com/clap-rs/clap/issues/156))
*   allows setting version number to auto-propagate through subcommands ([bc66d3c6](https://github.com/clap-rs/clap/commit/bc66d3c6deedeca62463fff95369ab1cfcdd366b), closes [#157](https://github.com/clap-rs/clap/issues/157))

#### Improvements

* **Help Strings**  properly aligns and handles newlines in long help strings ([f9800a29](https://github.com/clap-rs/clap/commit/f9800a29696dd2cc0b0284bf693b3011831e556f), closes [#145](https://github.com/clap-rs/clap/issues/145))


#### Performance

* **Help Messages**  big performance improvements when printing help messages ([52bcd892](https://github.com/clap-rs/clap/commit/52bcd892ea51564ce463bc5865acd64f8fe91cb1))

#### Documentation

*   updates readme with new features ([8232f7bb](https://github.com/clap-rs/clap/commit/8232f7bb52e88862bc13c3d4f99ee4f56cfe4bc0))
*   fix incorrect code example for `App::subcommand_required` ([8889689d](https://github.com/clap-rs/clap/commit/8889689dc6336ccc45b2c9f2cf8e2e483a639e93))


## v1.0.3 (2015-07-11)


#### Improvements

* **Errors**  writes errors to stderr ([cc76ab8c](https://github.com/clap-rs/clap/commit/cc76ab8c2b77c67b42f4717ded530df7806142cf), closes [#154](https://github.com/clap-rs/clap/issues/154))

#### Documentation

* **README.md**  updates example help message to new format ([0aca29bd](https://github.com/clap-rs/clap/commit/0aca29bd5d6d1a4e9971bdc88d946ffa58606efa))



## v1.0.2 (2015-07-09)


#### Improvements

* **Usage**  re-orders optional arguments and required to natural standard ([dc7e1fce](https://github.com/clap-rs/clap/commit/dc7e1fcea5c85d317018fb201d2a9262249131b4), closes [#147](https://github.com/clap-rs/clap/issues/147))



## v1.0.1 (2015-07-08)


#### Bug Fixes

*   allows empty values when using --long='' syntax ([083f82d3](https://github.com/clap-rs/clap/commit/083f82d333b69720a6ef30074875310921d964d1), closes [#151](https://github.com/clap-rs/clap/issues/151))



## v1.0.0 (2015-07-08)


#### Documentation

* **README.md**  adds new features to what's new list ([938f7f01](https://github.com/clap-rs/clap/commit/938f7f01340f521969376cf4e2e3d9436bca21f7))
* **README.md**  use with_name for subcommands ([28b7e316](https://github.com/clap-rs/clap/commit/28b7e3161fb772e5309042648fe8c3a420645bac))

#### Features

*   args can now be parsed from arbitrary locations, not just std::env::args() ([75312528](https://github.com/clap-rs/clap/commit/753125282b1b9bfff875f1557ce27610edcc59e1))



## v1.0.0-beta (2015-06-30)


#### Features

*   allows waiting for user input on error ([d0da3bdd](https://github.com/clap-rs/clap/commit/d0da3bdd9d1871541907ea9c645322a74d260e07), closes [#140](https://github.com/clap-rs/clap/issues/140))
* **Help**  allows one to fully override the auto-generated help message ([26d5ae3e](https://github.com/clap-rs/clap/commit/26d5ae3e330d1e150811d5b60b2b01a8f8df854e), closes [#141](https://github.com/clap-rs/clap/issues/141))

#### Documentation

*   adds "whats new" section to readme ([ff149a29](https://github.com/clap-rs/clap/commit/ff149a29dd9e179865e6d577cd7dc87c54f8f95c))

#### Improvements

*   removes deprecated functions in prep for 1.0 ([274484df](https://github.com/clap-rs/clap/commit/274484dfd08fff4859cefd7e9bef3b73d3a9cb5f))



## v0.11.0 (2015-06-17) - BREAKING CHANGE


#### Documentation

*   updates docs to new version flag defaults ([ebf442eb](https://github.com/clap-rs/clap/commit/ebf442ebebbcd2ec6bfe2c06566c9d362bccb112))

#### Features

* **Help and Version**  default short for version is now `-V` but can be overridden (only breaks manual documentation) (**BREAKING CHANGE** [eb1d9320](https://github.com/clap-rs/clap/commit/eb1d9320c509c1e4e57d7c7959da82bcfe06ada0))



## v0.10.5 (2015-06-06)


#### Bug Fixes

* **Global Args**  global arguments propagate fully now ([1f377960](https://github.com/clap-rs/clap/commit/1f377960a48c82f54ca5f39eb56bcb393140b046), closes [#137](https://github.com/clap-rs/clap/issues/137))



## v0.10.4 (2015-06-06)


#### Bug Fixes

* **Global Args**  global arguments propagate fully now ([8f2c0160](https://github.com/clap-rs/clap/commit/8f2c0160c8d844daef375a33dbaec7d89de00a00), closes [#137](https://github.com/clap-rs/clap/issues/137))



## v0.10.3 (2015-05-31)


#### Bug Fixes

* **Global Args**  fixes a bug where globals only transfer to one subcommand ([a37842ee](https://github.com/clap-rs/clap/commit/a37842eec1ee3162b86fdbda23420b221cdb1e3b), closes [#135](https://github.com/clap-rs/clap/issues/135))



## v0.10.2 (2015-05-30)


#### Improvements

* **Binary Names**  allows users to override the system determined bin name ([2191fe94](https://github.com/clap-rs/clap/commit/2191fe94bda35771383b52872fb7f5421b178be1), closes [#134](https://github.com/clap-rs/clap/issues/134))

#### Documentation

*   adds contributing guidelines ([6f76bd0a](https://github.com/clap-rs/clap/commit/6f76bd0a07e8b7419b391243ab2d6687cd8a9c5f))



## v0.10.1 (2015-05-26)


#### Features

*   can now specify that an app or subcommand should display help on no args or subcommands ([29ca7b2f](https://github.com/clap-rs/clap/commit/29ca7b2f74376ca0cdb9d8ee3bfa99f7640cc404), closes [#133](https://github.com/clap-rs/clap/issues/133))



## v0.10.0 (2015-05-23)


#### Features

* **Global Args**  allows args that propagate down to child commands ([2bcc6137](https://github.com/clap-rs/clap/commit/2bcc6137a83cb07757771a0afea953e68e692f0b), closes [#131](https://github.com/clap-rs/clap/issues/131))

#### Improvements

* **Colors**  implements more structured colored output ([d6c3ed54](https://github.com/clap-rs/clap/commit/d6c3ed54d21cf7b40d9f130d4280ff5448522fc5), closes [#129](https://github.com/clap-rs/clap/issues/129))

#### Deprecations

* **SubCommand/App**  several methods and functions for stable release ([28b73855](https://github.com/clap-rs/clap/commit/28b73855523ad170544afdb20665db98702fbe70))

#### Documentation

*   updates for deprecations and new features ([743eefe8](https://github.com/clap-rs/clap/commit/743eefe8dd40c1260065ce086d572e9e9358bc4c))



## v0.9.2 (2015-05-20)


#### Bug Fixes

* **help**  allows parent requirements to be ignored with help and version ([52218cc1](https://github.com/clap-rs/clap/commit/52218cc1fdb06a42456c964d98cc2c7ac3432412), closes [#124](https://github.com/clap-rs/clap/issues/124))



## v0.9.1 (2015-05-18)


#### Bug Fixes

* **help**  fixes a bug where requirements are included as program name in help and version ([08ba3f25](https://github.com/clap-rs/clap/commit/08ba3f25cf38b149229ba8b9cb37a5804fe6b789))



## v0.9.0 (2015-05-17)


#### Improvements

* **usage**  usage strings now include parent command requirements ([dd8f21c7](https://github.com/clap-rs/clap/commit/dd8f21c7c15cde348fdcf44fa7c205f0e98d2e4a), closes [#125](https://github.com/clap-rs/clap/issues/125))
* **args**  allows consumer of clap to decide if empty values are allowed or not ([ab4ec609](https://github.com/clap-rs/clap/commit/ab4ec609ccf692b9b72cccef5c9f74f5577e360d), closes [#122](https://github.com/clap-rs/clap/issues/122))

#### Features

* **subcommands**
  *  allows optionally specifying that no subcommand is an error ([7554f238](https://github.com/clap-rs/clap/commit/7554f238fd3afdd60b7e4dcf00ff4a9eccf842c1), closes [#126](https://github.com/clap-rs/clap/issues/126))
  *  subcommands can optionally negate parent requirements ([4a4229f5](https://github.com/clap-rs/clap/commit/4a4229f500e21c350e1ef78dd09ef27559653288), closes [#123](https://github.com/clap-rs/clap/issues/123))



## v0.8.6 (2015-05-17)


#### Bug Fixes

* **args**  `-` can now be parsed as a value for an argument ([bc12e78e](https://github.com/clap-rs/clap/commit/bc12e78eadd7eaf9d008a8469fdd2dfd7990cb5d), closes [#121](https://github.com/clap-rs/clap/issues/121))



## v0.8.5 (2015-05-15)


#### Bug Fixes

* **macros**  makes macro errors consistent with others ([0c264a8c](https://github.com/clap-rs/clap/commit/0c264a8ca57ec1cfdcb74dae79145d766cdc9b97), closes [#118](https://github.com/clap-rs/clap/issues/118))

#### Features

* **macros**
  *  arg_enum! and simple_enum! provide a Vec<&str> of variant names ([30fa87ba](https://github.com/clap-rs/clap/commit/30fa87ba4e0f3189351d8f4f78b72e616a30d0bd), closes [#119](https://github.com/clap-rs/clap/issues/119))
  *  arg_enum! and simple_enum! auto-implement Display ([d1219f0d](https://github.com/clap-rs/clap/commit/d1219f0d1371d872061bd0718057eca4ef47b739), closes [#120](https://github.com/clap-rs/clap/issues/120))



## v0.8.4 (2015-05-12)


#### Bug Fixes

* **suggestions**  --help and --version now get suggestions ([d2b3b1fa](https://github.com/clap-rs/clap/commit/d2b3b1faa0bdc1c5d2350cc4635aba81e02e9d96), closes [#116](https://github.com/clap-rs/clap/issues/116))



## v0.8.3 (2015-05-10)


#### Bug Fixes

* **usage**  groups unfold their members in usage strings ([55d15582](https://github.com/clap-rs/clap/commit/55d155827ea4a6b077a83669701e797ce1ad68f4), closes [#114](https://github.com/clap-rs/clap/issues/114))

#### Performance

* **usage**  removes unneeded allocations ([fd53cd18](https://github.com/clap-rs/clap/commit/fd53cd188555f5c3dc8bc341c5d7eb04b761a70f))



## v0.8.2 (2015-05-08)


#### Bug Fixes

* **usage strings**  positional arguments are presented in index order ([eb0e374e](https://github.com/clap-rs/clap/commit/eb0e374ecf952f1eefbc73113f21e0705936e40b), closes [#112](https://github.com/clap-rs/clap/issues/112))



## v0.8.1 (2015-05-06)


#### Bug Fixes

* **subcommands**  stops parsing multiple values when subcommands are found ([fc79017e](https://github.com/clap-rs/clap/commit/fc79017eced04fd41cc1801331e5054df41fac17), closes [#109](https://github.com/clap-rs/clap/issues/109))

#### Improvements

* **color**  reduces color in error messages ([aab44cca](https://github.com/clap-rs/clap/commit/aab44cca6352f47e280c296e50c535f5d752dd46), closes [#110](https://github.com/clap-rs/clap/issues/110))
* **suggestions**  adds suggested arguments to usage strings ([99447414](https://github.com/clap-rs/clap/commit/994474146e9fb8b701af773a52da71553d74d4b7))



## v0.8.0 (2015-05-06)


#### Bug Fixes

* **did-you-mean**  for review ([0535cfb0](https://github.com/clap-rs/clap/commit/0535cfb0c711331568b4de8080eeef80bd254b68))
* **Positional**  positionals were ignored if they matched a subcmd, even after '--' ([90e7b081](https://github.com/clap-rs/clap/commit/90e7b0818741668b47cbe3becd029bab588e3553))
* **help**  fixes bug where space between arg and help is too long ([632fb115](https://github.com/clap-rs/clap/commit/632fb11514c504999ea86bdce47cdd34f8ebf646))

#### Features

* **from_usage**  adds ability to add value names or num of vals in usage string ([3d581976](https://github.com/clap-rs/clap/commit/3d58197674ed7886ca315efb76e411608a327501), closes [#98](https://github.com/clap-rs/clap/issues/98))
* **did-you-mean**
  *  gate it behind 'suggestions' ([c0e38351](https://github.com/clap-rs/clap/commit/c0e383515d01bdd5ca459af9c2f7e2cf49e2488b))
  *  for possible values ([1cc2deb2](https://github.com/clap-rs/clap/commit/1cc2deb29158e0e4e8b434e4ce26b3d819301a7d))
  *  for long flags (i.e. --long) ([52a0b850](https://github.com/clap-rs/clap/commit/52a0b8505c99354bdf5fd1cd256cf41197ac2d81))
  *  for subcommands ([06e869b5](https://github.com/clap-rs/clap/commit/06e869b5180258047ed3c60ba099de818dd25fff))
* **Flags**  adds suggestions functionality ([8745071c](https://github.com/clap-rs/clap/commit/8745071c3257dd327c497013516f12a823df9530))
* **errors**  colorizes output red on error ([f8b26b13](https://github.com/clap-rs/clap/commit/f8b26b13da82ba3ba9a932d3d1ab4ea45d1ab036))

#### Improvements

* **arg_enum**  allows ascii case insensitivity for enum variants ([b249f965](https://github.com/clap-rs/clap/commit/b249f9657c6921c004764bd80d13ebca81585eec), closes [#104](https://github.com/clap-rs/clap/issues/104))
* **clap-test**  simplified `make test` invocation ([d17dcb29](https://github.com/clap-rs/clap/commit/d17dcb2920637a1f58c61c596b7bd362fd53047c))

#### Documentation

* **README**  adds details about optional and new features ([960389de](https://github.com/clap-rs/clap/commit/960389de02c9872aaee9adabe86987f71f986e39))
* **clap**  fix typos caught by codespell ([8891d929](https://github.com/clap-rs/clap/commit/8891d92917aa1a069cca67272be41b99e548356e))
* **from_usage**  explains new usage strings with multiple values ([05476fc6](https://github.com/clap-rs/clap/commit/05476fc61cd1e5f4a4e750d258c878732a3a9c64))



## v0.7.6 (2015-05-05)


#### Improvements

* **Options**  adds number of values to options in help/usage ([c1c993c4](https://github.com/clap-rs/clap/commit/c1c993c419d18e35c443785053d8de9a2ef88073))

#### Features

* **from_usage**  adds ability to add value names or num of vals in usage string ([ad55748c](https://github.com/clap-rs/clap/commit/ad55748c265cf27935c7b210307d2040b6a09125), closes [#98](https://github.com/clap-rs/clap/issues/98))

#### Bug Fixes

* **MultipleValues**  properly distinguishes between multiple values and multiple occurrences ([dd2a7564](https://github.com/clap-rs/clap/commit/dd2a75640ca68a91b973faad15f04df891356cef), closes [#99](https://github.com/clap-rs/clap/issues/99))
* **help**  fixes tab alignment with multiple values ([847001ff](https://github.com/clap-rs/clap/commit/847001ff6d8f4d9518e810fefb8edf746dd0f31e))

#### Documentation

* **from_usage**  explains new usage strings with multiple values ([5a3a42df](https://github.com/clap-rs/clap/commit/5a3a42dfa3a783537f88dedc0fd5f0edcb8ea372))



## v0.7.5 (2015-05-04)


#### Bug Fixes

* **Options**  fixes bug where options with no value don't error out ([a1fb94be](https://github.com/clap-rs/clap/commit/a1fb94be53141572ffd97aad037295d4ffec82d0))



## v0.7.4 (2015-05-03)


#### Bug Fixes

* **Options**  fixes a bug where option arguments in succession get their values skipped ([f66334d0](https://github.com/clap-rs/clap/commit/f66334d0ce984e2b56e5c19abb1dd536fae9342a))



## v0.7.3 (2015-05-03)


#### Bug Fixes

* **RequiredValues**  fixes a bug where missing values are parsed as missing arguments ([93c4a723](https://github.com/clap-rs/clap/commit/93c4a7231ba1a08152648598f7aa4503ea82e4de))

#### Improvements

* **ErrorMessages**  improves error messages and corrections ([a29c3983](https://github.com/clap-rs/clap/commit/a29c3983c4229906655a29146ec15a0e46dd942d))
* **ArgGroups**  improves requirement and confliction support for groups ([c236dc5f](https://github.com/clap-rs/clap/commit/c236dc5ff475110d2a1b80e62903f80296163ad3))



## v0.7.2 (2015-05-03)


#### Bug Fixes

* **RequiredArgs**  fixes bug where required-by-default arguments are not listed in usage ([12aea961](https://github.com/clap-rs/clap/commit/12aea9612d290845ba86515c240aeeb0a21198db), closes [#96](https://github.com/clap-rs/clap/issues/96))



## v0.7.1 (2015-05-01)


#### Bug Fixes

* **MultipleValues**  stops evaluating values if the max or exact number of values was reached ([86d92c9f](https://github.com/clap-rs/clap/commit/86d92c9fdbf9f422442e9562977bbaf268dbbae1))



## v0.7.0 (2015-04-30) - BREAKING CHANGE


#### Bug Fixes

* **from_usage**  removes bug where usage strings have no help text ([ad4e5451](https://github.com/clap-rs/clap/commit/ad4e54510739aeabf75f0da3278fb0952db531b3), closes [#83](https://github.com/clap-rs/clap/issues/83))

#### Features

* **MultipleValues**
  *  add support for minimum and maximum number of values ([53f6b8c9](https://github.com/clap-rs/clap/commit/53f6b8c9d8dc408b4fa9f833fc3a63683873c42f))
  *  adds support limited number and named values ([ae09f05e](https://github.com/clap-rs/clap/commit/ae09f05e92251c1b39a83d372736fcc7b504e432))
  *  implement shorthand for options with multiple values ([6669f0a9](https://github.com/clap-rs/clap/commit/6669f0a9687d4f668523145d7bd5c007d1eb59a8))
* **arg**  allow other types besides Vec for multiple value settings (**BREAKING CHANGE** [0cc2f698](https://github.com/clap-rs/clap/commit/0cc2f69839b9b1db5d06330771b494783049a88e), closes [#87](https://github.com/clap-rs/clap/issues/87))
* **usage**  implement smart usage strings on errors ([d77048ef](https://github.com/clap-rs/clap/commit/d77048efb1e595ffe831f1a2bea2f2700db53b9f), closes [#88](https://github.com/clap-rs/clap/issues/88))



## v0.6.9 (2015-04-29)


#### Bug Fixes

* **from_usage**  removes bug where usage strings have no help text ([ad4e5451](https://github.com/clap-rs/clap/commit/ad4e54510739aeabf75f0da3278fb0952db531b3), closes [#83](https://github.com/clap-rs/clap/issues/83))



## 0.6.8 (2015-04-27)


#### Bug Fixes

* **help**  change long help --long=long -> --long <long> ([1e25abfc](https://github.com/clap-rs/clap/commit/1e25abfc36679ab89eae71bf98ced4de81992d00))
* **RequiredArgs**  required by default args should no longer be required when their exclusions are present ([4bb4c3cc](https://github.com/clap-rs/clap/commit/4bb4c3cc076b49e86720e882bf8c489877199f2d))

#### Features

* **ArgGroups**  add ability to create arg groups ([09eb4d98](https://github.com/clap-rs/clap/commit/09eb4d9893af40c347e50e2b717e1adef552357d))



## v0.6.7 (2015-04-22)


#### Bug Fixes

* **from_usage**  fix bug causing args to not be required ([b76129e9](https://github.com/clap-rs/clap/commit/b76129e9b71a63365d5c77a7f57b58dbd1e94d49))

#### Features

* **apps**  add ability to display additional help info after auto-gen'ed help msg ([65cc259e](https://github.com/clap-rs/clap/commit/65cc259e4559cbe3653c865ec0c4b1e42a389b07))



## v0.6.6 (2015-04-19)


#### Bug Fixes

* **from_usage**  tabs and spaces should be treated equally ([4fd44181](https://github.com/clap-rs/clap/commit/4fd44181d55d8eb88caab1e625231cfa3129e347))

#### Features

* **macros.rs**  add macro to get version from Cargo.toml ([c630969a](https://github.com/clap-rs/clap/commit/c630969aa3bbd386379219cae27ba1305b117f3e))



## v0.6.5 (2015-04-19)


#### Bug Fixes

* **macros.rs**  fix use statements for trait impls ([86e4075e](https://github.com/clap-rs/clap/commit/86e4075eb111937c8a7bdb344e866e350429f042))



## v0.6.4 (2015-04-17)


#### Features

* **macros**  add ability to create enums pub or priv with derives ([2c499f80](https://github.com/clap-rs/clap/commit/2c499f8015a199827cdf1fa3ec4f6f171722f8c7))



## v0.6.3 (2015-04-16)


#### Features

* **macros**  add macro to create custom enums to use as types ([fb672aff](https://github.com/clap-rs/clap/commit/fb672aff561c29db2e343d6c607138f141aca8b6))



## v0.6.2 (2015-04-14)


#### Features

* **macros**
  *  add ability to get multiple typed values or exit ([0b87251f](https://github.com/clap-rs/clap/commit/0b87251fc088234bee51c323c2b652d7254f7a59))
  *  add ability to get a typed multiple values ([e243fe38](https://github.com/clap-rs/clap/commit/e243fe38ddbbf845a46c0b9baebaac3778c80927))
  *  add convenience macro to get a typed value or exit ([4b7cd3ea](https://github.com/clap-rs/clap/commit/4b7cd3ea4947780d9daa39f3e1ddab53ad4c7fef))
  *  add convenience macro to get a typed value ([8752700f](https://github.com/clap-rs/clap/commit/8752700fbb30e89ee68adbce24489ae9a24d33a9))



## v0.6.1 (2015-04-13)


#### Bug Fixes

* **from_usage**  trim all whitespace before parsing ([91d29045](https://github.com/clap-rs/clap/commit/91d2904599bd602deef2e515dfc65dc2863bdea0))



## v0.6.0 (2015-04-13)


#### Bug Fixes

* **tests**  fix failing doc tests ([3710cd69](https://github.com/clap-rs/clap/commit/3710cd69162f87221a62464f63437c1ce843ad3c))

#### Features

* **app**  add support for building args from usage strings ([d5d48bcf](https://github.com/clap-rs/clap/commit/d5d48bcf463a4e494ef758836bd69a4c220bbbb5))
* **args**  add ability to create basic arguments from a usage string ([ab409a8f](https://github.com/clap-rs/clap/commit/ab409a8f1db9e37cc70200f6f4a84a162692e618))



## v0.5.14 (2015-04-10)


#### Bug Fixes

* **usage**
  *  remove unneeded space ([51372789](https://github.com/clap-rs/clap/commit/5137278942121bc2593ce6e5dc224ec2682549e6))
  *  remove warning about unused variables ([ba817b9d](https://github.com/clap-rs/clap/commit/ba817b9d815e37320650973f1bea0e7af3030fd7))

#### Features

* **usage**  add ability to get usage string for subcommands too ([3636afc4](https://github.com/clap-rs/clap/commit/3636afc401c2caa966efb5b1869ef4f1ed3384aa))



## v0.5.13 (2015-04-09)


#### Features

* **SubCommands**  add method to get name and subcommand matches together ([64e53928](https://github.com/clap-rs/clap/commit/64e539280e23e567cf5de393b346eb0ca20e7eb5))
* **ArgMatches**  add method to get default usage string ([02462150](https://github.com/clap-rs/clap/commit/02462150ca750bdc7012627d7e8d96379d494d7f))



## v0.5.12 (2015-04-08)


#### Features

* **help**  sort arguments by name so as to not display a random order ([f4b2bf57](https://github.com/clap-rs/clap/commit/f4b2bf5767386013069fb74862e6e938dacf44d2))



## v0.5.11 (2015-04-08)


#### Bug Fixes

* **flags**  fix bug not allowing users to specify -v or -h ([90e72cff](https://github.com/clap-rs/clap/commit/90e72cffdee321b79eea7a2207119533540062b4))



## v0.5.10 (2015-04-08)


#### Bug Fixes

* **help**  fix spacing when option argument has not long version ([ca17fa49](https://github.com/clap-rs/clap/commit/ca17fa494b68e92da83ee364bf64b0687006824b))



## v0.5.9 (2015-04-08)


#### Bug Fixes

* **positional args**  all previous positional args become required when a latter one is required ([c14c3f31](https://github.com/clap-rs/clap/commit/c14c3f31fd557c165570b60911d8ee483d89d6eb), closes [#50](https://github.com/clap-rs/clap/issues/50))
* **clap**  remove unstable features for Rust 1.0 ([9abdb438](https://github.com/clap-rs/clap/commit/9abdb438e36e364d41550e7f5d44ebcaa8ee6b10))
* **args**  improve error messages for arguments with mutual exclusions ([18dbcf37](https://github.com/clap-rs/clap/commit/18dbcf37024daf2b76ca099a6f118b53827aa339), closes [#51](https://github.com/clap-rs/clap/issues/51))



## v0.5.8 (2015-04-08)


#### Bug Fixes

* **option args**  fix bug in getting the wrong number of occurrences for options ([82ad6ad7](https://github.com/clap-rs/clap/commit/82ad6ad77539cf9f9a03b78db466f575ebd972cc))
* **help**  fix formatting for option arguments with no long ([e8691004](https://github.com/clap-rs/clap/commit/e869100423d93fa3acff03c4620cbcc0d0e790a1))
* **flags**  add assertion to catch flags with specific value sets ([a0a2a40f](https://github.com/clap-rs/clap/commit/a0a2a40fed57f7c5ad9d68970d090e9856306c7d), closes [#52](https://github.com/clap-rs/clap/issues/52))
* **args**  improve error messages for arguments with mutual exclusions ([bff945fc](https://github.com/clap-rs/clap/commit/bff945fc5d03bba4266533340adcffb002508d1b), closes [#51](https://github.com/clap-rs/clap/issues/51))
* **tests**  add missing .takes_value(true) to option2 ([bdb0e88f](https://github.com/clap-rs/clap/commit/bdb0e88f696c8595c3def3bfb0e52d538c7be085))
* **positional args**  all previous positional args become required when a latter one is required ([343d47dc](https://github.com/clap-rs/clap/commit/343d47dcbf83786a45c0d0f01b27fd9dd76725de), closes [#50](https://github.com/clap-rs/clap/issues/50))



## v0.5.7 (2015-04-08)


#### Bug Fixes

* **args**  fix bug in arguments who are required and mutually exclusive ([6ceb88a5](https://github.com/clap-rs/clap/commit/6ceb88a594caae825605abc1cdad95204996bf29))



## v0.5.6 (2015-04-08)


#### Bug Fixes

* **help**  fix formatting of help and usage ([28691b52](https://github.com/clap-rs/clap/commit/28691b52f67e65c599e10e4ea2a0f6f9765a06b8))



## v0.5.5 (2015-04-08)


#### Bug Fixes

* **help**  fix formatting of help for flags and options ([6ec10115](https://github.com/clap-rs/clap/commit/6ec1011563a746f0578a93b76d45e63878e0f9a8))



## v0.5.4 (2015-04-08)


#### Features

* **help**  add '...' to indicate multiple values supported ([297ddba7](https://github.com/clap-rs/clap/commit/297ddba77000e2228762ab0eca50b480f7467386))



## v0.5.3 (2015-04-08)


#### Features

* **positionals**
  *  add assertions for positional args with multiple vals ([b7fa72d4](https://github.com/clap-rs/clap/commit/b7fa72d40f18806ec2042dd67a518401c2cf5681))
  *  add support for multiple values ([80784009](https://github.com/clap-rs/clap/commit/807840094109fbf90b348039ae22669ef27889ba))



## v0.5.2 (2015-04-08)


#### Bug Fixes

* **apps**  allow use of hyphens in application and subcommand names ([da549dcb](https://github.com/clap-rs/clap/commit/da549dcb6c7e0d773044ab17829744483a8b0f7f))



## v0.5.1 (2015-04-08)


#### Bug Fixes

* **args**  determine if the only arguments allowed are also required ([0a09eb36](https://github.com/clap-rs/clap/commit/0a09eb365ced9a03faf8ed24f083ef730acc90e8))



## v0.5.0 (2015-04-08)


#### Features

* **args**  add support for a specific set of allowed values on options or positional arguments ([270eb889](https://github.com/clap-rs/clap/commit/270eb88925b6dc2881bff1f31ee344f085d31809))



## v0.4.18 (2015-04-08)


#### Bug Fixes

* **usage**  display required args in usage, even if only required by others ([1b7316d4](https://github.com/clap-rs/clap/commit/1b7316d4a8df70b0aa584ccbfd33f68966ad2a54))

#### Features

* **subcommands**  properly list subcommands in help and usage ([4ee02344](https://github.com/clap-rs/clap/commit/4ee023442abc3dba54b68138006a52b714adf331))



## v0.4.17 (2015-04-08)


#### Bug Fixes

* **tests**  remove cargo test from claptests makefile ([1cf73817](https://github.com/clap-rs/clap/commit/1cf73817d6fb1dccb5b6a23b46c2efa8b567ad62))



## v0.4.16 (2015-04-08)


#### Bug Fixes

* **option**  fix bug with option occurrence values ([9af52e93](https://github.com/clap-rs/clap/commit/9af52e93cef9e17ac9974963f132013d0b97b946))
* **tests**  fix testing script bug and formatting ([d8f03a55](https://github.com/clap-rs/clap/commit/d8f03a55c4f74d126710ee06aad5a667246a8001))

#### Features

* **arg**  allow lifetimes other than 'static in arguments ([9e8c1fb9](https://github.com/clap-rs/clap/commit/9e8c1fb9406f8448873ca58bab07fe905f1551e5))

<!-- next-url -->
[Unreleased]: https://github.com/clap-rs/clap/compare/v4.5.36...HEAD
[4.5.36]: https://github.com/clap-rs/clap/compare/v4.5.35...v4.5.36
[4.5.35]: https://github.com/clap-rs/clap/compare/v4.5.34...v4.5.35
[4.5.34]: https://github.com/clap-rs/clap/compare/v4.5.33...v4.5.34
[4.5.33]: https://github.com/clap-rs/clap/compare/v4.5.32...v4.5.33
[4.5.32]: https://github.com/clap-rs/clap/compare/v4.5.31...v4.5.32
[4.5.31]: https://github.com/clap-rs/clap/compare/v4.5.30...v4.5.31
[4.5.30]: https://github.com/clap-rs/clap/compare/v4.5.29...v4.5.30
[4.5.29]: https://github.com/clap-rs/clap/compare/v4.5.28...v4.5.29
[4.5.28]: https://github.com/clap-rs/clap/compare/v4.5.27...v4.5.28
[4.5.27]: https://github.com/clap-rs/clap/compare/v4.5.26...v4.5.27
[4.5.26]: https://github.com/clap-rs/clap/compare/v4.5.25...v4.5.26
[4.5.25]: https://github.com/clap-rs/clap/compare/v4.5.24...v4.5.25
[4.5.24]: https://github.com/clap-rs/clap/compare/v4.5.23...v4.5.24
[4.5.23]: https://github.com/clap-rs/clap/compare/v4.5.22...v4.5.23
[4.5.22]: https://github.com/clap-rs/clap/compare/v4.5.21...v4.5.22
[4.5.21]: https://github.com/clap-rs/clap/compare/v4.5.20...v4.5.21
[4.5.20]: https://github.com/clap-rs/clap/compare/v4.5.19...v4.5.20
[4.5.19]: https://github.com/clap-rs/clap/compare/v4.5.18...v4.5.19
[4.5.18]: https://github.com/clap-rs/clap/compare/v4.5.17...v4.5.18
[4.5.17]: https://github.com/clap-rs/clap/compare/v4.5.16...v4.5.17
[4.5.16]: https://github.com/clap-rs/clap/compare/v4.5.15...v4.5.16
[4.5.15]: https://github.com/clap-rs/clap/compare/v4.5.14...v4.5.15
[4.5.14]: https://github.com/clap-rs/clap/compare/v4.5.13...v4.5.14
[4.5.13]: https://github.com/clap-rs/clap/compare/v4.5.12...v4.5.13
[4.5.12]: https://github.com/clap-rs/clap/compare/v4.5.11...v4.5.12
[4.5.11]: https://github.com/clap-rs/clap/compare/v4.5.10...v4.5.11
[4.5.10]: https://github.com/clap-rs/clap/compare/v4.5.9...v4.5.10
[4.5.9]: https://github.com/clap-rs/clap/compare/v4.5.8...v4.5.9
[4.5.8]: https://github.com/clap-rs/clap/compare/v4.5.7...v4.5.8
[4.5.7]: https://github.com/clap-rs/clap/compare/v4.5.6...v4.5.7
[4.5.6]: https://github.com/clap-rs/clap/compare/v4.5.5...v4.5.6
[4.5.5]: https://github.com/clap-rs/clap/compare/v4.5.4...v4.5.5
[4.5.4]: https://github.com/clap-rs/clap/compare/v4.5.3...v4.5.4
[4.5.3]: https://github.com/clap-rs/clap/compare/v4.5.2...v4.5.3
[4.5.2]: https://github.com/clap-rs/clap/compare/v4.5.1...v4.5.2
[4.5.1]: https://github.com/clap-rs/clap/compare/v4.5.0...v4.5.1
[4.5.0]: https://github.com/clap-rs/clap/compare/v4.4.18...v4.5.0
[4.4.18]: https://github.com/clap-rs/clap/compare/v4.4.17...v4.4.18
[4.4.17]: https://github.com/clap-rs/clap/compare/v4.4.16...v4.4.17
[4.4.16]: https://github.com/clap-rs/clap/compare/v4.4.15...v4.4.16
[4.4.15]: https://github.com/clap-rs/clap/compare/v4.4.14...v4.4.15
[4.4.14]: https://github.com/clap-rs/clap/compare/v4.4.13...v4.4.14
[4.4.13]: https://github.com/clap-rs/clap/compare/v4.4.12...v4.4.13
[4.4.12]: https://github.com/clap-rs/clap/compare/v4.4.11...v4.4.12
[4.4.11]: https://github.com/clap-rs/clap/compare/v4.4.10...v4.4.11
[4.4.10]: https://github.com/clap-rs/clap/compare/v4.4.9...v4.4.10
[4.4.9]: https://github.com/clap-rs/clap/compare/v4.4.8...v4.4.9
[4.4.8]: https://github.com/clap-rs/clap/compare/v4.4.7...v4.4.8
[4.4.7]: https://github.com/clap-rs/clap/compare/v4.4.6...v4.4.7
[4.4.6]: https://github.com/clap-rs/clap/compare/v4.4.5...v4.4.6
[4.4.5]: https://github.com/clap-rs/clap/compare/v4.4.4...v4.4.5
[4.4.4]: https://github.com/clap-rs/clap/compare/v4.4.3...v4.4.4
[4.4.3]: https://github.com/clap-rs/clap/compare/v4.4.2...v4.4.3
[4.4.2]: https://github.com/clap-rs/clap/compare/v4.4.1...v4.4.2
[4.4.1]: https://github.com/clap-rs/clap/compare/v4.4.0...v4.4.1
[4.4.0]: https://github.com/clap-rs/clap/compare/v4.3.24...v4.4.0
[4.3.24]: https://github.com/clap-rs/clap/compare/v4.3.23...v4.3.24
[4.3.23]: https://github.com/clap-rs/clap/compare/v4.3.22...v4.3.23
[4.3.22]: https://github.com/clap-rs/clap/compare/v4.3.21...v4.3.22
[4.3.21]: https://github.com/clap-rs/clap/compare/v4.3.20...v4.3.21
[4.3.20]: https://github.com/clap-rs/clap/compare/v4.3.19...v4.3.20
[4.3.19]: https://github.com/clap-rs/clap/compare/v4.3.18...v4.3.19
[4.3.18]: https://github.com/clap-rs/clap/compare/v4.3.17...v4.3.18
[4.3.17]: https://github.com/clap-rs/clap/compare/v4.3.16...v4.3.17
[4.3.16]: https://github.com/clap-rs/clap/compare/v4.3.15...v4.3.16
[4.3.15]: https://github.com/clap-rs/clap/compare/v4.3.14...v4.3.15
[4.3.14]: https://github.com/clap-rs/clap/compare/v4.3.13...v4.3.14
[4.3.13]: https://github.com/clap-rs/clap/compare/v4.3.12...v4.3.13
[4.3.12]: https://github.com/clap-rs/clap/compare/v4.3.11...v4.3.12
[4.3.11]: https://github.com/clap-rs/clap/compare/v4.3.10...v4.3.11
[4.3.10]: https://github.com/clap-rs/clap/compare/v4.3.9...v4.3.10
[4.3.9]: https://github.com/clap-rs/clap/compare/v4.3.8...v4.3.9
[4.3.8]: https://github.com/clap-rs/clap/compare/v4.3.7...v4.3.8
[4.3.7]: https://github.com/clap-rs/clap/compare/v4.3.6...v4.3.7
[4.3.6]: https://github.com/clap-rs/clap/compare/v4.3.5...v4.3.6
[4.3.5]: https://github.com/clap-rs/clap/compare/v4.3.4...v4.3.5
[4.3.4]: https://github.com/clap-rs/clap/compare/v4.3.3...v4.3.4
[4.3.3]: https://github.com/clap-rs/clap/compare/v4.3.2...v4.3.3
[4.3.2]: https://github.com/clap-rs/clap/compare/v4.3.1...v4.3.2
[4.3.1]: https://github.com/clap-rs/clap/compare/v4.3.0...v4.3.1
[4.3.0]: https://github.com/clap-rs/clap/compare/v4.2.7...v4.3.0
[4.2.7]: https://github.com/clap-rs/clap/compare/v4.2.6...v4.2.7
[4.2.6]: https://github.com/clap-rs/clap/compare/v4.2.5...v4.2.6
[4.2.5]: https://github.com/clap-rs/clap/compare/v4.2.4...v4.2.5
[4.2.4]: https://github.com/clap-rs/clap/compare/v4.2.3...v4.2.4
[4.2.3]: https://github.com/clap-rs/clap/compare/v4.2.2...v4.2.3
[4.2.2]: https://github.com/clap-rs/clap/compare/v4.2.1...v4.2.2
[4.2.1]: https://github.com/clap-rs/clap/compare/v4.2.0...v4.2.1
[4.2.0]: https://github.com/clap-rs/clap/compare/v4.1.14...v4.2.0
[4.1.14]: https://github.com/clap-rs/clap/compare/v4.1.13...v4.1.14
[4.1.13]: https://github.com/clap-rs/clap/compare/v4.1.12...v4.1.13
[4.1.12]: https://github.com/clap-rs/clap/compare/v4.1.11...v4.1.12
[4.1.11]: https://github.com/clap-rs/clap/compare/v4.1.10...v4.1.11
[4.1.10]: https://github.com/clap-rs/clap/compare/v4.1.9...v4.1.10
[4.1.9]: https://github.com/clap-rs/clap/compare/v4.1.8...v4.1.9
[4.1.8]: https://github.com/clap-rs/clap/compare/v4.1.7...v4.1.8
[4.1.7]: https://github.com/clap-rs/clap/compare/v4.1.6...v4.1.7
[4.1.6]: https://github.com/clap-rs/clap/compare/v4.1.5...v4.1.6
[4.1.5]: https://github.com/clap-rs/clap/compare/v4.1.4...v4.1.5
[4.1.4]: https://github.com/clap-rs/clap/compare/v4.1.3...v4.1.4
[4.1.3]: https://github.com/clap-rs/clap/compare/v4.1.2...v4.1.3
[4.1.2]: https://github.com/clap-rs/clap/compare/v4.1.1...v4.1.2
[4.1.1]: https://github.com/clap-rs/clap/compare/v4.1.0...v4.1.1
[4.1.0]: https://github.com/clap-rs/clap/compare/v4.0.32...v4.1.0
[4.0.32]: https://github.com/clap-rs/clap/compare/v4.0.31...v4.0.32
[4.0.31]: https://github.com/clap-rs/clap/compare/v4.0.30...v4.0.31
[4.0.30]: https://github.com/clap-rs/clap/compare/v4.0.29...v4.0.30
[4.0.29]: https://github.com/clap-rs/clap/compare/v4.0.28...v4.0.29
[4.0.28]: https://github.com/clap-rs/clap/compare/v4.0.27...v4.0.28
[4.0.27]: https://github.com/clap-rs/clap/compare/v4.0.26...v4.0.27
[4.0.26]: https://github.com/clap-rs/clap/compare/v4.0.25...v4.0.26
[4.0.25]: https://github.com/clap-rs/clap/compare/v4.0.24...v4.0.25
[4.0.24]: https://github.com/clap-rs/clap/compare/v4.0.23...v4.0.24
[4.0.23]: https://github.com/clap-rs/clap/compare/v4.0.22...v4.0.23
[4.0.22]: https://github.com/clap-rs/clap/compare/v4.0.21...v4.0.22
[4.0.21]: https://github.com/clap-rs/clap/compare/v4.0.20...v4.0.21
[4.0.20]: https://github.com/clap-rs/clap/compare/v4.0.19...v4.0.20
[4.0.19]: https://github.com/clap-rs/clap/compare/v4.0.18...v4.0.19
[4.0.18]: https://github.com/clap-rs/clap/compare/v4.0.17...v4.0.18
[4.0.17]: https://github.com/clap-rs/clap/compare/v4.0.16...v4.0.17
[4.0.16]: https://github.com/clap-rs/clap/compare/v4.0.15...v4.0.16
[4.0.15]: https://github.com/clap-rs/clap/compare/v4.0.14...v4.0.15
[4.0.14]: https://github.com/clap-rs/clap/compare/v4.0.13...v4.0.14
[4.0.13]: https://github.com/clap-rs/clap/compare/v4.0.12...v4.0.13
[4.0.12]: https://github.com/clap-rs/clap/compare/v4.0.11...v4.0.12
[4.0.11]: https://github.com/clap-rs/clap/compare/v4.0.10...v4.0.11
[4.0.10]: https://github.com/clap-rs/clap/compare/v4.0.9...v4.0.10
[4.0.9]: https://github.com/clap-rs/clap/compare/v4.0.8...v4.0.9
[4.0.8]: https://github.com/clap-rs/clap/compare/v4.0.7...v4.0.8
[4.0.7]: https://github.com/clap-rs/clap/compare/v4.0.6...v4.0.7
[4.0.6]: https://github.com/clap-rs/clap/compare/v4.0.5...v4.0.6
[4.0.5]: https://github.com/clap-rs/clap/compare/v4.0.4...v4.0.5
[4.0.4]: https://github.com/clap-rs/clap/compare/v4.0.3...v4.0.4
[4.0.3]: https://github.com/clap-rs/clap/compare/v4.0.2...v4.0.3
[4.0.2]: https://github.com/clap-rs/clap/compare/v4.0.1...v4.0.2
[4.0.1]: https://github.com/clap-rs/clap/compare/v4.0.0...v4.0.1
[4.0.0]: https://github.com/clap-rs/clap/compare/v3.2.18...v4.0.0
[3.2.18]: https://github.com/clap-rs/clap/compare/v3.2.17...v3.2.18
[3.2.17]: https://github.com/clap-rs/clap/compare/v3.2.16...v3.2.17
[3.2.16]: https://github.com/clap-rs/clap/compare/v3.2.15...v3.2.16
[3.2.15]: https://github.com/clap-rs/clap/compare/v3.2.14...v3.2.15
[3.2.14]: https://github.com/clap-rs/clap/compare/v3.2.13...v3.2.14
[3.2.13]: https://github.com/clap-rs/clap/compare/v3.2.12...v3.2.13
[3.2.12]: https://github.com/clap-rs/clap/compare/v3.2.11...v3.2.12
[3.2.11]: https://github.com/clap-rs/clap/compare/v3.2.10...v3.2.11
[3.2.10]: https://github.com/clap-rs/clap/compare/v3.2.8...v3.2.10
[3.2.8]: https://github.com/clap-rs/clap/compare/v3.2.7...v3.2.8
[3.2.7]: https://github.com/clap-rs/clap/compare/v3.2.6...v3.2.7
[3.2.6]: https://github.com/clap-rs/clap/compare/v3.2.5...v3.2.6
[3.2.5]: https://github.com/clap-rs/clap/compare/v3.2.4...v3.2.5
[3.2.4]: https://github.com/clap-rs/clap/compare/v3.2.3...v3.2.4
[3.2.3]: https://github.com/clap-rs/clap/compare/v3.2.2...v3.2.3
[3.2.2]: https://github.com/clap-rs/clap/compare/v3.2.1...v3.2.2
[3.2.1]: https://github.com/clap-rs/clap/compare/v3.2.0...v3.2.1
[3.2.0]: https://github.com/clap-rs/clap/compare/v3.1.18...v3.2.0
[3.1.18]: https://github.com/clap-rs/clap/compare/v3.1.17...v3.1.18
[3.1.17]: https://github.com/clap-rs/clap/compare/v3.1.16...v3.1.17
[3.1.16]: https://github.com/clap-rs/clap/compare/v3.1.15...v3.1.16
[3.1.15]: https://github.com/clap-rs/clap/compare/v3.1.14...v3.1.15
[3.1.14]: https://github.com/clap-rs/clap/compare/v3.1.13...v3.1.14
[3.1.13]: https://github.com/clap-rs/clap/compare/v3.1.12...v3.1.13
[3.1.12]: https://github.com/clap-rs/clap/compare/v3.1.11...v3.1.12
[3.1.11]: https://github.com/clap-rs/clap/compare/v3.1.10...v3.1.11
[3.1.10]: https://github.com/clap-rs/clap/compare/v3.1.9...v3.1.10
[3.1.9]: https://github.com/clap-rs/clap/compare/v3.1.8...v3.1.9
[3.1.8]: https://github.com/clap-rs/clap/compare/v3.1.7...v3.1.8
[3.1.7]: https://github.com/clap-rs/clap/compare/v3.1.6...v3.1.7
[3.1.6]: https://github.com/clap-rs/clap/compare/v3.1.5...v3.1.6
[3.1.5]: https://github.com/clap-rs/clap/compare/v3.1.4...v3.1.5
[3.1.4]: https://github.com/clap-rs/clap/compare/v3.1.3...v3.1.4
[3.1.3]: https://github.com/clap-rs/clap/compare/v3.1.2...v3.1.3
[3.1.2]: https://github.com/clap-rs/clap/compare/v3.1.1...v3.1.2
[3.1.1]: https://github.com/clap-rs/clap/compare/v3.1.0...v3.1.1
[3.1.0]: https://github.com/clap-rs/clap/compare/v3.0.14...v3.1.0
[3.0.14]: https://github.com/clap-rs/clap/compare/v3.0.13...v3.0.14
[3.0.13]: https://github.com/clap-rs/clap/compare/v3.0.12...v3.0.13
[3.0.12]: https://github.com/clap-rs/clap/compare/v3.0.11...v3.0.12
[3.0.11]: https://github.com/clap-rs/clap/compare/v3.0.10...v3.0.11
[3.0.10]: https://github.com/clap-rs/clap/compare/v3.0.9...v3.0.10
[3.0.9]: https://github.com/clap-rs/clap/compare/v3.0.8...v3.0.9
[3.0.8]: https://github.com/clap-rs/clap/compare/v3.0.7...v3.0.8
[3.0.7]: https://github.com/clap-rs/clap/compare/v3.0.6...v3.0.7
[3.0.6]: https://github.com/clap-rs/clap/compare/v3.0.5...v3.0.6
[3.0.5]: https://github.com/clap-rs/clap/compare/v3.0.4...v3.0.5
[3.0.4]: https://github.com/clap-rs/clap/compare/v3.0.3...v3.0.4
[3.0.3]: https://github.com/clap-rs/clap/compare/v3.0.2...v3.0.3
[3.0.2]: https://github.com/clap-rs/clap/compare/v3.0.1...v3.0.2
[3.0.1]: https://github.com/clap-rs/clap/compare/v3.0.0...v3.0.1
[3.0.0]: https://github.com/clap-rs/clap/compare/v2.34.0...v3.0.0
[2.34.0]: https://github.com/clap-rs/clap/compare/v2.33.4...v2.34.0
[2.33.4]: https://github.com/clap-rs/clap/compare/v2.33.3...v2.33.4
[2.33.3]: https://github.com/clap-rs/clap/compare/v2.33.2...v2.33.3
[2.33.2]: https://github.com/clap-rs/clap/compare/v2.33.1...v2.33.2
[2.33.1]: https://github.com/clap-rs/clap/compare/v2.33.0...v2.33.1
[2.33.0]: https://github.com/clap-rs/clap/compare/v2.32.0...v2.33.0

```

`clap/CITATION.cff`:

```cff
# Parser settings.
cff-version: 1.2.0
message: Please cite this crate using these information.

# Version information.
date-released: 2025-04-11
version: 4.5.36

# Project information.
abstract: A full featured, fast Command Line Argument Parser for Rust
authors:
  - alias: kbknapp
    family-names: Knapp
    given-names: Kevin B.
  - name: The Clap Community
license:
  - Apache-2.0
  - MIT
repository-artifact: https://crates.io/crates/clap
repository-code: https://github.com/clap-rs/clap
title: clap
url: https://docs.rs/clap

```

`clap/CONTRIBUTING.md`:

```md
# How to Contribute

Contributions are always welcome! And there is a multitude of ways in which you can help depending on what you like to do, or are good at. Anything from documentation, code cleanup, issue completion, new features, you name it, even filing issues is contributing and greatly appreciated!

## Goals

There are a few goals of `clap` that I'd like to maintain throughout contributions. If your proposed changes break, or go against any of these goals we'll discuss the changes further before merging (but will *not* be ignored, all contributes are welcome!). These are by no means hard-and-fast rules, as I'm no expert and break them myself from time to time (even if by mistake or ignorance :P).

* Remain backwards compatible when possible
  - If backwards compatibility *must* be broken, use deprecation warnings if at all possible before removing legacy code
  - This does not apply for security concerns
* Parse arguments quickly
  - Parsing of arguments shouldn't slow down usage of the main program
  - This is also true of generating help and usage information (although *slightly* less stringent, as the program is about to exit)
* Try to be cognizant of memory usage
  - Once parsing is complete, the memory footprint of `clap` should be low since the main program is the star of the show
* `panic!` on *developer* error
  (e.g. [apps](https://github.com/clap-rs/clap/blob/62eff1f8d3394cef819b4aa7b23a1032fc584f03/src/build/app/debug_asserts.rs) and [args](https://github.com/clap-rs/clap/blob/62eff1f8d3394cef819b4aa7b23a1032fc584f03/src/build/arg/debug_asserts.rs)),
  exit gracefully on *end-user* error

## General Overview

### Where to Start

- [Discussions](https://github.com/clap-rs/clap/discussions) can be useful for getting help and brainstorming
- [Issues](https://github.com/clap-rs/clap/issues) work well discussing a need and how to solve it
  - Focus: requirements gathering and design discussions
  - Sometimes a branch or Draft PR might be used to demonstrate an idea
- [PRs](https://github.com/clap-rs/clap/pulls) work well for when the solution has already been discussed as an Issue or there is little to no discussion (obvious bug or documentation fixes)
  - Focus: implementation discussions

### Compatibility Expectations

Our releases fall into one of:
- Major releases which are reserved for breaking changes
  - Aspire to at least 6-9 months between releases
  - Remove all deprecated functionality
  - Changes in help/error output that could cause glaring inconsistencies in end-user applications
  - Try to minimize new breaking changes to ease user transition and reduce time "we go dark" (unreleased feature-branch)
  - Upon release, a minor release will be made for the previous major that enables `deprecated` feature by default
- Minor releases which are for minor compatibility changes
  - Aspire to at least 2 months between releases
  - Changes to MSRV
  - Wide-spread help/error output changes that would cause minor inconsistencies in end-user applications
  - Deprecating existing functionality (behind the `deprecated` feature flag)
  - Making the `deprecated` feature flag enabled-by-default (only on last planned minor release)
  - `#[doc(hidden)]` all deprecated items in the prior minor release
- Patch releases
  - One for every user-facing, user-contributed PR (i.e. release early, release often)
  - Changes in help/error output that are one-off or improving consistency so as to not increase inconsistency with end-user applications

If your change does not fit within a "patch" release, please coordinate with the clap maintainers for how to handle the situation.

Some practices to avoid breaking changes
- Duplicate functionality, with old functionality marked as "deprecated"
  - Common documentation pattern: `/// Deprecated in [Issue #XXX](https://github.com/clap-rs/clap/issues/XXX), replaced with [intra-doc-link]`
  - Common deprecation pattern: `#[cfg_attr(feature = "deprecated", deprecated(since = "X.Y.Z", note = "Replaced with `ITEM` in Issue #XXX"))]`
    - `deprecated` feature flag is to allow people to process them on their
      time table and allow us to process feedback from early adopters before
      requiring everyone to process them on the next major version.
  - Please keep API addition and deprecation in separate commits in a PR to make it easier to review
- Develop the feature behind an `unstable-<name>` feature flag with a stabilization tracking issue (e.g. [Multicall Tracking issue](https://github.com/clap-rs/clap/issues/2861))

### Version Support Policy

As we work towards [a more flexible architecture](https://github.com/clap-rs/clap/discussions/3476), we hope to support multiple major versions to help ease users through the upgrade churn.

| Version                                              | Status        | Support | End-of-Life |
|------------------------------------------------------|---------------|---------|-------------|
| [v4](https://github.com/clap-rs/clap/tree/master)    | active        | Features and bug fixes target `master` by default | TBD |
| [v3](https://github.com/clap-rs/clap/tree/v3-master) | maintenance   | Accepting trivial cherry-picks from `master` (i.e. minimal conflict resolution) by contributors and fixes for ecosystem-wide showstoppers | TBD |
| [v2](https://github.com/clap-rs/clap/tree/v2-master) | deprecated    | Only accepting fixes for ecosystem-wide showstoppers | TBD |
| v1                                                   | unsupported   | \- | \- |

Note: We have not yet determined the End-of-Life schedule for previous major versions.  We will give at least a 2 month warning before changing the support status.

### Verifying Changes

A common (sub)set of commands for verifying your change:
```console
$ make test-full
$ make clippy-full
$ make doc
```
*(If `make` is not available on your system, you can look up what these expand to in the [Makefile](./Makefile))*

Check out the [Makefile](./Makefile) for more commands run by CI.

### Debugging Clap

A helpful technique is to see the `clap` debug output while developing features. In order to see the debug output while running the full test suite or individual tests, run:

```console
$ cargo test --features debug

# Or for individual tests
$ cargo test --test <test_name> --features debug
```

### Preparing the PR

As a heads up, we'll be running your PR through the following gauntlet:
- warnings turned to compile errors
- `cargo test`
- `rustfmt`
- `clippy`
- `rustdoc`
- [`committed`](https://github.com/crate-ci/committed) as we use [Conventional](https://www.conventionalcommits.org) commit style
- [`typos`](https://github.com/crate-ci/typos) to check spelling

Not everything can be checked automatically though.

We request that the commit history gets cleaned up.
We ask that commits are atomic, meaning they are complete and have a single responsibility.
PRs should tell a cohesive story, with test and refactor commits that keep the
fix or feature commits simple and clear.

Specifically, we would encourage
- File renames be isolated into their own commit
- Add tests in a commit before their feature or fix, showing the current behavior.
  The diff for the feature/fix commit will then show how the behavior changed,
  making it clearer to reviewers and the community and showing people that the
  test is verifying the expected state.
  - e.g. [clap#5520](https://github.com/clap-rs/clap/pull/5520)

Note that we are talking about ideals.
We understand having a clean history requires more advanced git skills;
feel free to ask us for help!
We might even suggest where it would work to be lax.
We also understand that editing some early commits may cause a lot of churn
with merge conflicts which can make it not worth editing all of the history.

For code organization, we recommend
- Grouping `impl` blocks next to their type (or trait)
- Grouping private items after the `pub` item that uses them.
  - The intent is to help people quickly find the "relevant" details, allowing them to "dig deeper" as needed.  Or put another way, the `pub` items serve as a table-of-contents.
  - The exact order is fuzzy; do what makes sense

## Conditions for fulfilling a bounty:

1. You should make a pull request which fixes the issue the bounty was promised for
2. The pull request should be merged by one of the maintainers

### Below are the steps to redeem a bounty:

1. Go to https://opencollective.com/clap/expenses/new.
2. Select **Invoice**.
3. Enter **Expense Title** as "Issue Bounty".
4. In **Description**, link the issue you are redeeming _(Ex: `https://github.com/clap-rs/clap/issues/1464`)_
5. In **Amount**, write the amount that the issue promised _(Ex: 10)_
6. Fill payment information and submit
7. Wait for us to approve it

### Can I forgo the bounty?

Yes, you can. In that case, you don't have to do anything except writing a
comment on the issue saying that I do. The bounty will be reassigned to another
issue.

## Specific Tasks

### Section-specific CONTRIBUTING

- [Example CONTRIBUTING](./examples/README.md#contributing)
- [Tutorial (builder) CONTRIBUTING](./examples/tutorial_builder/README.md#contributing)
- [Tutorial (derive) CONTRIBUTING](./examples/tutorial_derive/README.md#contributing)
- [clap_derive CONTRIBUTING](./clap_derive/CONTRIBUTING.md)

### Updating MSRV

Search for `MSRV`, for example
```bash
$ rg --hidden MSRV
```
And update all of the references

```

`clap/Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "addr2line"
version = "0.22.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e4503c46a5c0c7844e948c9a4d6acd9f50cccb4de1c48eb9e291ea17470c678"
dependencies = [
 "gimli",
]

[[package]]
name = "adler"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe"

[[package]]
name = "ahash"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011"
dependencies = [
 "cfg-if",
 "once_cell",
 "version_check",
 "zerocopy",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "allocator-api2"
version = "0.2.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f"

[[package]]
name = "alphanumeric-sort"
version = "1.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d67c60c5f10f11c6ee04de72b2dd98bb9d2548cbc314d22a609bfa8bd9e87e8f"

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "ansi-str"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cf4578926a981ab0ca955dc023541d19de37112bc24c1a197bd806d3d86ad1d"
dependencies = [
 "ansitok",
]

[[package]]
name = "ansitok"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "220044e6a1bb31ddee4e3db724d29767f352de47445a6cd75e1a173142136c83"
dependencies = [
 "nom",
 "vte 0.10.1",
]

[[package]]
name = "anstream"
version = "0.6.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "418c75fa768af9c03be99d17643f93f79bbba589895012a80e3452a19ddda15b"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55cc3b69f167a1ef2e161439aa98aed94e6028e5f9a59be9a6ffb47aef1651f9"

[[package]]
name = "anstyle-lossy"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "934ff8719effd2023a48cf63e69536c1c3ced9d3895068f6f5cc9a4ff845e59b"
dependencies = [
 "anstyle",
]

[[package]]
name = "anstyle-parse"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c03a11a9034d92058ceb6ee011ce58af4a9bf61491aa7e1e59ecd24bd40d22d4"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ad186efb764318d35165f1758e7dcef3b10628e26d41a44bc5550652e6804391"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "anstyle-svg"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3607949e9f6de49ea4bafe12f5e4fd73613ebf24795e48587302a8cc0e4bb35"
dependencies = [
 "anstream",
 "anstyle",
 "anstyle-lossy",
 "html-escape",
 "unicode-width 0.2.0",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61a38449feb7068f52bb06c12759005cf459ee52bb4adc1d5a7c4322d716fb19"
dependencies = [
 "anstyle",
 "windows-sys 0.52.0",
]

[[package]]
name = "arrayvec"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23b62fc65de8e4e7f52534fb52b0f3ed04746ae267519eef2a83941e8085068b"

[[package]]
name = "arrayvec"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96d30a06541fbafbc7f82ed10c06164cfbd2c401138f6addd8404629c4b16711"

[[package]]
name = "autocfg"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0"

[[package]]
name = "automod"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebb4bd301db2e2ca1f5be131c24eb8ebf2d9559bc3744419e93baf8ddea7e670"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "backtrace"
version = "0.3.73"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5cc23269a4f8976d0a4d2e7109211a419fe30e8d88d677cd60b6bc79c5732e0a"
dependencies = [
 "addr2line",
 "cc",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
]

[[package]]
name = "base64"
version = "0.21.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "bindgen"
version = "0.69.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a00dc851838a2120612785d195287475a3ac45514741da670b735818822129a0"
dependencies = [
 "bitflags 2.6.0",
 "cexpr",
 "clang-sys",
 "itertools 0.12.1",
 "lazy_static",
 "lazycell",
 "proc-macro2",
 "quote",
 "regex",
 "rustc-hash",
 "shlex",
 "syn",
]

[[package]]
name = "bit-set"
version = "0.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0700ddab506f33b20a03b13996eccd309a48e5ff77d0d95926aa0210fb4e95f1"
dependencies = [
 "bit-vec",
]

[[package]]
name = "bit-vec"
version = "0.6.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "349f9b6a179ed607305526ca489b34ad0a41aed5f7980fa90eb03160b69598fb"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de"
dependencies = [
 "serde",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bracoxide"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ada7f35ca622a86a4d6c27be2633fc6c243ecc834859628fcce0681d8e76e1c8"

[[package]]
name = "bumpalo"
version = "3.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c"

[[package]]
name = "byte-unit"
version = "4.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "da78b32057b8fdfc352504708feeba7216dcd65a2c9ab02978cbd288d1279b6c"
dependencies = [
 "serde",
 "utf8-width",
]

[[package]]
name = "bytecount"
version = "0.6.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5ce89b21cab1437276d2650d57e971f9d548a2d9037cc231abdc0562b97498ce"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytesize"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3e368af43e418a04d52505cf3dbc23dda4e3407ae2fa99fd0e4f308ce546acc"

[[package]]
name = "calamine"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fe0ba51a659bb6c8bffd6f7c1c5ffafcafa0c97e4769411d841c3cc5c154ab47"
dependencies = [
 "byteorder",
 "codepage",
 "encoding_rs",
 "log",
 "quick-xml",
 "serde",
 "zip",
]

[[package]]
name = "cc"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eaff6f8ce506b9773fa786672d63fc7a191ffea1be33f72bbd4aeacefca9ffc8"

[[package]]
name = "cexpr"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fac387a98bb7c37292057cffc56d62ecb629900026402633ae9160df93a8766"
dependencies = [
 "nom",
]

[[package]]
name = "cfg-if"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"

[[package]]
name = "cfg_aliases"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fd16c4719339c4530435d38e511904438d07cce7950afa3718a84ac36c10e89e"

[[package]]
name = "chardetng"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14b8f0b65b7b08ae3c8187e8d77174de20cb6777864c6b832d8ad365999cf1ea"
dependencies = [
 "cfg-if",
 "encoding_rs",
 "memchr",
]

[[package]]
name = "chrono"
version = "0.4.38"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "js-sys",
 "num-traits",
 "pure-rust-locales",
 "serde",
 "wasm-bindgen",
 "windows-targets 0.52.6",
]

[[package]]
name = "chrono-humanize"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "799627e6b4d27827a814e837b9d8a504832086081806d45b1afa34dc982b023b"
dependencies = [
 "chrono",
]

[[package]]
name = "chrono-tz"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d59ae0466b83e838b81a54256c39d5d7c20b9d7daa10510a242d9b75abd5936e"
dependencies = [
 "chrono",
 "chrono-tz-build",
 "phf",
]

[[package]]
name = "chrono-tz-build"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "433e39f13c9a060046954e0592a8d0a4bcb1040125cbf91cb8ee58964cfb350f"
dependencies = [
 "parse-zoneinfo",
 "phf",
 "phf_codegen",
]

[[package]]
name = "clang-sys"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b023947811758c97c59bf9d1c188fd619ad4718dcaa767947df1cadb14f39f4"
dependencies = [
 "glob",
 "libc",
 "libloading",
]

[[package]]
name = "clap"
version = "4.5.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "64acc1846d54c1fe936a78dc189c34e28d3f5afc348403f28ecf53660b9b8462"
dependencies = [
 "clap_builder 4.5.9",
]

[[package]]
name = "clap"
version = "4.5.36"
dependencies = [
 "automod",
 "clap-cargo",
 "clap_builder 4.5.36",
 "clap_derive",
 "jiff",
 "rustversion",
 "shlex",
 "snapbox",
 "trybuild",
 "trycmd",
]

[[package]]
name = "clap-cargo"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d546f0e84ff2bfa4da1ce9b54be42285767ba39c688572ca32412a09a73851e5"
dependencies = [
 "anstyle",
]

[[package]]
name = "clap_bench"
version = "0.0.0"
dependencies = [
 "clap 4.5.36",
 "divan",
 "lazy_static",
]

[[package]]
name = "clap_builder"
version = "4.5.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fb8393d67ba2e7bfaf28a23458e4e2b543cc73a99595511eb207fdb8aede942"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex 0.7.1",
 "strsim",
 "terminal_size 0.3.0",
]

[[package]]
name = "clap_builder"
version = "4.5.36"
dependencies = [
 "anstream",
 "anstyle",
 "backtrace",
 "clap_lex 0.7.4",
 "color-print",
 "static_assertions",
 "strsim",
 "terminal_size 0.4.0",
 "unic-emoji-char",
 "unicase",
 "unicode-width 0.2.0",
]

[[package]]
name = "clap_complete"
version = "4.5.47"
dependencies = [
 "automod",
 "clap 4.5.36",
 "clap_lex 0.7.4",
 "completest",
 "completest-pty",
 "is_executable",
 "shlex",
 "snapbox",
 "trycmd",
]

[[package]]
name = "clap_complete_nushell"
version = "4.5.5"
dependencies = [
 "clap 4.5.36",
 "clap_complete",
 "completest",
 "completest-nu",
 "snapbox",
]

[[package]]
name = "clap_derive"
version = "4.5.32"
dependencies = [
 "anstyle",
 "heck 0.5.0",
 "proc-macro2",
 "pulldown-cmark",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4b82cf0babdbd58558212896d1a4272303a57bdb245c2bf1147185fb45640e70"

[[package]]
name = "clap_lex"
version = "0.7.4"
dependencies = [
 "automod",
]

[[package]]
name = "clap_mangen"
version = "0.2.26"
dependencies = [
 "automod",
 "clap 4.5.36",
 "roff",
 "snapbox",
]

[[package]]
name = "codepage"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b0e9222c0cdf2c6ac27d73f664f9520266fa911c3106329d359f8861cb8bde9"
dependencies = [
 "encoding_rs",
]

[[package]]
name = "color-print"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3aa954171903797d5623e047d9ab69d91b493657917bdfb8c2c80ecaf9cdb6f4"
dependencies = [
 "color-print-proc-macro",
]

[[package]]
name = "color-print-proc-macro"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "692186b5ebe54007e45a59aea47ece9eb4108e141326c304cdc91699a7118a22"
dependencies = [
 "nom",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "colorchoice"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b6a852b24ab71dffc585bcb46eaf7959d175cb865a7152e35b348d1b2960422"

[[package]]
name = "completest"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "410de1ffe61368aa040f599747584e9e3d19235cf4045be6159edb167ef45ddb"

[[package]]
name = "completest-nu"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ffcc1bf2b48cda5a61ca565fa1f01344de38280e7acea8bcd3b48b5451c06c23"
dependencies = [
 "completest",
 "dunce",
 "nu-cli",
 "nu-cmd-lang",
 "nu-command",
 "nu-parser",
 "nu-protocol",
 "nu-test-support",
 "reedline",
]

[[package]]
name = "completest-pty"
version = "0.5.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbd2f22a999db122bd2861c504aa363bbacaa32ebea29edf6924ee6cfe044313"
dependencies = [
 "completest",
 "ptyprocess",
 "vt100",
]

[[package]]
name = "condtype"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "baf0a07a401f374238ab8e2f11a104d2851bf9ce711ec69804834de8af45c7af"

[[package]]
name = "console"
version = "0.15.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e1f83fc076bd6dd27517eacdf25fef6c4dfe5f1d7448bafaaf3a26f13b5e4eb"
dependencies = [
 "encode_unicode",
 "lazy_static",
 "libc",
 "unicode-width 0.1.13",
 "windows-sys 0.52.0",
]

[[package]]
name = "const_format"
version = "0.2.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3a214c7af3d04997541b18d432afaff4c455e79e2029079647e72fc2bd27673"
dependencies = [
 "const_format_proc_macros",
]

[[package]]
name = "const_format_proc_macros"
version = "0.2.32"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7f6ff08fd20f4f299298a28e2dfa8a8ba1036e6cd2460ac1de7b425d76f2500"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-xid",
]

[[package]]
name = "content_inspector"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7bda66e858c683005a53a9a60c69a4aca7eeaa45d124526e389f7aec8e62f38"
dependencies = [
 "memchr",
]

[[package]]
name = "core-foundation"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "91e195e091a93c46f7102ec7818a2aa394e1e1771c3ab4825963fa03e45afb8f"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "core-foundation-sys"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06ea2b9bc92be3c2baa9334a323ebca2d6f074ff852cd1d7b11064035cd3868f"

[[package]]
name = "cpufeatures"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53fe5e26ff1b7aef8bca9c6080520cfb8d9333c7568e1829cef191a9723e5504"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a97769d94ddab943e4510d138150169a2758b5ef3eb191a9ee688de3e23ef7b3"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-channel"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33480d6946193aa8033910124896ca395333cae7e2d1113d1fef6c3272217df2"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613f8cc01fe9cf1a3eb3d7f488fd2fa8388403e97039e2f73692932e291a770d"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80"

[[package]]
name = "crossterm"
version = "0.27.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f476fe445d41c9e991fd07515a6f463074b782242ccf4a5b7b1d1012e70824df"
dependencies = [
 "bitflags 2.6.0",
 "crossterm_winapi",
 "libc",
 "mio",
 "parking_lot",
 "serde",
 "signal-hook",
 "signal-hook-mio",
 "winapi",
]

[[package]]
name = "crossterm_winapi"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "acdd7c62a3665c7f6830a51635d9ac9b23ed385797f70a83bb8bafe9c572ab2b"
dependencies = [
 "winapi",
]

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "csv"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac574ff4d437a7b5ad237ef331c17ccca63c46479e5b5453eb8e10bb99a759fe"
dependencies = [
 "csv-core",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "csv-core"
version = "0.1.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5efa2b3d7902f4b634a20cae3c9c4e6209dc4779feb6863329607560143efa70"
dependencies = [
 "memchr",
]

[[package]]
name = "deranged"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b42b6fa04a440b495c8b04d0e71b707c585f83cb9cb28cf8cd0d976c315e31b4"
dependencies = [
 "powerfmt",
]

[[package]]
name = "dialoguer"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "658bce805d770f407bc62102fca7c2c64ceef2fbcb2b8bd19d2765ce093980de"
dependencies = [
 "console",
 "fuzzy-matcher",
 "shell-words",
 "thiserror",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "dirs-next"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b98cf8ebf19c3d1b223e151f99a4f9f0690dca41414773390fc824184ac833e1"
dependencies = [
 "cfg-if",
 "dirs-sys-next",
]

[[package]]
name = "dirs-sys-next"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4ebda144c4fe02d1f7ea1a7d9641b6fc6b580adcfa024ae48797ecdeb6825b4d"
dependencies = [
 "libc",
 "redox_users",
 "winapi",
]

[[package]]
name = "divan"
version = "0.1.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e05d17bd4ff1c1e7998ed4623d2efd91f72f1e24141ac33aac9377974270e1f"
dependencies = [
 "cfg-if",
 "clap 4.5.9",
 "condtype",
 "divan-macros",
 "libc",
 "regex-lite",
]

[[package]]
name = "divan-macros"
version = "0.1.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b4464d46ce68bfc7cb76389248c7c254def7baca8bece0693b02b83842c4c88"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "dtparse"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "458c7cfe1c34b1ef7c2c435076064711050aedabae9952a261687c500f80e839"
dependencies = [
 "chrono",
 "lazy_static",
 "num-traits",
 "rust_decimal",
]

[[package]]
name = "dunce"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56ce8c6da7551ec6c462cbaf3bfbc75131ebbfa1c944aeaa9dab51ca1c5f0c3b"

[[package]]
name = "either"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60b1af1c220855b6ceac025d3f6ecdd2b7c4894bfe9cd9bda4fbb4bc7c0d4cf0"

[[package]]
name = "encode_unicode"
version = "0.3.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f"

[[package]]
name = "encoding_rs"
version = "0.8.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b45de904aa0b010bce2ab45264d0631681847fa7b6f2eaa7dab7619943bc4f59"
dependencies = [
 "cfg-if",
]

[[package]]
name = "equivalent"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5443807d6dff69373d433ab9ef5378ad8df50ca6298caf15de6e52e24aaf54d5"

[[package]]
name = "erased-serde"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24e2389d65ab4fab27dc2a5de7b191e1f6617d1f1c8855c0dc569c94a4cbb18d"
dependencies = [
 "serde",
 "typeid",
]

[[package]]
name = "errno"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "534c5cf6194dfab3db3242765c03bbe257cf92f22b38f6bc0c58d59108a820ba"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "escargot"
version = "0.5.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05a3ac187a16b5382fef8c69fd1bad123c67b7cf3932240a2d43dcdd32cded88"
dependencies = [
 "log",
 "once_cell",
 "serde",
 "serde_json",
]

[[package]]
name = "fallible-iterator"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4443176a9f2c162692bd3d352d745ef9413eec5782a80d8fd6f8a1ac692a07f7"

[[package]]
name = "fallible-streaming-iterator"
version = "0.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7360491ce676a36bf9bb3c56c1aa791658183a54d2744120f27285738d90465a"

[[package]]
name = "fancy-regex"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b95f7c0680e4142284cf8b22c14a476e87d61b004a3a0861872b32ef7ead40a2"
dependencies = [
 "bit-set",
 "regex",
]

[[package]]
name = "fastrand"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fc0510504f03c51ada170672ac806f1f105a88aa97a5281117e1ddc3368e51a"

[[package]]
name = "fd-lock"
version = "3.0.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef033ed5e9bad94e55838ca0ca906db0e043f517adda0c8b79c7a8c66c93c1b5"
dependencies = [
 "cfg-if",
 "rustix",
 "windows-sys 0.48.0",
]

[[package]]
name = "file-id"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6584280525fb2059cba3db2c04abf947a1a29a45ddae89f3870f8281704fafc9"
dependencies = [
 "windows-sys 0.48.0",
]

[[package]]
name = "filesize"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "12d741e2415d4e2e5bd1c1d00409d1a8865a57892c2d689b504365655d237d43"
dependencies = [
 "winapi",
]

[[package]]
name = "filetime"
version = "0.2.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1ee447700ac8aa0b2f2bd7bc4462ad686ba06baa6727ac149a2d6277f0d240fd"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.4.1",
 "windows-sys 0.52.0",
]

[[package]]
name = "flate2"
version = "1.0.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f54427cfd1c7829e2a139fcefea601bf088ebca651d2bf53ebc600eac295dae"
dependencies = [
 "crc32fast",
 "miniz_oxide",
]

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "foreign-types"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1"
dependencies = [
 "foreign-types-shared",
]

[[package]]
name = "foreign-types-shared"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b"

[[package]]
name = "form_urlencoded"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e13624c2627564efccf4934284bdd98cbaa14e79b0b5a141218e507b3a823456"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fs_extra"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42703706b716c37f96a77aea830392ad231f44c9e9a67872fa5548707e11b11c"

[[package]]
name = "fsevent-sys"
version = "4.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76ee7a02da4d231650c7cea31349b889be2f45ddb3ef3032d2ec8185f6313fd2"
dependencies = [
 "libc",
]

[[package]]
name = "fuzzy-matcher"
version = "0.3.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "54614a3312934d066701a80f20f15fa3b56d67ac7722b39eea5b4c9dd1d66c94"
dependencies = [
 "thread_local",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7"
dependencies = [
 "cfg-if",
 "libc",
 "wasi",
]

[[package]]
name = "gimli"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "40ecd4077b5ae9fd2e9e169b102c6c330d0605168eb0e8bf79952b256dbefffd"

[[package]]
name = "glob"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b"

[[package]]
name = "hamcrest2"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f837c62de05dc9cc71ff6486cd85de8856a330395ae338a04bfcefe5e91075"
dependencies = [
 "num",
 "regex",
]

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"
dependencies = [
 "ahash",
 "allocator-api2",
]

[[package]]
name = "hashlink"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8094feaf31ff591f651a2664fb9cfd92bba7a60ce3197265e9482ebe753c8f7"
dependencies = [
 "hashbrown",
]

[[package]]
name = "heck"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231dfb89cfffdbc30e7fc41579ed6066ad03abda9e567ccafae602b97ec5024"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "home"
version = "0.5.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3d1354bf6b7235cb4a0576c2619fd4ed18183f689b12b006a0ee7329eeff9a5"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "html-escape"
version = "0.2.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6d1ad449764d627e22bfd7cd5e8868264fc9236e07c752972b4080cd351cb476"
dependencies = [
 "utf8-width",
]

[[package]]
name = "htmlescape"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e9025058dae765dee5070ec375f591e2ba14638c63feff74f13805a72e523163"

[[package]]
name = "human-date-parser"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c5cbf96a7157cc349eeafe4595e4f283c3fcab73b5a656d8b2cc00a870a74e1a"
dependencies = [
 "chrono",
 "pest",
 "pest_derive",
 "thiserror",
]

[[package]]
name = "humantime"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4"

[[package]]
name = "humantime-serde"
version = "1.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57a3db5ea5923d99402c94e9feb261dc5ee9b4efa158b0315f788cf549cc200c"
dependencies = [
 "humantime",
 "serde",
]

[[package]]
name = "iana-time-zone"
version = "0.1.60"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7ffbb5a1b541ea2561f8c41c087286cc091e21e556a4f09a8f6cbf17b69b141"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "idna"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "634d9b1461af396cad843f47fdba5597a4f9e6ddd4bfb6ff5d85028c25cb12f6"
dependencies = [
 "unicode-bidi",
 "unicode-normalization",
]

[[package]]
name = "indexmap"
version = "2.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "168fb715dda47215e360912c096649d23d58bf392ac62f73919e831745e40f26"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "indicatif"
version = "0.17.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "763a5a8f45087d6bcea4222e7b72c291a054edf80e4ef6efd2a4979878c7bea3"
dependencies = [
 "console",
 "instant",
 "number_prefix",
 "portable-atomic",
 "unicode-width 0.1.13",
]

[[package]]
name = "inotify"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8069d3ec154eb856955c1c0fbffefbf5f3c40a104ec912d4797314c1801abff"
dependencies = [
 "bitflags 1.3.2",
 "inotify-sys",
 "libc",
]

[[package]]
name = "inotify-sys"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e05c02b5e89bff3b946cedeca278abc628fe811e604f027c45a8aa3cf793d0eb"
dependencies = [
 "libc",
]

[[package]]
name = "instant"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222"
dependencies = [
 "cfg-if",
]

[[package]]
name = "inventory"
version = "0.3.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f958d3d68f4167080a18141e10381e7634563984a537f2a49a30fd8e53ac5767"

[[package]]
name = "is-docker"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "928bae27f42bc99b60d9ac7334e3a21d10ad8f1835a4e12ec3ec0464765ed1b3"
dependencies = [
 "once_cell",
]

[[package]]
name = "is-terminal"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f23ff5ef2b80d608d61efee834934d862cd92461afc0560dedf493e4c033738b"
dependencies = [
 "hermit-abi",
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "is-wsl"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "173609498df190136aa7dea1a91db051746d339e18476eed5ca40521f02d7aa5"
dependencies = [
 "is-docker",
 "once_cell",
]

[[package]]
name = "is_ci"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7655c9839580ee829dfacba1d1278c2b7883e50a277ff7541299489d6bdfdc45"

[[package]]
name = "is_debug"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06d198e9919d9822d5f7083ba8530e04de87841eaf21ead9af8f2304efd57c89"

[[package]]
name = "is_executable"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa9acdc6d67b75e626ad644734e8bc6df893d9cd2a834129065d3dd6158ea9c8"
dependencies = [
 "winapi",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f8478577c03552c21db0e2724ffb8986a5ce7af88107e6be5d2ee6e158c12800"

[[package]]
name = "itertools"
version = "0.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b1c173a5686ce8bfa551b3563d0c2170bf24ca44da99c7ca4bfdab5418c3fe57"
dependencies = [
 "either",
]

[[package]]
name = "itertools"
version = "0.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba291022dbbd398a455acf126c1e341954079855bc60dfdda641363bd6922569"
dependencies = [
 "either",
]

[[package]]
name = "itoa"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f1f14873335454500d59611f1cf4a4b0f786f9ac11f4312a78e4cf2566695b"

[[package]]
name = "jiff"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f33145a5cbea837164362c7bd596106eb7c5198f97d1ba6f6ebb3223952e488"
dependencies = [
 "jiff-static",
 "jiff-tzdb-platform",
 "log",
 "portable-atomic",
 "portable-atomic-util",
 "serde",
 "windows-sys 0.59.0",
]

[[package]]
name = "jiff-static"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "43ce13c40ec6956157a3635d97a1ee2df323b263f09ea14165131289cb0f5c19"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "jiff-tzdb"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1283705eb0a21404d2bfd6eef2a7593d240bc42a0bdb39db0ad6fa2ec026524"

[[package]]
name = "jiff-tzdb-platform"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "875a5a69ac2bab1a891711cf5eccbec1ce0341ea805560dcd90b7a2e925132e8"
dependencies = [
 "jiff-tzdb",
]

[[package]]
name = "joinery"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72167d68f5fce3b8655487b8038691a3c9984ee769590f93f2a631f4ad64e4f5"

[[package]]
name = "js-sys"
version = "0.3.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29c15563dc2726973df627357ce0c9ddddbea194836909d655df6a75d2cf296d"
dependencies = [
 "wasm-bindgen",
]

[[package]]
name = "kqueue"
version = "1.0.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7447f1ca1b7b563588a205fe93dea8df60fd981423a768bc1c0ded35ed147d0c"
dependencies = [
 "kqueue-sys",
 "libc",
]

[[package]]
name = "kqueue-sys"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed9625ffda8729b85e45cf04090035ac368927b8cebc34898e7c120f52e4838b"
dependencies = [
 "bitflags 1.3.2",
 "libc",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "lazycell"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55"

[[package]]
name = "libc"
version = "0.2.155"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97b3888a4aecf77e811145cadf6eef5901f4782c53886191b2f693f24761847c"

[[package]]
name = "libloading"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e310b3a6b5907f99202fcdb4960ff45b93735d7c7d96b760fcff8db2dc0e103d"
dependencies = [
 "cfg-if",
 "windows-targets 0.48.5",
]

[[package]]
name = "libproc"
version = "0.14.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ae9ea4b75e1a81675429dafe43441df1caea70081e82246a8cccf514884a88bb"
dependencies = [
 "bindgen",
 "errno",
 "libc",
]

[[package]]
name = "libredox"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0ff37bd590ca25063e35af745c343cb7a0271906fb7b37e4813e8f79f00268d"
dependencies = [
 "bitflags 2.6.0",
 "libc",
]

[[package]]
name = "libsqlite3-sys"
version = "0.26.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "afc22eff61b133b115c6e8c74e818c628d6d5e7a502afea6f64dee076dd94326"
dependencies = [
 "cc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "linked-hash-map"
version = "0.5.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0717cef1bc8b636c6e1c1bbdefc09e6322da8a9321966e8928ef80d20f7f770f"
dependencies = [
 "serde",
]

[[package]]
name = "linux-raw-sys"
version = "0.4.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78b3ae25bc7c8c38cec158d1f2757ee79e9b3740fbc7ccf0e59e4b08d793fa89"

[[package]]
name = "lock_api"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7a70ba024b9dc04c27ea2f0c0548feb474ec5c54bba33a7f72f873a39d07b24"

[[package]]
name = "lru"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3262e75e648fce39813cb56ac41f3c3e3f65217ebf3844d818d1f9398cfb0dc"
dependencies = [
 "hashbrown",
]

[[package]]
name = "lscolors"
version = "0.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf7015a04103ad78abb77e4b79ed151e767922d1cfde5f62640471c629a2320d"
dependencies = [
 "nu-ansi-term",
]

[[package]]
name = "mach2"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "19b955cdeb2a02b9117f121ce63aa52d08ade45de53e48fe6a38b39c10f6f709"
dependencies = [
 "libc",
]

[[package]]
name = "md-5"
version = "0.10.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d89e7ee0cfbedfc4da3340218492196241d89eefb6dab27de5df917a6d2e78cf"
dependencies = [
 "cfg-if",
 "digest",
]

[[package]]
name = "memchr"
version = "2.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3"

[[package]]
name = "memoffset"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5de893c32cde5f383baa4c04c5d6dbdd735cfd4a794b0debdb2bb1b421da5ff4"
dependencies = [
 "autocfg",
]

[[package]]
name = "miette"
version = "5.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59bb584eaeeab6bd0226ccf3509a69d7936d148cf3d036ad350abe35e8c6856e"
dependencies = [
 "is-terminal",
 "miette-derive",
 "once_cell",
 "owo-colors",
 "supports-color",
 "supports-hyperlinks",
 "supports-unicode",
 "terminal_size 0.1.17",
 "textwrap",
 "thiserror",
 "unicode-width 0.1.13",
]

[[package]]
name = "miette-derive"
version = "5.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49e7bc1560b95a3c4a25d03de42fe76ca718ab92d1a22a55b9b4cf67b3ae635c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "mime_guess"
version = "2.0.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7c44f8e672c00fe5308fa235f821cb4198414e1c77935c1ab6948d3fd78550e"
dependencies = [
 "mime",
 "unicase",
]

[[package]]
name = "minimal-lexical"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a"

[[package]]
name = "miniz_oxide"
version = "0.7.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8a240ddb74feaf34a79a7add65a741f3167852fba007066dcac1ca548d89c08"
dependencies = [
 "adler",
]

[[package]]
name = "mio"
version = "0.8.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4a650543ca06a924e8b371db273b2756685faae30f8487da1b56505a8f78b0c"
dependencies = [
 "libc",
 "log",
 "wasi",
 "windows-sys 0.48.0",
]

[[package]]
name = "native-tls"
version = "0.2.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8614eb2c83d59d1c8cc974dd3f920198647674a0a035e1af1fa58707e317466"
dependencies = [
 "libc",
 "log",
 "openssl",
 "openssl-probe",
 "openssl-sys",
 "schannel",
 "security-framework",
 "security-framework-sys",
 "tempfile",
]

[[package]]
name = "nix"
version = "0.26.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "598beaf3cc6fdd9a5dfb1630c2800c7acd31df7aaf0f565796fba2b53ca1af1b"
dependencies = [
 "bitflags 1.3.2",
 "cfg-if",
 "libc",
 "memoffset",
 "pin-utils",
]

[[package]]
name = "nix"
version = "0.27.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2eb04e9c688eff1c89d72b407f168cf79bb9e867a9d3323ed6c01519eb9cc053"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "libc",
]

[[package]]
name = "nix"
version = "0.28.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab2156c4fce2f8df6c499cc1c763e4394b7482525bf2a9701c9d79d215f519e4"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "cfg_aliases",
 "libc",
]

[[package]]
name = "nom"
version = "7.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d273983c5a657a70a3e8f2a01329822f3b8c8172b73826411a55751e404a0a4a"
dependencies = [
 "memchr",
 "minimal-lexical",
]

[[package]]
name = "normalize-line-endings"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61807f77802ff30975e01f4f071c8ba10c022052f98b3294119f3e615d13e5be"

[[package]]
name = "notify"
version = "6.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6205bd8bb1e454ad2e27422015fb5e4f2bcc7e08fa8f27058670d208324a4d2d"
dependencies = [
 "bitflags 2.6.0",
 "crossbeam-channel",
 "filetime",
 "fsevent-sys",
 "inotify",
 "kqueue",
 "libc",
 "log",
 "mio",
 "walkdir",
 "windows-sys 0.48.0",
]

[[package]]
name = "notify-debouncer-full"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49f5dab59c348b9b50cf7f261960a20e389feb2713636399cd9082cd4b536154"
dependencies = [
 "file-id",
 "log",
 "notify",
 "parking_lot",
 "walkdir",
]

[[package]]
name = "ntapi"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8a3895c6391c39d7fe7ebc444a87eb2991b2a0bc718fdabd071eec617fc68e4"
dependencies = [
 "winapi",
]

[[package]]
name = "nu-ansi-term"
version = "0.49.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c073d3c1930d0751774acf49e66653acecb416c3a54c6ec095a9b11caddb5a68"
dependencies = [
 "windows-sys 0.48.0",
]

[[package]]
name = "nu-cli"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436ddfe486b895bfabbc69d3dbee5d32ab722fb005838d5218acfeae54fd0dc0"
dependencies = [
 "chrono",
 "crossterm",
 "fancy-regex",
 "fuzzy-matcher",
 "is_executable",
 "log",
 "miette",
 "nu-ansi-term",
 "nu-cmd-base",
 "nu-color-config",
 "nu-engine",
 "nu-parser",
 "nu-path",
 "nu-protocol",
 "nu-utils",
 "once_cell",
 "pathdiff",
 "percent-encoding",
 "reedline",
 "sysinfo",
 "unicode-segmentation",
 "uuid",
 "which 5.0.0",
]

[[package]]
name = "nu-cmd-base"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e1f5d752e211d2164c71599a25aa95dd0da19c9f2be6fa1de76748d6378b579c"
dependencies = [
 "indexmap",
 "miette",
 "nu-engine",
 "nu-glob",
 "nu-parser",
 "nu-path",
 "nu-protocol",
 "nu-utils",
]

[[package]]
name = "nu-cmd-lang"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "63cb11e1ff0dfa73b286411744044cc3bc415135b4b1d9222d724bd517876d8c"
dependencies = [
 "fancy-regex",
 "itertools 0.11.0",
 "nu-ansi-term",
 "nu-engine",
 "nu-parser",
 "nu-protocol",
 "nu-utils",
 "shadow-rs",
]

[[package]]
name = "nu-color-config"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03703a4be321c340d0ea94622245abb612179feabaebbdf3bb041558f950ca2f"
dependencies = [
 "nu-ansi-term",
 "nu-engine",
 "nu-json",
 "nu-protocol",
 "nu-utils",
 "serde",
]

[[package]]
name = "nu-command"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cea3c4be1d23a9da0485cb9a38cc068ee189e38284d0423123d94dd075904d6f"
dependencies = [
 "alphanumeric-sort",
 "base64 0.21.7",
 "bracoxide",
 "byteorder",
 "bytesize",
 "calamine",
 "chardetng",
 "chrono",
 "chrono-humanize",
 "chrono-tz",
 "crossterm",
 "csv",
 "dialoguer",
 "digest",
 "dtparse",
 "encoding_rs",
 "fancy-regex",
 "filesize",
 "filetime",
 "fs_extra",
 "htmlescape",
 "human-date-parser",
 "indexmap",
 "indicatif",
 "itertools 0.11.0",
 "libc",
 "log",
 "lscolors",
 "md-5",
 "miette",
 "mime",
 "mime_guess",
 "native-tls",
 "nix 0.27.1",
 "notify-debouncer-full",
 "nu-ansi-term",
 "nu-cmd-base",
 "nu-color-config",
 "nu-engine",
 "nu-glob",
 "nu-json",
 "nu-parser",
 "nu-path",
 "nu-pretty-hex",
 "nu-protocol",
 "nu-system",
 "nu-table",
 "nu-term-grid",
 "nu-utils",
 "num-format",
 "num-traits",
 "once_cell",
 "open",
 "os_pipe",
 "pathdiff",
 "percent-encoding",
 "print-positions",
 "procfs",
 "quick-xml",
 "rand",
 "rayon",
 "regex",
 "roxmltree",
 "same-file",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "serde_yaml",
 "sha2",
 "sysinfo",
 "tabled",
 "terminal_size 0.3.0",
 "titlecase",
 "toml",
 "umask",
 "unicode-segmentation",
 "ureq",
 "url",
 "uu_cp",
 "uu_mkdir",
 "uu_mktemp",
 "uu_whoami",
 "uuid",
 "wax",
 "windows",
 "winreg",
]

[[package]]
name = "nu-engine"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31549205c091d89cb1bad9e97a5944b998f9417a718c0ad5d1ca373abe27c8b"
dependencies = [
 "nu-glob",
 "nu-path",
 "nu-protocol",
 "nu-utils",
]

[[package]]
name = "nu-glob"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8fc6e216ee3e0d3574085e3f9bc63b382d078b159b2f2f1380a6f4d08c1662fd"

[[package]]
name = "nu-json"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76e7825d084423fc8d01ddf814336757c5ea706a8799a6e358af4256f7c68d81"
dependencies = [
 "linked-hash-map",
 "num-traits",
 "serde",
]

[[package]]
name = "nu-parser"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "01db27d8c7a31504baf78c1b8f9104a5c77719ac08476ffb55738d86697e501d"
dependencies = [
 "bytesize",
 "chrono",
 "itertools 0.11.0",
 "log",
 "nu-engine",
 "nu-path",
 "nu-protocol",
 "serde_json",
]

[[package]]
name = "nu-path"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b89b96e3df2637c95dfb893ba0a97646d1733d6957e31ba3e6f46bee09cdea29"
dependencies = [
 "dirs-next",
 "omnipath",
 "pwd",
]

[[package]]
name = "nu-pretty-hex"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60c9ca2c5dc9e6fe7872375f2a6fcdead60a2c4e3608f6fcd5661c821219258a"
dependencies = [
 "nu-ansi-term",
]

[[package]]
name = "nu-protocol"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "243a5a60997b63173dd2e0fdd5c1a6d2c25e0782e444c23714fedeef3ac95949"
dependencies = [
 "byte-unit",
 "chrono",
 "chrono-humanize",
 "fancy-regex",
 "indexmap",
 "lru",
 "miette",
 "nu-path",
 "nu-system",
 "nu-utils",
 "num-format",
 "serde",
 "serde_json",
 "thiserror",
 "typetag",
]

[[package]]
name = "nu-system"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c8e2cd7ed9a6567b2794de6c82ce7cfa9661895d172190bdfde06d033e56cad0"
dependencies = [
 "chrono",
 "libc",
 "libproc",
 "log",
 "mach2",
 "nix 0.27.1",
 "ntapi",
 "once_cell",
 "procfs",
 "sysinfo",
 "winapi",
]

[[package]]
name = "nu-table"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56831906278b3593d6459c1532f430f835aec415ca3ac4dc23657830f71627a3"
dependencies = [
 "fancy-regex",
 "nu-ansi-term",
 "nu-color-config",
 "nu-engine",
 "nu-protocol",
 "nu-utils",
 "once_cell",
 "tabled",
]

[[package]]
name = "nu-term-grid"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc510407738832f385c46e2cca97ee6691c43d222f26c1ef237a3df4b9f980ac"
dependencies = [
 "nu-utils",
 "unicode-width 0.1.13",
]

[[package]]
name = "nu-test-support"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "de3e016e1319ae8805097d1d3466debc597c843ad0506d97095f0fad342d04d2"
dependencies = [
 "hamcrest2",
 "nu-glob",
 "nu-path",
 "nu-utils",
 "num-format",
 "tempfile",
 "which 4.4.2",
]

[[package]]
name = "nu-utils"
version = "0.88.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "339eed81dd7f6c59bcd14f9d9076f223c0aa0632b42e1efa60de1376f4fa04bd"
dependencies = [
 "crossterm_winapi",
 "log",
 "lscolors",
 "num-format",
 "strip-ansi-escapes",
 "sys-locale",
 "unicase",
]

[[package]]
name = "num"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8536030f9fea7127f841b45bb6243b27255787fb4eb83958aa1ef9d2fdc0c36"
dependencies = [
 "num-bigint",
 "num-complex",
 "num-integer",
 "num-iter",
 "num-rational",
 "num-traits",
]

[[package]]
name = "num-bigint"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "090c7f9998ee0ff65aa5b723e4009f7b217707f1fb5ea551329cc4d6231fb304"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-complex"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6b19411a9719e753aff12e5187b74d60d3dc449ec3f4dc21e3989c3f554bc95"
dependencies = [
 "autocfg",
 "num-traits",
]

[[package]]
name = "num-conv"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "51d515d32fb182ee37cda2ccdcb92950d6a3c2893aa280e540671c2cd0f3b1d9"

[[package]]
name = "num-format"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a652d9771a63711fd3c3deb670acfbe5c30a4072e664d7a3bf5a9e1056ac72c3"
dependencies = [
 "arrayvec 0.7.4",
 "itoa",
]

[[package]]
name = "num-integer"
version = "0.1.46"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7969661fd2958a5cb096e56c8e1ad0444ac2bbcd0061bd28660485a44879858f"
dependencies = [
 "num-traits",
]

[[package]]
name = "num-iter"
version = "0.1.45"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1429034a0490724d0075ebb2bc9e875d6503c3cf69e235a8941aa757d83ef5bf"
dependencies = [
 "autocfg",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-rational"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c000134b5dbf44adc5cb772486d335293351644b801551abe8f75c84cfa4aef"
dependencies = [
 "autocfg",
 "num-bigint",
 "num-integer",
 "num-traits",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "num_threads"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c7398b9c8b70908f6371f47ed36737907c87c52af34c268fed0bf0ceb92ead9"
dependencies = [
 "libc",
]

[[package]]
name = "number_prefix"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3"

[[package]]
name = "object"
version = "0.36.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "081b846d1d56ddfc18fdf1a922e4f6e07a11768ea1b92dec44e42b72712ccfce"
dependencies = [
 "memchr",
]

[[package]]
name = "omnipath"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80adb31078122c880307e9cdfd4e3361e6545c319f9b9dcafcb03acd3b51a575"

[[package]]
name = "once_cell"
version = "1.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92"

[[package]]
name = "open"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "61a877bf6abd716642a53ef1b89fb498923a4afca5c754f9050b4d081c05c4b3"
dependencies = [
 "is-wsl",
 "libc",
 "pathdiff",
]

[[package]]
name = "openssl"
version = "0.10.64"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "95a0481286a310808298130d22dd1fef0fa571e05a8f44ec801801e84b216b1f"
dependencies = [
 "bitflags 2.6.0",
 "cfg-if",
 "foreign-types",
 "libc",
 "once_cell",
 "openssl-macros",
 "openssl-sys",
]

[[package]]
name = "openssl-macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a948666b637a0f465e8564c73e89d4dde00d72d4d473cc972f390fc3dcee7d9c"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "openssl-probe"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf"

[[package]]
name = "openssl-sys"
version = "0.9.102"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c597637d56fbc83893a35eb0dd04b2b8e7a50c91e64e9493e398b5df4fb45fa2"
dependencies = [
 "cc",
 "libc",
 "pkg-config",
 "vcpkg",
]

[[package]]
name = "os_display"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a6229bad892b46b0dcfaaeb18ad0d2e56400f5aaea05b768bde96e73676cf75"
dependencies = [
 "unicode-width 0.1.13",
]

[[package]]
name = "os_pipe"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29d73ba8daf8fac13b0501d1abeddcfe21ba7401ada61a819144b6c2a4f32209"
dependencies = [
 "libc",
 "windows-sys 0.52.0",
]

[[package]]
name = "owo-colors"
version = "3.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1b04fb49957986fdce4d6ee7a65027d55d4b6d2265e5848bbb507b58ccfdb6f"

[[package]]
name = "papergrid"
version = "0.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2ccbe15f2b6db62f9a9871642746427e297b0ceb85f9a7f1ee5ff47d184d0c8"
dependencies = [
 "ansi-str",
 "ansitok",
 "bytecount",
 "fnv",
 "unicode-width 0.1.13",
]

[[package]]
name = "parking_lot"
version = "0.12.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1bf18183cf54e8d6059647fc3063646a1801cf30896933ec2311622cc4b9a27"
dependencies = [
 "lock_api",
 "parking_lot_core",
]

[[package]]
name = "parking_lot_core"
version = "0.9.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.5.2",
 "smallvec",
 "windows-targets 0.52.6",
]

[[package]]
name = "parse-zoneinfo"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f2a05b18d44e2957b88f96ba460715e295bc1d7510468a2f3d3b44535d26c24"
dependencies = [
 "regex",
]

[[package]]
name = "pathdiff"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8835116a5c179084a830efb3adc117ab007512b535bc1a21c991d3b32a6b44dd"

[[package]]
name = "percent-encoding"
version = "2.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3148f5046208a5d56bcfc03053e3ca6334e51da8dfb19b6cdc8b306fae3283e"

[[package]]
name = "pest"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd53dff83f26735fdc1ca837098ccf133605d794cdae66acfc2bfac3ec809d95"
dependencies = [
 "memchr",
 "thiserror",
 "ucd-trie",
]

[[package]]
name = "pest_derive"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2a548d2beca6773b1c244554d36fcf8548a8a58e74156968211567250e48e49a"
dependencies = [
 "pest",
 "pest_generator",
]

[[package]]
name = "pest_generator"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c93a82e8d145725dcbaf44e5ea887c8a869efdcc28706df2d08c69e17077183"
dependencies = [
 "pest",
 "pest_meta",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pest_meta"
version = "2.7.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a941429fea7e08bedec25e4f6785b6ffaacc6b755da98df5ef3e7dcf4a124c4f"
dependencies = [
 "once_cell",
 "pest",
 "sha2",
]

[[package]]
name = "phf"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ade2d8b8f33c7333b51bcf0428d37e217e9f32192ae4772156f65063b8ce03dc"
dependencies = [
 "phf_shared",
]

[[package]]
name = "phf_codegen"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e8d39688d359e6b34654d328e262234662d16cc0f60ec8dcbe5e718709342a5a"
dependencies = [
 "phf_generator",
 "phf_shared",
]

[[package]]
name = "phf_generator"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48e4cc64c2ad9ebe670cb8fd69dd50ae301650392e81c05f9bfcb2d5bdbc24b0"
dependencies = [
 "phf_shared",
 "rand",
]

[[package]]
name = "phf_shared"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "90fcb95eef784c2ac79119d1dd819e162b5da872ce6f3c3abe1e8ca1c082f72b"
dependencies = [
 "siphasher",
]

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkg-config"
version = "0.3.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d231b230927b5e4ad203db57bbcbee2802f6bce620b1e4a9024a07d94e2907ec"

[[package]]
name = "pori"
version = "0.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4a63d338dec139f56dacc692ca63ad35a6be6a797442479b55acd611d79e906"
dependencies = [
 "nom",
]

[[package]]
name = "portable-atomic"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "350e9b48cbc6b0e028b0473b114454c6316e57336ee184ceab6e53f72c178b3e"

[[package]]
name = "portable-atomic-util"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d8a2f0d8d040d7848a709caf78912debcc3f33ee4b3cac47d73d1e1069e83507"
dependencies = [
 "portable-atomic",
]

[[package]]
name = "powerfmt"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "439ee305def115ba05938db6eb1644ff94165c5ab5e9420d1c1bcedbba909391"

[[package]]
name = "ppv-lite86"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b40af805b3121feab8a3c29f04d8ad262fa8e0561883e7653e024ae4479e6de"

[[package]]
name = "print-positions"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1df593470e3ef502e48cb0cfc9a3a61e5f61e967b78e1ed35a67ac615cfbd208"
dependencies = [
 "unicode-segmentation",
]

[[package]]
name = "proc-macro2"
version = "1.0.94"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a31971752e70b8b2686d7e46ec17fb38dad4051d94024c88df49b667caea9c84"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "procfs"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "731e0d9356b0c25f16f33b5be79b1c57b562f141ebfcdb0ad8ac2c13a24293b4"
dependencies = [
 "bitflags 2.6.0",
 "chrono",
 "flate2",
 "hex",
 "lazy_static",
 "procfs-core",
 "rustix",
]

[[package]]
name = "procfs-core"
version = "0.16.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2d3554923a69f4ce04c4a754260c338f505ce22642d3830e049a399fc2059a29"
dependencies = [
 "bitflags 2.6.0",
 "chrono",
 "hex",
]

[[package]]
name = "ptyprocess"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e05aef7befb11a210468a2d77d978dde2c6381a0381e33beb575e91f57fe8cf"
dependencies = [
 "nix 0.26.4",
]

[[package]]
name = "pulldown-cmark"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e8bbe1a966bd2f362681a44f6edce3c2310ac21e4d5067a6e7ec396297a6ea0"
dependencies = [
 "bitflags 2.6.0",
 "memchr",
 "unicase",
]

[[package]]
name = "pure-rust-locales"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1190fd18ae6ce9e137184f207593877e70f39b015040156b1e05081cdfe3733a"

[[package]]
name = "pwd"
version = "1.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72c71c0c79b9701efe4e1e4b563b2016dd4ee789eb99badcb09d61ac4b92e4a2"
dependencies = [
 "libc",
 "thiserror",
]

[[package]]
name = "quick-error"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a993555f31e5a609f617c12db6250dedcac1b0a85076912c436e6fc9b2c8e6a3"

[[package]]
name = "quick-xml"
version = "0.30.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eff6510e86862b57b210fd8cbe8ed3f0d7d600b9c2863cd4549a2e033c66e956"
dependencies = [
 "encoding_rs",
 "memchr",
]

[[package]]
name = "quote"
version = "1.0.39"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1f1914ce909e1658d9907913b4b91947430c7d9be598b15a1912935b8c04801"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "rayon"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b418a60154510ca1a002a752ca9714984e21e4241e804d32555251faf8b78ffa"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.12.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1465873a3dfdaa8ae7cb14b4383657caab0b3e8a0aa9ae8e04b044854c8dfce2"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "redox_syscall"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4722d768eff46b75989dd134e5c353f0d6296e5aaa3132e776cbdb56be7731aa"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c82cf8cff14456045f55ec4241383baeff27af886adb72ffb2162f99911de0fd"
dependencies = [
 "bitflags 2.6.0",
]

[[package]]
name = "redox_users"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd283d9651eeda4b2a83a43c1c91b266c40fd76ecd39a50a8c630ae69dc72891"
dependencies = [
 "getrandom",
 "libredox",
 "thiserror",
]

[[package]]
name = "reedline"
version = "0.27.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07046f804ccb26a6fa8b638f505ccd2a8b7702399a89b9640a0d40ecda49233d"
dependencies = [
 "chrono",
 "crossterm",
 "fd-lock",
 "itertools 0.10.5",
 "nu-ansi-term",
 "rusqlite",
 "serde",
 "serde_json",
 "strip-ansi-escapes",
 "strum",
 "strum_macros",
 "thiserror",
 "unicode-segmentation",
 "unicode-width 0.1.13",
]

[[package]]
name = "regex"
version = "1.10.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b91213439dad192326a0d7c6ee3955910425f441d7038e0d6933b0aec5c4517f"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38caf58cc5ef2fed281f89292ef23f6365465ed9a41b7a7754eb4e26496c92df"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-lite"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53a49587ad06b26609c52e423de037e7f57f20d53535d66e08c695f347df952a"

[[package]]
name = "regex-syntax"
version = "0.8.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a66a03ae7c801facd77a29370b4faec201768915ac14a721ba36f20bc9c209b"

[[package]]
name = "roff"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b833d8d034ea094b1ea68aa6d5c740e0d04bad9d16568d08ba6f76823a114316"

[[package]]
name = "roxmltree"
version = "0.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "862340e351ce1b271a378ec53f304a5558f7db87f3769dc655a8f6ecbb68b302"
dependencies = [
 "xmlparser",
]

[[package]]
name = "rusqlite"
version = "0.29.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "549b9d036d571d42e6e85d1c1425e2ac83491075078ca9a15be021c56b1641f2"
dependencies = [
 "bitflags 2.6.0",
 "fallible-iterator",
 "fallible-streaming-iterator",
 "hashlink",
 "libsqlite3-sys",
 "smallvec",
]

[[package]]
name = "rust_decimal"
version = "1.35.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1790d1c4c0ca81211399e0e0af16333276f375209e71a37b67698a373db5b47a"
dependencies = [
 "arrayvec 0.7.4",
 "num-traits",
]

[[package]]
name = "rustc-demangle"
version = "0.1.24"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f"

[[package]]
name = "rustc-hash"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2"

[[package]]
name = "rustix"
version = "0.38.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70dc5ec042f7a43c4a73241207cecc9873a06d45debb38b329f8541d85c2730f"
dependencies = [
 "bitflags 2.6.0",
 "errno",
 "libc",
 "linux-raw-sys",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustversion"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eded382c5f5f786b989652c49544c4877d9f015cc22e145a5ea8ea66c2921cd2"

[[package]]
name = "ryu"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3cb5ba0dc43242ce17de99c180e96db90b235b8a9fdc9543c96d2209116bd9f"

[[package]]
name = "same-file"
version = "1.0.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502"
dependencies = [
 "winapi-util",
]

[[package]]
name = "schannel"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fbc91545643bcf3a0bbb6569265615222618bdf33ce4ffbbd13c4bbd4c093534"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "security-framework"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c627723fd09706bacdb5cf41499e95098555af3c3c29d014dc3c458ef6be11c0"
dependencies = [
 "bitflags 2.6.0",
 "core-foundation",
 "core-foundation-sys",
 "libc",
 "security-framework-sys",
]

[[package]]
name = "security-framework-sys"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "317936bbbd05227752583946b9e66d7ce3b489f84e11a94a510b4437fef407d7"
dependencies = [
 "core-foundation-sys",
 "libc",
]

[[package]]
name = "serde"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc76f558e0cbb2a839d37354c575f1dc3fdc6546b5be373ba43d95f231bf7c12"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.204"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0cd7e117be63d3c3678776753929474f3b04a43a080c744d6b0ae2a8c28e222"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.120"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e0d21c9a8cae1235ad58a00c11cb40d4b1e5c784f1ef2c537876ed6ffd8b7c5"
dependencies = [
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_spanned"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "79e674e01f999af37c49f70a6ede167a8a60b2503e56c5599532a65baa5969a0"
dependencies = [
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "serde_yaml"
version = "0.9.34+deprecated"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a8b1a1a2ebf674015cc02edccce75287f1a0130d394307b36743c2f5d504b47"
dependencies = [
 "indexmap",
 "itoa",
 "ryu",
 "serde",
 "unsafe-libyaml",
]

[[package]]
name = "sha2"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "shadow-rs"
version = "0.24.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f9198caff1c94f1a5df6664bddbc379896b51b98a55b0b3fedcb23078fe00c77"
dependencies = [
 "const_format",
 "is_debug",
 "time",
]

[[package]]
name = "shell-words"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24188a676b6ae68c3b2cb3a01be17fbf7240ce009799bb56d5b1409051e78fde"

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8621587d4798caf8eb44879d42e56b9a93ea5dcd315a6487c357130095b62801"
dependencies = [
 "libc",
 "signal-hook-registry",
]

[[package]]
name = "signal-hook-mio"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29ad2e15f37ec9a6cc544097b78a1ec90001e9f71b81338ca39f430adaca99af"
dependencies = [
 "libc",
 "mio",
 "signal-hook",
]

[[package]]
name = "signal-hook-registry"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a9e9e0b4211b72e7b8b6e85c807d36c212bdb33ea8587f7569562a84df5465b1"
dependencies = [
 "libc",
]

[[package]]
name = "similar"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa42c91313f1d05da9b26f267f931cf178d4aba455b4c4622dd7355eb80c6640"

[[package]]
name = "siphasher"
version = "0.3.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38b58827f4464d87d377d175e90bf58eb00fd8716ff0a62f80356b5e61555d0d"

[[package]]
name = "smallvec"
version = "1.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67"

[[package]]
name = "smawk"
version = "0.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7c388c1b5e93756d0c740965c41e8822f866621d41acbdf6336a6a168f8840c"

[[package]]
name = "snapbox"
version = "0.6.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96dcfc4581e3355d70ac2ee14cfdf81dce3d85c85f1ed9e2c1d3013f53b3436b"
dependencies = [
 "anstream",
 "anstyle",
 "anstyle-svg",
 "content_inspector",
 "dunce",
 "escargot",
 "filetime",
 "libc",
 "normalize-line-endings",
 "os_pipe",
 "serde_json",
 "similar",
 "snapbox-macros",
 "tempfile",
 "wait-timeout",
 "walkdir",
 "windows-sys 0.59.0",
]

[[package]]
name = "snapbox-macros"
version = "0.3.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "16569f53ca23a41bb6f62e0a5084aa1661f4814a67fa33696a79073e03a664af"
dependencies = [
 "anstream",
]

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "strip-ansi-escapes"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55ff8ef943b384c414f54aefa961dd2bd853add74ec75e7ac74cf91dba62bcfa"
dependencies = [
 "vte 0.11.1",
]

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "strum"
version = "0.25.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "290d54ea6f91c969195bdbcd7442c8c2a2ba87da8bf60a7ee86a235d4bc1e125"

[[package]]
name = "strum_macros"
version = "0.25.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "23dc1fa9ac9c169a78ba62f0b841814b7abae11bdd047b9c58f893439e309ea0"
dependencies = [
 "heck 0.4.1",
 "proc-macro2",
 "quote",
 "rustversion",
 "syn",
]

[[package]]
name = "supports-color"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d6398cde53adc3c4557306a96ce67b302968513830a77a95b2b17305d9719a89"
dependencies = [
 "is-terminal",
 "is_ci",
]

[[package]]
name = "supports-hyperlinks"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f84231692eb0d4d41e4cdd0cabfdd2e6cd9e255e65f80c9aa7c98dd502b4233d"
dependencies = [
 "is-terminal",
]

[[package]]
name = "supports-unicode"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f850c19edd184a205e883199a261ed44471c81e39bd95b1357f5febbef00e77a"
dependencies = [
 "is-terminal",
]

[[package]]
name = "syn"
version = "2.0.99"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e02e925281e18ffd9d640e234264753c43edc62d64b2d4cf898f1bc5e75f3fc2"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sys-locale"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e801cf239ecd6ccd71f03d270d67dd53d13e90aab208bf4b8fe4ad957ea949b0"
dependencies = [
 "libc",
]

[[package]]
name = "sysinfo"
version = "0.29.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cd727fc423c2060f6c92d9534cef765c65a6ed3f428a03d7def74a8c4348e666"
dependencies = [
 "cfg-if",
 "core-foundation-sys",
 "libc",
 "ntapi",
 "once_cell",
 "rayon",
 "winapi",
]

[[package]]
name = "tabled"
version = "0.14.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfe9c3632da101aba5131ed63f9eed38665f8b3c68703a6bb18124835c1a5d22"
dependencies = [
 "ansi-str",
 "ansitok",
 "papergrid",
 "unicode-width 0.1.13",
]

[[package]]
name = "target-triple"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42a4d50cdb458045afc8131fd91b64904da29548bcb63c7236e0844936c13078"

[[package]]
name = "tempfile"
version = "3.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85b77fafb263dd9d05cbeac119526425676db3784113aa9295c88498cbf8bff1"
dependencies = [
 "cfg-if",
 "fastrand",
 "rustix",
 "windows-sys 0.52.0",
]

[[package]]
name = "termcolor"
version = "1.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06794f8f6c5c898b3275aebefa6b8a1cb24cd2c6c79397ab15774837a0bc5755"
dependencies = [
 "winapi-util",
]

[[package]]
name = "terminal_size"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "633c1a546cee861a1a6d0dc69ebeca693bf4296661ba7852b9d21d159e0506df"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "terminal_size"
version = "0.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21bebf2b7c9e0a515f6e0f8c51dc0f8e4696391e6f1ff30379559f8365fb0df7"
dependencies = [
 "rustix",
 "windows-sys 0.48.0",
]

[[package]]
name = "terminal_size"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4f599bd7ca042cfdf8f4512b277c02ba102247820f9d9d4a9f521f496751a6ef"
dependencies = [
 "rustix",
 "windows-sys 0.59.0",
]

[[package]]
name = "textwrap"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b7b3e525a49ec206798b40326a44121291b530c963cfb01018f63e135bac543d"
dependencies = [
 "smawk",
 "unicode-linebreak",
 "unicode-width 0.1.13",
]

[[package]]
name = "thiserror"
version = "1.0.61"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c546c80d6be4bc6a00c0f01730c08df82eaa7a7a61f11d656526506112cc1709"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "1.0.61"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c3384250002a6d5af4d114f2845d37b57521033f30d5c3f46c4d70e1197533"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thread_local"
version = "1.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b9ef9bad013ada3808854ceac7b46812a6465ba368859a37e2100283d2d719c"
dependencies = [
 "cfg-if",
 "once_cell",
]

[[package]]
name = "time"
version = "0.3.36"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5dfd88e563464686c916c7e46e623e520ddc6d79fa6641390f2e3fa86e83e885"
dependencies = [
 "deranged",
 "itoa",
 "libc",
 "num-conv",
 "num_threads",
 "powerfmt",
 "serde",
 "time-core",
 "time-macros",
]

[[package]]
name = "time-core"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef927ca75afb808a4d64dd374f00a2adf8d0fcff8e7b184af886c3c87ec4a3f3"

[[package]]
name = "time-macros"
version = "0.2.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f252a68540fde3a3877aeea552b832b40ab9a69e318efd078774a01ddee1ccf"
dependencies = [
 "num-conv",
 "time-core",
]

[[package]]
name = "tinyvec"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "445e881f4f6d382d5f27c034e25eb92edd7c784ceab92a0937db7f2e9471b938"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "titlecase"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38397a8cdb017cfeb48bf6c154d6de975ac69ffeed35980fde199d2ee0842042"
dependencies = [
 "joinery",
 "lazy_static",
 "regex",
]

[[package]]
name = "toml"
version = "0.8.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6f49eb2ab21d2f26bd6db7bf383edc527a7ebaee412d17af4d40fdccd442f335"
dependencies = [
 "serde",
 "serde_spanned",
 "toml_datetime",
 "toml_edit",
]

[[package]]
name = "toml_datetime"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4badfd56924ae69bcc9039335b2e017639ce3f9b001c393c1b2d1ef846ce2cbf"
dependencies = [
 "serde",
]

[[package]]
name = "toml_edit"
version = "0.22.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d59a3a72298453f564e2b111fa896f8d07fabb36f51f06d7e875fc5e0b5a3ef1"
dependencies = [
 "indexmap",
 "serde",
 "serde_spanned",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "trybuild"
version = "1.0.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6ae08be68c056db96f0e6c6dd820727cca756ced9e1f4cc7fdd20e2a55e23898"
dependencies = [
 "glob",
 "serde",
 "serde_derive",
 "serde_json",
 "target-triple",
 "termcolor",
 "toml",
]

[[package]]
name = "trycmd"
version = "0.15.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8b5cf29388862aac065d6597ac9c8e842d1cc827cb50f7c32f11d29442eaae4"
dependencies = [
 "anstream",
 "automod",
 "glob",
 "humantime",
 "humantime-serde",
 "rayon",
 "serde",
 "shlex",
 "snapbox",
 "toml_edit",
]

[[package]]
name = "typeid"
version = "1.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "059d83cc991e7a42fc37bd50941885db0888e34209f8cfd9aab07ddec03bc9cf"

[[package]]
name = "typenum"
version = "1.17.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42ff0bf0c66b8238c6f3b578df37d0b7848e55df8577b3f74f92a69acceeb825"

[[package]]
name = "typetag"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "661d18414ec032a49ece2d56eee03636e43c4e8d577047ab334c0ba892e29aaf"
dependencies = [
 "erased-serde",
 "inventory",
 "once_cell",
 "serde",
 "typetag-impl",
]

[[package]]
name = "typetag-impl"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac73887f47b9312552aa90ef477927ff014d63d1920ca8037c6c1951eab64bb1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "ucd-trie"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed646292ffc8188ef8ea4d1e0e0150fb15a5c2e12ad9b8fc191ae7a8a7f3c4b9"

[[package]]
name = "umask"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec9a46c2549e35c054e0ffe281a3a6ec0007793db4df106604d37ed3f4d73d1c"
dependencies = [
 "thiserror",
]

[[package]]
name = "unic-char-property"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8c57a407d9b6fa02b4795eb81c5b6652060a15a7903ea981f3d723e6c0be221"
dependencies = [
 "unic-char-range",
]

[[package]]
name = "unic-char-range"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0398022d5f700414f6b899e10b8348231abf9173fa93144cbc1a43b9793c1fbc"

[[package]]
name = "unic-common"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "80d7ff825a6a654ee85a63e80f92f054f904f21e7d12da4e22f9834a4aaa35bc"

[[package]]
name = "unic-emoji-char"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b07221e68897210270a38bde4babb655869637af0f69407f96053a34f76494d"
dependencies = [
 "unic-char-property",
 "unic-char-range",
 "unic-ucd-version",
]

[[package]]
name = "unic-ucd-version"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96bd2f2237fe450fcd0a1d2f5f4e91711124f7857ba2e964247776ebeeb7b0c4"
dependencies = [
 "unic-common",
]

[[package]]
name = "unicase"
version = "2.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f7d2d4dafb69621809a81864c9c1b864479e1235c0dd4e199924b9742439ed89"
dependencies = [
 "version_check",
]

[[package]]
name = "unicode-bidi"
version = "0.3.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08f95100a766bf4f8f28f90d77e0a5461bbdb219042e7679bebe79004fed8d75"

[[package]]
name = "unicode-ident"
version = "1.0.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b"

[[package]]
name = "unicode-linebreak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b09c83c3c29d37506a3e260c08c03743a6bb66a9cd432c6934ab501a190571f"

[[package]]
name = "unicode-normalization"
version = "0.1.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a56d1686db2308d901306f92a263857ef59ea39678a5458e7cb17f01415101f5"
dependencies = [
 "tinyvec",
]

[[package]]
name = "unicode-segmentation"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4c87d22b6e3f4a18d4d40ef354e97c90fcb14dd91d7dc0aa9d8a1172ebf7202"

[[package]]
name = "unicode-width"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0336d538f7abc86d282a4189614dfaa90810dfc2c6f6427eaf88e16311dd225d"

[[package]]
name = "unicode-width"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fc81956842c57dac11422a97c3b8195a1ff727f06e85c84ed2e8aa277c9a0fd"

[[package]]
name = "unicode-xid"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c"

[[package]]
name = "unsafe-libyaml"
version = "0.2.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "673aac59facbab8a9007c7f6108d11f63b603f7cabff99fabf650fea5c32b861"

[[package]]
name = "ureq"
version = "2.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72139d247e5f97a3eff96229a7ae85ead5328a39efe76f8bf5a06313d505b6ea"
dependencies = [
 "base64 0.22.1",
 "encoding_rs",
 "flate2",
 "log",
 "native-tls",
 "once_cell",
 "serde",
 "serde_json",
 "url",
]

[[package]]
name = "url"
version = "2.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22784dbdf76fdde8af1aeda5622b546b422b6fc585325248a2bf9f5e41e94d6c"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
]

[[package]]
name = "utf8-width"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86bd8d4e895da8537e5315b8254664e6b769c4ff3db18321b297a1e7004392e3"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "uu_cp"
version = "0.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4c8e090cfcfa51cb224d247e05938d25718a7203c6f8c0f0de7b3b031d99dcea"
dependencies = [
 "clap 4.5.9",
 "filetime",
 "indicatif",
 "libc",
 "quick-error",
 "uucore",
 "walkdir",
 "xattr",
]

[[package]]
name = "uu_mkdir"
version = "0.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dcbf657c9e738d16ebc5c161a611ff25327c1fb599645afb2831062efb23c851"
dependencies = [
 "clap 4.5.9",
 "uucore",
]

[[package]]
name = "uu_mktemp"
version = "0.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "154531208d9ec160629bf9545a56ad9df38e964e547e0a17ee9d75aeec9831cb"
dependencies = [
 "clap 4.5.9",
 "rand",
 "tempfile",
 "uucore",
]

[[package]]
name = "uu_whoami"
version = "0.0.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70589dc3b41f34cbfe1fb22b8f20fcac233fa4565409905f12dd06780b18374d"
dependencies = [
 "clap 4.5.9",
 "libc",
 "uucore",
 "windows-sys 0.48.0",
]

[[package]]
name = "uucore"
version = "0.0.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7b54aad02cf7e96f5fafabb6b836efa73eef934783b17530095a29ffd4fdc154"
dependencies = [
 "clap 4.5.9",
 "dunce",
 "glob",
 "libc",
 "nix 0.28.0",
 "number_prefix",
 "once_cell",
 "os_display",
 "uucore_procs",
 "walkdir",
 "wild",
 "winapi-util",
 "windows-sys 0.48.0",
]

[[package]]
name = "uucore_procs"
version = "0.0.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3d588f57acb2ba416e072a6fa652f2e11cf727267c697d2e2d65175f3b10c41"
dependencies = [
 "proc-macro2",
 "quote",
 "uuhelp_parser",
]

[[package]]
name = "uuhelp_parser"
version = "0.0.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96f26868814bf1ca9deec910a08007c93eb1d8e407ce36451999d4c1c1ea6767"

[[package]]
name = "uuid"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81dfa00651efa65069b0b6b651f4aaa31ba9e3c3ce0137aaad053604ee7e0314"
dependencies = [
 "getrandom",
]

[[package]]
name = "vcpkg"
version = "0.2.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "accd4ea62f7bb7a82fe23066fb0957d48ef677f6eeb8215f372f52e48bb32426"

[[package]]
name = "version_check"
version = "0.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"

[[package]]
name = "vt100"
version = "0.15.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "84cd863bf0db7e392ba3bd04994be3473491b31e66340672af5d11943c6274de"
dependencies = [
 "itoa",
 "log",
 "unicode-width 0.1.13",
 "vte 0.11.1",
]

[[package]]
name = "vte"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6cbce692ab4ca2f1f3047fcf732430249c0e971bfdd2b234cf2c47ad93af5983"
dependencies = [
 "arrayvec 0.5.2",
 "utf8parse",
 "vte_generate_state_changes",
]

[[package]]
name = "vte"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f5022b5fbf9407086c180e9557be968742d839e68346af7792b8592489732197"
dependencies = [
 "arrayvec 0.7.4",
 "utf8parse",
 "vte_generate_state_changes",
]

[[package]]
name = "vte_generate_state_changes"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e369bee1b05d510a7b4ed645f5faa90619e05437111783ea5848f28d97d3c2e"
dependencies = [
 "proc-macro2",
 "quote",
]

[[package]]
name = "wait-timeout"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6"
dependencies = [
 "libc",
]

[[package]]
name = "walkdir"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "29790946404f91d9c5d06f9874efddea1dc06c5efe94541a7d6863108e3a5e4b"
dependencies = [
 "same-file",
 "winapi-util",
]

[[package]]
name = "wasi"
version = "0.11.0+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423"

[[package]]
name = "wasm-bindgen"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4be2531df63900aeb2bca0daaaddec08491ee64ceecbee5076636a3b026795a8"
dependencies = [
 "cfg-if",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "614d787b966d3989fa7bb98a654e369c762374fd3213d212cfc0251257e747da"
dependencies = [
 "bumpalo",
 "log",
 "once_cell",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a1f8823de937b71b9460c0c34e25f3da88250760bec0ebac694b49997550d726"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e94f17b526d0a461a191c78ea52bbce64071ed5c04c9ffe424dcb38f74171bb7"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.92"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "af190c94f2773fdb3729c55b007a722abb5384da03bc0986df4c289bf5567e96"

[[package]]
name = "wax"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d12a78aa0bab22d2f26ed1a96df7ab58e8a93506a3e20adb47c51a93b4e1357"
dependencies = [
 "const_format",
 "itertools 0.11.0",
 "nom",
 "pori",
 "regex",
 "thiserror",
 "walkdir",
]

[[package]]
name = "which"
version = "4.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "87ba24419a2078cd2b0f2ede2691b6c66d8e47836da3b6db8265ebad47afbfc7"
dependencies = [
 "either",
 "home",
 "once_cell",
 "rustix",
]

[[package]]
name = "which"
version = "5.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9bf3ea8596f3a0dd5980b46430f2058dfe2c36a27ccfbb1845d6fbfcd9ba6e14"
dependencies = [
 "either",
 "home",
 "once_cell",
 "rustix",
 "windows-sys 0.48.0",
]

[[package]]
name = "wild"
version = "2.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a3131afc8c575281e1e80f36ed6a092aa502c08b18ed7524e86fbbb12bb410e1"
dependencies = [
 "glob",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-util"
version = "0.1.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4d4cc384e1e73b93bafa6fb4f1df8c41695c8a91cf9c4c64358067d15a7b6c6b"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e686886bc078bc1b0b600cac0147aadb815089b6e4da64016cbd754b6342700f"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-core"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.48.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "677d2418bec65e3338edb076e806bc1ec15693c5d0104683f2efe857f61056a9"
dependencies = [
 "windows-targets 0.48.5",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets 0.52.6",
]

[[package]]
name = "windows-targets"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9a2fa6e2155d7247be68c096456083145c183cbbbc2764150dda45a87197940c"
dependencies = [
 "windows_aarch64_gnullvm 0.48.5",
 "windows_aarch64_msvc 0.48.5",
 "windows_i686_gnu 0.48.5",
 "windows_i686_msvc 0.48.5",
 "windows_x86_64_gnu 0.48.5",
 "windows_x86_64_gnullvm 0.48.5",
 "windows_x86_64_msvc 0.48.5",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm 0.52.6",
 "windows_aarch64_msvc 0.52.6",
 "windows_i686_gnu 0.52.6",
 "windows_i686_gnullvm",
 "windows_i686_msvc 0.52.6",
 "windows_x86_64_gnu 0.52.6",
 "windows_x86_64_gnullvm 0.52.6",
 "windows_x86_64_msvc 0.52.6",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.48.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "winnow"
version = "0.6.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59b5e5f6c299a3c7890b876a2a587f3115162487e704907d9b6cd29473052ba1"
dependencies = [
 "memchr",
]

[[package]]
name = "winreg"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a277a57398d4bfa075df44f501a17cfdf8542d224f0d36095a2adc7aee4ef0a5"
dependencies = [
 "cfg-if",
 "windows-sys 0.48.0",
]

[[package]]
name = "xattr"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8da84f1a25939b27f6820d92aed108f83ff920fdf11a7b19366c27c4cda81d4f"
dependencies = [
 "libc",
 "linux-raw-sys",
 "rustix",
]

[[package]]
name = "xmlparser"
version = "0.13.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "66fee0b777b0f5ac1c69bb06d361268faafa61cd4682ae064a171c16c433e9e4"

[[package]]
name = "zerocopy"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1b9b4fd18abc82b8136838da5d50bae7bdea537c574d8dc1a34ed098d6c166f0"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.7.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fa4f8080344d4671fb4e831a13ad1e68092748387dfc4f55e356242fae12ce3e"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zip"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "760394e246e4c28189f19d488c058bf16f564016aefac5d32bb1f3b51d5e9261"
dependencies = [
 "byteorder",
 "crc32fast",
 "crossbeam-utils",
 "flate2",
]

```

`clap/Cargo.toml`:

```toml
[workspace]
resolver = "2"
members = [
  "clap_bench",
  "clap_builder",
  "clap_derive",
  "clap_lex",
  "clap_complete",
  "clap_complete_nushell",
  "clap_mangen",
]

[workspace.package]
repository = "https://github.com/clap-rs/clap"
license = "MIT OR Apache-2.0"
edition = "2021"
rust-version = "1.74"  # MSRV
include = [
  "build.rs",
  "src/**/*",
  "Cargo.toml",
  "LICENSE*",
  "README.md",
  "benches/**/*",
  "examples/**/*"
]

[workspace.lints.rust]
rust_2018_idioms = { level = "warn", priority = -1 }
unreachable_pub = "warn"
unsafe_op_in_unsafe_fn = "warn"
unused_lifetimes = "warn"
unused_macro_rules = "warn"
unused_qualifications = "warn"

[workspace.lints.clippy]
bool_assert_comparison = "allow"
branches_sharing_code = "allow"
checked_conversions = "warn"
collapsible_else_if = "allow"
create_dir = "warn"
dbg_macro = "warn"
debug_assert_with_mut_call = "warn"
doc_markdown = "warn"
empty_enum = "warn"
enum_glob_use = "warn"
expl_impl_clone_on_copy = "warn"
explicit_deref_methods = "warn"
explicit_into_iter_loop = "warn"
fallible_impl_from = "warn"
filter_map_next = "warn"
flat_map_option = "warn"
float_cmp_const = "warn"
fn_params_excessive_bools = "warn"
from_iter_instead_of_collect = "warn"
if_same_then_else = "allow"
implicit_clone = "warn"
imprecise_flops = "warn"
inconsistent_struct_constructor = "warn"
inefficient_to_string = "warn"
infinite_loop = "warn"
invalid_upcast_comparisons = "warn"
large_digit_groups = "warn"
large_stack_arrays = "warn"
large_types_passed_by_value = "warn"
let_and_return = "allow"  # sometimes good to name what you are returning
linkedlist = "warn"
lossy_float_literal = "warn"
macro_use_imports = "warn"
mem_forget = "warn"
mutex_integer = "warn"
needless_continue = "warn"
needless_for_each = "warn"
negative_feature_names = "warn"
path_buf_push_overwrite = "warn"
ptr_as_ptr = "warn"
rc_mutex = "warn"
redundant_feature_names = "warn"
ref_option_ref = "warn"
rest_pat_in_fully_bound_structs = "warn"
same_functions_in_if_condition = "warn"
self_named_module_files = "warn"
semicolon_if_nothing_returned = "warn"
# str_to_string = "warn"
# string_add = "warn"
string_add_assign = "warn"
string_lit_as_bytes = "warn"
# string_to_string = "warn"
todo = "warn"
trait_duplication_in_bounds = "warn"
uninlined_format_args = "warn"
verbose_file_reads = "warn"
# wildcard_imports = "warn"
zero_sized_map_values = "warn"
# Fix later:
multiple_bound_locations = "allow"
assigning_clones = "allow"
blocks_in_conditions = "allow"

[package]
name = "clap"
version = "4.5.36"
description = "A simple to use, efficient, and full-featured Command Line Argument Parser"
categories = ["command-line-interface"]
keywords = [
  "argument",
  "cli",
  "arg",
  "parser",
  "parse"
]
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
include.workspace = true

[package.metadata.docs.rs]
features = ["unstable-doc"]
rustdoc-args = ["--cfg", "docsrs", "--generate-link-to-definition"]

[package.metadata.playground]
features = ["unstable-doc"]

[package.metadata.release]
shared-version = true
tag-name = "v{{version}}"
pre-release-replacements = [
  {file="CHANGELOG.md", search="Unreleased", replace="{{version}}", min=1},
  {file="CHANGELOG.md", search="\\.\\.\\.HEAD", replace="...{{tag_name}}", exactly=1},
  {file="CHANGELOG.md", search="ReleaseDate", replace="{{date}}", min=1},
  {file="CHANGELOG.md", search="<!-- next-header -->", replace="<!-- next-header -->\n## [Unreleased] - ReleaseDate\n", exactly=1},
  {file="CHANGELOG.md", search="<!-- next-url -->", replace="<!-- next-url -->\n[Unreleased]: https://github.com/clap-rs/clap/compare/{{tag_name}}...HEAD", exactly=1},
  {file="CITATION.cff", search="^date-released: ....-..-..", replace="date-released: {{date}}"},
  {file="CITATION.cff", search="^version: .+\\..+\\..+", replace="version: {{version}}"},
  {file="src/lib.rs", search="blob/v.+\\..+\\..+/CHANGELOG.md", replace="blob/v{{version}}/CHANGELOG.md", exactly=1},
]

[features]
default = [
  "std",
  "color",
  "help",
  "usage",
  "error-context",
  "suggestions",
]
debug = ["clap_builder/debug", "clap_derive?/debug"] # Enables debug messages
unstable-doc = ["clap_builder/unstable-doc", "derive"] # for docs.rs

# Used in default
std = ["clap_builder/std"] # support for no_std in a backwards-compatible way
color = ["clap_builder/color"]
help = ["clap_builder/help"]
usage = ["clap_builder/usage"]
error-context = ["clap_builder/error-context"]
suggestions = ["clap_builder/suggestions"]

# Optional
deprecated = ["clap_builder/deprecated", "clap_derive?/deprecated"] # Guided experience to prepare for next breaking release (at different stages of development, this may become default)
derive = ["dep:clap_derive"]
cargo = ["clap_builder/cargo"] # Disable if you're not using Cargo, enables Cargo-env-var-dependent macros
wrap_help = ["clap_builder/wrap_help"]
env = ["clap_builder/env"] # Use environment variables during arg parsing
unicode = ["clap_builder/unicode"]  # Support for unicode characters in arguments and help messages
string = ["clap_builder/string"]  # Allow runtime generated strings

# In-work features
unstable-v5 = ["clap_builder/unstable-v5", "clap_derive?/unstable-v5", "deprecated"]
unstable-ext = ["clap_builder/unstable-ext"]
unstable-styles = ["clap_builder/unstable-styles"]  # deprecated
unstable-derive-ui-tests = []
unstable-markdown = ["clap_derive/unstable-markdown"]

[lib]
bench = false

[dependencies]
clap_builder = { path = "./clap_builder", version = "=4.5.36", default-features = false }
clap_derive = { path = "./clap_derive", version = "=4.5.32", optional = true }

[dev-dependencies]
trybuild = "1.0.91"
rustversion = "1.0.15"
# Cutting out `filesystem` feature
trycmd = { version = "0.15.3", default-features = false, features = ["color-auto", "diff", "examples"] }
jiff = "0.2.3"
snapbox = { version = "0.6.16", features = ["term-svg"] }
shlex = "1.3.0"
automod = "1.0.14"
clap-cargo = { version = "0.15.0", default-features = false }

[[example]]
name = "demo"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "cargo-example"
required-features = ["cargo", "color"]
doc-scrape-examples = true

[[example]]
name = "cargo-example-derive"
required-features = ["derive", "color"]
doc-scrape-examples = true

[[example]]
name = "escaped-positional"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "escaped-positional-derive"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "find"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "git-derive"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "typed-derive"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "busybox"
path = "examples/multicall-busybox.rs"
doc-scrape-examples = true

[[example]]
name = "hostname"
path = "examples/multicall-hostname.rs"
doc-scrape-examples = true

[[example]]
name = "repl"
path = "examples/repl.rs"
required-features = ["help"]
doc-scrape-examples = true

[[example]]
name = "repl-derive"
path = "examples/repl-derive.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "01_quick"
path = "examples/tutorial_builder/01_quick.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "02_apps"
path = "examples/tutorial_builder/02_apps.rs"
doc-scrape-examples = true

[[example]]
name = "02_crate"
path = "examples/tutorial_builder/02_crate.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "02_app_settings"
path = "examples/tutorial_builder/02_app_settings.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "03_01_flag_bool"
path = "examples/tutorial_builder/03_01_flag_bool.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "03_01_flag_count"
path = "examples/tutorial_builder/03_01_flag_count.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "03_02_option"
path = "examples/tutorial_builder/03_02_option.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "03_02_option_mult"
path = "examples/tutorial_builder/03_02_option_mult.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "03_03_positional"
path = "examples/tutorial_builder/03_03_positional.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "03_03_positional_mult"
path = "examples/tutorial_builder/03_03_positional_mult.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "03_04_subcommands"
path = "examples/tutorial_builder/03_04_subcommands.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "03_05_default_values"
path = "examples/tutorial_builder/03_05_default_values.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "03_06_required"
path = "examples/tutorial_builder/03_06_required.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "04_01_possible"
path = "examples/tutorial_builder/04_01_possible.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "04_01_enum"
path = "examples/tutorial_builder/04_01_enum.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "04_02_parse"
path = "examples/tutorial_builder/04_02_parse.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "04_02_validate"
path = "examples/tutorial_builder/04_02_validate.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "04_03_relations"
path = "examples/tutorial_builder/04_03_relations.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "04_04_custom"
path = "examples/tutorial_builder/04_04_custom.rs"
required-features = ["cargo"]
doc-scrape-examples = true

[[example]]
name = "05_01_assert"
path = "examples/tutorial_builder/05_01_assert.rs"
required-features = ["cargo"]
test = true
doc-scrape-examples = true

[[example]]
name = "01_quick_derive"
path = "examples/tutorial_derive/01_quick.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "02_apps_derive"
path = "examples/tutorial_derive/02_apps.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "02_crate_derive"
path = "examples/tutorial_derive/02_crate.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "02_app_settings_derive"
path = "examples/tutorial_derive/02_app_settings.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_01_flag_bool_derive"
path = "examples/tutorial_derive/03_01_flag_bool.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_01_flag_count_derive"
path = "examples/tutorial_derive/03_01_flag_count.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_02_option_derive"
path = "examples/tutorial_derive/03_02_option.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_02_option_mult_derive"
path = "examples/tutorial_derive/03_02_option_mult.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_03_positional_derive"
path = "examples/tutorial_derive/03_03_positional.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_03_positional_mult_derive"
path = "examples/tutorial_derive/03_03_positional_mult.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_04_subcommands_derive"
path = "examples/tutorial_derive/03_04_subcommands.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_04_subcommands_alt_derive"
path = "examples/tutorial_derive/03_04_subcommands_alt.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_05_default_values_derive"
path = "examples/tutorial_derive/03_05_default_values.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "03_06_optional_derive"
path = "examples/tutorial_derive/03_06_optional.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "04_01_enum_derive"
path = "examples/tutorial_derive/04_01_enum.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "04_02_parse_derive"
path = "examples/tutorial_derive/04_02_parse.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "04_02_validate_derive"
path = "examples/tutorial_derive/04_02_validate.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "04_03_relations_derive"
path = "examples/tutorial_derive/04_03_relations.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "04_04_custom_derive"
path = "examples/tutorial_derive/04_04_custom.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "05_01_assert_derive"
path = "examples/tutorial_derive/05_01_assert.rs"
required-features = ["derive"]
test = true
doc-scrape-examples = true

[[example]]
name = "interop_augment_args"
path = "examples/derive_ref/augment_args.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "interop_augment_subcommands"
path = "examples/derive_ref/augment_subcommands.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "interop_hand_subcommand"
path = "examples/derive_ref/hand_subcommand.rs"
required-features = ["derive"]
doc-scrape-examples = true

[[example]]
name = "interop_flatten_hand_args"
path = "examples/derive_ref/flatten_hand_args.rs"
required-features = ["derive"]
doc-scrape-examples = true

[profile.test]
opt-level = 1

[profile.bench]
lto = true
codegen-units = 1

[lints]
workspace = true

```

`clap/LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


```

`clap/LICENSE-MIT`:

```
Copyright (c) Individual contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`clap/Makefile`:

```
# CI Steps
#
# Considerations
# - Easy to debug: show the command being run
# - Leverage CI features: Only run individual steps so we can use features like reporting elapsed time per step

ARGS?=--workspace
TOOLCHAIN_TARGET ?=
ifneq (${TOOLCHAIN_TARGET},)
  ARGS+=--target ${TOOLCHAIN_TARGET}
endif

STABLE?=1.86

_FEATURES = minimal default wasm full debug release
_FEATURES_minimal = --no-default-features --features "std"
_FEATURES_default =
_FEATURES_wasm = --no-default-features --features "std help usage error-context suggestions" --features "deprecated derive cargo env unicode string"
_FEATURES_full = --features "deprecated derive cargo env unicode string wrap_help unstable-ext"
_FEATURES_next = ${_FEATURES_full} --features "unstable-v5 unstable-markdown"
_FEATURES_debug = ${_FEATURES_full} --features debug --features clap_complete/debug
_FEATURES_release = ${_FEATURES_full} --release

check-wasm:
	cargo check ${_FEATURES_${@:check-%=%}} ${ARGS}

check-%:
	cargo check ${_FEATURES_${@:check-%=%}} --all-targets ${ARGS}

build-%:
	cargo test ${_FEATURES_${@:build-%=%}} --all-targets --no-run ${ARGS}

test-%:
	cargo test ${_FEATURES_${@:test-%=%}} ${ARGS}

clippy-%:
	cargo clippy ${_FEATURES_${@:clippy-%=%}} ${ARGS} --all-targets -- -D warnings -A deprecated

test-ui-%:
	cargo +${STABLE} test --test derive_ui --features derive,unstable-derive-ui-tests ${_FEATURES_${@:test-ui-%=%}}

doc:
	cargo doc --workspace --all-features --no-deps --document-private-items

```

`clap/README.md`:

```md
# clap

> **Command Line Argument Parser for Rust**

[![Crates.io](https://img.shields.io/crates/v/clap?style=flat-square)](https://crates.io/crates/clap)
[![Crates.io](https://img.shields.io/crates/d/clap?style=flat-square)](https://crates.io/crates/clap)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue?style=flat-square)](LICENSE-APACHE)
[![License](https://img.shields.io/badge/license-MIT-blue?style=flat-square)](LICENSE-MIT)
[![Build Status](https://img.shields.io/github/actions/workflow/status/clap-rs/clap/ci.yml?branch=master&style=flat-square)](https://github.com/clap-rs/clap/actions/workflows/ci.yml?query=branch%3Amaster)
[![Coverage Status](https://img.shields.io/coveralls/github/clap-rs/clap/master?style=flat-square)](https://coveralls.io/github/clap-rs/clap?branch=master)
[![Contributors](https://img.shields.io/github/contributors/clap-rs/clap?style=flat-square)](https://github.com/clap-rs/clap/graphs/contributors)

Dual-licensed under [Apache 2.0](LICENSE-APACHE) or [MIT](LICENSE-MIT).

## About

Create your command-line parser, with all of the bells and whistles, declaratively or procedurally.

For more details, see:
- [docs.rs](https://docs.rs/clap/latest/clap/)
- [examples](examples/)

## Sponsors

<!-- omit in TOC -->
### Gold

[![](https://opencollective.com/clap/tiers/gold.svg?avatarHeight=36&width=600)](https://opencollective.com/clap)

<!-- omit in TOC -->
### Silver

[![](https://opencollective.com/clap/tiers/silver.svg?avatarHeight=36&width=600)](https://opencollective.com/clap)

<!-- omit in TOC -->
### Bronze

[![](https://opencollective.com/clap/tiers/bronze.svg?avatarHeight=36&width=600)](https://opencollective.com/clap)

<!-- omit in TOC -->
### Backer

[![](https://opencollective.com/clap/tiers/backer.svg?avatarHeight=36&width=600)](https://opencollective.com/clap)

```

`clap/clap_bench/Cargo.toml`:

```toml
[package]
name = "clap_bench"
version = "0.0.0"
description = "Benchmarks for clap"
publish = false
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
include.workspace = true

[package.metadata.release]
release = false

[dev-dependencies]
clap = { path = "../", version = "4.0.0", default-features = false, features = ["std", "help"] }
divan = "0.1.14"
lazy_static = "1.4.0"

[[bench]]
harness = false
name = "empty"

[[bench]]
harness = false
name = "simple"

[[bench]]
harness = false
name = "complex"

[[bench]]
harness = false
name = "rustup"

[[bench]]
harness = false
name = "ripgrep"

[lints]
workspace = true

```

`clap/clap_bench/benches/complex.rs`:

```rs
#![allow(elided_lifetimes_in_paths)] // needed for divan

use clap::{arg, ArgMatches, Command};

macro_rules! create_app {
    () => {{
        Command::new("claptests")
            .version("0.1")
            .about("tests clap library")
            .author("Kevin K. <kbknapp@gmail.com>")
            .arg(arg!(-o --option <opt> ... "tests options"))
            .arg(arg!([positional] "tests positionals"))
            .arg(arg!(-f --flag ... "tests flags").global(true))
            .args([
                arg!(flag2: -F "tests flags with exclusions")
                    .conflicts_with("flag")
                    .requires("option2"),
                arg!(option2: --"long-option-2" <option2> "tests long options with exclusions")
                    .conflicts_with("option")
                    .requires("positional2"),
                arg!([positional2] "tests positionals with exclusions"),
                arg!(-O --Option <option3> "tests options with specific value sets")
                    .value_parser(["fast", "slow"]),
                arg!([positional3] ... "tests positionals with specific values")
                    .value_parser(["vi", "emacs"]),
                arg!(--multvals <s> "Tests multiple values not mult occs").value_names(["one", "two"]),
                arg!(
                    --multvalsmo <s> "Tests multiple values, not mult occs"
                ).required(false).value_names(["one", "two"]),
                arg!(--minvals2 <minvals> ... "Tests 2 min vals").num_args(2..),
                arg!(--maxvals3 <maxvals> ... "Tests 3 max vals").num_args(1..=3),
            ])
            .subcommand(
                Command::new("subcmd")
                    .about("tests subcommands")
                    .version("0.1")
                    .author("Kevin K. <kbknapp@gmail.com>")
                    .arg(arg!(-o --option <scoption> ... "tests options"))
                    .arg(arg!([scpositional] "tests positionals"))
            )
    }};
}

#[divan::bench]
fn build() -> Command {
    create_app!()
}

#[divan::bench(args=COMPLEX_ARGS)]
fn startup(args: &Args) -> ArgMatches {
    create_app!().get_matches_from(args.args())
}

#[divan::bench]
fn render_help(bencher: divan::Bencher) {
    let mut cmd = create_app!();
    bencher.bench_local(|| build_help(&mut cmd));
}

fn build_help(cmd: &mut Command) -> String {
    let help = cmd.render_help();
    help.to_string()
}

const COMPLEX_ARGS: &[Args] = &[
    Args("empty", &[""]),
    Args("flag", &["myprog", "-f"]),
    Args("opt", &["myprog", "-o", "option1"]),
    Args("pos", &["myprog", "arg1"]),
    Args("sc", &["myprog", "subcmd"]),
    Args("sc_flag", &["myprog", "subcmd", "-f"]),
    Args("sc_opt", &["myprog", "subcmd", "-o", "option1"]),
    Args("sc_pos", &["myprog", "subcmd", "arg1"]),
    Args(
        "sc_nested",
        &["myprog", "subcmd", "-f", "-o", "option1", "arg1"],
    ),
    Args(
        "mixed1",
        &[
            "myprog",
            "-ff",
            "-o",
            "option1",
            "arg1",
            "-O",
            "fast",
            "arg2",
            "--multvals",
            "one",
            "two",
            "emacs",
        ],
    ),
    Args(
        "mixed2",
        &[
            "myprog",
            "arg1",
            "-f",
            "arg2",
            "--long-option-2",
            "some",
            "-O",
            "slow",
            "--multvalsmo",
            "one",
            "two",
            "--minvals2",
            "3",
            "2",
            "1",
        ],
    ),
];

#[derive(Debug)]
pub struct Args(&'static str, &'static [&'static str]);

impl Args {
    pub const fn name(&self) -> &'static str {
        self.0
    }

    pub const fn args(&self) -> &[&str] {
        self.1
    }
}

impl std::fmt::Display for Args {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.name().fmt(f)
    }
}

fn main() {
    divan::main();
}

```

`clap/clap_bench/benches/empty.rs`:

```rs
#![allow(elided_lifetimes_in_paths)] // needed for divan

use clap::ArgMatches;
use clap::Command;

macro_rules! create_app {
    () => {{
        Command::new("claptests")
    }};
}

#[divan::bench]
fn build() -> Command {
    create_app!()
}

#[divan::bench]
fn startup() -> ArgMatches {
    create_app!().get_matches_from(vec![""])
}

#[divan::bench]
fn render_help(bencher: divan::Bencher) {
    let mut cmd = create_app!();
    bencher.bench_local(|| build_help(&mut cmd));
}

fn build_help(cmd: &mut Command) -> String {
    let help = cmd.render_help();
    help.to_string()
}

fn main() {
    divan::main();
}

```

`clap/clap_bench/benches/ripgrep.rs`:

```rs
//! Used to simulate a fairly large number of options/flags and parsing with thousands of positional
//! args
//!
//! CLI used is adapted from ripgrep 48a8a3a691220f9e5b2b08f4051abe8655ea7e8a

#![allow(elided_lifetimes_in_paths)] // needed for divan

use std::collections::HashMap;

use clap::{value_parser, Arg, ArgAction, ArgMatches, Command};
use lazy_static::lazy_static;

mod build {
    use super::{app_long, app_short, Command};

    #[divan::bench]
    fn short_help() -> Command {
        app_short()
    }

    #[divan::bench]
    fn long_help() -> Command {
        app_long()
    }
}

mod render_help {
    use super::{app_long, app_short, build_help};

    #[divan::bench]
    fn short_help(bencher: divan::Bencher) {
        let mut cmd = app_short();
        bencher.bench_local(|| build_help(&mut cmd));
    }

    #[divan::bench]
    fn long_help(bencher: divan::Bencher) {
        let mut cmd = app_long();
        bencher.bench_local(|| build_help(&mut cmd));
    }
}

mod startup {
    use super::{app_short, ArgMatches};

    #[divan::bench]
    fn simple() -> ArgMatches {
        app_short().get_matches_from(vec!["rg", "pat"])
    }

    #[divan::bench]
    fn complex() -> ArgMatches {
        app_short().get_matches_from(vec![
            "rg",
            "pat",
            "-cFlN",
            "-pqr=some",
            "--null",
            "--no-filename",
            "--no-messages",
            "-SH",
            "-C5",
            "--follow",
            "-e some",
        ])
    }

    #[divan::bench]
    fn xargs() -> ArgMatches {
        app_short().get_matches_from(vec![
            "rg", "pat", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some",
        ])
    }
}

const ABOUT: &str = "
ripgrep (rg) recursively searches your current directory for a regex pattern.

ripgrep's regex engine uses finite automata and guarantees linear time
searching. Because of this, features like backreferences and arbitrary
lookaround are not supported.

Project home page: https://github.com/BurntSushi/ripgrep

Use -h for short descriptions and --help for more details.";

const USAGE: &str = "
    rg [OPTIONS] <pattern> [<path> ...]
    rg [OPTIONS] [-e PATTERN | -f FILE ]... [<path> ...]
    rg [OPTIONS] --files [<path> ...]
    rg [OPTIONS] --type-list";

const TEMPLATE: &str = "\
{name} {version}
{author}
{about}

USAGE:{usage}

ARGS:
{positionals}

OPTIONS:
{options}";

/// Build a clap application with short help strings.
fn app_short() -> Command {
    cmd(false, |k| USAGES[k].short)
}

/// Build a clap application with long help strings.
fn app_long() -> Command {
    cmd(true, |k| USAGES[k].long)
}

/// Build the help text of an application.
fn build_help(cmd: &mut Command) -> String {
    let help = cmd.render_help();
    help.to_string()
}

/// Build a clap application parameterized by usage strings.
///
/// The function given should take a clap argument name and return a help
/// string. `cmd` will panic if a usage string is not defined.
///
/// This is an intentionally stand-alone module so that it can be used easily
/// in a `build.rs` script to build shell completion files.
fn cmd<F>(_next_line_help: bool, doc: F) -> Command
where
    F: Fn(&'static str) -> &'static str,
{
    let arg = |name| Arg::new(name).help(doc(name));
    let flag = |name| arg(name).long(name).action(ArgAction::SetTrue);

    Command::new("ripgrep")
        .author("BurntSushi") // simulating since it's only a bench
        .version("0.4.0") // Simulating
        .about(ABOUT)
        .max_term_width(100)
        .override_usage(USAGE)
        .help_template(TEMPLATE)
        // Handle help/version manually to make their output formatting
        // consistent with short/long views.
        .disable_help_flag(true)
        .disable_version_flag(true)
        .arg(arg("help-short").short('h'))
        .arg(flag("help"))
        .arg(flag("version").short('V'))
        // First, set up primary positional/flag arguments.
        .arg(arg("pattern").required_unless_present_any([
            "file",
            "files",
            "help-short",
            "help",
            "regexp",
            "type-list",
            "version",
        ]))
        .arg(arg("path").num_args(1..))
        .arg(
            flag("regexp")
                .short('e')
                .allow_hyphen_values(true)
                .action(ArgAction::Append)
                .value_name("pattern"),
        )
        .arg(
            flag("files")
                // This should also conflict with `pattern`, but the first file
                // path will actually be in `pattern`.
                .conflicts_with_all(["file", "regexp", "type-list"]),
        )
        .arg(flag("type-list").conflicts_with_all(["file", "files", "pattern", "regexp"]))
        // Second, set up common flags.
        .arg(flag("text").short('a'))
        .arg(flag("count").short('c'))
        .arg(
            flag("color")
                .value_name("WHEN")
                .action(ArgAction::Set)
                .hide_possible_values(true)
                .value_parser(["never", "auto", "always", "ansi"]),
        )
        .arg(flag("colors").value_name("SPEC").action(ArgAction::Append))
        .arg(flag("fixed-strings").short('F'))
        .arg(
            flag("glob")
                .short('g')
                .action(ArgAction::Append)
                .value_name("GLOB"),
        )
        .arg(flag("ignore-case").short('i'))
        .arg(flag("line-number").short('n'))
        .arg(flag("no-line-number").short('N'))
        .arg(flag("quiet").short('q'))
        .arg(
            flag("type")
                .short('t')
                .action(ArgAction::Append)
                .value_name("TYPE"),
        )
        .arg(
            flag("type-not")
                .short('T')
                .action(ArgAction::Append)
                .value_name("TYPE"),
        )
        .arg(flag("unrestricted").short('u').action(ArgAction::Append))
        .arg(flag("invert-match").short('v'))
        .arg(flag("word-regexp").short('w'))
        // Third, set up less common flags.
        .arg(
            flag("after-context")
                .short('A')
                .action(ArgAction::Set)
                .value_name("NUM")
                .value_parser(value_parser!(usize)),
        )
        .arg(
            flag("before-context")
                .short('B')
                .action(ArgAction::Set)
                .value_name("NUM")
                .value_parser(value_parser!(usize)),
        )
        .arg(
            flag("context")
                .short('C')
                .action(ArgAction::Set)
                .value_name("NUM")
                .value_parser(value_parser!(usize)),
        )
        .arg(flag("column"))
        .arg(flag("context-separator").value_name("SEPARATOR"))
        .arg(flag("debug"))
        .arg(
            flag("file")
                .short('f')
                .value_name("FILE")
                .action(ArgAction::Append),
        )
        .arg(flag("files-with-matches").short('l'))
        .arg(flag("files-without-match"))
        .arg(flag("with-filename").short('H'))
        .arg(flag("no-filename"))
        .arg(flag("heading").overrides_with("no-heading"))
        .arg(flag("no-heading").overrides_with("heading"))
        .arg(flag("hidden"))
        .arg(
            flag("ignore-file")
                .value_name("FILE")
                .action(ArgAction::Append),
        )
        .arg(flag("follow").short('L'))
        .arg(
            flag("max-count")
                .short('m')
                .action(ArgAction::Set)
                .value_name("NUM")
                .value_parser(value_parser!(usize)),
        )
        .arg(
            flag("maxdepth")
                .action(ArgAction::Set)
                .value_name("NUM")
                .value_parser(value_parser!(usize)),
        )
        .arg(flag("mmap"))
        .arg(flag("no-messages"))
        .arg(flag("no-mmap"))
        .arg(flag("no-ignore"))
        .arg(flag("no-ignore-parent"))
        .arg(flag("no-ignore-vcs"))
        .arg(flag("null"))
        .arg(flag("path-separator").value_name("SEPARATOR"))
        .arg(flag("pretty").short('p'))
        .arg(
            flag("replace")
                .short('r')
                .action(ArgAction::Set)
                .value_name("ARG"),
        )
        .arg(flag("case-sensitive").short('s'))
        .arg(flag("smart-case").short('S'))
        .arg(flag("sort-files"))
        .arg(
            flag("threads")
                .short('j')
                .action(ArgAction::Set)
                .value_name("ARG")
                .value_parser(value_parser!(usize)),
        )
        .arg(flag("vimgrep"))
        .arg(
            flag("type-add")
                .value_name("TYPE")
                .action(ArgAction::Append),
        )
        .arg(
            flag("type-clear")
                .value_name("TYPE")
                .action(ArgAction::Append),
        )
}

struct Usage {
    short: &'static str,
    long: &'static str,
}

macro_rules! doc {
    ($map:expr, $name:expr, $short:expr) => {
        doc!($map, $name, $short, $short)
    };
    ($map:expr, $name:expr, $short:expr, $long:expr) => {
        $map.insert(
            $name,
            Usage {
                short: $short,
                long: concat!($long, "\n "),
            },
        );
    };
}

lazy_static! {
    static ref USAGES: HashMap<&'static str, Usage> = {
        let mut h = HashMap::new();
        doc!(
            h,
            "help-short",
            "Show short help output.",
            "Show short help output. Use --help to show more details."
        );
        doc!(
            h,
            "help",
            "Show verbose help output.",
            "When given, more details about flags are provided."
        );
        doc!(h, "version", "Print version information.");

        doc!(
            h,
            "pattern",
            "A regular expression used for searching.",
            "A regular expression used for searching. Multiple patterns \
             may be given. To match a pattern beginning with a -, use [-]."
        );
        doc!(
            h,
            "regexp",
            "A regular expression used for searching.",
            "A regular expression used for searching. Multiple patterns \
             may be given. To match a pattern beginning with a -, use [-]."
        );
        doc!(
            h,
            "path",
            "A file or directory to search.",
            "A file or directory to search. Directories are searched \
             recursively."
        );
        doc!(
            h,
            "files",
            "Print each file that would be searched.",
            "Print each file that would be searched without actually \
             performing the search. This is useful to determine whether a \
             particular file is being searched or not."
        );
        doc!(
            h,
            "type-list",
            "Show all supported file types.",
            "Show all supported file types and their corresponding globs."
        );

        doc!(h, "text", "Search binary files as if they were text.");
        doc!(h, "count", "Only show count of matches for each file.");
        doc!(
            h,
            "color",
            "When to use color. [default: auto]",
            "When to use color in the output. The possible values are \
             never, auto, always or ansi. The default is auto. When always \
             is used, coloring is attempted based on your environment. When \
             ansi used, coloring is forcefully done using ANSI escape color \
             codes."
        );
        doc!(
            h,
            "colors",
            "Configure color settings and styles.",
            "This flag specifies color settings for use in the output. \
             This flag may be provided multiple times. Settings are applied \
             iteratively. Colors are limited to one of eight choices: \
             red, blue, green, cyan, magenta, yellow, white and black. \
             Styles are limited to nobold, bold, nointense or intense.\n\n\
             The format of the flag is {type}:{attribute}:{value}. {type} \
             should be one of path, line or match. {attribute} can be fg, bg \
             or style. {value} is either a color (for fg and bg) or a text \
             style. A special format, {type}:none, will clear all color \
             settings for {type}.\n\nFor example, the following command will \
             change the match color to magenta and the background color for \
             line numbers to yellow:\n\n\
             rg --colors 'match:fg:magenta' --colors 'line:bg:yellow' foo."
        );
        doc!(
            h,
            "fixed-strings",
            "Treat the pattern as a literal string.",
            "Treat the pattern as a literal string instead of a regular \
             expression. When this flag is used, special regular expression \
             meta characters such as (){}*+. do not need to be escaped."
        );
        doc!(
            h,
            "glob",
            "Include or exclude files/directories.",
            "Include or exclude files/directories for searching that \
             match the given glob. This always overrides any other \
             ignore logic. Multiple glob flags may be used. Globbing \
             rules match .gitignore globs. Precede a glob with a ! \
             to exclude it."
        );
        doc!(
            h,
            "ignore-case",
            "Case insensitive search.",
            "Case insensitive search. This is overridden by \
             --case-sensitive."
        );
        doc!(
            h,
            "line-number",
            "Show line numbers.",
            "Show line numbers (1-based). This is enabled by default when \
             searching in a tty."
        );
        doc!(
            h,
            "no-line-number",
            "Suppress line numbers.",
            "Suppress line numbers. This is enabled by default when NOT \
             searching in a tty."
        );
        doc!(
            h,
            "quiet",
            "Do not print anything to stdout.",
            "Do not print anything to stdout. If a match is found in a file, \
             stop searching. This is useful when ripgrep is used only for \
             its exit code."
        );
        doc!(
            h,
            "type",
            "Only search files matching TYPE.",
            "Only search files matching TYPE. Multiple type flags may be \
             provided. Use the --type-list flag to list all available \
             types."
        );
        doc!(
            h,
            "type-not",
            "Do not search files matching TYPE.",
            "Do not search files matching TYPE. Multiple type-not flags may \
             be provided. Use the --type-list flag to list all available \
             types."
        );
        doc!(
            h,
            "unrestricted",
            "Reduce the level of \"smart\" searching.",
            "Reduce the level of \"smart\" searching. A single -u \
             won't respect .gitignore (etc.) files. Two -u flags will \
             additionally search hidden files and directories. Three \
             -u flags will additionally search binary files. -uu is \
             roughly equivalent to grep -r and -uuu is roughly \
             equivalent to grep -a -r."
        );
        doc!(
            h,
            "invert-match",
            "Invert matching.",
            "Invert matching. Show lines that don't match given patterns."
        );
        doc!(
            h,
            "word-regexp",
            "Only show matches surrounded by word boundaries.",
            "Only show matches surrounded by word boundaries. This is \
             equivalent to putting \\b before and after all of the search \
             patterns."
        );

        doc!(h, "after-context", "Show NUM lines after each match.");
        doc!(h, "before-context", "Show NUM lines before each match.");
        doc!(h, "context", "Show NUM lines before and after each match.");
        doc!(
            h,
            "column",
            "Show column numbers",
            "Show column numbers (1-based). This only shows the column \
             numbers for the first match on each line. This does not try \
             to account for Unicode. One byte is equal to one column. This \
             implies --line-number."
        );
        doc!(
            h,
            "context-separator",
            "Set the context separator string. [default: --]",
            "The string used to separate non-contiguous context lines in the \
             output. Escape sequences like \\x7F or \\t may be used. The \
             default value is --."
        );
        doc!(
            h,
            "debug",
            "Show debug messages.",
            "Show debug messages. Please use this when filing a bug report."
        );
        doc!(
            h,
            "file",
            "Search for patterns from the given file.",
            "Search for patterns from the given file, with one pattern per \
             line. When this flag is used or multiple times or in \
             combination with the -e/--regexp flag, then all patterns \
             provided are searched. Empty pattern lines will match all input \
             lines, and the newline is not counted as part of the pattern."
        );
        doc!(
            h,
            "files-with-matches",
            "Only show the path of each file with at least one match."
        );
        doc!(
            h,
            "files-without-match",
            "Only show the path of each file that contains zero matches."
        );
        doc!(
            h,
            "with-filename",
            "Show file name for each match.",
            "Prefix each match with the file name that contains it. This is \
             the default when more than one file is searched."
        );
        doc!(
            h,
            "no-filename",
            "Never show the file name for a match.",
            "Never show the file name for a match. This is the default when \
             one file is searched."
        );
        doc!(
            h,
            "heading",
            "Show matches grouped by each file.",
            "This shows the file name above clusters of matches from each \
             file instead of showing the file name for every match. This is \
             the default mode at a tty."
        );
        doc!(
            h,
            "no-heading",
            "Don't group matches by each file.",
            "Don't group matches by each file. If -H/--with-filename is \
             enabled, then file names will be shown for every line matched. \
             This is the default mode when not at a tty."
        );
        doc!(
            h,
            "hidden",
            "Search hidden files and directories.",
            "Search hidden files and directories. By default, hidden files \
             and directories are skipped."
        );
        doc!(
            h,
            "ignore-file",
            "Specify additional ignore files.",
            "Specify additional ignore files for filtering file paths. \
             Ignore files should be in the gitignore format and are matched \
             relative to the current working directory. These ignore files \
             have lower precedence than all other ignore files. When \
             specifying multiple ignore files, earlier files have lower \
             precedence than later files."
        );
        doc!(h, "follow", "Follow symbolic links.");
        doc!(
            h,
            "max-count",
            "Limit the number of matches.",
            "Limit the number of matching lines per file searched to NUM."
        );
        doc!(
            h,
            "maxdepth",
            "Descend at most NUM directories.",
            "Limit the depth of directory traversal to NUM levels beyond \
             the paths given. A value of zero only searches the \
             starting-points themselves.\n\nFor example, \
             'rg --maxdepth 0 dir/' is a no-op because dir/ will not be \
             descended into. 'rg --maxdepth 1 dir/' will search only the \
             direct children of dir/."
        );
        doc!(
            h,
            "mmap",
            "Searching using memory maps when possible.",
            "Search using memory maps when possible. This is enabled by \
             default when ripgrep thinks it will be faster. Note that memory \
             map searching doesn't currently support all options, so if an \
             incompatible option (e.g., --context) is given with --mmap, \
             then memory maps will not be used."
        );
        doc!(
            h,
            "no-messages",
            "Suppress all error messages.",
            "Suppress all error messages. This is equivalent to redirecting \
             stderr to /dev/null."
        );
        doc!(
            h,
            "no-mmap",
            "Never use memory maps.",
            "Never use memory maps, even when they might be faster."
        );
        doc!(
            h,
            "no-ignore",
            "Don't respect ignore files.",
            "Don't respect ignore files (.gitignore, .ignore, etc.). This \
             implies --no-ignore-parent and --no-ignore-vcs."
        );
        doc!(
            h,
            "no-ignore-parent",
            "Don't respect ignore files in parent directories.",
            "Don't respect ignore files (.gitignore, .ignore, etc.) in \
             parent directories."
        );
        doc!(
            h,
            "no-ignore-vcs",
            "Don't respect VCS ignore files",
            "Don't respect version control ignore files (.gitignore, etc.). \
             This implies --no-ignore-parent. Note that .ignore files will \
             continue to be respected."
        );
        doc!(
            h,
            "null",
            "Print NUL byte after file names",
            "Whenever a file name is printed, follow it with a NUL byte. \
             This includes printing file names before matches, and when \
             printing a list of matching files such as with --count, \
             --files-with-matches and --files. This option is useful for use \
             with xargs."
        );
        doc!(
            h,
            "path-separator",
            "Path separator to use when printing file paths.",
            "The path separator to use when printing file paths. This \
             defaults to your platform's path separator, which is / on Unix \
             and \\ on Windows. This flag is intended for overriding the \
             default when the environment demands it (e.g., cygwin). A path \
             separator is limited to a single byte."
        );
        doc!(h, "pretty", "Alias for --color always --heading -n.");
        doc!(
            h,
            "replace",
            "Replace matches with string given.",
            "Replace every match with the string given when printing \
             results. Neither this flag nor any other flag will modify your \
             files.\n\nCapture group indices (e.g., $5) and names \
             (e.g., $foo) are supported in the replacement string.\n\n\
             Note that the replacement by default replaces each match, and \
             NOT the entire line. To replace the entire line, you should \
             match the entire line."
        );
        doc!(
            h,
            "case-sensitive",
            "Search case sensitively.",
            "Search case sensitively. This overrides -i/--ignore-case and \
             -S/--smart-case."
        );
        doc!(
            h,
            "smart-case",
            "Smart case search.",
            "Searches case insensitively if the pattern is all lowercase. \
             Search case sensitively otherwise. This is overridden by \
             either -s/--case-sensitive or -i/--ignore-case."
        );
        doc!(
            h,
            "sort-files",
            "Sort results by file path. Implies --threads=1.",
            "Sort results by file path. Note that this currently \
             disables all parallelism and runs search in a single thread."
        );
        doc!(
            h,
            "threads",
            "The approximate number of threads to use.",
            "The approximate number of threads to use. A value of 0 (which \
             is the default) causes ripgrep to choose the thread count \
             using heuristics."
        );
        doc!(
            h,
            "vimgrep",
            "Show results in vim compatible format.",
            "Show results with every match on its own line, including \
             line numbers and column numbers. With this option, a line with \
             more than one match will be printed more than once."
        );

        doc!(
            h,
            "type-add",
            "Add a new glob for a file type.",
            "Add a new glob for a particular file type. Only one glob can be \
             added at a time. Multiple --type-add flags can be provided. \
             Unless --type-clear is used, globs are added to any existing \
             globs defined inside of ripgrep.\n\nNote that this MUST be \
             passed to every invocation of ripgrep. Type settings are NOT \
             persisted.\n\nExample: \
             rg --type-add 'foo:*.foo' -tfoo PATTERN.\n\n\
             --type-add can also be used to include rules from other types \
             with the special include directive. The include directive \
             permits specifying one or more other type names (separated by a \
             comma) that have been defined and its rules will automatically \
             be imported into the type specified. For example, to create a \
             type called src that matches C++, Python and Markdown files, one \
             can use:\n\n\
             --type-add 'src:include:cpp,py,md'\n\n\
             Additional glob rules can still be added to the src type by \
             using the --type-add flag again:\n\n\
             --type-add 'src:include:cpp,py,md' --type-add 'src:*.foo'\n\n\
             Note that type names must consist only of Unicode letters or \
             numbers. Punctuation characters are not allowed."
        );
        doc!(
            h,
            "type-clear",
            "Clear globs for given file type.",
            "Clear the file type globs previously defined for TYPE. This \
             only clears the default type definitions that are found inside \
             of ripgrep.\n\nNote that this MUST be passed to every \
             invocation of ripgrep. Type settings are NOT persisted."
        );

        h
    };
}

fn main() {
    divan::main();
}

```

`clap/clap_bench/benches/rustup.rs`:

```rs
//! Used to simulate a fairly large number of subcommands
//!
//! CLI used is from rustup 408ed84f0e50511ed44a405dd91365e5da588790

#![allow(elided_lifetimes_in_paths)] // needed for divan

use clap::{Arg, ArgAction, ArgGroup, ArgMatches, Command};

#[divan::bench]
fn build() -> Command {
    build_cli()
}

mod startup {
    use super::{build_cli, ArgMatches};

    #[divan::bench]
    fn empty() -> ArgMatches {
        build_cli().get_matches_from([""])
    }

    #[divan::bench]
    fn sc() -> ArgMatches {
        build_cli().get_matches_from(["rustup override add stable"])
    }
}

fn build_cli() -> Command {
    Command::new("rustup")
        .version("0.9.0") // Simulating
        .about("The Rust toolchain installer")
        .after_help(RUSTUP_HELP)
        .arg(
            Arg::new("verbose")
                .help("Enable verbose output")
                .short('v')
                .long("verbose")
                .action(ArgAction::SetTrue),
        )
        .subcommand(
            Command::new("show")
                .about("Show the active and installed toolchains")
                .after_help(SHOW_HELP),
        )
        .subcommand(
            Command::new("install")
                .about("Update Rust toolchains")
                .after_help(TOOLCHAIN_INSTALL_HELP)
                .hide(true) // synonym for 'toolchain install'
                .arg(Arg::new("toolchain").required(true)),
        )
        .subcommand(
            Command::new("update")
                .about("Update Rust toolchains")
                .after_help(UPDATE_HELP)
                .arg(Arg::new("toolchain").required(true))
                .arg(
                    Arg::new("no-self-update")
                        .help("Don't perform self update when running the `rustup` command")
                        .long("no-self-update")
                        .action(ArgAction::SetTrue)
                        .hide(true),
                ),
        )
        .subcommand(
            Command::new("default")
                .about("Set the default toolchain")
                .after_help(DEFAULT_HELP)
                .arg(Arg::new("toolchain").required(true)),
        )
        .subcommand(
            Command::new("toolchain")
                .about("Modify or query the installed toolchains")
                .after_help(TOOLCHAIN_HELP)
                .subcommand(Command::new("list").about("List installed toolchains"))
                .subcommand(
                    Command::new("install")
                        .about("Install or update a given toolchain")
                        .arg(Arg::new("toolchain").required(true)),
                )
                .subcommand(
                    Command::new("uninstall")
                        .about("Uninstall a toolchain")
                        .arg(Arg::new("toolchain").required(true)),
                )
                .subcommand(
                    Command::new("link")
                        .about("Create a custom toolchain by symlinking to a directory")
                        .arg(Arg::new("toolchain").required(true))
                        .arg(Arg::new("path").required(true)),
                )
                .subcommand(
                    Command::new("update")
                        .hide(true) // synonym for 'install'
                        .arg(Arg::new("toolchain").required(true)),
                )
                .subcommand(
                    Command::new("add")
                        .hide(true) // synonym for 'install'
                        .arg(Arg::new("toolchain").required(true)),
                )
                .subcommand(
                    Command::new("remove")
                        .hide(true) // synonym for 'uninstall'
                        .arg(Arg::new("toolchain").required(true)),
                ),
        )
        .subcommand(
            Command::new("target")
                .about("Modify a toolchain's supported targets")
                .subcommand(
                    Command::new("list")
                        .about("List installed and available targets")
                        .arg(
                            Arg::new("toolchain")
                                .long("toolchain")
                                .action(ArgAction::Set),
                        ),
                )
                .subcommand(
                    Command::new("add")
                        .about("Add a target to a Rust toolchain")
                        .arg(Arg::new("target").required(true))
                        .arg(
                            Arg::new("toolchain")
                                .long("toolchain")
                                .action(ArgAction::Set),
                        ),
                )
                .subcommand(
                    Command::new("remove")
                        .about("Remove a target  from a Rust toolchain")
                        .arg(Arg::new("target").required(true))
                        .arg(
                            Arg::new("toolchain")
                                .long("toolchain")
                                .action(ArgAction::Set),
                        ),
                )
                .subcommand(
                    Command::new("install")
                        .hide(true) // synonym for 'add'
                        .arg(Arg::new("target").required(true))
                        .arg(
                            Arg::new("toolchain")
                                .long("toolchain")
                                .action(ArgAction::Set),
                        ),
                )
                .subcommand(
                    Command::new("uninstall")
                        .hide(true) // synonym for 'remove'
                        .arg(Arg::new("target").required(true))
                        .arg(
                            Arg::new("toolchain")
                                .long("toolchain")
                                .action(ArgAction::Set),
                        ),
                ),
        )
        .subcommand(
            Command::new("component")
                .about("Modify a toolchain's installed components")
                .subcommand(
                    Command::new("list")
                        .about("List installed and available components")
                        .arg(
                            Arg::new("toolchain")
                                .long("toolchain")
                                .action(ArgAction::Set),
                        ),
                )
                .subcommand(
                    Command::new("add")
                        .about("Add a component to a Rust toolchain")
                        .arg(Arg::new("component").required(true))
                        .arg(
                            Arg::new("toolchain")
                                .long("toolchain")
                                .action(ArgAction::Set),
                        )
                        .arg(Arg::new("target").long("target").action(ArgAction::Set)),
                )
                .subcommand(
                    Command::new("remove")
                        .about("Remove a component from a Rust toolchain")
                        .arg(Arg::new("component").required(true))
                        .arg(
                            Arg::new("toolchain")
                                .long("toolchain")
                                .action(ArgAction::Set),
                        )
                        .arg(Arg::new("target").long("target").action(ArgAction::Set)),
                ),
        )
        .subcommand(
            Command::new("override")
                .about("Modify directory toolchain overrides")
                .after_help(OVERRIDE_HELP)
                .subcommand(Command::new("list").about("List directory toolchain overrides"))
                .subcommand(
                    Command::new("set")
                        .about("Set the override toolchain for a directory")
                        .arg(Arg::new("toolchain").required(true)),
                )
                .subcommand(
                    Command::new("unset")
                        .about("Remove the override toolchain for a directory")
                        .after_help(OVERRIDE_UNSET_HELP)
                        .arg(
                            Arg::new("path")
                                .long("path")
                                .action(ArgAction::Set)
                                .help("Path to the directory"),
                        )
                        .arg(
                            Arg::new("nonexistent")
                                .long("nonexistent")
                                .action(ArgAction::SetTrue)
                                .help("Remove override toolchain for all nonexistent directories"),
                        ),
                )
                .subcommand(
                    Command::new("add")
                        .hide(true) // synonym for 'set'
                        .arg(Arg::new("toolchain").required(true)),
                )
                .subcommand(
                    Command::new("remove")
                        .hide(true) // synonym for 'unset'
                        .about("Remove the override toolchain for a directory")
                        .arg(Arg::new("path").long("path").action(ArgAction::Set))
                        .arg(
                            Arg::new("nonexistent")
                                .long("nonexistent")
                                .action(ArgAction::SetTrue)
                                .help("Remove override toolchain for all nonexistent directories"),
                        ),
                ),
        )
        .subcommand(
            Command::new("run")
                .about("Run a command with an environment configured for a given toolchain")
                .after_help(RUN_HELP)
                .arg(Arg::new("toolchain").required(true))
                .arg(
                    Arg::new("command")
                        .required(true)
                        .num_args(1..)
                        .trailing_var_arg(true),
                ),
        )
        .subcommand(
            Command::new("which")
                .about("Display which binary will be run for a given command")
                .arg(Arg::new("command").required(true)),
        )
        .subcommand(
            Command::new("doc")
                .about("Open the documentation for the current toolchain")
                .after_help(DOC_HELP)
                .arg(
                    Arg::new("book")
                        .long("book")
                        .action(ArgAction::SetTrue)
                        .help("The Rust Programming Language book"),
                )
                .arg(
                    Arg::new("std")
                        .long("std")
                        .action(ArgAction::SetTrue)
                        .help("Standard library API documentation"),
                )
                .group(ArgGroup::new("page").args(["book", "std"])),
        )
        .subcommand(
            Command::new("man")
                .about("View the man page for a given command")
                .arg(Arg::new("command").required(true))
                .arg(
                    Arg::new("toolchain")
                        .long("toolchain")
                        .action(ArgAction::Set),
                ),
        )
        .subcommand(
            Command::new("self")
                .about("Modify the rustup installation")
                .subcommand(Command::new("update").about("Download and install updates to rustup"))
                .subcommand(
                    Command::new("uninstall")
                        .about("Uninstall rustup.")
                        .arg(Arg::new("no-prompt").short('y').action(ArgAction::SetTrue)),
                )
                .subcommand(
                    Command::new("upgrade-data").about("Upgrade the internal data format."),
                ),
        )
        .subcommand(
            Command::new("telemetry")
                .about("rustup telemetry commands")
                .hide(true)
                .subcommand(Command::new("enable").about("Enable rustup telemetry"))
                .subcommand(Command::new("disable").about("Disable rustup telemetry"))
                .subcommand(Command::new("analyze").about("Analyze stored telemetry")),
        )
        .subcommand(
            Command::new("set")
                .about("Alter rustup settings")
                .subcommand(
                    Command::new("default-host")
                        .about("The triple used to identify toolchains when not specified")
                        .arg(Arg::new("host_triple").required(true)),
                ),
        )
}

static RUSTUP_HELP: &str = r"
rustup installs The Rust Programming Language from the official
release channels, enabling you to easily switch between stable, beta,
and nightly compilers and keep them updated. It makes cross-compiling
simpler with binary builds of the standard library for common platforms.

If you are new to Rust consider running `rustup doc --book`
to learn Rust.";

static SHOW_HELP: &str = r"
Shows the name of the active toolchain and the version of `rustc`.

If the active toolchain has installed support for additional
compilation targets, then they are listed as well.

If there are multiple toolchains installed then all installed
toolchains are listed as well.";

static UPDATE_HELP: &str = r"
With no toolchain specified, the `update` command updates each of the
installed toolchains from the official release channels, then updates
rustup itself.

If given a toolchain argument then `update` updates that toolchain,
the same as `rustup toolchain install`.

'toolchain' specifies a toolchain name, such as 'stable', 'nightly',
or '1.8.0'. For more information see `rustup help toolchain`.";

static TOOLCHAIN_INSTALL_HELP: &str = r"
Installs a specific rust toolchain.

The 'install' command is an alias for 'rustup update <toolchain>'.

'toolchain' specifies a toolchain name, such as 'stable', 'nightly',
or '1.8.0'. For more information see `rustup help toolchain`.";

static DEFAULT_HELP: &str = r"
Sets the default toolchain to the one specified. If the toolchain is
not already installed then it is installed first.";

static TOOLCHAIN_HELP: &str = r"
Many `rustup` commands deal with *toolchains*, a single installation
of the Rust compiler. `rustup` supports multiple types of
toolchains. The most basic track the official release channels:
'stable', 'beta' and 'nightly'; but `rustup` can also install
toolchains from the official archives, for alternate host platforms,
and from local builds.

Standard release channel toolchain names have the following form:

    <channel>[-<date>][-<host>]

    <channel>       = stable|beta|nightly|<version>
    <date>          = YYYY-MM-DD
    <host>          = <target-triple>

'channel' is either a named release channel or an explicit version
number, such as '1.8.0'. Channel names can be optionally appended with
an archive date, as in 'nightly-2014-12-18', in which case the
toolchain is downloaded from the archive for that date.

Finally, the host may be specified as a target triple. This is most
useful for installing a 32-bit compiler on a 64-bit platform, or for
installing the [MSVC-based toolchain] on Windows. For example:

    rustup toolchain install stable-x86_64-pc-windows-msvc

For convenience, elements of the target triple that are omitted will be
inferred, so the above could be written:

    $ rustup default stable-msvc

Toolchain names that don't name a channel instead can be used to name
custom toolchains with the `rustup toolchain link` command.";

static OVERRIDE_HELP: &str = r"
Overrides configure rustup to use a specific toolchain when
running in a specific directory.

Directories can be assigned their own Rust toolchain with
`rustup override`. When a directory has an override then
any time `rustc` or `cargo` is run inside that directory,
or one of its child directories, the override toolchain
will be invoked.

To pin to a specific nightly:

    rustup override set nightly-2014-12-18

Or a specific stable release:

    rustup override set 1.0.0

To see the active toolchain use `rustup show`. To remove the override
and use the default toolchain again, `rustup override unset`.";

static OVERRIDE_UNSET_HELP: &str = r"
If `--path` argument is present, removes the override toolchain for
the specified directory. If `--nonexistent` argument is present, removes
the override toolchain for all nonexistent directories. Otherwise,
removes the override toolchain for the current directory.";

static RUN_HELP: &str = r"
Configures an environment to use the given toolchain and then runs
the specified program. The command may be any program, not just
rustc or cargo. This can be used for testing arbitrary toolchains
without setting an override.

Commands explicitly proxied by `rustup` (such as `rustc` and `cargo`)
also have a shorthand for this available. The toolchain can be set by
using `+toolchain` as the first argument. These are equivalent:

    cargo +nightly build

    rustup run nightly cargo build";

static DOC_HELP: &str = r"
Opens the documentation for the currently active toolchain with the
default browser.

By default, it opens the documentation index. Use the various flags to
open specific pieces of documentation.";

fn main() {
    divan::main();
}

```

`clap/clap_bench/benches/simple.rs`:

```rs
#![allow(elided_lifetimes_in_paths)] // needed for divan

use clap::{arg, ArgMatches, Command};

macro_rules! create_app {
    () => {{
        Command::new("claptests")
            .version("0.1")
            .about("tests clap library")
            .author("Kevin K. <kbknapp@gmail.com>")
            .arg(arg!(-f --flag         "tests flags"))
            .arg(arg!(-o --option <opt> "tests options"))
            .arg(arg!([positional]      "tests positional"))
    }};
}

#[divan::bench]
fn build() -> Command {
    create_app!()
}

mod startup {
    use super::{arg, ArgMatches, Command};

    #[divan::bench]
    fn flag() -> ArgMatches {
        create_app!().get_matches_from(vec!["myprog", "-f"])
    }

    #[divan::bench]
    fn opt() -> ArgMatches {
        create_app!().get_matches_from(vec!["myprog", "-o", "option1"])
    }

    #[divan::bench]
    fn pos() -> ArgMatches {
        create_app!().get_matches_from(vec!["myprog", "arg1"])
    }
}

#[divan::bench]
fn render_help(bencher: divan::Bencher) {
    let mut cmd = create_app!();
    bencher.bench_local(|| build_help(&mut cmd));
}

fn build_help(cmd: &mut Command) -> String {
    let help = cmd.render_help();
    help.to_string()
}

fn main() {
    divan::main();
}

```

`clap/clap_bench/src/lib.rs`:

```rs
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![forbid(unsafe_code)]
#![warn(clippy::print_stderr)]
#![warn(clippy::print_stdout)]

```

`clap/clap_builder/CONTRIBUTING.md`:

```md
# How to Contribute

See the [clap-wide CONTRIBUTING.md](../CONTRIBUTING.md).  This will contain `clap_builder` specific notes.

```

`clap/clap_builder/Cargo.toml`:

```toml
[package]
name = "clap_builder"
version = "4.5.36"
description = "A simple to use, efficient, and full-featured Command Line Argument Parser"
categories = ["command-line-interface"]
keywords = [
  "argument",
  "cli",
  "arg",
  "parser",
  "parse"
]
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
include.workspace = true

[package.metadata.docs.rs]
features = ["unstable-doc"]
rustdoc-args = ["--cfg", "docsrs"]
cargo-args = ["-Zunstable-options", "-Zrustdoc-scrape-examples"]

[package.metadata.playground]
features = ["unstable-doc"]

[package.metadata.release]
shared-version = true
dependent-version = "upgrade"
tag-name = "v{{version}}"

[features]
default = ["std", "color", "help", "usage", "error-context", "suggestions"]
debug = ["dep:backtrace"] # Enables debug messages
unstable-doc = ["cargo", "wrap_help", "env", "unicode", "string", "unstable-ext"] # for docs.rs

# Used in default
std = ["anstyle/std"] # support for no_std in a backwards-compatible way
color = ["dep:anstream"]
help = []
usage = []
error-context = []
suggestions = ["dep:strsim", "error-context"]

# Optional
deprecated = [] # Guided experience to prepare for next breaking release (at different stages of development, this may become default)
cargo = [] # Disable if you're not using Cargo, enables Cargo-env-var-dependent macros
wrap_help = ["help", "dep:terminal_size"]
env = [] # Use environment variables during arg parsing
unicode = ["dep:unicode-width", "dep:unicase"]  # Support for unicode characters in arguments and help messages
string = []  # Allow runtime generated strings

# In-work features
unstable-v5 = ["deprecated"]
unstable-ext = []
unstable-styles = ["color"]  # deprecated

[lib]
bench = false

[dependencies]
clap_lex = { path = "../clap_lex", version = "0.7.4" }
unicase = { version = "2.6.0", optional = true }
strsim = { version = "0.11.0",  optional = true }
anstream = { version = "0.6.7", optional = true }
anstyle = "1.0.8"
terminal_size = { version = "0.4.0", optional = true }
backtrace = { version = "0.3.73", optional = true }
unicode-width = { version = "0.2.0", optional = true }

[dev-dependencies]
static_assertions = "1.1.0"
unic-emoji-char = "0.9.0"
color-print = "0.3.6"

[lints]
workspace = true

```

`clap/clap_builder/LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`clap/clap_builder/LICENSE-MIT`:

```
The MIT License (MIT)

Copyright (c) 2015-2022 Kevin B. Knapp and Clap Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`clap/clap_builder/README.md`:

```md
# `clap_builder`

Builder implementation for clap.

[docs.rs](https://docs.rs/clap)
- [Derive Tutorial](https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html)
- [Derive Reference](https://docs.rs/clap/latest/clap/_derive/index.html)

## License

Licensed under either of

- Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or <https://www.apache.org/licenses/LICENSE-2.0>)
- MIT license ([LICENSE-MIT](LICENSE-MIT) or <https://opensource.org/licenses/MIT>)

at your option.

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as above, without any additional terms or conditions.

See [CONTRIBUTING](CONTRIBUTING.md) for more details.

```

`clap/clap_builder/src/builder/action.rs`:

```rs
#[cfg(debug_assertions)]
use crate::util::AnyValueId;

use crate::builder::ValueRange;

/// Behavior of arguments when they are encountered while parsing
///
/// # Examples
///
/// ```rust
/// # #[cfg(feature = "help")] {
/// # use clap_builder as clap;
/// # use clap::Command;
/// # use clap::Arg;
/// let cmd = Command::new("mycmd")
///     .arg(
///         Arg::new("special-help")
///             .short('?')
///             .action(clap::ArgAction::Help)
///     );
///
/// // Existing help still exists
/// let err = cmd.clone().try_get_matches_from(["mycmd", "-h"]).unwrap_err();
/// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayHelp);
///
/// // New help available
/// let err = cmd.try_get_matches_from(["mycmd", "-?"]).unwrap_err();
/// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayHelp);
/// # }
/// ```
#[derive(Clone, Debug)]
#[non_exhaustive]
#[allow(missing_copy_implementations)] // In the future, we may accept `Box<dyn ...>`
pub enum ArgAction {
    /// When encountered, store the associated value(s) in [`ArgMatches`][crate::ArgMatches]
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** If the argument has previously been seen, it will result in a
    /// [`ArgumentConflict`][crate::error::ErrorKind::ArgumentConflict] unless
    /// [`Command::args_override_self(true)`][crate::Command::args_override_self] is set.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::Set)
    ///     );
    ///
    /// let matches = cmd.try_get_matches_from(["mycmd", "--flag", "value"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_many::<String>("flag").unwrap_or_default().map(|v| v.as_str()).collect::<Vec<_>>(),
    ///     vec!["value"]
    /// );
    /// ```
    Set,
    /// When encountered, store the associated value(s) in [`ArgMatches`][crate::ArgMatches]
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::Append)
    ///     );
    ///
    /// let matches = cmd.try_get_matches_from(["mycmd", "--flag", "value1", "--flag", "value2"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_many::<String>("flag").unwrap_or_default().map(|v| v.as_str()).collect::<Vec<_>>(),
    ///     vec!["value1", "value2"]
    /// );
    /// ```
    Append,
    /// When encountered, act as if `"true"` was encountered on the command-line
    ///
    /// If no [`default_value`][super::Arg::default_value] is set, it will be `false`.
    ///
    /// No value is allowed. To optionally accept a value, see
    /// [`Arg::default_missing_value`][super::Arg::default_missing_value]
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** If the argument has previously been seen, it will result in a
    /// [`ArgumentConflict`][crate::error::ErrorKind::ArgumentConflict] unless
    /// [`Command::args_override_self(true)`][crate::Command::args_override_self] is set.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::SetTrue)
    ///     );
    ///
    /// let matches = cmd.clone().try_get_matches_from(["mycmd", "--flag"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_flag("flag"),
    ///     true
    /// );
    ///
    /// let matches = cmd.try_get_matches_from(["mycmd"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_flag("flag"),
    ///     false
    /// );
    /// ```
    ///
    /// You can use [`TypedValueParser::map`][crate::builder::TypedValueParser::map] to have the
    /// flag control an application-specific type:
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// # use clap::builder::TypedValueParser as _;
    /// # use clap::builder::BoolishValueParser;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::SetTrue)
    ///             .value_parser(
    ///                 BoolishValueParser::new()
    ///                 .map(|b| -> usize {
    ///                     if b { 10 } else { 5 }
    ///                 })
    ///             )
    ///     );
    ///
    /// let matches = cmd.clone().try_get_matches_from(["mycmd", "--flag"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_one::<usize>("flag").copied(),
    ///     Some(10)
    /// );
    ///
    /// let matches = cmd.try_get_matches_from(["mycmd"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_one::<usize>("flag").copied(),
    ///     Some(5)
    /// );
    /// ```
    SetTrue,
    /// When encountered, act as if `"false"` was encountered on the command-line
    ///
    /// If no [`default_value`][super::Arg::default_value] is set, it will be `true`.
    ///
    /// No value is allowed. To optionally accept a value, see
    /// [`Arg::default_missing_value`][super::Arg::default_missing_value]
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** If the argument has previously been seen, it will result in a
    /// [`ArgumentConflict`][crate::error::ErrorKind::ArgumentConflict] unless
    /// [`Command::args_override_self(true)`][crate::Command::args_override_self] is set.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::SetFalse)
    ///     );
    ///
    /// let matches = cmd.clone().try_get_matches_from(["mycmd", "--flag"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_flag("flag"),
    ///     false
    /// );
    ///
    /// let matches = cmd.try_get_matches_from(["mycmd"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_flag("flag"),
    ///     true
    /// );
    /// ```
    SetFalse,
    /// When encountered, increment a `u8` counter starting from `0`.
    ///
    /// If no [`default_value`][super::Arg::default_value] is set, it will be `0`.
    ///
    /// No value is allowed. To optionally accept a value, see
    /// [`Arg::default_missing_value`][super::Arg::default_missing_value]
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::Count)
    ///     );
    ///
    /// let matches = cmd.clone().try_get_matches_from(["mycmd", "--flag", "--flag"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_count("flag"),
    ///     2
    /// );
    ///
    /// let matches = cmd.try_get_matches_from(["mycmd"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_count("flag"),
    ///     0
    /// );
    /// ```
    Count,
    /// When encountered, display [`Command::print_help`][super::Command::print_help]
    ///
    /// Depending on the flag, [`Command::print_long_help`][super::Command::print_long_help] may be shown
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("special-help")
    ///             .short('?')
    ///             .action(clap::ArgAction::Help)
    ///     );
    ///
    /// // Existing help still exists
    /// let err = cmd.clone().try_get_matches_from(["mycmd", "-h"]).unwrap_err();
    /// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayHelp);
    ///
    /// // New help available
    /// let err = cmd.try_get_matches_from(["mycmd", "-?"]).unwrap_err();
    /// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayHelp);
    /// # }
    /// ```
    Help,
    /// When encountered, display [`Command::print_help`][super::Command::print_help]
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("special-help")
    ///             .short('?')
    ///             .action(clap::ArgAction::HelpShort)
    ///     );
    ///
    /// // Existing help still exists
    /// let err = cmd.clone().try_get_matches_from(["mycmd", "-h"]).unwrap_err();
    /// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayHelp);
    ///
    /// // New help available
    /// let err = cmd.try_get_matches_from(["mycmd", "-?"]).unwrap_err();
    /// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayHelp);
    /// # }
    /// ```
    HelpShort,
    /// When encountered, display [`Command::print_long_help`][super::Command::print_long_help]
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("special-help")
    ///             .short('?')
    ///             .action(clap::ArgAction::HelpLong)
    ///     );
    ///
    /// // Existing help still exists
    /// let err = cmd.clone().try_get_matches_from(["mycmd", "-h"]).unwrap_err();
    /// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayHelp);
    ///
    /// // New help available
    /// let err = cmd.try_get_matches_from(["mycmd", "-?"]).unwrap_err();
    /// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayHelp);
    /// # }
    /// ```
    HelpLong,
    /// When encountered, display [`Command::version`][super::Command::version]
    ///
    /// Depending on the flag, [`Command::long_version`][super::Command::long_version] may be shown
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .version("1.0.0")
    ///     .arg(
    ///         Arg::new("special-version")
    ///             .long("special-version")
    ///             .action(clap::ArgAction::Version)
    ///     );
    ///
    /// // Existing help still exists
    /// let err = cmd.clone().try_get_matches_from(["mycmd", "--version"]).unwrap_err();
    /// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayVersion);
    ///
    /// // New help available
    /// let err = cmd.try_get_matches_from(["mycmd", "--special-version"]).unwrap_err();
    /// assert_eq!(err.kind(), clap::error::ErrorKind::DisplayVersion);
    /// ```
    Version,
}

impl ArgAction {
    /// Returns whether this action accepts values on the command-line
    ///
    /// [`default_values`][super::Arg::default_values] and [`env`][super::Arg::env] may still be
    /// processed.
    pub fn takes_values(&self) -> bool {
        match self {
            Self::Set => true,
            Self::Append => true,
            Self::SetTrue => false,
            Self::SetFalse => false,
            Self::Count => false,
            Self::Help => false,
            Self::HelpShort => false,
            Self::HelpLong => false,
            Self::Version => false,
        }
    }

    #[cfg(debug_assertions)]
    pub(crate) fn max_num_args(&self) -> ValueRange {
        match self {
            Self::Set => ValueRange::FULL,
            Self::Append => ValueRange::FULL,
            Self::SetTrue => ValueRange::OPTIONAL,
            Self::SetFalse => ValueRange::OPTIONAL,
            Self::Count => ValueRange::EMPTY,
            Self::Help => ValueRange::EMPTY,
            Self::HelpShort => ValueRange::EMPTY,
            Self::HelpLong => ValueRange::EMPTY,
            Self::Version => ValueRange::EMPTY,
        }
    }

    pub(crate) fn default_num_args(&self) -> ValueRange {
        match self {
            Self::Set => ValueRange::SINGLE,
            Self::Append => ValueRange::SINGLE,
            Self::SetTrue => ValueRange::EMPTY,
            Self::SetFalse => ValueRange::EMPTY,
            Self::Count => ValueRange::EMPTY,
            Self::Help => ValueRange::EMPTY,
            Self::HelpShort => ValueRange::EMPTY,
            Self::HelpLong => ValueRange::EMPTY,
            Self::Version => ValueRange::EMPTY,
        }
    }

    pub(crate) fn default_value(&self) -> Option<&'static std::ffi::OsStr> {
        match self {
            Self::Set => None,
            Self::Append => None,
            Self::SetTrue => Some(std::ffi::OsStr::new("false")),
            Self::SetFalse => Some(std::ffi::OsStr::new("true")),
            Self::Count => Some(std::ffi::OsStr::new("0")),
            Self::Help => None,
            Self::HelpShort => None,
            Self::HelpLong => None,
            Self::Version => None,
        }
    }

    pub(crate) fn default_missing_value(&self) -> Option<&'static std::ffi::OsStr> {
        match self {
            Self::Set => None,
            Self::Append => None,
            Self::SetTrue => Some(std::ffi::OsStr::new("true")),
            Self::SetFalse => Some(std::ffi::OsStr::new("false")),
            Self::Count => None,
            Self::Help => None,
            Self::HelpShort => None,
            Self::HelpLong => None,
            Self::Version => None,
        }
    }

    pub(crate) fn default_value_parser(&self) -> Option<super::ValueParser> {
        match self {
            Self::Set => None,
            Self::Append => None,
            Self::SetTrue => Some(super::ValueParser::bool()),
            Self::SetFalse => Some(super::ValueParser::bool()),
            Self::Count => Some(crate::value_parser!(u8).into()),
            Self::Help => None,
            Self::HelpShort => None,
            Self::HelpLong => None,
            Self::Version => None,
        }
    }

    #[cfg(debug_assertions)]
    pub(crate) fn value_type_id(&self) -> Option<AnyValueId> {
        match self {
            Self::Set => None,
            Self::Append => None,
            Self::SetTrue => None,
            Self::SetFalse => None,
            Self::Count => Some(AnyValueId::of::<CountType>()),
            Self::Help => None,
            Self::HelpShort => None,
            Self::HelpLong => None,
            Self::Version => None,
        }
    }
}

pub(crate) type CountType = u8;

```

`clap/clap_builder/src/builder/app_settings.rs`:

```rs
#[allow(unused)]
use crate::Arg;
#[allow(unused)]
use crate::Command;

#[derive(Default, Copy, Clone, Debug, PartialEq, Eq)]
pub(crate) struct AppFlags(u32);

impl AppFlags {
    pub(crate) fn set(&mut self, setting: AppSettings) {
        self.0 |= setting.bit();
    }

    pub(crate) fn unset(&mut self, setting: AppSettings) {
        self.0 &= !setting.bit();
    }

    pub(crate) fn is_set(&self, setting: AppSettings) -> bool {
        self.0 & setting.bit() != 0
    }

    pub(crate) fn insert(&mut self, other: Self) {
        self.0 |= other.0;
    }
}

impl std::ops::BitOr for AppFlags {
    type Output = Self;

    fn bitor(mut self, rhs: Self) -> Self::Output {
        self.insert(rhs);
        self
    }
}

/// Application level settings, which affect how [`Command`] operates
///
/// <div class="warning">
///
/// **NOTE:** When these settings are used, they apply only to current command, and are *not*
/// propagated down or up through child or parent subcommands
///
/// </div>
///
/// [`Command`]: crate::Command
#[derive(Debug, PartialEq, Copy, Clone)]
#[repr(u8)]
pub(crate) enum AppSettings {
    IgnoreErrors,
    AllowHyphenValues,
    AllowNegativeNumbers,
    AllArgsOverrideSelf,
    AllowMissingPositional,
    TrailingVarArg,
    DontDelimitTrailingValues,
    InferLongArgs,
    InferSubcommands,
    SubcommandRequired,
    AllowExternalSubcommands,
    Multicall,
    SubcommandsNegateReqs,
    ArgsNegateSubcommands,
    SubcommandPrecedenceOverArg,
    FlattenHelp,
    ArgRequiredElseHelp,
    NextLineHelp,
    DisableColoredHelp,
    DisableHelpFlag,
    DisableHelpSubcommand,
    DisableVersionFlag,
    PropagateVersion,
    Hidden,
    HidePossibleValues,
    HelpExpected,
    NoBinaryName,
    #[allow(dead_code)]
    ColorAuto,
    ColorAlways,
    ColorNever,
    Built,
    BinNameBuilt,
}

impl AppSettings {
    fn bit(self) -> u32 {
        1 << (self as u8)
    }
}

```

`clap/clap_builder/src/builder/arg.rs`:

```rs
// Std
#[cfg(feature = "env")]
use std::env;
#[cfg(feature = "env")]
use std::ffi::OsString;
use std::{
    cmp::{Ord, Ordering},
    fmt::{self, Display, Formatter},
    str,
};

// Internal
use super::{ArgFlags, ArgSettings};
#[cfg(feature = "unstable-ext")]
use crate::builder::ext::Extension;
use crate::builder::ext::Extensions;
use crate::builder::ArgPredicate;
use crate::builder::IntoResettable;
use crate::builder::OsStr;
use crate::builder::PossibleValue;
use crate::builder::Str;
use crate::builder::StyledStr;
use crate::builder::Styles;
use crate::builder::ValueRange;
use crate::util::AnyValueId;
use crate::ArgAction;
use crate::Id;
use crate::ValueHint;
use crate::INTERNAL_ERROR_MSG;

/// The abstract representation of a command line argument. Used to set all the options and
/// relationships that define a valid argument for the program.
///
/// There are two methods for constructing [`Arg`]s, using the builder pattern and setting options
/// manually, or using a usage string which is far less verbose but has fewer options. You can also
/// use a combination of the two methods to achieve the best of both worlds.
///
/// - [Basic API][crate::Arg#basic-api]
/// - [Value Handling][crate::Arg#value-handling]
/// - [Help][crate::Arg#help-1]
/// - [Advanced Argument Relations][crate::Arg#advanced-argument-relations]
/// - [Reflection][crate::Arg#reflection]
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::{Arg, arg, ArgAction};
/// // Using the traditional builder pattern and setting each option manually
/// let cfg = Arg::new("config")
///       .short('c')
///       .long("config")
///       .action(ArgAction::Set)
///       .value_name("FILE")
///       .help("Provides a config file to myprog");
/// // Using a usage string (setting a similar argument to the one above)
/// let input = arg!(-i --input <FILE> "Provides an input file to the program");
/// ```
#[derive(Default, Clone)]
pub struct Arg {
    pub(crate) id: Id,
    pub(crate) help: Option<StyledStr>,
    pub(crate) long_help: Option<StyledStr>,
    pub(crate) action: Option<ArgAction>,
    pub(crate) value_parser: Option<super::ValueParser>,
    pub(crate) blacklist: Vec<Id>,
    pub(crate) settings: ArgFlags,
    pub(crate) overrides: Vec<Id>,
    pub(crate) groups: Vec<Id>,
    pub(crate) requires: Vec<(ArgPredicate, Id)>,
    pub(crate) r_ifs: Vec<(Id, OsStr)>,
    pub(crate) r_ifs_all: Vec<(Id, OsStr)>,
    pub(crate) r_unless: Vec<Id>,
    pub(crate) r_unless_all: Vec<Id>,
    pub(crate) short: Option<char>,
    pub(crate) long: Option<Str>,
    pub(crate) aliases: Vec<(Str, bool)>, // (name, visible)
    pub(crate) short_aliases: Vec<(char, bool)>, // (name, visible)
    pub(crate) disp_ord: Option<usize>,
    pub(crate) val_names: Vec<Str>,
    pub(crate) num_vals: Option<ValueRange>,
    pub(crate) val_delim: Option<char>,
    pub(crate) default_vals: Vec<OsStr>,
    pub(crate) default_vals_ifs: Vec<(Id, ArgPredicate, Option<OsStr>)>,
    pub(crate) default_missing_vals: Vec<OsStr>,
    #[cfg(feature = "env")]
    pub(crate) env: Option<(OsStr, Option<OsString>)>,
    pub(crate) terminator: Option<Str>,
    pub(crate) index: Option<usize>,
    pub(crate) help_heading: Option<Option<Str>>,
    pub(crate) ext: Extensions,
}

/// # Basic API
impl Arg {
    /// Create a new [`Arg`] with a unique name.
    ///
    /// The name is used to check whether or not the argument was used at
    /// runtime, get values, set relationships with other args, etc..
    ///
    /// By default, an `Arg` is
    /// - Positional, see [`Arg::short`] or [`Arg::long`] turn it into an option
    /// - Accept a single value, see [`Arg::action`] to override this
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** In the case of arguments that take values (i.e. [`Arg::action(ArgAction::Set)`])
    /// and positional arguments (i.e. those without a preceding `-` or `--`) the name will also
    /// be displayed when the user prints the usage/help information of the program.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Arg::new("config")
    /// # ;
    /// ```
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    pub fn new(id: impl Into<Id>) -> Self {
        Arg::default().id(id)
    }

    /// Set the identifier used for referencing this argument in the clap API.
    ///
    /// See [`Arg::new`] for more details.
    #[must_use]
    pub fn id(mut self, id: impl Into<Id>) -> Self {
        self.id = id.into();
        self
    }

    /// Sets the short version of the argument without the preceding `-`.
    ///
    /// By default `V` and `h` are used by the auto-generated `version` and `help` arguments,
    /// respectively. You will need to disable the auto-generated flags
    /// ([`disable_help_flag`][crate::Command::disable_help_flag],
    /// [`disable_version_flag`][crate::Command::disable_version_flag]) and define your own.
    ///
    /// # Examples
    ///
    /// When calling `short`, use a single valid UTF-8 character which will allow using the
    /// argument via a single hyphen (`-`) such as `-c`:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg,  ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("config")
    ///         .short('c')
    ///         .action(ArgAction::Set))
    ///     .get_matches_from(vec![
    ///         "prog", "-c", "file.toml"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("config").map(String::as_str), Some("file.toml"));
    /// ```
    ///
    /// To use `-h` for your own flag and still have help:
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg,  ArgAction};
    /// let m = Command::new("prog")
    ///     .disable_help_flag(true)
    ///     .arg(Arg::new("host")
    ///         .short('h')
    ///         .long("host"))
    ///     .arg(Arg::new("help")
    ///         .long("help")
    ///         .global(true)
    ///         .action(ArgAction::Help))
    ///     .get_matches_from(vec![
    ///         "prog", "-h", "wikipedia.org"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("host").map(String::as_str), Some("wikipedia.org"));
    /// ```
    #[inline]
    #[must_use]
    pub fn short(mut self, s: impl IntoResettable<char>) -> Self {
        if let Some(s) = s.into_resettable().into_option() {
            debug_assert!(s != '-', "short option name cannot be `-`");
            self.short = Some(s);
        } else {
            self.short = None;
        }
        self
    }

    /// Sets the long version of the argument without the preceding `--`.
    ///
    /// By default `version` and `help` are used by the auto-generated `version` and `help`
    /// arguments, respectively. You may use the word `version` or `help` for the long form of your
    /// own arguments, in which case `clap` simply will not assign those to the auto-generated
    /// `version` or `help` arguments.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Any leading `-` characters will be stripped
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// To set `long` use a word containing valid UTF-8. If you supply a double leading
    /// `--` such as `--config` they will be stripped. Hyphens in the middle of the word, however,
    /// will *not* be stripped (i.e. `config-file` is allowed).
    ///
    /// Setting `long` allows using the argument via a double hyphen (`--`) such as `--config`
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .long("config")
    ///         .action(ArgAction::Set))
    ///     .get_matches_from(vec![
    ///         "prog", "--config", "file.toml"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("cfg").map(String::as_str), Some("file.toml"));
    /// ```
    #[inline]
    #[must_use]
    pub fn long(mut self, l: impl IntoResettable<Str>) -> Self {
        self.long = l.into_resettable().into_option();
        self
    }

    /// Add an alias, which functions as a hidden long flag.
    ///
    /// This is more efficient, and easier than creating multiple hidden arguments as one only
    /// needs to check for the existence of this command, and not all variants.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///             .arg(Arg::new("test")
    ///             .long("test")
    ///             .alias("alias")
    ///             .action(ArgAction::Set))
    ///        .get_matches_from(vec![
    ///             "prog", "--alias", "cool"
    ///         ]);
    /// assert_eq!(m.get_one::<String>("test").unwrap(), "cool");
    /// ```
    #[must_use]
    pub fn alias(mut self, name: impl IntoResettable<Str>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            self.aliases.push((name, false));
        } else {
            self.aliases.clear();
        }
        self
    }

    /// Add an alias, which functions as a hidden short flag.
    ///
    /// This is more efficient, and easier than creating multiple hidden arguments as one only
    /// needs to check for the existence of this command, and not all variants.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///             .arg(Arg::new("test")
    ///             .short('t')
    ///             .short_alias('e')
    ///             .action(ArgAction::Set))
    ///        .get_matches_from(vec![
    ///             "prog", "-e", "cool"
    ///         ]);
    /// assert_eq!(m.get_one::<String>("test").unwrap(), "cool");
    /// ```
    #[must_use]
    pub fn short_alias(mut self, name: impl IntoResettable<char>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            debug_assert!(name != '-', "short alias name cannot be `-`");
            self.short_aliases.push((name, false));
        } else {
            self.short_aliases.clear();
        }
        self
    }

    /// Add aliases, which function as hidden long flags.
    ///
    /// This is more efficient, and easier than creating multiple hidden subcommands as one only
    /// needs to check for the existence of this command, and not all variants.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///             .arg(Arg::new("test")
    ///                     .long("test")
    ///                     .aliases(["do-stuff", "do-tests", "tests"])
    ///                     .action(ArgAction::SetTrue)
    ///                     .help("the file to add")
    ///                     .required(false))
    ///             .get_matches_from(vec![
    ///                 "prog", "--do-tests"
    ///             ]);
    /// assert_eq!(m.get_flag("test"), true);
    /// ```
    #[must_use]
    pub fn aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
        self.aliases
            .extend(names.into_iter().map(|x| (x.into(), false)));
        self
    }

    /// Add aliases, which functions as a hidden short flag.
    ///
    /// This is more efficient, and easier than creating multiple hidden subcommands as one only
    /// needs to check for the existence of this command, and not all variants.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///             .arg(Arg::new("test")
    ///                     .short('t')
    ///                     .short_aliases(['e', 's'])
    ///                     .action(ArgAction::SetTrue)
    ///                     .help("the file to add")
    ///                     .required(false))
    ///             .get_matches_from(vec![
    ///                 "prog", "-s"
    ///             ]);
    /// assert_eq!(m.get_flag("test"), true);
    /// ```
    #[must_use]
    pub fn short_aliases(mut self, names: impl IntoIterator<Item = char>) -> Self {
        for s in names {
            debug_assert!(s != '-', "short alias name cannot be `-`");
            self.short_aliases.push((s, false));
        }
        self
    }

    /// Add an alias, which functions as a visible long flag.
    ///
    /// Like [`Arg::alias`], except that they are visible inside the help message.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///             .arg(Arg::new("test")
    ///                 .visible_alias("something-awesome")
    ///                 .long("test")
    ///                 .action(ArgAction::Set))
    ///        .get_matches_from(vec![
    ///             "prog", "--something-awesome", "coffee"
    ///         ]);
    /// assert_eq!(m.get_one::<String>("test").unwrap(), "coffee");
    /// ```
    /// [`Command::alias`]: Arg::alias()
    #[must_use]
    pub fn visible_alias(mut self, name: impl IntoResettable<Str>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            self.aliases.push((name, true));
        } else {
            self.aliases.clear();
        }
        self
    }

    /// Add an alias, which functions as a visible short flag.
    ///
    /// Like [`Arg::short_alias`], except that they are visible inside the help message.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///             .arg(Arg::new("test")
    ///                 .long("test")
    ///                 .visible_short_alias('t')
    ///                 .action(ArgAction::Set))
    ///        .get_matches_from(vec![
    ///             "prog", "-t", "coffee"
    ///         ]);
    /// assert_eq!(m.get_one::<String>("test").unwrap(), "coffee");
    /// ```
    #[must_use]
    pub fn visible_short_alias(mut self, name: impl IntoResettable<char>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            debug_assert!(name != '-', "short alias name cannot be `-`");
            self.short_aliases.push((name, true));
        } else {
            self.short_aliases.clear();
        }
        self
    }

    /// Add aliases, which function as visible long flags.
    ///
    /// Like [`Arg::aliases`], except that they are visible inside the help message.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///             .arg(Arg::new("test")
    ///                 .long("test")
    ///                 .action(ArgAction::SetTrue)
    ///                 .visible_aliases(["something", "awesome", "cool"]))
    ///        .get_matches_from(vec![
    ///             "prog", "--awesome"
    ///         ]);
    /// assert_eq!(m.get_flag("test"), true);
    /// ```
    /// [`Command::aliases`]: Arg::aliases()
    #[must_use]
    pub fn visible_aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
        self.aliases
            .extend(names.into_iter().map(|n| (n.into(), true)));
        self
    }

    /// Add aliases, which function as visible short flags.
    ///
    /// Like [`Arg::short_aliases`], except that they are visible inside the help message.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///             .arg(Arg::new("test")
    ///                 .long("test")
    ///                 .action(ArgAction::SetTrue)
    ///                 .visible_short_aliases(['t', 'e']))
    ///        .get_matches_from(vec![
    ///             "prog", "-t"
    ///         ]);
    /// assert_eq!(m.get_flag("test"), true);
    /// ```
    #[must_use]
    pub fn visible_short_aliases(mut self, names: impl IntoIterator<Item = char>) -> Self {
        for n in names {
            debug_assert!(n != '-', "short alias name cannot be `-`");
            self.short_aliases.push((n, true));
        }
        self
    }

    /// Specifies the index of a positional argument **starting at** 1.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The index refers to position according to **other positional argument**. It does
    /// not define position in the argument list as a whole.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** You can optionally leave off the `index` method, and the index will be
    /// assigned in order of evaluation. Utilizing the `index` method allows for setting
    /// indexes out of order
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This is only meant to be used for positional arguments and shouldn't to be used
    /// with [`Arg::short`] or [`Arg::long`].
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** When utilized with [`Arg::num_args(1..)`], only the **last** positional argument
    /// may be defined as having a variable number of arguments (i.e. with the highest index)
    ///
    /// </div>
    ///
    /// # Panics
    ///
    /// [`Command`] will [`panic!`] if indexes are skipped (such as defining `index(1)` and `index(3)`
    /// but not `index(2)`, or a positional argument is defined as multiple and is not the highest
    /// index (debug builds)
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Arg::new("config")
    ///     .index(1)
    /// # ;
    /// ```
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("mode")
    ///         .index(1))
    ///     .arg(Arg::new("debug")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue))
    ///     .get_matches_from(vec![
    ///         "prog", "--debug", "fast"
    ///     ]);
    ///
    /// assert!(m.contains_id("mode"));
    /// assert_eq!(m.get_one::<String>("mode").unwrap(), "fast"); // notice index(1) means "first positional"
    ///                                                           // *not* first argument
    /// ```
    /// [`Arg::short`]: Arg::short()
    /// [`Arg::long`]: Arg::long()
    /// [`Arg::num_args(true)`]: Arg::num_args()
    /// [`Command`]: crate::Command
    #[inline]
    #[must_use]
    pub fn index(mut self, idx: impl IntoResettable<usize>) -> Self {
        self.index = idx.into_resettable().into_option();
        self
    }

    /// This is a "var arg" and everything that follows should be captured by it, as if the user had
    /// used a `--`.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** To start the trailing "var arg" on unknown flags (and not just a positional
    /// value), set [`allow_hyphen_values`][Arg::allow_hyphen_values].  Either way, users still
    /// have the option to explicitly escape ambiguous arguments with `--`.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** [`Arg::value_delimiter`] still applies if set.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this requires [`Arg::num_args(..)`].
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg};
    /// let m = Command::new("myprog")
    ///     .arg(arg!(<cmd> ... "commands to run").trailing_var_arg(true))
    ///     .get_matches_from(vec!["myprog", "arg1", "-r", "val1"]);
    ///
    /// let trail: Vec<_> = m.get_many::<String>("cmd").unwrap().collect();
    /// assert_eq!(trail, ["arg1", "-r", "val1"]);
    /// ```
    /// [`Arg::num_args(..)`]: crate::Arg::num_args()
    pub fn trailing_var_arg(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::TrailingVarArg)
        } else {
            self.unset_setting(ArgSettings::TrailingVarArg)
        }
    }

    /// This arg is the last, or final, positional argument (i.e. has the highest
    /// index) and is *only* able to be accessed via the `--` syntax (i.e. `$ prog args --
    /// last_arg`).
    ///
    /// Even, if no other arguments are left to parse, if the user omits the `--` syntax
    /// they will receive an [`UnknownArgument`] error. Setting an argument to `.last(true)` also
    /// allows one to access this arg early using the `--` syntax. Accessing an arg early, even with
    /// the `--` syntax is otherwise not possible.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This will change the usage string to look like `$ prog [OPTIONS] [-- <ARG>]` if
    /// `ARG` is marked as `.last(true)`.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This setting will imply [`crate::Command::dont_collapse_args_in_usage`] because failing
    /// to set this can make the usage string very confusing.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE**: This setting only applies to positional arguments, and has no effect on OPTIONS
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this requires [taking values][Arg::num_args]
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **WARNING:** Using this setting *and* having child subcommands is not
    /// recommended with the exception of *also* using
    /// [`crate::Command::args_conflicts_with_subcommands`]
    /// (or [`crate::Command::subcommand_negates_reqs`] if the argument marked `Last` is also
    /// marked [`Arg::required`])
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Arg, ArgAction};
    /// Arg::new("args")
    ///     .action(ArgAction::Set)
    ///     .last(true)
    /// # ;
    /// ```
    ///
    /// Setting `last` ensures the arg has the highest [index] of all positional args
    /// and requires that the `--` syntax be used to access it early.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("first"))
    ///     .arg(Arg::new("second"))
    ///     .arg(Arg::new("third")
    ///         .action(ArgAction::Set)
    ///         .last(true))
    ///     .try_get_matches_from(vec![
    ///         "prog", "one", "--", "three"
    ///     ]);
    ///
    /// assert!(res.is_ok());
    /// let m = res.unwrap();
    /// assert_eq!(m.get_one::<String>("third").unwrap(), "three");
    /// assert_eq!(m.get_one::<String>("second"), None);
    /// ```
    ///
    /// Even if the positional argument marked `Last` is the only argument left to parse,
    /// failing to use the `--` syntax results in an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("first"))
    ///     .arg(Arg::new("second"))
    ///     .arg(Arg::new("third")
    ///         .action(ArgAction::Set)
    ///         .last(true))
    ///     .try_get_matches_from(vec![
    ///         "prog", "one", "two", "three"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::UnknownArgument);
    /// ```
    /// [index]: Arg::index()
    /// [`UnknownArgument`]: crate::error::ErrorKind::UnknownArgument
    #[inline]
    #[must_use]
    pub fn last(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::Last)
        } else {
            self.unset_setting(ArgSettings::Last)
        }
    }

    /// Specifies that the argument must be present.
    ///
    /// Required by default means it is required, when no other conflicting rules or overrides have
    /// been evaluated. Conflicting rules take precedence over being required.
    ///
    /// **Pro tip:** Flags (i.e. not positional, or arguments that take values) shouldn't be
    /// required by default. This is because if a flag were to be required, it should simply be
    /// implied. No additional information is required from user. Flags by their very nature are
    /// simply boolean on/off switches. The only time a user *should* be required to use a flag
    /// is if the operation is destructive in nature, and the user is essentially proving to you,
    /// "Yes, I know what I'm doing."
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .required(true)
    /// # ;
    /// ```
    ///
    /// Setting required requires that the argument be used at runtime.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required(true)
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--config", "file.conf",
    ///     ]);
    ///
    /// assert!(res.is_ok());
    /// ```
    ///
    /// Setting required and then *not* supplying that argument at runtime is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required(true)
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .try_get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    #[inline]
    #[must_use]
    pub fn required(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::Required)
        } else {
            self.unset_setting(ArgSettings::Required)
        }
    }

    /// Sets an argument that is required when this one is present
    ///
    /// i.e. when using this argument, the following argument *must* be present.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** [Conflicting] rules and [override] rules take precedence over being required
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .requires("input")
    /// # ;
    /// ```
    ///
    /// Setting [`Arg::requires(name)`] requires that the argument be used at runtime if the
    /// defining argument is used. If the defining argument isn't used, the other argument isn't
    /// required
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .requires("input")
    ///         .long("config"))
    ///     .arg(Arg::new("input"))
    ///     .try_get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert!(res.is_ok()); // We didn't use cfg, so input wasn't required
    /// ```
    ///
    /// Setting [`Arg::requires(name)`] and *not* supplying that argument is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .requires("input")
    ///         .long("config"))
    ///     .arg(Arg::new("input"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--config", "file.conf"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [`Arg::requires(name)`]: Arg::requires()
    /// [Conflicting]: Arg::conflicts_with()
    /// [override]: Arg::overrides_with()
    #[must_use]
    pub fn requires(mut self, arg_id: impl IntoResettable<Id>) -> Self {
        if let Some(arg_id) = arg_id.into_resettable().into_option() {
            self.requires.push((ArgPredicate::IsPresent, arg_id));
        } else {
            self.requires.clear();
        }
        self
    }

    /// This argument must be passed alone; it conflicts with all other arguments.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .exclusive(true)
    /// # ;
    /// ```
    ///
    /// Setting an exclusive argument and having any other arguments present at runtime
    /// is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("exclusive")
    ///         .action(ArgAction::Set)
    ///         .exclusive(true)
    ///         .long("exclusive"))
    ///     .arg(Arg::new("debug")
    ///         .long("debug"))
    ///     .arg(Arg::new("input"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--exclusive", "file.conf", "file.txt"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::ArgumentConflict);
    /// ```
    #[inline]
    #[must_use]
    pub fn exclusive(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::Exclusive)
        } else {
            self.unset_setting(ArgSettings::Exclusive)
        }
    }

    /// Specifies that an argument can be matched to all child [`Subcommand`]s.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Global arguments *only* propagate down, **not** up (to parent commands), however
    /// their values once a user uses them will be propagated back up to parents. In effect, this
    /// means one should *define* all global arguments at the top level, however it doesn't matter
    /// where the user *uses* the global argument.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// Assume an application with two subcommands, and you'd like to define a
    /// `--verbose` flag that can be called on any of the subcommands and parent, but you don't
    /// want to clutter the source with three duplicate [`Arg`] definitions.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("verb")
    ///         .long("verbose")
    ///         .short('v')
    ///         .action(ArgAction::SetTrue)
    ///         .global(true))
    ///     .subcommand(Command::new("test"))
    ///     .subcommand(Command::new("do-stuff"))
    ///     .get_matches_from(vec![
    ///         "prog", "do-stuff", "--verbose"
    ///     ]);
    ///
    /// assert_eq!(m.subcommand_name(), Some("do-stuff"));
    /// let sub_m = m.subcommand_matches("do-stuff").unwrap();
    /// assert_eq!(sub_m.get_flag("verb"), true);
    /// ```
    ///
    /// [`Subcommand`]: crate::Subcommand
    #[inline]
    #[must_use]
    pub fn global(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::Global)
        } else {
            self.unset_setting(ArgSettings::Global)
        }
    }

    #[inline]
    pub(crate) fn is_set(&self, s: ArgSettings) -> bool {
        self.settings.is_set(s)
    }

    #[inline]
    #[must_use]
    pub(crate) fn setting(mut self, setting: ArgSettings) -> Self {
        self.settings.set(setting);
        self
    }

    #[inline]
    #[must_use]
    pub(crate) fn unset_setting(mut self, setting: ArgSettings) -> Self {
        self.settings.unset(setting);
        self
    }

    /// Extend [`Arg`] with [`ArgExt`] data
    #[cfg(feature = "unstable-ext")]
    #[allow(clippy::should_implement_trait)]
    pub fn add<T: ArgExt + Extension>(mut self, tagged: T) -> Self {
        self.ext.set(tagged);
        self
    }
}

/// # Value Handling
impl Arg {
    /// Specify how to react to an argument when parsing it.
    ///
    /// [`ArgAction`] controls things like
    /// - Overwriting previous values with new ones
    /// - Appending new values to all previous ones
    /// - Counting how many times a flag occurs
    ///
    /// The default action is `ArgAction::Set`
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::Append)
    ///     );
    ///
    /// let matches = cmd.try_get_matches_from(["mycmd", "--flag", "value"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_many::<String>("flag").unwrap_or_default().map(|v| v.as_str()).collect::<Vec<_>>(),
    ///     vec!["value"]
    /// );
    /// ```
    #[inline]
    #[must_use]
    pub fn action(mut self, action: impl IntoResettable<ArgAction>) -> Self {
        self.action = action.into_resettable().into_option();
        self
    }

    /// Specify the typed behavior of the argument.
    ///
    /// This allows parsing and validating a value before storing it into
    /// [`ArgMatches`][crate::ArgMatches] as the given type.
    ///
    /// Possible value parsers include:
    /// - [`value_parser!(T)`][crate::value_parser!] for auto-selecting a value parser for a given type
    ///   - Or [range expressions like `0..=1`][std::ops::RangeBounds] as a shorthand for [`RangedI64ValueParser`][crate::builder::RangedI64ValueParser]
    /// - `Fn(&str) -> Result<T, E>`
    /// - `[&str]` and [`PossibleValuesParser`][crate::builder::PossibleValuesParser] for static enumerated values
    /// - [`BoolishValueParser`][crate::builder::BoolishValueParser], and [`FalseyValueParser`][crate::builder::FalseyValueParser] for alternative `bool` implementations
    /// - [`NonEmptyStringValueParser`][crate::builder::NonEmptyStringValueParser] for basic validation for strings
    /// - or any other [`TypedValueParser`][crate::builder::TypedValueParser] implementation
    ///
    /// The default value is [`ValueParser::string`][crate::builder::ValueParser::string].
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::ArgAction;
    /// let mut cmd = clap::Command::new("raw")
    ///     .arg(
    ///         clap::Arg::new("color")
    ///             .long("color")
    ///             .value_parser(["always", "auto", "never"])
    ///             .default_value("auto")
    ///     )
    ///     .arg(
    ///         clap::Arg::new("hostname")
    ///             .long("hostname")
    ///             .value_parser(clap::builder::NonEmptyStringValueParser::new())
    ///             .action(ArgAction::Set)
    ///             .required(true)
    ///     )
    ///     .arg(
    ///         clap::Arg::new("port")
    ///             .long("port")
    ///             .value_parser(clap::value_parser!(u16).range(3000..))
    ///             .action(ArgAction::Set)
    ///             .required(true)
    ///     );
    ///
    /// let m = cmd.try_get_matches_from_mut(
    ///     ["cmd", "--hostname", "rust-lang.org", "--port", "3001"]
    /// ).unwrap();
    ///
    /// let color: &String = m.get_one("color")
    ///     .expect("default");
    /// assert_eq!(color, "auto");
    ///
    /// let hostname: &String = m.get_one("hostname")
    ///     .expect("required");
    /// assert_eq!(hostname, "rust-lang.org");
    ///
    /// let port: u16 = *m.get_one("port")
    ///     .expect("required");
    /// assert_eq!(port, 3001);
    /// ```
    pub fn value_parser(mut self, parser: impl IntoResettable<super::ValueParser>) -> Self {
        self.value_parser = parser.into_resettable().into_option();
        self
    }

    /// Specifies the number of arguments parsed per occurrence
    ///
    /// For example, if you had a `-f <file>` argument where you wanted exactly 3 'files' you would
    /// set `.num_args(3)`, and this argument wouldn't be satisfied unless the user
    /// provided 3 and only 3 values.
    ///
    /// Users may specify values for arguments in any of the following methods
    ///
    /// - Using a space such as `-o value` or `--option value`
    /// - Using an equals and no space such as `-o=value` or `--option=value`
    /// - Use a short and no space such as `-ovalue`
    ///
    /// <div class="warning">
    ///
    /// **WARNING:**
    ///
    /// Setting a variable number of values (e.g. `1..=10`) for an argument without
    /// other details can be dangerous in some circumstances. Because multiple values are
    /// allowed, `--option val1 val2 val3` is perfectly valid. Be careful when designing a CLI
    /// where **positional arguments** or **subcommands** are *also* expected as `clap` will continue
    /// parsing *values* until one of the following happens:
    ///
    /// - It reaches the maximum number of values
    /// - It reaches a specific number of values
    /// - It finds another flag or option (i.e. something that starts with a `-`)
    /// - It reaches the [`Arg::value_terminator`] if set
    ///
    /// Alternatively,
    /// - Use a delimiter between values with [`Arg::value_delimiter`]
    /// - Require a flag occurrence per value with [`ArgAction::Append`]
    /// - Require positional arguments to appear after `--` with [`Arg::last`]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// Option:
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("mode")
    ///         .long("mode")
    ///         .num_args(1))
    ///     .get_matches_from(vec![
    ///         "prog", "--mode", "fast"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("mode").unwrap(), "fast");
    /// ```
    ///
    /// Flag/option hybrid (see also [`default_missing_value`][Arg::default_missing_value])
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let cmd = Command::new("prog")
    ///     .arg(Arg::new("mode")
    ///         .long("mode")
    ///         .default_missing_value("slow")
    ///         .default_value("plaid")
    ///         .num_args(0..=1));
    ///
    /// let m = cmd.clone()
    ///     .get_matches_from(vec![
    ///         "prog", "--mode", "fast"
    ///     ]);
    /// assert_eq!(m.get_one::<String>("mode").unwrap(), "fast");
    ///
    /// let m = cmd.clone()
    ///     .get_matches_from(vec![
    ///         "prog", "--mode",
    ///     ]);
    /// assert_eq!(m.get_one::<String>("mode").unwrap(), "slow");
    ///
    /// let m = cmd.clone()
    ///     .get_matches_from(vec![
    ///         "prog",
    ///     ]);
    /// assert_eq!(m.get_one::<String>("mode").unwrap(), "plaid");
    /// ```
    ///
    /// Tuples
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let cmd = Command::new("prog")
    ///     .arg(Arg::new("file")
    ///         .action(ArgAction::Set)
    ///         .num_args(2)
    ///         .short('F'));
    ///
    /// let m = cmd.clone()
    ///     .get_matches_from(vec![
    ///         "prog", "-F", "in-file", "out-file"
    ///     ]);
    /// assert_eq!(
    ///     m.get_many::<String>("file").unwrap_or_default().map(|v| v.as_str()).collect::<Vec<_>>(),
    ///     vec!["in-file", "out-file"]
    /// );
    ///
    /// let res = cmd.clone()
    ///     .try_get_matches_from(vec![
    ///         "prog", "-F", "file1"
    ///     ]);
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::WrongNumberOfValues);
    /// ```
    ///
    /// A common mistake is to define an option which allows multiple values and a positional
    /// argument.
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let cmd = Command::new("prog")
    ///     .arg(Arg::new("file")
    ///         .action(ArgAction::Set)
    ///         .num_args(0..)
    ///         .short('F'))
    ///     .arg(Arg::new("word"));
    ///
    /// let m = cmd.clone().get_matches_from(vec![
    ///     "prog", "-F", "file1", "file2", "file3", "word"
    /// ]);
    /// let files: Vec<_> = m.get_many::<String>("file").unwrap().collect();
    /// assert_eq!(files, ["file1", "file2", "file3", "word"]); // wait...what?!
    /// assert!(!m.contains_id("word")); // but we clearly used word!
    ///
    /// // but this works
    /// let m = cmd.clone().get_matches_from(vec![
    ///     "prog", "word", "-F", "file1", "file2", "file3",
    /// ]);
    /// let files: Vec<_> = m.get_many::<String>("file").unwrap().collect();
    /// assert_eq!(files, ["file1", "file2", "file3"]);
    /// assert_eq!(m.get_one::<String>("word").unwrap(), "word");
    /// ```
    /// The problem is `clap` doesn't know when to stop parsing values for "file".
    ///
    /// A solution for the example above is to limit how many values with a maximum, or specific
    /// number, or to say [`ArgAction::Append`] is ok, but multiple values are not.
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("file")
    ///         .action(ArgAction::Append)
    ///         .short('F'))
    ///     .arg(Arg::new("word"))
    ///     .get_matches_from(vec![
    ///         "prog", "-F", "file1", "-F", "file2", "-F", "file3", "word"
    ///     ]);
    ///
    /// let files: Vec<_> = m.get_many::<String>("file").unwrap().collect();
    /// assert_eq!(files, ["file1", "file2", "file3"]);
    /// assert_eq!(m.get_one::<String>("word").unwrap(), "word");
    /// ```
    #[inline]
    #[must_use]
    pub fn num_args(mut self, qty: impl IntoResettable<ValueRange>) -> Self {
        self.num_vals = qty.into_resettable().into_option();
        self
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::num_args`")
    )]
    pub fn number_of_values(self, qty: usize) -> Self {
        self.num_args(qty)
    }

    /// Placeholder for the argument's value in the help message / usage.
    ///
    /// This name is cosmetic only; the name is **not** used to access arguments.
    /// This setting can be very helpful when describing the type of input the user should be
    /// using, such as `FILE`, `INTERFACE`, etc. Although not required, it's somewhat convention to
    /// use all capital letters for the value name.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** implicitly sets [`Arg::action(ArgAction::Set)`]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Arg::new("cfg")
    ///     .long("config")
    ///     .value_name("FILE")
    /// # ;
    /// ```
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # #[cfg(feature = "help")] {
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("config")
    ///         .long("config")
    ///         .value_name("FILE")
    ///         .help("Some help text"))
    ///     .get_matches_from(vec![
    ///         "prog", "--help"
    ///     ]);
    /// # }
    /// ```
    /// Running the above program produces the following output
    ///
    /// ```text
    /// valnames
    ///
    /// Usage: valnames [OPTIONS]
    ///
    /// Options:
    ///     --config <FILE>     Some help text
    ///     -h, --help          Print help information
    ///     -V, --version       Print version information
    /// ```
    /// [positional]: Arg::index()
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    #[inline]
    #[must_use]
    pub fn value_name(mut self, name: impl IntoResettable<Str>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            self.value_names([name])
        } else {
            self.val_names.clear();
            self
        }
    }

    /// Placeholders for the argument's values in the help message / usage.
    ///
    /// These names are cosmetic only, used for help and usage strings only. The names are **not**
    /// used to access arguments. The values of the arguments are accessed in numeric order (i.e.
    /// if you specify two names `one` and `two` `one` will be the first matched value, `two` will
    /// be the second).
    ///
    /// This setting can be very helpful when describing the type of input the user should be
    /// using, such as `FILE`, `INTERFACE`, etc. Although not required, it's somewhat convention to
    /// use all capital letters for the value name.
    ///
    /// <div class="warning">
    ///
    /// **TIP:** It may help to use [`Arg::next_line_help(true)`] if there are long, or
    /// multiple value names in order to not throw off the help text alignment of all options.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** implicitly sets [`Arg::action(ArgAction::Set)`] and [`Arg::num_args(1..)`].
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Arg::new("speed")
    ///     .short('s')
    ///     .value_names(["fast", "slow"]);
    /// ```
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # #[cfg(feature = "help")] {
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("io")
    ///         .long("io-files")
    ///         .value_names(["INFILE", "OUTFILE"]))
    ///     .get_matches_from(vec![
    ///         "prog", "--help"
    ///     ]);
    /// # }
    /// ```
    ///
    /// Running the above program produces the following output
    ///
    /// ```text
    /// valnames
    ///
    /// Usage: valnames [OPTIONS]
    ///
    /// Options:
    ///     -h, --help                       Print help information
    ///     --io-files <INFILE> <OUTFILE>    Some help text
    ///     -V, --version                    Print version information
    /// ```
    /// [`Arg::next_line_help(true)`]: Arg::next_line_help()
    /// [`Arg::num_args`]: Arg::num_args()
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    /// [`Arg::num_args(1..)`]: Arg::num_args()
    #[must_use]
    pub fn value_names(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
        self.val_names = names.into_iter().map(|s| s.into()).collect();
        self
    }

    /// Provide the shell a hint about how to complete this argument.
    ///
    /// See [`ValueHint`] for more information.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** implicitly sets [`Arg::action(ArgAction::Set)`].
    ///
    /// </div>
    ///
    /// For example, to take a username as argument:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Arg, ValueHint};
    /// Arg::new("user")
    ///     .short('u')
    ///     .long("user")
    ///     .value_hint(ValueHint::Username);
    /// ```
    ///
    /// To take a full command line and its arguments (for example, when writing a command wrapper):
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ValueHint, ArgAction};
    /// Command::new("prog")
    ///     .trailing_var_arg(true)
    ///     .arg(
    ///         Arg::new("command")
    ///             .action(ArgAction::Set)
    ///             .num_args(1..)
    ///             .value_hint(ValueHint::CommandWithArguments)
    ///     );
    /// ```
    #[must_use]
    pub fn value_hint(mut self, value_hint: impl IntoResettable<ValueHint>) -> Self {
        // HACK: we should use `Self::add` and `Self::remove` to type-check that `ArgExt` is used
        match value_hint.into_resettable().into_option() {
            Some(value_hint) => {
                self.ext.set(value_hint);
            }
            None => {
                self.ext.remove::<ValueHint>();
            }
        }
        self
    }

    /// Match values against [`PossibleValuesParser`][crate::builder::PossibleValuesParser] without matching case.
    ///
    /// When other arguments are conditionally required based on the
    /// value of a case-insensitive argument, the equality check done
    /// by [`Arg::required_if_eq`], [`Arg::required_if_eq_any`], or
    /// [`Arg::required_if_eq_all`] is case-insensitive.
    ///
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this requires [taking values][Arg::num_args]
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** To do unicode case folding, enable the `unicode` feature flag.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("pv")
    ///     .arg(Arg::new("option")
    ///         .long("option")
    ///         .action(ArgAction::Set)
    ///         .ignore_case(true)
    ///         .value_parser(["test123"]))
    ///     .get_matches_from(vec![
    ///         "pv", "--option", "TeSt123",
    ///     ]);
    ///
    /// assert!(m.get_one::<String>("option").unwrap().eq_ignore_ascii_case("test123"));
    /// ```
    ///
    /// This setting also works when multiple values can be defined:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("pv")
    ///     .arg(Arg::new("option")
    ///         .short('o')
    ///         .long("option")
    ///         .action(ArgAction::Set)
    ///         .ignore_case(true)
    ///         .num_args(1..)
    ///         .value_parser(["test123", "test321"]))
    ///     .get_matches_from(vec![
    ///         "pv", "--option", "TeSt123", "teST123", "tESt321"
    ///     ]);
    ///
    /// let matched_vals = m.get_many::<String>("option").unwrap().collect::<Vec<_>>();
    /// assert_eq!(&*matched_vals, &["TeSt123", "teST123", "tESt321"]);
    /// ```
    #[inline]
    #[must_use]
    pub fn ignore_case(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::IgnoreCase)
        } else {
            self.unset_setting(ArgSettings::IgnoreCase)
        }
    }

    /// Allows values which start with a leading hyphen (`-`)
    ///
    /// To limit values to just numbers, see
    /// [`allow_negative_numbers`][Arg::allow_negative_numbers].
    ///
    /// See also [`trailing_var_arg`][Arg::trailing_var_arg].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this requires [taking values][Arg::num_args]
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **WARNING:** Prior arguments with `allow_hyphen_values(true)` get precedence over known
    /// flags but known flags get precedence over the next possible positional argument with
    /// `allow_hyphen_values(true)`.  When combined with [`Arg::num_args(..)`],
    /// [`Arg::value_terminator`] is one way to ensure processing stops.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **WARNING**: Take caution when using this setting combined with another argument using
    /// [`Arg::num_args`], as this becomes ambiguous `$ prog --arg -- -- val`. All
    /// three `--, --, val` will be values when the user may have thought the second `--` would
    /// constitute the normal, "Only positional args follow" idiom.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("pat")
    ///         .action(ArgAction::Set)
    ///         .allow_hyphen_values(true)
    ///         .long("pattern"))
    ///     .get_matches_from(vec![
    ///         "prog", "--pattern", "-file"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("pat").unwrap(), "-file");
    /// ```
    ///
    /// Not setting `Arg::allow_hyphen_values(true)` and supplying a value which starts with a
    /// hyphen is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("pat")
    ///         .action(ArgAction::Set)
    ///         .long("pattern"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--pattern", "-file"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::UnknownArgument);
    /// ```
    /// [`Arg::num_args(1)`]: Arg::num_args()
    #[inline]
    #[must_use]
    pub fn allow_hyphen_values(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::AllowHyphenValues)
        } else {
            self.unset_setting(ArgSettings::AllowHyphenValues)
        }
    }

    /// Allows negative numbers to pass as values.
    ///
    /// This is similar to [`Arg::allow_hyphen_values`] except that it only allows numbers,
    /// all other undefined leading hyphens will fail to parse.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this requires [taking values][Arg::num_args]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let res = Command::new("myprog")
    ///     .arg(Arg::new("num").allow_negative_numbers(true))
    ///     .try_get_matches_from(vec![
    ///         "myprog", "-20"
    ///     ]);
    /// assert!(res.is_ok());
    /// let m = res.unwrap();
    /// assert_eq!(m.get_one::<String>("num").unwrap(), "-20");
    /// ```
    #[inline]
    pub fn allow_negative_numbers(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::AllowNegativeNumbers)
        } else {
            self.unset_setting(ArgSettings::AllowNegativeNumbers)
        }
    }

    /// Requires that options use the `--option=val` syntax
    ///
    /// i.e. an equals between the option and associated value.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this requires [taking values][Arg::num_args]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// Setting `require_equals` requires that the option have an equals sign between
    /// it and the associated value.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .require_equals(true)
    ///         .long("config"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--config=file.conf"
    ///     ]);
    ///
    /// assert!(res.is_ok());
    /// ```
    ///
    /// Setting `require_equals` and *not* supplying the equals will cause an
    /// error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .require_equals(true)
    ///         .long("config"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--config", "file.conf"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::NoEquals);
    /// ```
    #[inline]
    #[must_use]
    pub fn require_equals(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::RequireEquals)
        } else {
            self.unset_setting(ArgSettings::RequireEquals)
        }
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::value_delimiter`")
    )]
    pub fn use_value_delimiter(mut self, yes: bool) -> Self {
        if yes {
            self.val_delim.get_or_insert(',');
        } else {
            self.val_delim = None;
        }
        self
    }

    /// Allow grouping of multiple values via a delimiter.
    ///
    /// i.e. allow values (`val1,val2,val3`) to be parsed as three values (`val1`, `val2`,
    /// and `val3`) instead of one value (`val1,val2,val3`).
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("config")
    ///         .short('c')
    ///         .long("config")
    ///         .value_delimiter(','))
    ///     .get_matches_from(vec![
    ///         "prog", "--config=val1,val2,val3"
    ///     ]);
    ///
    /// assert_eq!(m.get_many::<String>("config").unwrap().collect::<Vec<_>>(), ["val1", "val2", "val3"])
    /// ```
    /// [`Arg::value_delimiter(',')`]: Arg::value_delimiter()
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    #[inline]
    #[must_use]
    pub fn value_delimiter(mut self, d: impl IntoResettable<char>) -> Self {
        self.val_delim = d.into_resettable().into_option();
        self
    }

    /// Sentinel to **stop** parsing multiple values of a given argument.
    ///
    /// By default when
    /// one sets [`num_args(1..)`] on an argument, clap will continue parsing values for that
    /// argument until it reaches another valid argument, or one of the other more specific settings
    /// for multiple values is used (such as [`num_args`]).
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This setting only applies to [options] and [positional arguments]
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** When the terminator is passed in on the command line, it is **not** stored as one
    /// of the values
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// Arg::new("vals")
    ///     .action(ArgAction::Set)
    ///     .num_args(1..)
    ///     .value_terminator(";")
    /// # ;
    /// ```
    ///
    /// The following example uses two arguments, a sequence of commands, and the location in which
    /// to perform them
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("cmds")
    ///         .action(ArgAction::Set)
    ///         .num_args(1..)
    ///         .allow_hyphen_values(true)
    ///         .value_terminator(";"))
    ///     .arg(Arg::new("location"))
    ///     .get_matches_from(vec![
    ///         "prog", "find", "-type", "f", "-name", "special", ";", "/home/clap"
    ///     ]);
    /// let cmds: Vec<_> = m.get_many::<String>("cmds").unwrap().collect();
    /// assert_eq!(&cmds, &["find", "-type", "f", "-name", "special"]);
    /// assert_eq!(m.get_one::<String>("location").unwrap(), "/home/clap");
    /// ```
    /// [options]: Arg::action
    /// [positional arguments]: Arg::index()
    /// [`num_args(1..)`]: Arg::num_args()
    /// [`num_args`]: Arg::num_args()
    #[inline]
    #[must_use]
    pub fn value_terminator(mut self, term: impl IntoResettable<Str>) -> Self {
        self.terminator = term.into_resettable().into_option();
        self
    }

    /// Consume all following arguments.
    ///
    /// Do not parse them individually, but rather pass them in entirety.
    ///
    /// It is worth noting that setting this requires all values to come after a `--` to indicate
    /// they should all be captured. For example:
    ///
    /// ```text
    /// --foo something -- -v -v -v -b -b -b --baz -q -u -x
    /// ```
    ///
    /// Will result in everything after `--` to be considered one raw argument. This behavior
    /// may not be exactly what you are expecting and using [`Arg::trailing_var_arg`]
    /// may be more appropriate.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Implicitly sets [`Arg::action(ArgAction::Set)`], [`Arg::num_args(1..)`],
    /// [`Arg::allow_hyphen_values(true)`], and [`Arg::last(true)`] when set to `true`.
    ///
    /// </div>
    ///
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    /// [`Arg::num_args(1..)`]: Arg::num_args()
    /// [`Arg::allow_hyphen_values(true)`]: Arg::allow_hyphen_values()
    /// [`Arg::last(true)`]: Arg::last()
    #[inline]
    #[must_use]
    pub fn raw(mut self, yes: bool) -> Self {
        if yes {
            self.num_vals.get_or_insert_with(|| (1..).into());
        }
        self.allow_hyphen_values(yes).last(yes)
    }

    /// Value for the argument when not present.
    ///
    /// Like with command-line values, this will be split by [`Arg::value_delimiter`].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** If the user *does not* use this argument at runtime [`ArgMatches::contains_id`] will
    /// still return `true`. If you wish to determine whether the argument was used at runtime or
    /// not, consider [`ArgMatches::value_source`][crate::ArgMatches::value_source].
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This setting is perfectly compatible with [`Arg::default_value_if`] but slightly
    /// different. `Arg::default_value` *only* takes effect when the user has not provided this arg
    /// at runtime. `Arg::default_value_if` however only takes effect when the user has not provided
    /// a value at runtime **and** these other conditions are met as well. If you have set
    /// `Arg::default_value` and `Arg::default_value_if`, and the user **did not** provide this arg
    /// at runtime, nor were the conditions met for `Arg::default_value_if`, the `Arg::default_value`
    /// will be applied.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// First we use the default value without providing any value at runtime.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, parser::ValueSource};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("opt")
    ///         .long("myopt")
    ///         .default_value("myval"))
    ///     .get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("opt").unwrap(), "myval");
    /// assert!(m.contains_id("opt"));
    /// assert_eq!(m.value_source("opt"), Some(ValueSource::DefaultValue));
    /// ```
    ///
    /// Next we provide a value at runtime to override the default.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, parser::ValueSource};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("opt")
    ///         .long("myopt")
    ///         .default_value("myval"))
    ///     .get_matches_from(vec![
    ///         "prog", "--myopt=non_default"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("opt").unwrap(), "non_default");
    /// assert!(m.contains_id("opt"));
    /// assert_eq!(m.value_source("opt"), Some(ValueSource::CommandLine));
    /// ```
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    /// [`ArgMatches::contains_id`]: crate::ArgMatches::contains_id()
    /// [`Arg::default_value_if`]: Arg::default_value_if()
    #[inline]
    #[must_use]
    pub fn default_value(mut self, val: impl IntoResettable<OsStr>) -> Self {
        if let Some(val) = val.into_resettable().into_option() {
            self.default_values([val])
        } else {
            self.default_vals.clear();
            self
        }
    }

    #[inline]
    #[must_use]
    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::default_value`")
    )]
    pub fn default_value_os(self, val: impl Into<OsStr>) -> Self {
        self.default_values([val])
    }

    /// Value for the argument when not present.
    ///
    /// See [`Arg::default_value`].
    ///
    /// [`Arg::default_value`]: Arg::default_value()
    #[inline]
    #[must_use]
    pub fn default_values(mut self, vals: impl IntoIterator<Item = impl Into<OsStr>>) -> Self {
        self.default_vals = vals.into_iter().map(|s| s.into()).collect();
        self
    }

    #[inline]
    #[must_use]
    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::default_values`")
    )]
    pub fn default_values_os(self, vals: impl IntoIterator<Item = impl Into<OsStr>>) -> Self {
        self.default_values(vals)
    }

    /// Value for the argument when the flag is present but no value is specified.
    ///
    /// This configuration option is often used to give the user a shortcut and allow them to
    /// efficiently specify an option argument without requiring an explicitly value. The `--color`
    /// argument is a common example. By supplying a default, such as `default_missing_value("always")`,
    /// the user can quickly just add `--color` to the command line to produce the desired color output.
    ///
    /// Like with command-line values, this will be split by [`Arg::value_delimiter`].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** using this configuration option requires the use of the
    /// [`.num_args(0..N)`][Arg::num_args] and the
    /// [`.require_equals(true)`][Arg::require_equals] configuration option. These are required in
    /// order to unambiguously determine what, if any, value was supplied for the argument.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// For POSIX style `--color`:
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, parser::ValueSource};
    /// fn cli() -> Command {
    ///     Command::new("prog")
    ///         .arg(Arg::new("color").long("color")
    ///             .value_name("WHEN")
    ///             .value_parser(["always", "auto", "never"])
    ///             .default_value("auto")
    ///             .num_args(0..=1)
    ///             .require_equals(true)
    ///             .default_missing_value("always")
    ///             .help("Specify WHEN to colorize output.")
    ///         )
    /// }
    ///
    /// // first, we'll provide no arguments
    /// let m  = cli().get_matches_from(vec![
    ///         "prog"
    ///     ]);
    /// assert_eq!(m.get_one::<String>("color").unwrap(), "auto");
    /// assert_eq!(m.value_source("color"), Some(ValueSource::DefaultValue));
    ///
    /// // next, we'll provide a runtime value to override the default (as usually done).
    /// let m  = cli().get_matches_from(vec![
    ///         "prog", "--color=never"
    ///     ]);
    /// assert_eq!(m.get_one::<String>("color").unwrap(), "never");
    /// assert_eq!(m.value_source("color"), Some(ValueSource::CommandLine));
    ///
    /// // finally, we will use the shortcut and only provide the argument without a value.
    /// let m  = cli().get_matches_from(vec![
    ///         "prog", "--color"
    ///     ]);
    /// assert_eq!(m.get_one::<String>("color").unwrap(), "always");
    /// assert_eq!(m.value_source("color"), Some(ValueSource::CommandLine));
    /// ```
    ///
    /// For bool literals:
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, parser::ValueSource, value_parser};
    /// fn cli() -> Command {
    ///     Command::new("prog")
    ///         .arg(Arg::new("create").long("create")
    ///             .value_name("BOOL")
    ///             .value_parser(value_parser!(bool))
    ///             .num_args(0..=1)
    ///             .require_equals(true)
    ///             .default_missing_value("true")
    ///         )
    /// }
    ///
    /// // first, we'll provide no arguments
    /// let m  = cli().get_matches_from(vec![
    ///         "prog"
    ///     ]);
    /// assert_eq!(m.get_one::<bool>("create").copied(), None);
    ///
    /// // next, we'll provide a runtime value to override the default (as usually done).
    /// let m  = cli().get_matches_from(vec![
    ///         "prog", "--create=false"
    ///     ]);
    /// assert_eq!(m.get_one::<bool>("create").copied(), Some(false));
    /// assert_eq!(m.value_source("create"), Some(ValueSource::CommandLine));
    ///
    /// // finally, we will use the shortcut and only provide the argument without a value.
    /// let m  = cli().get_matches_from(vec![
    ///         "prog", "--create"
    ///     ]);
    /// assert_eq!(m.get_one::<bool>("create").copied(), Some(true));
    /// assert_eq!(m.value_source("create"), Some(ValueSource::CommandLine));
    /// ```
    ///
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    /// [`Arg::default_value`]: Arg::default_value()
    #[inline]
    #[must_use]
    pub fn default_missing_value(mut self, val: impl IntoResettable<OsStr>) -> Self {
        if let Some(val) = val.into_resettable().into_option() {
            self.default_missing_values_os([val])
        } else {
            self.default_missing_vals.clear();
            self
        }
    }

    /// Value for the argument when the flag is present but no value is specified.
    ///
    /// See [`Arg::default_missing_value`].
    ///
    /// [`Arg::default_missing_value`]: Arg::default_missing_value()
    /// [`OsStr`]: std::ffi::OsStr
    #[inline]
    #[must_use]
    pub fn default_missing_value_os(self, val: impl Into<OsStr>) -> Self {
        self.default_missing_values_os([val])
    }

    /// Value for the argument when the flag is present but no value is specified.
    ///
    /// See [`Arg::default_missing_value`].
    ///
    /// [`Arg::default_missing_value`]: Arg::default_missing_value()
    #[inline]
    #[must_use]
    pub fn default_missing_values(self, vals: impl IntoIterator<Item = impl Into<OsStr>>) -> Self {
        self.default_missing_values_os(vals)
    }

    /// Value for the argument when the flag is present but no value is specified.
    ///
    /// See [`Arg::default_missing_values`].
    ///
    /// [`Arg::default_missing_values`]: Arg::default_missing_values()
    /// [`OsStr`]: std::ffi::OsStr
    #[inline]
    #[must_use]
    pub fn default_missing_values_os(
        mut self,
        vals: impl IntoIterator<Item = impl Into<OsStr>>,
    ) -> Self {
        self.default_missing_vals = vals.into_iter().map(|s| s.into()).collect();
        self
    }

    /// Read from `name` environment variable when argument is not present.
    ///
    /// If it is not present in the environment, then default
    /// rules will apply.
    ///
    /// If user sets the argument in the environment:
    /// - When [`Arg::action(ArgAction::Set)`] is not set, the flag is considered raised.
    /// - When [`Arg::action(ArgAction::Set)`] is set,
    ///   [`ArgMatches::get_one`][crate::ArgMatches::get_one] will
    ///   return value of the environment variable.
    ///
    /// If user doesn't set the argument in the environment:
    /// - When [`Arg::action(ArgAction::Set)`] is not set, the flag is considered off.
    /// - When [`Arg::action(ArgAction::Set)`] is set,
    ///   [`ArgMatches::get_one`][crate::ArgMatches::get_one] will
    ///   return the default specified.
    ///
    /// Like with command-line values, this will be split by [`Arg::value_delimiter`].
    ///
    /// # Examples
    ///
    /// In this example, we show the variable coming from the environment:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::env;
    /// # use clap::{Command, Arg, ArgAction};
    ///
    /// env::set_var("MY_FLAG", "env");
    ///
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .env("MY_FLAG")
    ///         .action(ArgAction::Set))
    ///     .get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("flag").unwrap(), "env");
    /// ```
    ///
    /// In this example, because `prog` is a flag that accepts an optional, case-insensitive
    /// boolean literal.
    ///
    /// Note that the value parser controls how flags are parsed.  In this case we've selected
    /// [`FalseyValueParser`][crate::builder::FalseyValueParser].  A `false` literal is `n`, `no`,
    /// `f`, `false`, `off` or `0`.  An absent environment variable will also be considered as
    /// `false`.  Anything else will considered as `true`.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::env;
    /// # use clap::{Command, Arg, ArgAction};
    /// # use clap::builder::FalseyValueParser;
    ///
    /// env::set_var("TRUE_FLAG", "true");
    /// env::set_var("FALSE_FLAG", "0");
    ///
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("true_flag")
    ///         .long("true_flag")
    ///         .action(ArgAction::SetTrue)
    ///         .value_parser(FalseyValueParser::new())
    ///         .env("TRUE_FLAG"))
    ///     .arg(Arg::new("false_flag")
    ///         .long("false_flag")
    ///         .action(ArgAction::SetTrue)
    ///         .value_parser(FalseyValueParser::new())
    ///         .env("FALSE_FLAG"))
    ///     .arg(Arg::new("absent_flag")
    ///         .long("absent_flag")
    ///         .action(ArgAction::SetTrue)
    ///         .value_parser(FalseyValueParser::new())
    ///         .env("ABSENT_FLAG"))
    ///     .get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert!(m.get_flag("true_flag"));
    /// assert!(!m.get_flag("false_flag"));
    /// assert!(!m.get_flag("absent_flag"));
    /// ```
    ///
    /// In this example, we show the variable coming from an option on the CLI:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::env;
    /// # use clap::{Command, Arg, ArgAction};
    ///
    /// env::set_var("MY_FLAG", "env");
    ///
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .env("MY_FLAG")
    ///         .action(ArgAction::Set))
    ///     .get_matches_from(vec![
    ///         "prog", "--flag", "opt"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("flag").unwrap(), "opt");
    /// ```
    ///
    /// In this example, we show the variable coming from the environment even with the
    /// presence of a default:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::env;
    /// # use clap::{Command, Arg, ArgAction};
    ///
    /// env::set_var("MY_FLAG", "env");
    ///
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .env("MY_FLAG")
    ///         .action(ArgAction::Set)
    ///         .default_value("default"))
    ///     .get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("flag").unwrap(), "env");
    /// ```
    ///
    /// In this example, we show the use of multiple values in a single environment variable:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::env;
    /// # use clap::{Command, Arg, ArgAction};
    ///
    /// env::set_var("MY_FLAG_MULTI", "env1,env2");
    ///
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .env("MY_FLAG_MULTI")
    ///         .action(ArgAction::Set)
    ///         .num_args(1..)
    ///         .value_delimiter(','))
    ///     .get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert_eq!(m.get_many::<String>("flag").unwrap().collect::<Vec<_>>(), vec!["env1", "env2"]);
    /// ```
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    /// [`Arg::value_delimiter(',')`]: Arg::value_delimiter()
    #[cfg(feature = "env")]
    #[inline]
    #[must_use]
    pub fn env(mut self, name: impl IntoResettable<OsStr>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            let value = env::var_os(&name);
            self.env = Some((name, value));
        } else {
            self.env = None;
        }
        self
    }

    #[cfg(feature = "env")]
    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::env`")
    )]
    pub fn env_os(self, name: impl Into<OsStr>) -> Self {
        self.env(name)
    }
}

/// # Help
impl Arg {
    /// Sets the description of the argument for short help (`-h`).
    ///
    /// Typically, this is a short (one line) description of the arg.
    ///
    /// If [`Arg::long_help`] is not specified, this message will be displayed for `--help`.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Only `Arg::help` is used in completion script generation in order to be concise
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// Any valid UTF-8 is allowed in the help text. The one exception is when one wishes to
    /// include a newline in the help text and have the following text be properly aligned with all
    /// the other help text.
    ///
    /// Setting `help` displays a short message to the side of the argument when the user passes
    /// `-h` or `--help` (by default).
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .long("config")
    ///         .help("Some help text describing the --config arg"))
    ///     .get_matches_from(vec![
    ///         "prog", "--help"
    ///     ]);
    /// # }
    /// ```
    ///
    /// The above example displays
    ///
    /// ```notrust
    /// helptest
    ///
    /// Usage: helptest [OPTIONS]
    ///
    /// Options:
    ///     --config     Some help text describing the --config arg
    /// -h, --help       Print help information
    /// -V, --version    Print version information
    /// ```
    /// [`Arg::long_help`]: Arg::long_help()
    #[inline]
    #[must_use]
    pub fn help(mut self, h: impl IntoResettable<StyledStr>) -> Self {
        self.help = h.into_resettable().into_option();
        self
    }

    /// Sets the description of the argument for long help (`--help`).
    ///
    /// Typically this a more detailed (multi-line) message
    /// that describes the arg.
    ///
    /// If [`Arg::help`] is not specified, this message will be displayed for `-h`.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Only [`Arg::help`] is used in completion script generation in order to be concise
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// Any valid UTF-8 is allowed in the help text. The one exception is when one wishes to
    /// include a newline in the help text and have the following text be properly aligned with all
    /// the other help text.
    ///
    /// Setting `help` displays a short message to the side of the argument when the user passes
    /// `-h` or `--help` (by default).
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .long("config")
    ///         .long_help(
    /// "The config file used by the myprog must be in JSON format
    /// with only valid keys and may not contain other nonsense
    /// that cannot be read by this program. Obviously I'm going on
    /// and on, so I'll stop now."))
    ///     .get_matches_from(vec![
    ///         "prog", "--help"
    ///     ]);
    /// # }
    /// ```
    ///
    /// The above example displays
    ///
    /// ```text
    /// prog
    ///
    /// Usage: prog [OPTIONS]
    ///
    /// Options:
    ///         --config
    ///             The config file used by the myprog must be in JSON format
    ///             with only valid keys and may not contain other nonsense
    ///             that cannot be read by this program. Obviously I'm going on
    ///             and on, so I'll stop now.
    ///
    ///     -h, --help
    ///             Print help information
    ///
    ///     -V, --version
    ///             Print version information
    /// ```
    /// [`Arg::help`]: Arg::help()
    #[inline]
    #[must_use]
    pub fn long_help(mut self, h: impl IntoResettable<StyledStr>) -> Self {
        self.long_help = h.into_resettable().into_option();
        self
    }

    /// Allows custom ordering of args within the help message.
    ///
    /// `Arg`s with a lower value will be displayed first in the help message.
    /// Those with the same display order will be sorted.
    ///
    /// `Arg`s are automatically assigned a display order based on the order they are added to the
    /// [`Command`][crate::Command].
    /// Overriding this is helpful when the order arguments are added in isn't the same as the
    /// display order, whether in one-off cases or to automatically sort arguments.
    ///
    /// To change, see [`Command::next_display_order`][crate::Command::next_display_order].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This setting is ignored for [positional arguments] which are always displayed in
    /// [index] order.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("boat")
    ///         .short('b')
    ///         .long("boat")
    ///         .action(ArgAction::Set)
    ///         .display_order(0)  // Sort
    ///         .help("Some help and text"))
    ///     .arg(Arg::new("airplane")
    ///         .short('a')
    ///         .long("airplane")
    ///         .action(ArgAction::Set)
    ///         .display_order(0)  // Sort
    ///         .help("I should be first!"))
    ///     .arg(Arg::new("custom-help")
    ///         .short('?')
    ///         .action(ArgAction::Help)
    ///         .display_order(100)  // Don't sort
    ///         .help("Alt help"))
    ///     .get_matches_from(vec![
    ///         "prog", "--help"
    ///     ]);
    /// # }
    /// ```
    ///
    /// The above example displays the following help message
    ///
    /// ```text
    /// cust-ord
    ///
    /// Usage: cust-ord [OPTIONS]
    ///
    /// Options:
    ///     -a, --airplane <airplane>    I should be first!
    ///     -b, --boat <boar>            Some help and text
    ///     -h, --help                   Print help information
    ///     -?                           Alt help
    /// ```
    /// [positional arguments]: Arg::index()
    /// [index]: Arg::index()
    #[inline]
    #[must_use]
    pub fn display_order(mut self, ord: impl IntoResettable<usize>) -> Self {
        self.disp_ord = ord.into_resettable().into_option();
        self
    }

    /// Override the [current] help section.
    ///
    /// [current]: crate::Command::next_help_heading
    #[inline]
    #[must_use]
    pub fn help_heading(mut self, heading: impl IntoResettable<Str>) -> Self {
        self.help_heading = Some(heading.into_resettable().into_option());
        self
    }

    /// Render the [help][Arg::help] on the line after the argument.
    ///
    /// This can be helpful for arguments with very long or complex help messages.
    /// This can also be helpful for arguments with very long flag names, or many/long value names.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** To apply this setting to all arguments and subcommands, consider using
    /// [`crate::Command::next_line_help`]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("opt")
    ///         .long("long-option-flag")
    ///         .short('o')
    ///         .action(ArgAction::Set)
    ///         .next_line_help(true)
    ///         .value_names(["value1", "value2"])
    ///         .help("Some really long help and complex\n\
    ///                help that makes more sense to be\n\
    ///                on a line after the option"))
    ///     .get_matches_from(vec![
    ///         "prog", "--help"
    ///     ]);
    /// # }
    /// ```
    ///
    /// The above example displays the following help message
    ///
    /// ```text
    /// nlh
    ///
    /// Usage: nlh [OPTIONS]
    ///
    /// Options:
    ///     -h, --help       Print help information
    ///     -V, --version    Print version information
    ///     -o, --long-option-flag <value1> <value2>
    ///         Some really long help and complex
    ///         help that makes more sense to be
    ///         on a line after the option
    /// ```
    #[inline]
    #[must_use]
    pub fn next_line_help(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::NextLineHelp)
        } else {
            self.unset_setting(ArgSettings::NextLineHelp)
        }
    }

    /// Do not display the argument in help message.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This does **not** hide the argument from usage strings on error
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// Setting `Hidden` will hide the argument when displaying help text
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .long("config")
    ///         .hide(true)
    ///         .help("Some help text describing the --config arg"))
    ///     .get_matches_from(vec![
    ///         "prog", "--help"
    ///     ]);
    /// # }
    /// ```
    ///
    /// The above example displays
    ///
    /// ```text
    /// helptest
    ///
    /// Usage: helptest [OPTIONS]
    ///
    /// Options:
    /// -h, --help       Print help information
    /// -V, --version    Print version information
    /// ```
    #[inline]
    #[must_use]
    pub fn hide(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::Hidden)
        } else {
            self.unset_setting(ArgSettings::Hidden)
        }
    }

    /// Do not display the [possible values][crate::builder::ValueParser::possible_values] in the help message.
    ///
    /// This is useful for args with many values, or ones which are explained elsewhere in the
    /// help text.
    ///
    /// To set this for all arguments, see
    /// [`Command::hide_possible_values`][crate::Command::hide_possible_values].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this requires [taking values][Arg::num_args]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("mode")
    ///         .long("mode")
    ///         .value_parser(["fast", "slow"])
    ///         .action(ArgAction::Set)
    ///         .hide_possible_values(true));
    /// ```
    /// If we were to run the above program with `--help` the `[values: fast, slow]` portion of
    /// the help text would be omitted.
    #[inline]
    #[must_use]
    pub fn hide_possible_values(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::HidePossibleValues)
        } else {
            self.unset_setting(ArgSettings::HidePossibleValues)
        }
    }

    /// Do not display the default value of the argument in the help message.
    ///
    /// This is useful when default behavior of an arg is explained elsewhere in the help text.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this requires [taking values][Arg::num_args]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("connect")
    ///     .arg(Arg::new("host")
    ///         .long("host")
    ///         .default_value("localhost")
    ///         .action(ArgAction::Set)
    ///         .hide_default_value(true));
    ///
    /// ```
    ///
    /// If we were to run the above program with `--help` the `[default: localhost]` portion of
    /// the help text would be omitted.
    #[inline]
    #[must_use]
    pub fn hide_default_value(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::HideDefaultValue)
        } else {
            self.unset_setting(ArgSettings::HideDefaultValue)
        }
    }

    /// Do not display in help the environment variable name.
    ///
    /// This is useful when the variable option is explained elsewhere in the help text.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("mode")
    ///         .long("mode")
    ///         .env("MODE")
    ///         .action(ArgAction::Set)
    ///         .hide_env(true));
    /// ```
    ///
    /// If we were to run the above program with `--help` the `[env: MODE]` portion of the help
    /// text would be omitted.
    #[cfg(feature = "env")]
    #[inline]
    #[must_use]
    pub fn hide_env(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::HideEnv)
        } else {
            self.unset_setting(ArgSettings::HideEnv)
        }
    }

    /// Do not display in help any values inside the associated ENV variables for the argument.
    ///
    /// This is useful when ENV vars contain sensitive values.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("connect")
    ///     .arg(Arg::new("host")
    ///         .long("host")
    ///         .env("CONNECT")
    ///         .action(ArgAction::Set)
    ///         .hide_env_values(true));
    ///
    /// ```
    ///
    /// If we were to run the above program with `$ CONNECT=super_secret connect --help` the
    /// `[default: CONNECT=super_secret]` portion of the help text would be omitted.
    #[cfg(feature = "env")]
    #[inline]
    #[must_use]
    pub fn hide_env_values(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::HideEnvValues)
        } else {
            self.unset_setting(ArgSettings::HideEnvValues)
        }
    }

    /// Hides an argument from short help (`-h`).
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This does **not** hide the argument from usage strings on error
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this option will cause next-line-help output style to be used
    /// when long help (`--help`) is called.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Arg::new("debug")
    ///     .hide_short_help(true);
    /// ```
    ///
    /// Setting `hide_short_help(true)` will hide the argument when displaying short help text
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .long("config")
    ///         .hide_short_help(true)
    ///         .help("Some help text describing the --config arg"))
    ///     .get_matches_from(vec![
    ///         "prog", "-h"
    ///     ]);
    /// # }
    /// ```
    ///
    /// The above example displays
    ///
    /// ```text
    /// helptest
    ///
    /// Usage: helptest [OPTIONS]
    ///
    /// Options:
    /// -h, --help       Print help information
    /// -V, --version    Print version information
    /// ```
    ///
    /// However, when --help is called
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .long("config")
    ///         .hide_short_help(true)
    ///         .help("Some help text describing the --config arg"))
    ///     .get_matches_from(vec![
    ///         "prog", "--help"
    ///     ]);
    /// # }
    /// ```
    ///
    /// Then the following would be displayed
    ///
    /// ```text
    /// helptest
    ///
    /// Usage: helptest [OPTIONS]
    ///
    /// Options:
    ///     --config     Some help text describing the --config arg
    /// -h, --help       Print help information
    /// -V, --version    Print version information
    /// ```
    #[inline]
    #[must_use]
    pub fn hide_short_help(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::HiddenShortHelp)
        } else {
            self.unset_setting(ArgSettings::HiddenShortHelp)
        }
    }

    /// Hides an argument from long help (`--help`).
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This does **not** hide the argument from usage strings on error
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this option will cause next-line-help output style to be used
    /// when long help (`--help`) is called.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// Setting `hide_long_help(true)` will hide the argument when displaying long help text
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .long("config")
    ///         .hide_long_help(true)
    ///         .help("Some help text describing the --config arg"))
    ///     .get_matches_from(vec![
    ///         "prog", "--help"
    ///     ]);
    /// # }
    /// ```
    ///
    /// The above example displays
    ///
    /// ```text
    /// helptest
    ///
    /// Usage: helptest [OPTIONS]
    ///
    /// Options:
    /// -h, --help       Print help information
    /// -V, --version    Print version information
    /// ```
    ///
    /// However, when -h is called
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .long("config")
    ///         .hide_long_help(true)
    ///         .help("Some help text describing the --config arg"))
    ///     .get_matches_from(vec![
    ///         "prog", "-h"
    ///     ]);
    /// # }
    /// ```
    ///
    /// Then the following would be displayed
    ///
    /// ```text
    /// helptest
    ///
    /// Usage: helptest [OPTIONS]
    ///
    /// OPTIONS:
    ///     --config     Some help text describing the --config arg
    /// -h, --help       Print help information
    /// -V, --version    Print version information
    /// ```
    #[inline]
    #[must_use]
    pub fn hide_long_help(self, yes: bool) -> Self {
        if yes {
            self.setting(ArgSettings::HiddenLongHelp)
        } else {
            self.unset_setting(ArgSettings::HiddenLongHelp)
        }
    }
}

/// # Advanced Argument Relations
impl Arg {
    /// The name of the [`ArgGroup`] the argument belongs to.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// Arg::new("debug")
    ///     .long("debug")
    ///     .action(ArgAction::SetTrue)
    ///     .group("mode")
    /// # ;
    /// ```
    ///
    /// Multiple arguments can be a member of a single group and then the group checked as if it
    /// was one of said arguments.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("debug")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue)
    ///         .group("mode"))
    ///     .arg(Arg::new("verbose")
    ///         .long("verbose")
    ///         .action(ArgAction::SetTrue)
    ///         .group("mode"))
    ///     .get_matches_from(vec![
    ///         "prog", "--debug"
    ///     ]);
    /// assert!(m.contains_id("mode"));
    /// ```
    ///
    /// [`ArgGroup`]: crate::ArgGroup
    #[must_use]
    pub fn group(mut self, group_id: impl IntoResettable<Id>) -> Self {
        if let Some(group_id) = group_id.into_resettable().into_option() {
            self.groups.push(group_id);
        } else {
            self.groups.clear();
        }
        self
    }

    /// The names of [`ArgGroup`]'s the argument belongs to.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// Arg::new("debug")
    ///     .long("debug")
    ///     .action(ArgAction::SetTrue)
    ///     .groups(["mode", "verbosity"])
    /// # ;
    /// ```
    ///
    /// Arguments can be members of multiple groups and then the group checked as if it
    /// was one of said arguments.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("debug")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue)
    ///         .groups(["mode", "verbosity"]))
    ///     .arg(Arg::new("verbose")
    ///         .long("verbose")
    ///         .action(ArgAction::SetTrue)
    ///         .groups(["mode", "verbosity"]))
    ///     .get_matches_from(vec![
    ///         "prog", "--debug"
    ///     ]);
    /// assert!(m.contains_id("mode"));
    /// assert!(m.contains_id("verbosity"));
    /// ```
    ///
    /// [`ArgGroup`]: crate::ArgGroup
    #[must_use]
    pub fn groups(mut self, group_ids: impl IntoIterator<Item = impl Into<Id>>) -> Self {
        self.groups.extend(group_ids.into_iter().map(Into::into));
        self
    }

    /// Specifies the value of the argument if `arg` has been used at runtime.
    ///
    /// If `default` is set to `None`, `default_value` will be removed.
    ///
    /// Like with command-line values, this will be split by [`Arg::value_delimiter`].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This setting is perfectly compatible with [`Arg::default_value`] but slightly
    /// different. `Arg::default_value` *only* takes effect when the user has not provided this arg
    /// at runtime. This setting however only takes effect when the user has not provided a value at
    /// runtime **and** these other conditions are met as well. If you have set `Arg::default_value`
    /// and `Arg::default_value_if`, and the user **did not** provide this arg at runtime, nor were
    /// the conditions met for `Arg::default_value_if`, the `Arg::default_value` will be applied.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// First we use the default value only if another arg is present at runtime.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// # use clap::builder::{ArgPredicate};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .default_value_if("flag", ArgPredicate::IsPresent, Some("default")))
    ///     .get_matches_from(vec![
    ///         "prog", "--flag"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("other").unwrap(), "default");
    /// ```
    ///
    /// Next we run the same test, but without providing `--flag`.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .default_value_if("flag", "true", Some("default")))
    ///     .get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("other"), None);
    /// ```
    ///
    /// Now lets only use the default value if `--opt` contains the value `special`.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("opt")
    ///         .action(ArgAction::Set)
    ///         .long("opt"))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .default_value_if("opt", "special", Some("default")))
    ///     .get_matches_from(vec![
    ///         "prog", "--opt", "special"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("other").unwrap(), "default");
    /// ```
    ///
    /// We can run the same test and provide any value *other than* `special` and we won't get a
    /// default value.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("opt")
    ///         .action(ArgAction::Set)
    ///         .long("opt"))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .default_value_if("opt", "special", Some("default")))
    ///     .get_matches_from(vec![
    ///         "prog", "--opt", "hahaha"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("other"), None);
    /// ```
    ///
    /// If we want to unset the default value for an Arg based on the presence or
    /// value of some other Arg.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .default_value("default")
    ///         .default_value_if("flag", "true", None))
    ///     .get_matches_from(vec![
    ///         "prog", "--flag"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("other"), None);
    /// ```
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    /// [`Arg::default_value`]: Arg::default_value()
    #[must_use]
    pub fn default_value_if(
        mut self,
        arg_id: impl Into<Id>,
        predicate: impl Into<ArgPredicate>,
        default: impl IntoResettable<OsStr>,
    ) -> Self {
        self.default_vals_ifs.push((
            arg_id.into(),
            predicate.into(),
            default.into_resettable().into_option(),
        ));
        self
    }

    #[must_use]
    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::default_value_if`")
    )]
    pub fn default_value_if_os(
        self,
        arg_id: impl Into<Id>,
        predicate: impl Into<ArgPredicate>,
        default: impl IntoResettable<OsStr>,
    ) -> Self {
        self.default_value_if(arg_id, predicate, default)
    }

    /// Specifies multiple values and conditions in the same manner as [`Arg::default_value_if`].
    ///
    /// The method takes a slice of tuples in the `(arg, predicate, default)` format.
    ///
    /// Like with command-line values, this will be split by [`Arg::value_delimiter`].
    ///
    /// <div class="warning">
    ///
    /// **NOTE**: The conditions are stored in order and evaluated in the same order. I.e. the first
    /// if multiple conditions are true, the first one found will be applied and the ultimate value.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// First we use the default value only if another arg is present at runtime.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("opt")
    ///         .long("opt")
    ///         .action(ArgAction::Set))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .default_value_ifs([
    ///             ("flag", "true", Some("default")),
    ///             ("opt", "channal", Some("chan")),
    ///         ]))
    ///     .get_matches_from(vec![
    ///         "prog", "--opt", "channal"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("other").unwrap(), "chan");
    /// ```
    ///
    /// Next we run the same test, but without providing `--flag`.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .default_value_ifs([
    ///             ("flag", "true", Some("default")),
    ///             ("opt", "channal", Some("chan")),
    ///         ]))
    ///     .get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("other"), None);
    /// ```
    ///
    /// We can also see that these values are applied in order, and if more than one condition is
    /// true, only the first evaluated "wins"
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// # use clap::builder::ArgPredicate;
    /// let m = Command::new("prog")
    ///     .arg(Arg::new("flag")
    ///         .long("flag")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("opt")
    ///         .long("opt")
    ///         .action(ArgAction::Set))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .default_value_ifs([
    ///             ("flag", ArgPredicate::IsPresent, Some("default")),
    ///             ("opt", ArgPredicate::Equals("channal".into()), Some("chan")),
    ///         ]))
    ///     .get_matches_from(vec![
    ///         "prog", "--opt", "channal", "--flag"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("other").unwrap(), "default");
    /// ```
    /// [`Arg::action(ArgAction::Set)`]: Arg::action()
    /// [`Arg::default_value_if`]: Arg::default_value_if()
    #[must_use]
    pub fn default_value_ifs(
        mut self,
        ifs: impl IntoIterator<
            Item = (
                impl Into<Id>,
                impl Into<ArgPredicate>,
                impl IntoResettable<OsStr>,
            ),
        >,
    ) -> Self {
        for (arg, predicate, default) in ifs {
            self = self.default_value_if(arg, predicate, default);
        }
        self
    }

    #[must_use]
    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::default_value_ifs`")
    )]
    pub fn default_value_ifs_os(
        self,
        ifs: impl IntoIterator<
            Item = (
                impl Into<Id>,
                impl Into<ArgPredicate>,
                impl IntoResettable<OsStr>,
            ),
        >,
    ) -> Self {
        self.default_value_ifs(ifs)
    }

    /// Set this arg as [required] as long as the specified argument is not present at runtime.
    ///
    /// <div class="warning">
    ///
    /// **TIP:** Using `Arg::required_unless_present` implies [`Arg::required`] and is therefore not
    /// mandatory to also set.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .required_unless_present("debug")
    /// # ;
    /// ```
    ///
    /// In the following example, the required argument is *not* provided,
    /// but it's not an error because the `unless` arg has been supplied.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_unless_present("dbg")
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("dbg")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--debug"
    ///     ]);
    ///
    /// assert!(res.is_ok());
    /// ```
    ///
    /// Setting `Arg::required_unless_present(name)` and *not* supplying `name` or this arg is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_unless_present("dbg")
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("dbg")
    ///         .long("debug"))
    ///     .try_get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [required]: Arg::required()
    #[must_use]
    pub fn required_unless_present(mut self, arg_id: impl IntoResettable<Id>) -> Self {
        if let Some(arg_id) = arg_id.into_resettable().into_option() {
            self.r_unless.push(arg_id);
        } else {
            self.r_unless.clear();
        }
        self
    }

    /// Sets this arg as [required] unless *all* of the specified arguments are present at runtime.
    ///
    /// In other words, parsing will succeed only if user either
    /// * supplies the `self` arg.
    /// * supplies *all* of the `names` arguments.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** If you wish for this argument to only be required unless *any of* these args are
    /// present see [`Arg::required_unless_present_any`]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .required_unless_present_all(["cfg", "dbg"])
    /// # ;
    /// ```
    ///
    /// In the following example, the required argument is *not* provided, but it's not an error
    /// because *all* of the `names` args have been supplied.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_unless_present_all(["dbg", "infile"])
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("dbg")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("infile")
    ///         .short('i')
    ///         .action(ArgAction::Set))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--debug", "-i", "file"
    ///     ]);
    ///
    /// assert!(res.is_ok());
    /// ```
    ///
    /// Setting [`Arg::required_unless_present_all(names)`] and *not* supplying
    /// either *all* of `unless` args or the `self` arg is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_unless_present_all(["dbg", "infile"])
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("dbg")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("infile")
    ///         .short('i')
    ///         .action(ArgAction::Set))
    ///     .try_get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [required]: Arg::required()
    /// [`Arg::required_unless_present_any`]: Arg::required_unless_present_any()
    /// [`Arg::required_unless_present_all(names)`]: Arg::required_unless_present_all()
    #[must_use]
    pub fn required_unless_present_all(
        mut self,
        names: impl IntoIterator<Item = impl Into<Id>>,
    ) -> Self {
        self.r_unless_all.extend(names.into_iter().map(Into::into));
        self
    }

    /// Sets this arg as [required] unless *any* of the specified arguments are present at runtime.
    ///
    /// In other words, parsing will succeed only if user either
    /// * supplies the `self` arg.
    /// * supplies *one or more* of the `unless` arguments.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** If you wish for this argument to be required unless *all of* these args are
    /// present see [`Arg::required_unless_present_all`]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .required_unless_present_any(["cfg", "dbg"])
    /// # ;
    /// ```
    ///
    /// Setting [`Arg::required_unless_present_any(names)`] requires that the argument be used at runtime
    /// *unless* *at least one of* the args in `names` are present. In the following example, the
    /// required argument is *not* provided, but it's not an error because one the `unless` args
    /// have been supplied.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_unless_present_any(["dbg", "infile"])
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("dbg")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("infile")
    ///         .short('i')
    ///         .action(ArgAction::Set))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--debug"
    ///     ]);
    ///
    /// assert!(res.is_ok());
    /// ```
    ///
    /// Setting [`Arg::required_unless_present_any(names)`] and *not* supplying *at least one of* `names`
    /// or this arg is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_unless_present_any(["dbg", "infile"])
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("dbg")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("infile")
    ///         .short('i')
    ///         .action(ArgAction::Set))
    ///     .try_get_matches_from(vec![
    ///         "prog"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [required]: Arg::required()
    /// [`Arg::required_unless_present_any(names)`]: Arg::required_unless_present_any()
    /// [`Arg::required_unless_present_all`]: Arg::required_unless_present_all()
    #[must_use]
    pub fn required_unless_present_any(
        mut self,
        names: impl IntoIterator<Item = impl Into<Id>>,
    ) -> Self {
        self.r_unless.extend(names.into_iter().map(Into::into));
        self
    }

    /// This argument is [required] only if the specified `arg` is present at runtime and its value
    /// equals `val`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .required_if_eq("other_arg", "value")
    /// # ;
    /// ```
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .required_if_eq("other", "special")
    ///         .long("config"))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .action(ArgAction::Set))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--other", "not-special"
    ///     ]);
    ///
    /// assert!(res.is_ok()); // We didn't use --other=special, so "cfg" wasn't required
    ///
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .required_if_eq("other", "special")
    ///         .long("config"))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .action(ArgAction::Set))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--other", "special"
    ///     ]);
    ///
    /// // We did use --other=special so "cfg" had become required but was missing.
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    ///
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .required_if_eq("other", "special")
    ///         .long("config"))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .action(ArgAction::Set))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--other", "SPECIAL"
    ///     ]);
    ///
    /// // By default, the comparison is case-sensitive, so "cfg" wasn't required
    /// assert!(res.is_ok());
    ///
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .required_if_eq("other", "special")
    ///         .long("config"))
    ///     .arg(Arg::new("other")
    ///         .long("other")
    ///         .ignore_case(true)
    ///         .action(ArgAction::Set))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--other", "SPECIAL"
    ///     ]);
    ///
    /// // However, case-insensitive comparisons can be enabled.  This typically occurs when using Arg::possible_values().
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [`Arg::requires(name)`]: Arg::requires()
    /// [Conflicting]: Arg::conflicts_with()
    /// [required]: Arg::required()
    #[must_use]
    pub fn required_if_eq(mut self, arg_id: impl Into<Id>, val: impl Into<OsStr>) -> Self {
        self.r_ifs.push((arg_id.into(), val.into()));
        self
    }

    /// Specify this argument is [required] based on multiple conditions.
    ///
    /// The conditions are set up in a `(arg, val)` style tuple. The requirement will only become
    /// valid if one of the specified `arg`'s value equals its corresponding `val`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .required_if_eq_any([
    ///         ("extra", "val"),
    ///         ("option", "spec")
    ///     ])
    /// # ;
    /// ```
    ///
    /// Setting `Arg::required_if_eq_any([(arg, val)])` makes this arg required if any of the `arg`s
    /// are used at runtime and it's corresponding value is equal to `val`. If the `arg`'s value is
    /// anything other than `val`, this argument isn't required.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_if_eq_any([
    ///             ("extra", "val"),
    ///             ("option", "spec")
    ///         ])
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("extra")
    ///         .action(ArgAction::Set)
    ///         .long("extra"))
    ///     .arg(Arg::new("option")
    ///         .action(ArgAction::Set)
    ///         .long("option"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--option", "other"
    ///     ]);
    ///
    /// assert!(res.is_ok()); // We didn't use --option=spec, or --extra=val so "cfg" isn't required
    /// ```
    ///
    /// Setting `Arg::required_if_eq_any([(arg, val)])` and having any of the `arg`s used with its
    /// value of `val` but *not* using this arg is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_if_eq_any([
    ///             ("extra", "val"),
    ///             ("option", "spec")
    ///         ])
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("extra")
    ///         .action(ArgAction::Set)
    ///         .long("extra"))
    ///     .arg(Arg::new("option")
    ///         .action(ArgAction::Set)
    ///         .long("option"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--option", "spec"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [`Arg::requires(name)`]: Arg::requires()
    /// [Conflicting]: Arg::conflicts_with()
    /// [required]: Arg::required()
    #[must_use]
    pub fn required_if_eq_any(
        mut self,
        ifs: impl IntoIterator<Item = (impl Into<Id>, impl Into<OsStr>)>,
    ) -> Self {
        self.r_ifs
            .extend(ifs.into_iter().map(|(id, val)| (id.into(), val.into())));
        self
    }

    /// Specify this argument is [required] based on multiple conditions.
    ///
    /// The conditions are set up in a `(arg, val)` style tuple. The requirement will only become
    /// valid if every one of the specified `arg`'s value equals its corresponding `val`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .required_if_eq_all([
    ///         ("extra", "val"),
    ///         ("option", "spec")
    ///     ])
    /// # ;
    /// ```
    ///
    /// Setting `Arg::required_if_eq_all([(arg, val)])` makes this arg required if all of the `arg`s
    /// are used at runtime and every value is equal to its corresponding `val`. If the `arg`'s value is
    /// anything other than `val`, this argument isn't required.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_if_eq_all([
    ///             ("extra", "val"),
    ///             ("option", "spec")
    ///         ])
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("extra")
    ///         .action(ArgAction::Set)
    ///         .long("extra"))
    ///     .arg(Arg::new("option")
    ///         .action(ArgAction::Set)
    ///         .long("option"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--option", "spec"
    ///     ]);
    ///
    /// assert!(res.is_ok()); // We didn't use --option=spec --extra=val so "cfg" isn't required
    /// ```
    ///
    /// Setting `Arg::required_if_eq_all([(arg, val)])` and having all of the `arg`s used with its
    /// value of `val` but *not* using this arg is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .required_if_eq_all([
    ///             ("extra", "val"),
    ///             ("option", "spec")
    ///         ])
    ///         .action(ArgAction::Set)
    ///         .long("config"))
    ///     .arg(Arg::new("extra")
    ///         .action(ArgAction::Set)
    ///         .long("extra"))
    ///     .arg(Arg::new("option")
    ///         .action(ArgAction::Set)
    ///         .long("option"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--extra", "val", "--option", "spec"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [required]: Arg::required()
    #[must_use]
    pub fn required_if_eq_all(
        mut self,
        ifs: impl IntoIterator<Item = (impl Into<Id>, impl Into<OsStr>)>,
    ) -> Self {
        self.r_ifs_all
            .extend(ifs.into_iter().map(|(id, val)| (id.into(), val.into())));
        self
    }

    /// Require another argument if this arg matches the [`ArgPredicate`]
    ///
    /// This method takes `value, another_arg` pair. At runtime, clap will check
    /// if this arg (`self`) matches the [`ArgPredicate`].
    /// If it does, `another_arg` will be marked as required.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .requires_if("val", "arg")
    /// # ;
    /// ```
    ///
    /// Setting `Arg::requires_if(val, arg)` requires that the `arg` be used at runtime if the
    /// defining argument's value is equal to `val`. If the defining argument is anything other than
    /// `val`, the other argument isn't required.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .requires_if("my.cfg", "other")
    ///         .long("config"))
    ///     .arg(Arg::new("other"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--config", "some.cfg"
    ///     ]);
    ///
    /// assert!(res.is_ok()); // We didn't use --config=my.cfg, so other wasn't required
    /// ```
    ///
    /// Setting `Arg::requires_if(val, arg)` and setting the value to `val` but *not* supplying
    /// `arg` is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .requires_if("my.cfg", "input")
    ///         .long("config"))
    ///     .arg(Arg::new("input"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--config", "my.cfg"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [`Arg::requires(name)`]: Arg::requires()
    /// [Conflicting]: Arg::conflicts_with()
    /// [override]: Arg::overrides_with()
    #[must_use]
    pub fn requires_if(mut self, val: impl Into<ArgPredicate>, arg_id: impl Into<Id>) -> Self {
        self.requires.push((val.into(), arg_id.into()));
        self
    }

    /// Allows multiple conditional requirements.
    ///
    /// The requirement will only become valid if this arg's value matches the
    /// [`ArgPredicate`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .requires_ifs([
    ///         ("val", "arg"),
    ///         ("other_val", "arg2"),
    ///     ])
    /// # ;
    /// ```
    ///
    /// Setting `Arg::requires_ifs(["val", "arg"])` requires that the `arg` be used at runtime if the
    /// defining argument's value is equal to `val`. If the defining argument's value is anything other
    /// than `val`, `arg` isn't required.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .requires_ifs([
    ///             ("special.conf", "opt"),
    ///             ("other.conf", "other"),
    ///         ])
    ///         .long("config"))
    ///     .arg(Arg::new("opt")
    ///         .long("option")
    ///         .action(ArgAction::Set))
    ///     .arg(Arg::new("other"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--config", "special.conf"
    ///     ]);
    ///
    /// assert!(res.is_err()); // We  used --config=special.conf so --option <val> is required
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    ///
    /// Setting `Arg::requires_ifs` with [`ArgPredicate::IsPresent`] and *not* supplying all the
    /// arguments is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction, builder::ArgPredicate};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .requires_ifs([
    ///             (ArgPredicate::IsPresent, "input"),
    ///             (ArgPredicate::IsPresent, "output"),
    ///         ])
    ///         .long("config"))
    ///     .arg(Arg::new("input"))
    ///     .arg(Arg::new("output"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--config", "file.conf", "in.txt"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// // We didn't use output
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    ///
    /// [`Arg::requires(name)`]: Arg::requires()
    /// [Conflicting]: Arg::conflicts_with()
    /// [override]: Arg::overrides_with()
    #[must_use]
    pub fn requires_ifs(
        mut self,
        ifs: impl IntoIterator<Item = (impl Into<ArgPredicate>, impl Into<Id>)>,
    ) -> Self {
        self.requires
            .extend(ifs.into_iter().map(|(val, arg)| (val.into(), arg.into())));
        self
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::requires_ifs`")
    )]
    pub fn requires_all(self, ids: impl IntoIterator<Item = impl Into<Id>>) -> Self {
        self.requires_ifs(ids.into_iter().map(|id| (ArgPredicate::IsPresent, id)))
    }

    /// This argument is mutually exclusive with the specified argument.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Conflicting rules take precedence over being required by default. Conflict rules
    /// only need to be set for one of the two arguments, they do not need to be set for each.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Defining a conflict is two-way, but does *not* need to defined for both arguments
    /// (i.e. if A conflicts with B, defining `A.conflicts_with(B)` is sufficient. You do not
    /// need to also do `B.conflicts_with(A)`)
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** [`Arg::conflicts_with_all(names)`] allows specifying an argument which conflicts with more than one argument.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE** [`Arg::exclusive(true)`] allows specifying an argument which conflicts with every other argument.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** All arguments implicitly conflict with themselves.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .conflicts_with("debug")
    /// # ;
    /// ```
    ///
    /// Setting conflicting argument, and having both arguments present at runtime is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .conflicts_with("debug")
    ///         .long("config"))
    ///     .arg(Arg::new("debug")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--debug", "--config", "file.conf"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::ArgumentConflict);
    /// ```
    ///
    /// [`Arg::conflicts_with_all(names)`]: Arg::conflicts_with_all()
    /// [`Arg::exclusive(true)`]: Arg::exclusive()
    #[must_use]
    pub fn conflicts_with(mut self, arg_id: impl IntoResettable<Id>) -> Self {
        if let Some(arg_id) = arg_id.into_resettable().into_option() {
            self.blacklist.push(arg_id);
        } else {
            self.blacklist.clear();
        }
        self
    }

    /// This argument is mutually exclusive with the specified arguments.
    ///
    /// See [`Arg::conflicts_with`].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Conflicting rules take precedence over being required by default. Conflict rules
    /// only need to be set for one of the two arguments, they do not need to be set for each.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Defining a conflict is two-way, but does *not* need to defined for both arguments
    /// (i.e. if A conflicts with B, defining `A.conflicts_with(B)` is sufficient. You do not need
    /// need to also do `B.conflicts_with(A)`)
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** [`Arg::exclusive(true)`] allows specifying an argument which conflicts with every other argument.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// Arg::new("config")
    ///     .conflicts_with_all(["debug", "input"])
    /// # ;
    /// ```
    ///
    /// Setting conflicting argument, and having any of the arguments present at runtime with a
    /// conflicting argument is an error.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("cfg")
    ///         .action(ArgAction::Set)
    ///         .conflicts_with_all(["debug", "input"])
    ///         .long("config"))
    ///     .arg(Arg::new("debug")
    ///         .long("debug"))
    ///     .arg(Arg::new("input"))
    ///     .try_get_matches_from(vec![
    ///         "prog", "--config", "file.conf", "file.txt"
    ///     ]);
    ///
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::ArgumentConflict);
    /// ```
    /// [`Arg::conflicts_with`]: Arg::conflicts_with()
    /// [`Arg::exclusive(true)`]: Arg::exclusive()
    #[must_use]
    pub fn conflicts_with_all(mut self, names: impl IntoIterator<Item = impl Into<Id>>) -> Self {
        self.blacklist.extend(names.into_iter().map(Into::into));
        self
    }

    /// Sets an overridable argument.
    ///
    /// i.e. this argument and the following argument
    /// will override each other in POSIX style (whichever argument was specified at runtime
    /// **last** "wins")
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** When an argument is overridden it is essentially as if it never was used, any
    /// conflicts, requirements, etc. are evaluated **after** all "overrides" have been removed
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Overriding an argument implies they [conflict][Arg::conflicts_with`].
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg};
    /// let m = Command::new("prog")
    ///     .arg(arg!(-f --flag "some flag")
    ///         .conflicts_with("debug"))
    ///     .arg(arg!(-d --debug "other flag"))
    ///     .arg(arg!(-c --color "third flag")
    ///         .overrides_with("flag"))
    ///     .get_matches_from(vec![
    ///         "prog", "-f", "-d", "-c"]);
    ///             //    ^~~~~~~~~~~~^~~~~ flag is overridden by color
    ///
    /// assert!(m.get_flag("color"));
    /// assert!(m.get_flag("debug")); // even though flag conflicts with debug, it's as if flag
    ///                                 // was never used because it was overridden with color
    /// assert!(!m.get_flag("flag"));
    /// ```
    #[must_use]
    pub fn overrides_with(mut self, arg_id: impl IntoResettable<Id>) -> Self {
        if let Some(arg_id) = arg_id.into_resettable().into_option() {
            self.overrides.push(arg_id);
        } else {
            self.overrides.clear();
        }
        self
    }

    /// Sets multiple mutually overridable arguments by name.
    ///
    /// i.e. this argument and the following argument will override each other in POSIX style
    /// (whichever argument was specified at runtime **last** "wins")
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** When an argument is overridden it is essentially as if it never was used, any
    /// conflicts, requirements, etc. are evaluated **after** all "overrides" have been removed
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Overriding an argument implies they [conflict][Arg::conflicts_with_all`].
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg};
    /// let m = Command::new("prog")
    ///     .arg(arg!(-f --flag "some flag")
    ///         .conflicts_with("color"))
    ///     .arg(arg!(-d --debug "other flag"))
    ///     .arg(arg!(-c --color "third flag")
    ///         .overrides_with_all(["flag", "debug"]))
    ///     .get_matches_from(vec![
    ///         "prog", "-f", "-d", "-c"]);
    ///             //    ^~~~~~^~~~~~~~~ flag and debug are overridden by color
    ///
    /// assert!(m.get_flag("color")); // even though flag conflicts with color, it's as if flag
    ///                                 // and debug were never used because they were overridden
    ///                                 // with color
    /// assert!(!m.get_flag("debug"));
    /// assert!(!m.get_flag("flag"));
    /// ```
    #[must_use]
    pub fn overrides_with_all(mut self, names: impl IntoIterator<Item = impl Into<Id>>) -> Self {
        self.overrides.extend(names.into_iter().map(Into::into));
        self
    }
}

/// # Reflection
impl Arg {
    /// Get the name of the argument
    #[inline]
    pub fn get_id(&self) -> &Id {
        &self.id
    }

    /// Get the help specified for this argument, if any
    #[inline]
    pub fn get_help(&self) -> Option<&StyledStr> {
        self.help.as_ref()
    }

    /// Get the long help specified for this argument, if any
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// let arg = Arg::new("foo").long_help("long help");
    /// assert_eq!(Some("long help".to_owned()), arg.get_long_help().map(|s| s.to_string()));
    /// ```
    ///
    #[inline]
    pub fn get_long_help(&self) -> Option<&StyledStr> {
        self.long_help.as_ref()
    }

    /// Get the placement within help
    #[inline]
    pub fn get_display_order(&self) -> usize {
        self.disp_ord.unwrap_or(999)
    }

    /// Get the help heading specified for this argument, if any
    #[inline]
    pub fn get_help_heading(&self) -> Option<&str> {
        self.help_heading
            .as_ref()
            .map(|s| s.as_deref())
            .unwrap_or_default()
    }

    /// Get the short option name for this argument, if any
    #[inline]
    pub fn get_short(&self) -> Option<char> {
        self.short
    }

    /// Get visible short aliases for this argument, if any
    #[inline]
    pub fn get_visible_short_aliases(&self) -> Option<Vec<char>> {
        if self.short_aliases.is_empty() {
            None
        } else {
            Some(
                self.short_aliases
                    .iter()
                    .filter_map(|(c, v)| if *v { Some(c) } else { None })
                    .copied()
                    .collect(),
            )
        }
    }

    /// Get *all* short aliases for this argument, if any, both visible and hidden.
    #[inline]
    pub fn get_all_short_aliases(&self) -> Option<Vec<char>> {
        if self.short_aliases.is_empty() {
            None
        } else {
            Some(self.short_aliases.iter().map(|(s, _)| s).copied().collect())
        }
    }

    /// Get the short option name and its visible aliases, if any
    #[inline]
    pub fn get_short_and_visible_aliases(&self) -> Option<Vec<char>> {
        let mut shorts = match self.short {
            Some(short) => vec![short],
            None => return None,
        };
        if let Some(aliases) = self.get_visible_short_aliases() {
            shorts.extend(aliases);
        }
        Some(shorts)
    }

    /// Get the long option name for this argument, if any
    #[inline]
    pub fn get_long(&self) -> Option<&str> {
        self.long.as_deref()
    }

    /// Get visible aliases for this argument, if any
    #[inline]
    pub fn get_visible_aliases(&self) -> Option<Vec<&str>> {
        if self.aliases.is_empty() {
            None
        } else {
            Some(
                self.aliases
                    .iter()
                    .filter_map(|(s, v)| if *v { Some(s.as_str()) } else { None })
                    .collect(),
            )
        }
    }

    /// Get *all* aliases for this argument, if any, both visible and hidden.
    #[inline]
    pub fn get_all_aliases(&self) -> Option<Vec<&str>> {
        if self.aliases.is_empty() {
            None
        } else {
            Some(self.aliases.iter().map(|(s, _)| s.as_str()).collect())
        }
    }

    /// Get the long option name and its visible aliases, if any
    #[inline]
    pub fn get_long_and_visible_aliases(&self) -> Option<Vec<&str>> {
        let mut longs = match self.get_long() {
            Some(long) => vec![long],
            None => return None,
        };
        if let Some(aliases) = self.get_visible_aliases() {
            longs.extend(aliases);
        }
        Some(longs)
    }

    /// Get hidden aliases for this argument, if any
    #[inline]
    pub fn get_aliases(&self) -> Option<Vec<&str>> {
        if self.aliases.is_empty() {
            None
        } else {
            Some(
                self.aliases
                    .iter()
                    .filter_map(|(s, v)| if !*v { Some(s.as_str()) } else { None })
                    .collect(),
            )
        }
    }

    /// Get the names of possible values for this argument. Only useful for user
    /// facing applications, such as building help messages or man files
    pub fn get_possible_values(&self) -> Vec<PossibleValue> {
        if !self.is_takes_value_set() {
            vec![]
        } else {
            self.get_value_parser()
                .possible_values()
                .map(|pvs| pvs.collect())
                .unwrap_or_default()
        }
    }

    /// Get the names of values for this argument.
    #[inline]
    pub fn get_value_names(&self) -> Option<&[Str]> {
        if self.val_names.is_empty() {
            None
        } else {
            Some(&self.val_names)
        }
    }

    /// Get the number of values for this argument.
    #[inline]
    pub fn get_num_args(&self) -> Option<ValueRange> {
        self.num_vals
    }

    #[inline]
    pub(crate) fn get_min_vals(&self) -> usize {
        self.get_num_args().expect(INTERNAL_ERROR_MSG).min_values()
    }

    /// Get the delimiter between multiple values
    #[inline]
    pub fn get_value_delimiter(&self) -> Option<char> {
        self.val_delim
    }

    /// Get the value terminator for this argument. The `value_terminator` is a value
    /// that terminates parsing of multi-valued arguments.
    #[inline]
    pub fn get_value_terminator(&self) -> Option<&Str> {
        self.terminator.as_ref()
    }

    /// Get the index of this argument, if any
    #[inline]
    pub fn get_index(&self) -> Option<usize> {
        self.index
    }

    /// Get the value hint of this argument
    pub fn get_value_hint(&self) -> ValueHint {
        // HACK: we should use `Self::add` and `Self::remove` to type-check that `ArgExt` is used
        self.ext.get::<ValueHint>().copied().unwrap_or_else(|| {
            if self.is_takes_value_set() {
                let type_id = self.get_value_parser().type_id();
                if type_id == AnyValueId::of::<std::path::PathBuf>() {
                    ValueHint::AnyPath
                } else {
                    ValueHint::default()
                }
            } else {
                ValueHint::default()
            }
        })
    }

    /// Get the environment variable name specified for this argument, if any
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::ffi::OsStr;
    /// # use clap::Arg;
    /// let arg = Arg::new("foo").env("ENVIRONMENT");
    /// assert_eq!(arg.get_env(), Some(OsStr::new("ENVIRONMENT")));
    /// ```
    #[cfg(feature = "env")]
    pub fn get_env(&self) -> Option<&std::ffi::OsStr> {
        self.env.as_ref().map(|x| x.0.as_os_str())
    }

    /// Get the default values specified for this argument, if any
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// let arg = Arg::new("foo").default_value("default value");
    /// assert_eq!(arg.get_default_values(), &["default value"]);
    /// ```
    pub fn get_default_values(&self) -> &[OsStr] {
        &self.default_vals
    }

    /// Checks whether this argument is a positional or not.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Arg;
    /// let arg = Arg::new("foo");
    /// assert_eq!(arg.is_positional(), true);
    ///
    /// let arg = Arg::new("foo").long("foo");
    /// assert_eq!(arg.is_positional(), false);
    /// ```
    pub fn is_positional(&self) -> bool {
        self.get_long().is_none() && self.get_short().is_none()
    }

    /// Reports whether [`Arg::required`] is set
    pub fn is_required_set(&self) -> bool {
        self.is_set(ArgSettings::Required)
    }

    pub(crate) fn is_multiple_values_set(&self) -> bool {
        self.get_num_args().unwrap_or_default().is_multiple()
    }

    pub(crate) fn is_takes_value_set(&self) -> bool {
        self.get_num_args()
            .unwrap_or_else(|| 1.into())
            .takes_values()
    }

    /// Report whether [`Arg::allow_hyphen_values`] is set
    pub fn is_allow_hyphen_values_set(&self) -> bool {
        self.is_set(ArgSettings::AllowHyphenValues)
    }

    /// Report whether [`Arg::allow_negative_numbers`] is set
    pub fn is_allow_negative_numbers_set(&self) -> bool {
        self.is_set(ArgSettings::AllowNegativeNumbers)
    }

    /// Behavior when parsing the argument
    pub fn get_action(&self) -> &ArgAction {
        const DEFAULT: ArgAction = ArgAction::Set;
        self.action.as_ref().unwrap_or(&DEFAULT)
    }

    /// Configured parser for argument values
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// let cmd = clap::Command::new("raw")
    ///     .arg(
    ///         clap::Arg::new("port")
    ///             .value_parser(clap::value_parser!(usize))
    ///     );
    /// let value_parser = cmd.get_arguments()
    ///     .find(|a| a.get_id() == "port").unwrap()
    ///     .get_value_parser();
    /// println!("{value_parser:?}");
    /// ```
    pub fn get_value_parser(&self) -> &super::ValueParser {
        if let Some(value_parser) = self.value_parser.as_ref() {
            value_parser
        } else {
            static DEFAULT: super::ValueParser = super::ValueParser::string();
            &DEFAULT
        }
    }

    /// Report whether [`Arg::global`] is set
    pub fn is_global_set(&self) -> bool {
        self.is_set(ArgSettings::Global)
    }

    /// Report whether [`Arg::next_line_help`] is set
    pub fn is_next_line_help_set(&self) -> bool {
        self.is_set(ArgSettings::NextLineHelp)
    }

    /// Report whether [`Arg::hide`] is set
    pub fn is_hide_set(&self) -> bool {
        self.is_set(ArgSettings::Hidden)
    }

    /// Report whether [`Arg::hide_default_value`] is set
    pub fn is_hide_default_value_set(&self) -> bool {
        self.is_set(ArgSettings::HideDefaultValue)
    }

    /// Report whether [`Arg::hide_possible_values`] is set
    pub fn is_hide_possible_values_set(&self) -> bool {
        self.is_set(ArgSettings::HidePossibleValues)
    }

    /// Report whether [`Arg::hide_env`] is set
    #[cfg(feature = "env")]
    pub fn is_hide_env_set(&self) -> bool {
        self.is_set(ArgSettings::HideEnv)
    }

    /// Report whether [`Arg::hide_env_values`] is set
    #[cfg(feature = "env")]
    pub fn is_hide_env_values_set(&self) -> bool {
        self.is_set(ArgSettings::HideEnvValues)
    }

    /// Report whether [`Arg::hide_short_help`] is set
    pub fn is_hide_short_help_set(&self) -> bool {
        self.is_set(ArgSettings::HiddenShortHelp)
    }

    /// Report whether [`Arg::hide_long_help`] is set
    pub fn is_hide_long_help_set(&self) -> bool {
        self.is_set(ArgSettings::HiddenLongHelp)
    }

    /// Report whether [`Arg::require_equals`] is set
    pub fn is_require_equals_set(&self) -> bool {
        self.is_set(ArgSettings::RequireEquals)
    }

    /// Reports whether [`Arg::exclusive`] is set
    pub fn is_exclusive_set(&self) -> bool {
        self.is_set(ArgSettings::Exclusive)
    }

    /// Report whether [`Arg::trailing_var_arg`] is set
    pub fn is_trailing_var_arg_set(&self) -> bool {
        self.is_set(ArgSettings::TrailingVarArg)
    }

    /// Reports whether [`Arg::last`] is set
    pub fn is_last_set(&self) -> bool {
        self.is_set(ArgSettings::Last)
    }

    /// Reports whether [`Arg::ignore_case`] is set
    pub fn is_ignore_case_set(&self) -> bool {
        self.is_set(ArgSettings::IgnoreCase)
    }

    /// Access an [`ArgExt`]
    #[cfg(feature = "unstable-ext")]
    pub fn get<T: ArgExt + Extension>(&self) -> Option<&T> {
        self.ext.get::<T>()
    }

    /// Remove an [`ArgExt`]
    #[cfg(feature = "unstable-ext")]
    pub fn remove<T: ArgExt + Extension>(mut self) -> Option<T> {
        self.ext.remove::<T>()
    }
}

/// # Internally used only
impl Arg {
    pub(crate) fn _build(&mut self) {
        if self.action.is_none() {
            if self.num_vals == Some(ValueRange::EMPTY) {
                let action = ArgAction::SetTrue;
                self.action = Some(action);
            } else {
                let action =
                    if self.is_positional() && self.num_vals.unwrap_or_default().is_unbounded() {
                        // Allow collecting arguments interleaved with flags
                        //
                        // Bounded values are probably a group and the user should explicitly opt-in to
                        // Append
                        ArgAction::Append
                    } else {
                        ArgAction::Set
                    };
                self.action = Some(action);
            }
        }
        if let Some(action) = self.action.as_ref() {
            if let Some(default_value) = action.default_value() {
                if self.default_vals.is_empty() {
                    self.default_vals = vec![default_value.into()];
                }
            }
            if let Some(default_value) = action.default_missing_value() {
                if self.default_missing_vals.is_empty() {
                    self.default_missing_vals = vec![default_value.into()];
                }
            }
        }

        if self.value_parser.is_none() {
            if let Some(default) = self.action.as_ref().and_then(|a| a.default_value_parser()) {
                self.value_parser = Some(default);
            } else {
                self.value_parser = Some(super::ValueParser::string());
            }
        }

        let val_names_len = self.val_names.len();
        if val_names_len > 1 {
            self.num_vals.get_or_insert(val_names_len.into());
        } else {
            let nargs = self.get_action().default_num_args();
            self.num_vals.get_or_insert(nargs);
        }
    }

    // Used for positionals when printing
    pub(crate) fn name_no_brackets(&self) -> String {
        debug!("Arg::name_no_brackets:{}", self.get_id());
        let delim = " ";
        if !self.val_names.is_empty() {
            debug!("Arg::name_no_brackets: val_names={:#?}", self.val_names);

            if self.val_names.len() > 1 {
                self.val_names
                    .iter()
                    .map(|n| format!("<{n}>"))
                    .collect::<Vec<_>>()
                    .join(delim)
            } else {
                self.val_names
                    .first()
                    .expect(INTERNAL_ERROR_MSG)
                    .as_str()
                    .to_owned()
            }
        } else {
            debug!("Arg::name_no_brackets: just name");
            self.get_id().as_str().to_owned()
        }
    }

    pub(crate) fn stylized(&self, styles: &Styles, required: Option<bool>) -> StyledStr {
        use std::fmt::Write as _;
        let literal = styles.get_literal();

        let mut styled = StyledStr::new();
        // Write the name such --long or -l
        if let Some(l) = self.get_long() {
            let _ = write!(styled, "{literal}--{l}{literal:#}",);
        } else if let Some(s) = self.get_short() {
            let _ = write!(styled, "{literal}-{s}{literal:#}");
        }
        styled.push_styled(&self.stylize_arg_suffix(styles, required));
        styled
    }

    pub(crate) fn stylize_arg_suffix(&self, styles: &Styles, required: Option<bool>) -> StyledStr {
        use std::fmt::Write as _;
        let literal = styles.get_literal();
        let placeholder = styles.get_placeholder();
        let mut styled = StyledStr::new();

        let mut need_closing_bracket = false;
        if self.is_takes_value_set() && !self.is_positional() {
            let is_optional_val = self.get_min_vals() == 0;
            let (style, start) = if self.is_require_equals_set() {
                if is_optional_val {
                    need_closing_bracket = true;
                    (placeholder, "[=")
                } else {
                    (literal, "=")
                }
            } else if is_optional_val {
                need_closing_bracket = true;
                (placeholder, " [")
            } else {
                (placeholder, " ")
            };
            let _ = write!(styled, "{style}{start}{style:#}");
        }
        if self.is_takes_value_set() || self.is_positional() {
            let required = required.unwrap_or_else(|| self.is_required_set());
            let arg_val = self.render_arg_val(required);
            let _ = write!(styled, "{placeholder}{arg_val}{placeholder:#}",);
        } else if matches!(*self.get_action(), ArgAction::Count) {
            let _ = write!(styled, "{placeholder}...{placeholder:#}",);
        }
        if need_closing_bracket {
            let _ = write!(styled, "{placeholder}]{placeholder:#}",);
        }

        styled
    }

    /// Write the values such as `<name1> <name2>`
    fn render_arg_val(&self, required: bool) -> String {
        let mut rendered = String::new();

        let num_vals = self.get_num_args().unwrap_or_else(|| 1.into());

        let mut val_names = if self.val_names.is_empty() {
            vec![self.id.as_internal_str().to_owned()]
        } else {
            self.val_names.clone()
        };
        if val_names.len() == 1 {
            let min = num_vals.min_values().max(1);
            let val_name = val_names.pop().unwrap();
            val_names = vec![val_name; min];
        }

        debug_assert!(self.is_takes_value_set());
        for (n, val_name) in val_names.iter().enumerate() {
            let arg_name = if self.is_positional() && (num_vals.min_values() == 0 || !required) {
                format!("[{val_name}]")
            } else {
                format!("<{val_name}>")
            };

            if n != 0 {
                rendered.push(' ');
            }
            rendered.push_str(&arg_name);
        }

        let mut extra_values = false;
        extra_values |= val_names.len() < num_vals.max_values();
        if self.is_positional() && matches!(*self.get_action(), ArgAction::Append) {
            extra_values = true;
        }
        if extra_values {
            rendered.push_str("...");
        }

        rendered
    }

    /// Either multiple values or occurrences
    pub(crate) fn is_multiple(&self) -> bool {
        self.is_multiple_values_set() || matches!(*self.get_action(), ArgAction::Append)
    }
}

impl From<&'_ Arg> for Arg {
    fn from(a: &Arg) -> Self {
        a.clone()
    }
}

impl PartialEq for Arg {
    fn eq(&self, other: &Arg) -> bool {
        self.get_id() == other.get_id()
    }
}

impl PartialOrd for Arg {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Arg {
    fn cmp(&self, other: &Arg) -> Ordering {
        self.get_id().cmp(other.get_id())
    }
}

impl Eq for Arg {}

impl Display for Arg {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let plain = Styles::plain();
        self.stylized(&plain, None).fmt(f)
    }
}

impl fmt::Debug for Arg {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
        let mut ds = f.debug_struct("Arg");

        #[allow(unused_mut)]
        let mut ds = ds
            .field("id", &self.id)
            .field("help", &self.help)
            .field("long_help", &self.long_help)
            .field("action", &self.action)
            .field("value_parser", &self.value_parser)
            .field("blacklist", &self.blacklist)
            .field("settings", &self.settings)
            .field("overrides", &self.overrides)
            .field("groups", &self.groups)
            .field("requires", &self.requires)
            .field("r_ifs", &self.r_ifs)
            .field("r_unless", &self.r_unless)
            .field("short", &self.short)
            .field("long", &self.long)
            .field("aliases", &self.aliases)
            .field("short_aliases", &self.short_aliases)
            .field("disp_ord", &self.disp_ord)
            .field("val_names", &self.val_names)
            .field("num_vals", &self.num_vals)
            .field("val_delim", &self.val_delim)
            .field("default_vals", &self.default_vals)
            .field("default_vals_ifs", &self.default_vals_ifs)
            .field("terminator", &self.terminator)
            .field("index", &self.index)
            .field("help_heading", &self.help_heading)
            .field("default_missing_vals", &self.default_missing_vals)
            .field("ext", &self.ext);

        #[cfg(feature = "env")]
        {
            ds = ds.field("env", &self.env);
        }

        ds.finish()
    }
}

/// User-provided data that can be attached to an [`Arg`]
#[cfg(feature = "unstable-ext")]
pub trait ArgExt: Extension {}

// Flags
#[cfg(test)]
mod test {
    use super::Arg;
    use super::ArgAction;

    #[test]
    fn flag_display_long() {
        let mut f = Arg::new("flg").long("flag").action(ArgAction::SetTrue);
        f._build();

        assert_eq!(f.to_string(), "--flag");
    }

    #[test]
    fn flag_display_short() {
        let mut f2 = Arg::new("flg").short('f').action(ArgAction::SetTrue);
        f2._build();

        assert_eq!(f2.to_string(), "-f");
    }

    #[test]
    fn flag_display_count() {
        let mut f2 = Arg::new("flg").long("flag").action(ArgAction::Count);
        f2._build();

        assert_eq!(f2.to_string(), "--flag...");
    }

    #[test]
    fn flag_display_single_alias() {
        let mut f = Arg::new("flg")
            .long("flag")
            .visible_alias("als")
            .action(ArgAction::SetTrue);
        f._build();

        assert_eq!(f.to_string(), "--flag");
    }

    #[test]
    fn flag_display_multiple_aliases() {
        let mut f = Arg::new("flg").short('f').action(ArgAction::SetTrue);
        f.aliases = vec![
            ("alias_not_visible".into(), false),
            ("f2".into(), true),
            ("f3".into(), true),
            ("f4".into(), true),
        ];
        f._build();

        assert_eq!(f.to_string(), "-f");
    }

    #[test]
    fn flag_display_single_short_alias() {
        let mut f = Arg::new("flg").short('a').action(ArgAction::SetTrue);
        f.short_aliases = vec![('b', true)];
        f._build();

        assert_eq!(f.to_string(), "-a");
    }

    #[test]
    fn flag_display_multiple_short_aliases() {
        let mut f = Arg::new("flg").short('a').action(ArgAction::SetTrue);
        f.short_aliases = vec![('b', false), ('c', true), ('d', true), ('e', true)];
        f._build();

        assert_eq!(f.to_string(), "-a");
    }

    // Options

    #[test]
    fn option_display_multiple_occurrences() {
        let mut o = Arg::new("opt").long("option").action(ArgAction::Append);
        o._build();

        assert_eq!(o.to_string(), "--option <opt>");
    }

    #[test]
    fn option_display_multiple_values() {
        let mut o = Arg::new("opt")
            .long("option")
            .action(ArgAction::Set)
            .num_args(1..);
        o._build();

        assert_eq!(o.to_string(), "--option <opt>...");
    }

    #[test]
    fn option_display_zero_or_more_values() {
        let mut o = Arg::new("opt")
            .long("option")
            .action(ArgAction::Set)
            .num_args(0..);
        o._build();

        assert_eq!(o.to_string(), "--option [<opt>...]");
    }

    #[test]
    fn option_display_one_or_more_values() {
        let mut o = Arg::new("opt")
            .long("option")
            .action(ArgAction::Set)
            .num_args(1..);
        o._build();

        assert_eq!(o.to_string(), "--option <opt>...");
    }

    #[test]
    fn option_display_zero_or_more_values_with_value_name() {
        let mut o = Arg::new("opt")
            .short('o')
            .action(ArgAction::Set)
            .num_args(0..)
            .value_names(["file"]);
        o._build();

        assert_eq!(o.to_string(), "-o [<file>...]");
    }

    #[test]
    fn option_display_one_or_more_values_with_value_name() {
        let mut o = Arg::new("opt")
            .short('o')
            .action(ArgAction::Set)
            .num_args(1..)
            .value_names(["file"]);
        o._build();

        assert_eq!(o.to_string(), "-o <file>...");
    }

    #[test]
    fn option_display_optional_value() {
        let mut o = Arg::new("opt")
            .long("option")
            .action(ArgAction::Set)
            .num_args(0..=1);
        o._build();

        assert_eq!(o.to_string(), "--option [<opt>]");
    }

    #[test]
    fn option_display_value_names() {
        let mut o = Arg::new("opt")
            .short('o')
            .action(ArgAction::Set)
            .value_names(["file", "name"]);
        o._build();

        assert_eq!(o.to_string(), "-o <file> <name>");
    }

    #[test]
    fn option_display3() {
        let mut o = Arg::new("opt")
            .short('o')
            .num_args(1..)
            .action(ArgAction::Set)
            .value_names(["file", "name"]);
        o._build();

        assert_eq!(o.to_string(), "-o <file> <name>...");
    }

    #[test]
    fn option_display_single_alias() {
        let mut o = Arg::new("opt")
            .long("option")
            .action(ArgAction::Set)
            .visible_alias("als");
        o._build();

        assert_eq!(o.to_string(), "--option <opt>");
    }

    #[test]
    fn option_display_multiple_aliases() {
        let mut o = Arg::new("opt")
            .long("option")
            .action(ArgAction::Set)
            .visible_aliases(["als2", "als3", "als4"])
            .alias("als_not_visible");
        o._build();

        assert_eq!(o.to_string(), "--option <opt>");
    }

    #[test]
    fn option_display_single_short_alias() {
        let mut o = Arg::new("opt")
            .short('a')
            .action(ArgAction::Set)
            .visible_short_alias('b');
        o._build();

        assert_eq!(o.to_string(), "-a <opt>");
    }

    #[test]
    fn option_display_multiple_short_aliases() {
        let mut o = Arg::new("opt")
            .short('a')
            .action(ArgAction::Set)
            .visible_short_aliases(['b', 'c', 'd'])
            .short_alias('e');
        o._build();

        assert_eq!(o.to_string(), "-a <opt>");
    }

    // Positionals

    #[test]
    fn positional_display_multiple_values() {
        let mut p = Arg::new("pos").index(1).num_args(1..);
        p._build();

        assert_eq!(p.to_string(), "[pos]...");
    }

    #[test]
    fn positional_display_multiple_values_required() {
        let mut p = Arg::new("pos").index(1).num_args(1..).required(true);
        p._build();

        assert_eq!(p.to_string(), "<pos>...");
    }

    #[test]
    fn positional_display_zero_or_more_values() {
        let mut p = Arg::new("pos").index(1).num_args(0..);
        p._build();

        assert_eq!(p.to_string(), "[pos]...");
    }

    #[test]
    fn positional_display_one_or_more_values() {
        let mut p = Arg::new("pos").index(1).num_args(1..);
        p._build();

        assert_eq!(p.to_string(), "[pos]...");
    }

    #[test]
    fn positional_display_one_or_more_values_required() {
        let mut p = Arg::new("pos").index(1).num_args(1..).required(true);
        p._build();

        assert_eq!(p.to_string(), "<pos>...");
    }

    #[test]
    fn positional_display_optional_value() {
        let mut p = Arg::new("pos")
            .index(1)
            .num_args(0..=1)
            .action(ArgAction::Set);
        p._build();

        assert_eq!(p.to_string(), "[pos]");
    }

    #[test]
    fn positional_display_multiple_occurrences() {
        let mut p = Arg::new("pos").index(1).action(ArgAction::Append);
        p._build();

        assert_eq!(p.to_string(), "[pos]...");
    }

    #[test]
    fn positional_display_multiple_occurrences_required() {
        let mut p = Arg::new("pos")
            .index(1)
            .action(ArgAction::Append)
            .required(true);
        p._build();

        assert_eq!(p.to_string(), "<pos>...");
    }

    #[test]
    fn positional_display_required() {
        let mut p = Arg::new("pos").index(1).required(true);
        p._build();

        assert_eq!(p.to_string(), "<pos>");
    }

    #[test]
    fn positional_display_val_names() {
        let mut p = Arg::new("pos").index(1).value_names(["file1", "file2"]);
        p._build();

        assert_eq!(p.to_string(), "[file1] [file2]");
    }

    #[test]
    fn positional_display_val_names_required() {
        let mut p = Arg::new("pos")
            .index(1)
            .value_names(["file1", "file2"])
            .required(true);
        p._build();

        assert_eq!(p.to_string(), "<file1> <file2>");
    }
}

```

`clap/clap_builder/src/builder/arg_group.rs`:

```rs
// Internal
use crate::builder::IntoResettable;
use crate::util::Id;

/// Family of related [arguments].
///
/// By placing arguments in a logical group, you can create easier requirement and
/// exclusion rules instead of having to list each argument individually, or when you want a rule
/// to apply "any but not all" arguments.
///
/// For instance, you can make an entire `ArgGroup` required. If [`ArgGroup::multiple(true)`] is
/// set, this means that at least one argument from that group must be present. If
/// [`ArgGroup::multiple(false)`] is set (the default), one and *only* one must be present.
///
/// You can also do things such as name an entire `ArgGroup` as a [conflict] or [requirement] for
/// another argument, meaning any of the arguments that belong to that group will cause a failure
/// if present, or must be present respectively.
///
/// Perhaps the most common use of `ArgGroup`s is to require one and *only* one argument to be
/// present out of a given set. Imagine that you had multiple arguments, and you want one of them
/// to be required, but making all of them required isn't feasible because perhaps they conflict
/// with each other. For example, lets say that you were building an application where one could
/// set a given version number by supplying a string with an option argument, i.e.
/// `--set-ver v1.2.3`, you also wanted to support automatically using a previous version number
/// and simply incrementing one of the three numbers. So you create three flags `--major`,
/// `--minor`, and `--patch`. All of these arguments shouldn't be used at one time but you want to
/// specify that *at least one* of them is used. For this, you can create a group.
///
/// Finally, you may use `ArgGroup`s to pull a value from a group of arguments when you don't care
/// exactly which argument was actually used at runtime.
///
/// # Examples
///
/// The following example demonstrates using an `ArgGroup` to ensure that one, and only one, of
/// the arguments from the specified group is present at runtime.
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::{Command, arg, ArgGroup, error::ErrorKind};
/// let result = Command::new("cmd")
///     .arg(arg!(--"set-ver" <ver> "set the version manually"))
///     .arg(arg!(--major           "auto increase major"))
///     .arg(arg!(--minor           "auto increase minor"))
///     .arg(arg!(--patch           "auto increase patch"))
///     .group(ArgGroup::new("vers")
///          .args(["set-ver", "major", "minor", "patch"])
///          .required(true))
///     .try_get_matches_from(vec!["cmd", "--major", "--patch"]);
/// // Because we used two args in the group it's an error
/// assert!(result.is_err());
/// let err = result.unwrap_err();
/// assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
/// ```
///
/// This next example shows a passing parse of the same scenario
/// ```rust
/// # use clap_builder as clap;
/// # use clap::{Command, arg, ArgGroup, Id};
/// let result = Command::new("cmd")
///     .arg(arg!(--"set-ver" <ver> "set the version manually"))
///     .arg(arg!(--major           "auto increase major"))
///     .arg(arg!(--minor           "auto increase minor"))
///     .arg(arg!(--patch           "auto increase patch"))
///     .group(ArgGroup::new("vers")
///          .args(["set-ver", "major", "minor","patch"])
///          .required(true))
///     .try_get_matches_from(vec!["cmd", "--major"]);
/// assert!(result.is_ok());
/// let matches = result.unwrap();
/// // We may not know which of the args was used, so we can test for the group...
/// assert!(matches.contains_id("vers"));
/// // We can also ask the group which arg was used
/// assert_eq!(matches
///     .get_one::<Id>("vers")
///     .expect("`vers` is required")
///     .as_str(),
///     "major"
/// );
/// // we could also alternatively check each arg individually (not shown here)
/// ```
/// [`ArgGroup::multiple(true)`]: ArgGroup::multiple()
///
/// [`ArgGroup::multiple(false)`]: ArgGroup::multiple()
/// [arguments]: crate::Arg
/// [conflict]: crate::Arg::conflicts_with()
/// [requirement]: crate::Arg::requires()
#[derive(Default, Clone, Debug, PartialEq, Eq)]
pub struct ArgGroup {
    pub(crate) id: Id,
    pub(crate) args: Vec<Id>,
    pub(crate) required: bool,
    pub(crate) requires: Vec<Id>,
    pub(crate) conflicts: Vec<Id>,
    pub(crate) multiple: bool,
}

/// # Builder
impl ArgGroup {
    /// Create a `ArgGroup` using a unique name.
    ///
    /// The name will be used to get values from the group or refer to the group inside of conflict
    /// and requirement rules.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, ArgGroup};
    /// ArgGroup::new("config")
    /// # ;
    /// ```
    pub fn new(id: impl Into<Id>) -> Self {
        ArgGroup::default().id(id)
    }

    /// Sets the group name.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, ArgGroup};
    /// ArgGroup::default().id("config")
    /// # ;
    /// ```
    #[must_use]
    pub fn id(mut self, id: impl Into<Id>) -> Self {
        self.id = id.into();
        self
    }

    /// Adds an [argument] to this group by name
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgGroup, ArgAction};
    /// let m = Command::new("myprog")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("color")
    ///         .short('c')
    ///         .action(ArgAction::SetTrue))
    ///     .group(ArgGroup::new("req_flags")
    ///         .arg("flag")
    ///         .arg("color"))
    ///     .get_matches_from(vec!["myprog", "-f"]);
    /// // maybe we don't know which of the two flags was used...
    /// assert!(m.contains_id("req_flags"));
    /// // but we can also check individually if needed
    /// assert!(m.contains_id("flag"));
    /// ```
    /// [argument]: crate::Arg
    #[must_use]
    pub fn arg(mut self, arg_id: impl IntoResettable<Id>) -> Self {
        if let Some(arg_id) = arg_id.into_resettable().into_option() {
            self.args.push(arg_id);
        } else {
            self.args.clear();
        }
        self
    }

    /// Adds multiple [arguments] to this group by name
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgGroup, ArgAction};
    /// let m = Command::new("myprog")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("color")
    ///         .short('c')
    ///         .action(ArgAction::SetTrue))
    ///     .group(ArgGroup::new("req_flags")
    ///         .args(["flag", "color"]))
    ///     .get_matches_from(vec!["myprog", "-f"]);
    /// // maybe we don't know which of the two flags was used...
    /// assert!(m.contains_id("req_flags"));
    /// // but we can also check individually if needed
    /// assert!(m.contains_id("flag"));
    /// ```
    /// [arguments]: crate::Arg
    #[must_use]
    pub fn args(mut self, ns: impl IntoIterator<Item = impl Into<Id>>) -> Self {
        for n in ns {
            self = self.arg(n);
        }
        self
    }

    /// Getters for all args. It will return a vector of `Id`
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{ArgGroup};
    /// let args: Vec<&str> = vec!["a1".into(), "a4".into()];
    /// let grp = ArgGroup::new("program").args(&args);
    ///
    /// for (pos, arg) in grp.get_args().enumerate() {
    ///     assert_eq!(*arg, args[pos]);
    /// }
    /// ```
    pub fn get_args(&self) -> impl Iterator<Item = &Id> {
        self.args.iter()
    }

    /// Allows more than one of the [`Arg`]s in this group to be used. (Default: `false`)
    ///
    /// # Examples
    ///
    /// Notice in this example we use *both* the `-f` and `-c` flags which are both part of the
    /// group
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgGroup, ArgAction};
    /// let m = Command::new("myprog")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("color")
    ///         .short('c')
    ///         .action(ArgAction::SetTrue))
    ///     .group(ArgGroup::new("req_flags")
    ///         .args(["flag", "color"])
    ///         .multiple(true))
    ///     .get_matches_from(vec!["myprog", "-f", "-c"]);
    /// // maybe we don't know which of the two flags was used...
    /// assert!(m.contains_id("req_flags"));
    /// ```
    /// In this next example, we show the default behavior (i.e. `multiple(false)`) which will throw
    /// an error if more than one of the args in the group was used.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgGroup, error::ErrorKind, ArgAction};
    /// let result = Command::new("myprog")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("color")
    ///         .short('c')
    ///         .action(ArgAction::SetTrue))
    ///     .group(ArgGroup::new("req_flags")
    ///         .args(["flag", "color"]))
    ///     .try_get_matches_from(vec!["myprog", "-f", "-c"]);
    /// // Because we used both args in the group it's an error
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    /// assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
    /// ```
    ///
    /// [`Arg`]: crate::Arg
    #[inline]
    #[must_use]
    pub fn multiple(mut self, yes: bool) -> Self {
        self.multiple = yes;
        self
    }

    /// Return true if the group allows more than one of the arguments
    /// in this group to be used. (Default: `false`)
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{ArgGroup};
    /// let mut group = ArgGroup::new("myprog")
    ///     .args(["f", "c"])
    ///     .multiple(true);
    ///
    /// assert!(group.is_multiple());
    /// ```
    pub fn is_multiple(&mut self) -> bool {
        self.multiple
    }

    /// Require an argument from the group to be present when parsing.
    ///
    /// This is unless conflicting with another argument.  A required group will be displayed in
    /// the usage string of the application in the format `<arg|arg2|arg3>`.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This setting only applies to the current [`Command`] / [`Subcommand`]s, and not
    /// globally.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** By default, [`ArgGroup::multiple`] is set to `false` which when combined with
    /// `ArgGroup::required(true)` states, "One and *only one* arg must be used from this group.
    /// Use of more than one arg is an error." Vice setting `ArgGroup::multiple(true)` which
    /// states, '*At least* one arg from this group must be used. Using multiple is OK."
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgGroup, error::ErrorKind, ArgAction};
    /// let result = Command::new("myprog")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("color")
    ///         .short('c')
    ///         .action(ArgAction::SetTrue))
    ///     .group(ArgGroup::new("req_flags")
    ///         .args(["flag", "color"])
    ///         .required(true))
    ///     .try_get_matches_from(vec!["myprog"]);
    /// // Because we didn't use any of the args in the group, it's an error
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    /// assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    ///
    /// [`Subcommand`]: crate::Subcommand
    /// [`ArgGroup::multiple`]: ArgGroup::multiple()
    /// [`Command`]: crate::Command
    #[inline]
    #[must_use]
    pub fn required(mut self, yes: bool) -> Self {
        self.required = yes;
        self
    }

    /// Specify an argument or group that must be present when this group is.
    ///
    /// This is not to be confused with a [required group]. Requirement rules function just like
    /// [argument requirement rules], you can name other arguments or groups that must be present
    /// when any one of the arguments from this group is used.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The name provided may be an argument or group name
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgGroup, error::ErrorKind, ArgAction};
    /// let result = Command::new("myprog")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("color")
    ///         .short('c')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("debug")
    ///         .short('d')
    ///         .action(ArgAction::SetTrue))
    ///     .group(ArgGroup::new("req_flags")
    ///         .args(["flag", "color"])
    ///         .requires("debug"))
    ///     .try_get_matches_from(vec!["myprog", "-c"]);
    /// // because we used an arg from the group, and the group requires "-d" to be used, it's an
    /// // error
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    /// assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [required group]: ArgGroup::required()
    /// [argument requirement rules]: crate::Arg::requires()
    #[must_use]
    pub fn requires(mut self, id: impl IntoResettable<Id>) -> Self {
        if let Some(id) = id.into_resettable().into_option() {
            self.requires.push(id);
        } else {
            self.requires.clear();
        }
        self
    }

    /// Specify arguments or groups that must be present when this group is.
    ///
    /// This is not to be confused with a [required group]. Requirement rules function just like
    /// [argument requirement rules], you can name other arguments or groups that must be present
    /// when one of the arguments from this group is used.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The names provided may be an argument or group name
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgGroup, error::ErrorKind, ArgAction};
    /// let result = Command::new("myprog")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("color")
    ///         .short('c')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("debug")
    ///         .short('d')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("verb")
    ///         .short('v')
    ///         .action(ArgAction::SetTrue))
    ///     .group(ArgGroup::new("req_flags")
    ///         .args(["flag", "color"])
    ///         .requires_all(["debug", "verb"]))
    ///     .try_get_matches_from(vec!["myprog", "-c", "-d"]);
    /// // because we used an arg from the group, and the group requires "-d" and "-v" to be used,
    /// // yet we only used "-d" it's an error
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    /// assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    /// [required group]: ArgGroup::required()
    /// [argument requirement rules]: crate::Arg::requires_ifs()
    #[must_use]
    pub fn requires_all(mut self, ns: impl IntoIterator<Item = impl Into<Id>>) -> Self {
        for n in ns {
            self = self.requires(n);
        }
        self
    }

    /// Specify an argument or group that must **not** be present when this group is.
    ///
    /// Exclusion (aka conflict) rules function just like [argument exclusion rules], you can name
    /// other arguments or groups that must *not* be present when one of the arguments from this
    /// group are used.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The name provided may be an argument, or group name
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgGroup, error::ErrorKind, ArgAction};
    /// let result = Command::new("myprog")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("color")
    ///         .short('c')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("debug")
    ///         .short('d')
    ///         .action(ArgAction::SetTrue))
    ///     .group(ArgGroup::new("req_flags")
    ///         .args(["flag", "color"])
    ///         .conflicts_with("debug"))
    ///     .try_get_matches_from(vec!["myprog", "-c", "-d"]);
    /// // because we used an arg from the group, and the group conflicts with "-d", it's an error
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    /// assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
    /// ```
    /// [argument exclusion rules]: crate::Arg::conflicts_with()
    #[must_use]
    pub fn conflicts_with(mut self, id: impl IntoResettable<Id>) -> Self {
        if let Some(id) = id.into_resettable().into_option() {
            self.conflicts.push(id);
        } else {
            self.conflicts.clear();
        }
        self
    }

    /// Specify arguments or groups that must **not** be present when this group is.
    ///
    /// Exclusion rules function just like [argument exclusion rules], you can name other arguments
    /// or groups that must *not* be present when one of the arguments from this group are used.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The names provided may be an argument, or group name
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgGroup, error::ErrorKind, ArgAction};
    /// let result = Command::new("myprog")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("color")
    ///         .short('c')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("debug")
    ///         .short('d')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("verb")
    ///         .short('v')
    ///         .action(ArgAction::SetTrue))
    ///     .group(ArgGroup::new("req_flags")
    ///         .args(["flag", "color"])
    ///         .conflicts_with_all(["debug", "verb"]))
    ///     .try_get_matches_from(vec!["myprog", "-c", "-v"]);
    /// // because we used an arg from the group, and the group conflicts with either "-v" or "-d"
    /// // it's an error
    /// assert!(result.is_err());
    /// let err = result.unwrap_err();
    /// assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
    /// ```
    ///
    /// [argument exclusion rules]: crate::Arg::conflicts_with_all()
    #[must_use]
    pub fn conflicts_with_all(mut self, ns: impl IntoIterator<Item = impl Into<Id>>) -> Self {
        for n in ns {
            self = self.conflicts_with(n);
        }
        self
    }
}

/// # Reflection
impl ArgGroup {
    /// Get the name of the group
    #[inline]
    pub fn get_id(&self) -> &Id {
        &self.id
    }

    /// Reports whether [`ArgGroup::required`] is set
    #[inline]
    pub fn is_required_set(&self) -> bool {
        self.required
    }
}

impl From<&'_ ArgGroup> for ArgGroup {
    fn from(g: &ArgGroup) -> Self {
        g.clone()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn groups() {
        let g = ArgGroup::new("test")
            .arg("a1")
            .arg("a4")
            .args(["a2", "a3"])
            .required(true)
            .conflicts_with("c1")
            .conflicts_with_all(["c2", "c3"])
            .conflicts_with("c4")
            .requires("r1")
            .requires_all(["r2", "r3"])
            .requires("r4");

        let args: Vec<Id> = vec!["a1".into(), "a4".into(), "a2".into(), "a3".into()];
        let reqs: Vec<Id> = vec!["r1".into(), "r2".into(), "r3".into(), "r4".into()];
        let confs: Vec<Id> = vec!["c1".into(), "c2".into(), "c3".into(), "c4".into()];

        assert_eq!(g.args, args);
        assert_eq!(g.requires, reqs);
        assert_eq!(g.conflicts, confs);
    }

    #[test]
    fn test_from() {
        let g = ArgGroup::new("test")
            .arg("a1")
            .arg("a4")
            .args(["a2", "a3"])
            .required(true)
            .conflicts_with("c1")
            .conflicts_with_all(["c2", "c3"])
            .conflicts_with("c4")
            .requires("r1")
            .requires_all(["r2", "r3"])
            .requires("r4");

        let args: Vec<Id> = vec!["a1".into(), "a4".into(), "a2".into(), "a3".into()];
        let reqs: Vec<Id> = vec!["r1".into(), "r2".into(), "r3".into(), "r4".into()];
        let confs: Vec<Id> = vec!["c1".into(), "c2".into(), "c3".into(), "c4".into()];

        let g2 = ArgGroup::from(&g);
        assert_eq!(g2.args, args);
        assert_eq!(g2.requires, reqs);
        assert_eq!(g2.conflicts, confs);
    }

    // This test will *fail to compile* if ArgGroup is not Send + Sync
    #[test]
    fn arg_group_send_sync() {
        fn foo<T: Send + Sync>(_: T) {}
        foo(ArgGroup::new("test"));
    }

    #[test]
    fn arg_group_expose_is_multiple_helper() {
        let args: Vec<Id> = vec!["a1".into(), "a4".into()];

        let mut grp_multiple = ArgGroup::new("test_multiple").args(&args).multiple(true);
        assert!(grp_multiple.is_multiple());

        let mut grp_not_multiple = ArgGroup::new("test_multiple").args(&args).multiple(false);
        assert!(!grp_not_multiple.is_multiple());
    }

    #[test]
    fn arg_group_expose_get_args_helper() {
        let args: Vec<Id> = vec!["a1".into(), "a4".into()];
        let grp = ArgGroup::new("program").args(&args);

        for (pos, arg) in grp.get_args().enumerate() {
            assert_eq!(*arg, args[pos]);
        }
    }
}

```

`clap/clap_builder/src/builder/arg_predicate.rs`:

```rs
use crate::builder::OsStr;

/// Operations to perform on argument values
///
/// These do not apply to [`ValueSource::DefaultValue`][crate::parser::ValueSource::DefaultValue]
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "unstable-v5", non_exhaustive)]
pub enum ArgPredicate {
    /// Is the argument present?
    IsPresent,
    /// Does the argument match the specified value?
    Equals(OsStr),
}

impl<S: Into<OsStr>> From<S> for ArgPredicate {
    fn from(other: S) -> Self {
        Self::Equals(other.into())
    }
}

```

`clap/clap_builder/src/builder/arg_settings.rs`:

```rs
#[allow(unused)]
use crate::Arg;

#[derive(Default, Copy, Clone, Debug, PartialEq, Eq)]
pub(crate) struct ArgFlags(u32);

impl ArgFlags {
    pub(crate) fn set(&mut self, setting: ArgSettings) {
        self.0 |= setting.bit();
    }

    pub(crate) fn unset(&mut self, setting: ArgSettings) {
        self.0 &= !setting.bit();
    }

    pub(crate) fn is_set(&self, setting: ArgSettings) -> bool {
        self.0 & setting.bit() != 0
    }

    pub(crate) fn insert(&mut self, other: Self) {
        self.0 |= other.0;
    }
}

impl std::ops::BitOr for ArgFlags {
    type Output = Self;

    fn bitor(mut self, rhs: Self) -> Self::Output {
        self.insert(rhs);
        self
    }
}

/// Various settings that apply to arguments and may be set, unset, and checked via getter/setter
/// methods [`Arg::setting`], [`Arg::unset_setting`], and [`Arg::is_set`]. This is what the
/// [`Arg`] methods which accept a `bool` use internally.
///
/// [`Arg`]: crate::Arg
/// [`Arg::setting`]: crate::Arg::setting()
/// [`Arg::unset_setting`]: crate::Arg::unset_setting()
/// [`Arg::is_set`]: crate::Arg::is_set()
#[derive(Debug, PartialEq, Copy, Clone)]
#[repr(u8)]
pub(crate) enum ArgSettings {
    Required,
    Global,
    Hidden,
    NextLineHelp,
    HidePossibleValues,
    AllowHyphenValues,
    AllowNegativeNumbers,
    RequireEquals,
    Last,
    TrailingVarArg,
    HideDefaultValue,
    IgnoreCase,
    #[cfg(feature = "env")]
    HideEnv,
    #[cfg(feature = "env")]
    HideEnvValues,
    HiddenShortHelp,
    HiddenLongHelp,
    Exclusive,
}

impl ArgSettings {
    fn bit(self) -> u32 {
        1 << (self as u8)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::Arg;

    #[test]
    fn setting() {
        let m = Arg::new("setting").setting(ArgSettings::Required);
        assert!(m.is_required_set());
    }

    #[test]
    fn unset_setting() {
        let m = Arg::new("unset_setting").setting(ArgSettings::Required);
        assert!(m.is_required_set());

        let m = m.unset_setting(ArgSettings::Required);
        assert!(!m.is_required_set(), "{m:#?}");
    }
}

```

`clap/clap_builder/src/builder/command.rs`:

```rs
#![cfg_attr(not(feature = "usage"), allow(unused_mut))]

// Std
use std::env;
use std::ffi::OsString;
use std::fmt;
use std::io;
use std::ops::Index;
use std::path::Path;

// Internal
use crate::builder::app_settings::{AppFlags, AppSettings};
use crate::builder::arg_settings::ArgSettings;
use crate::builder::ext::Extension;
use crate::builder::ext::Extensions;
use crate::builder::ArgAction;
use crate::builder::IntoResettable;
use crate::builder::PossibleValue;
use crate::builder::Str;
use crate::builder::StyledStr;
use crate::builder::Styles;
use crate::builder::{Arg, ArgGroup, ArgPredicate};
use crate::error::ErrorKind;
use crate::error::Result as ClapResult;
use crate::mkeymap::MKeyMap;
use crate::output::fmt::Stream;
use crate::output::{fmt::Colorizer, write_help, Usage};
use crate::parser::{ArgMatcher, ArgMatches, Parser};
use crate::util::ChildGraph;
use crate::util::{color::ColorChoice, Id};
use crate::{Error, INTERNAL_ERROR_MSG};

#[cfg(debug_assertions)]
use crate::builder::debug_asserts::assert_app;

/// Build a command-line interface.
///
/// This includes defining arguments, subcommands, parser behavior, and help output.
/// Once all configuration is complete,
/// the [`Command::get_matches`] family of methods starts the runtime-parsing
/// process. These methods then return information about the user supplied
/// arguments (or lack thereof).
///
/// When deriving a [`Parser`][crate::Parser], you can use
/// [`CommandFactory::command`][crate::CommandFactory::command] to access the
/// `Command`.
///
/// - [Basic API][crate::Command#basic-api]
/// - [Application-wide Settings][crate::Command#application-wide-settings]
/// - [Command-specific Settings][crate::Command#command-specific-settings]
/// - [Subcommand-specific Settings][crate::Command#subcommand-specific-settings]
/// - [Reflection][crate::Command#reflection]
///
/// # Examples
///
/// ```no_run
/// # use clap_builder as clap;
/// # use clap::{Command, Arg};
/// let m = Command::new("My Program")
///     .author("Me, me@mail.com")
///     .version("1.0.2")
///     .about("Explains in brief what the program does")
///     .arg(
///         Arg::new("in_file")
///     )
///     .after_help("Longer explanation to appear after the options when \
///                  displaying the help information from --help or -h")
///     .get_matches();
///
/// // Your program logic starts here...
/// ```
/// [`Command::get_matches`]: Command::get_matches()
#[derive(Debug, Clone)]
pub struct Command {
    name: Str,
    long_flag: Option<Str>,
    short_flag: Option<char>,
    display_name: Option<String>,
    bin_name: Option<String>,
    author: Option<Str>,
    version: Option<Str>,
    long_version: Option<Str>,
    about: Option<StyledStr>,
    long_about: Option<StyledStr>,
    before_help: Option<StyledStr>,
    before_long_help: Option<StyledStr>,
    after_help: Option<StyledStr>,
    after_long_help: Option<StyledStr>,
    aliases: Vec<(Str, bool)>,             // (name, visible)
    short_flag_aliases: Vec<(char, bool)>, // (name, visible)
    long_flag_aliases: Vec<(Str, bool)>,   // (name, visible)
    usage_str: Option<StyledStr>,
    usage_name: Option<String>,
    help_str: Option<StyledStr>,
    disp_ord: Option<usize>,
    #[cfg(feature = "help")]
    template: Option<StyledStr>,
    settings: AppFlags,
    g_settings: AppFlags,
    args: MKeyMap,
    subcommands: Vec<Command>,
    groups: Vec<ArgGroup>,
    current_help_heading: Option<Str>,
    current_disp_ord: Option<usize>,
    subcommand_value_name: Option<Str>,
    subcommand_heading: Option<Str>,
    external_value_parser: Option<super::ValueParser>,
    long_help_exists: bool,
    deferred: Option<fn(Command) -> Command>,
    #[cfg(feature = "unstable-ext")]
    ext: Extensions,
    app_ext: Extensions,
}

/// # Basic API
impl Command {
    /// Creates a new instance of an `Command`.
    ///
    /// It is common, but not required, to use binary name as the `name`. This
    /// name will only be displayed to the user when they request to print
    /// version or help and usage information.
    ///
    /// See also [`command!`](crate::command!) and [`crate_name!`](crate::crate_name!).
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("My Program")
    /// # ;
    /// ```
    pub fn new(name: impl Into<Str>) -> Self {
        /// The actual implementation of `new`, non-generic to save code size.
        ///
        /// If we don't do this rustc will unnecessarily generate multiple versions
        /// of this code.
        fn new_inner(name: Str) -> Command {
            Command {
                name,
                ..Default::default()
            }
        }

        new_inner(name.into())
    }

    /// Adds an [argument] to the list of valid possibilities.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg, Arg};
    /// Command::new("myprog")
    ///     // Adding a single "flag" argument with a short and help text, using Arg::new()
    ///     .arg(
    ///         Arg::new("debug")
    ///            .short('d')
    ///            .help("turns on debugging mode")
    ///     )
    ///     // Adding a single "option" argument with a short, a long, and help text using the less
    ///     // verbose Arg::from()
    ///     .arg(
    ///         arg!(-c --config <CONFIG> "Optionally sets a config file to use")
    ///     )
    /// # ;
    /// ```
    /// [argument]: Arg
    #[must_use]
    pub fn arg(mut self, a: impl Into<Arg>) -> Self {
        let arg = a.into();
        self.arg_internal(arg);
        self
    }

    fn arg_internal(&mut self, mut arg: Arg) {
        if let Some(current_disp_ord) = self.current_disp_ord.as_mut() {
            if !arg.is_positional() {
                let current = *current_disp_ord;
                arg.disp_ord.get_or_insert(current);
                *current_disp_ord = current + 1;
            }
        }

        arg.help_heading
            .get_or_insert_with(|| self.current_help_heading.clone());
        self.args.push(arg);
    }

    /// Adds multiple [arguments] to the list of valid possibilities.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg, Arg};
    /// Command::new("myprog")
    ///     .args([
    ///         arg!(-d --debug "turns on debugging info"),
    ///         Arg::new("input").help("the input file to use")
    ///     ])
    /// # ;
    /// ```
    /// [arguments]: Arg
    #[must_use]
    pub fn args(mut self, args: impl IntoIterator<Item = impl Into<Arg>>) -> Self {
        for arg in args {
            self = self.arg(arg);
        }
        self
    }

    /// Allows one to mutate an [`Arg`] after it's been added to a [`Command`].
    ///
    /// # Panics
    ///
    /// If the argument is undefined
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    ///
    /// let mut cmd = Command::new("foo")
    ///     .arg(Arg::new("bar")
    ///         .short('b')
    ///         .action(ArgAction::SetTrue))
    ///     .mut_arg("bar", |a| a.short('B'));
    ///
    /// let res = cmd.try_get_matches_from_mut(vec!["foo", "-b"]);
    ///
    /// // Since we changed `bar`'s short to "B" this should err as there
    /// // is no `-b` anymore, only `-B`
    ///
    /// assert!(res.is_err());
    ///
    /// let res = cmd.try_get_matches_from_mut(vec!["foo", "-B"]);
    /// assert!(res.is_ok());
    /// ```
    #[must_use]
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn mut_arg<F>(mut self, arg_id: impl AsRef<str>, f: F) -> Self
    where
        F: FnOnce(Arg) -> Arg,
    {
        let id = arg_id.as_ref();
        let a = self
            .args
            .remove_by_name(id)
            .unwrap_or_else(|| panic!("Argument `{id}` is undefined"));

        self.args.push(f(a));
        self
    }

    /// Allows one to mutate all [`Arg`]s after they've been added to a [`Command`].
    ///
    /// This does not affect the built-in `--help` or `--version` arguments.
    ///
    /// # Examples
    ///
    #[cfg_attr(feature = "string", doc = "```")]
    #[cfg_attr(not(feature = "string"), doc = "```ignore")]
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    ///
    /// let mut cmd = Command::new("foo")
    ///     .arg(Arg::new("bar")
    ///         .long("bar")
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("baz")
    ///         .long("baz")
    ///         .action(ArgAction::SetTrue))
    ///     .mut_args(|a| {
    ///         if let Some(l) = a.get_long().map(|l| format!("prefix-{l}")) {
    ///             a.long(l)
    ///         } else {
    ///             a
    ///         }
    ///     });
    ///
    /// let res = cmd.try_get_matches_from_mut(vec!["foo", "--bar"]);
    ///
    /// // Since we changed `bar`'s long to "prefix-bar" this should err as there
    /// // is no `--bar` anymore, only `--prefix-bar`.
    ///
    /// assert!(res.is_err());
    ///
    /// let res = cmd.try_get_matches_from_mut(vec!["foo", "--prefix-bar"]);
    /// assert!(res.is_ok());
    /// ```
    #[must_use]
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn mut_args<F>(mut self, f: F) -> Self
    where
        F: FnMut(Arg) -> Arg,
    {
        self.args.mut_args(f);
        self
    }

    /// Allows one to mutate an [`ArgGroup`] after it's been added to a [`Command`].
    ///
    /// # Panics
    ///
    /// If the argument is undefined
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg, ArgGroup};
    ///
    /// Command::new("foo")
    ///     .arg(arg!(--"set-ver" <ver> "set the version manually").required(false))
    ///     .arg(arg!(--major "auto increase major"))
    ///     .arg(arg!(--minor "auto increase minor"))
    ///     .arg(arg!(--patch "auto increase patch"))
    ///     .group(ArgGroup::new("vers")
    ///          .args(["set-ver", "major", "minor","patch"])
    ///          .required(true))
    ///     .mut_group("vers", |a| a.required(false));
    /// ```
    #[must_use]
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn mut_group<F>(mut self, arg_id: impl AsRef<str>, f: F) -> Self
    where
        F: FnOnce(ArgGroup) -> ArgGroup,
    {
        let id = arg_id.as_ref();
        let index = self
            .groups
            .iter()
            .position(|g| g.get_id() == id)
            .unwrap_or_else(|| panic!("Group `{id}` is undefined"));
        let a = self.groups.remove(index);

        self.groups.push(f(a));
        self
    }
    /// Allows one to mutate a [`Command`] after it's been added as a subcommand.
    ///
    /// This can be useful for modifying auto-generated arguments of nested subcommands with
    /// [`Command::mut_arg`].
    ///
    /// # Panics
    ///
    /// If the subcommand is undefined
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    ///
    /// let mut cmd = Command::new("foo")
    ///         .subcommand(Command::new("bar"))
    ///         .mut_subcommand("bar", |subcmd| subcmd.disable_help_flag(true));
    ///
    /// let res = cmd.try_get_matches_from_mut(vec!["foo", "bar", "--help"]);
    ///
    /// // Since we disabled the help flag on the "bar" subcommand, this should err.
    ///
    /// assert!(res.is_err());
    ///
    /// let res = cmd.try_get_matches_from_mut(vec!["foo", "bar"]);
    /// assert!(res.is_ok());
    /// ```
    #[must_use]
    pub fn mut_subcommand<F>(mut self, name: impl AsRef<str>, f: F) -> Self
    where
        F: FnOnce(Self) -> Self,
    {
        let name = name.as_ref();
        let pos = self.subcommands.iter().position(|s| s.name == name);

        let subcmd = if let Some(idx) = pos {
            self.subcommands.remove(idx)
        } else {
            panic!("Command `{name}` is undefined")
        };

        self.subcommands.push(f(subcmd));
        self
    }

    /// Adds an [`ArgGroup`] to the application.
    ///
    /// [`ArgGroup`]s are a family of related arguments.
    /// By placing them in a logical group, you can build easier requirement and exclusion rules.
    ///
    /// Example use cases:
    /// - Make an entire [`ArgGroup`] required, meaning that one (and *only*
    ///   one) argument from that group must be present at runtime.
    /// - Name an [`ArgGroup`] as a conflict to another argument.
    ///   Meaning any of the arguments that belong to that group will cause a failure if present with
    ///   the conflicting argument.
    /// - Ensure exclusion between arguments.
    /// - Extract a value from a group instead of determining exactly which argument was used.
    ///
    /// # Examples
    ///
    /// The following example demonstrates using an [`ArgGroup`] to ensure that one, and only one,
    /// of the arguments from the specified group is present at runtime.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg, ArgGroup};
    /// Command::new("cmd")
    ///     .arg(arg!(--"set-ver" <ver> "set the version manually").required(false))
    ///     .arg(arg!(--major "auto increase major"))
    ///     .arg(arg!(--minor "auto increase minor"))
    ///     .arg(arg!(--patch "auto increase patch"))
    ///     .group(ArgGroup::new("vers")
    ///          .args(["set-ver", "major", "minor","patch"])
    ///          .required(true))
    /// # ;
    /// ```
    #[inline]
    #[must_use]
    pub fn group(mut self, group: impl Into<ArgGroup>) -> Self {
        self.groups.push(group.into());
        self
    }

    /// Adds multiple [`ArgGroup`]s to the [`Command`] at once.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg, ArgGroup};
    /// Command::new("cmd")
    ///     .arg(arg!(--"set-ver" <ver> "set the version manually").required(false))
    ///     .arg(arg!(--major         "auto increase major"))
    ///     .arg(arg!(--minor         "auto increase minor"))
    ///     .arg(arg!(--patch         "auto increase patch"))
    ///     .arg(arg!(-c <FILE>       "a config file").required(false))
    ///     .arg(arg!(-i <IFACE>      "an interface").required(false))
    ///     .groups([
    ///         ArgGroup::new("vers")
    ///             .args(["set-ver", "major", "minor","patch"])
    ///             .required(true),
    ///         ArgGroup::new("input")
    ///             .args(["c", "i"])
    ///     ])
    /// # ;
    /// ```
    #[must_use]
    pub fn groups(mut self, groups: impl IntoIterator<Item = impl Into<ArgGroup>>) -> Self {
        for g in groups {
            self = self.group(g.into());
        }
        self
    }

    /// Adds a subcommand to the list of valid possibilities.
    ///
    /// Subcommands are effectively sub-[`Command`]s, because they can contain their own arguments,
    /// subcommands, version, usage, etc. They also function just like [`Command`]s, in that they get
    /// their own auto generated help, version, and usage.
    ///
    /// A subcommand's [`Command::name`] will be used for:
    /// - The argument the user passes in
    /// - Programmatically looking up the subcommand
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg};
    /// Command::new("myprog")
    ///     .subcommand(Command::new("config")
    ///         .about("Controls configuration features")
    ///         .arg(arg!(<config> "Required configuration file to use")))
    /// # ;
    /// ```
    #[inline]
    #[must_use]
    pub fn subcommand(self, subcmd: impl Into<Command>) -> Self {
        let subcmd = subcmd.into();
        self.subcommand_internal(subcmd)
    }

    fn subcommand_internal(mut self, mut subcmd: Self) -> Self {
        if let Some(current_disp_ord) = self.current_disp_ord.as_mut() {
            let current = *current_disp_ord;
            subcmd.disp_ord.get_or_insert(current);
            *current_disp_ord = current + 1;
        }
        self.subcommands.push(subcmd);
        self
    }

    /// Adds multiple subcommands to the list of valid possibilities.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// # Command::new("myprog")
    /// .subcommands( [
    ///        Command::new("config").about("Controls configuration functionality")
    ///                                 .arg(Arg::new("config_file")),
    ///        Command::new("debug").about("Controls debug functionality")])
    /// # ;
    /// ```
    /// [`IntoIterator`]: std::iter::IntoIterator
    #[must_use]
    pub fn subcommands(mut self, subcmds: impl IntoIterator<Item = impl Into<Self>>) -> Self {
        for subcmd in subcmds {
            self = self.subcommand(subcmd);
        }
        self
    }

    /// Delay initialization for parts of the `Command`
    ///
    /// This is useful for large applications to delay definitions of subcommands until they are
    /// being invoked.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg};
    /// Command::new("myprog")
    ///     .subcommand(Command::new("config")
    ///         .about("Controls configuration features")
    ///         .defer(|cmd| {
    ///             cmd.arg(arg!(<config> "Required configuration file to use"))
    ///         })
    ///     )
    /// # ;
    /// ```
    pub fn defer(mut self, deferred: fn(Command) -> Command) -> Self {
        self.deferred = Some(deferred);
        self
    }

    /// Catch problems earlier in the development cycle.
    ///
    /// Most error states are handled as asserts under the assumption they are programming mistake
    /// and not something to handle at runtime.  Rather than relying on tests (manual or automated)
    /// that exhaustively test your CLI to ensure the asserts are evaluated, this will run those
    /// asserts in a way convenient for running as a test.
    ///
    /// **Note:** This will not help with asserts in [`ArgMatches`], those will need exhaustive
    /// testing of your CLI.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// fn cmd() -> Command {
    ///     Command::new("foo")
    ///         .arg(
    ///             Arg::new("bar").short('b').action(ArgAction::SetTrue)
    ///         )
    /// }
    ///
    /// #[test]
    /// fn verify_app() {
    ///     cmd().debug_assert();
    /// }
    ///
    /// fn main() {
    ///     let m = cmd().get_matches_from(vec!["foo", "-b"]);
    ///     println!("{}", m.get_flag("bar"));
    /// }
    /// ```
    pub fn debug_assert(mut self) {
        self.build();
    }

    /// Custom error message for post-parsing validation
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, error::ErrorKind};
    /// let mut cmd = Command::new("myprog");
    /// let err = cmd.error(ErrorKind::InvalidValue, "Some failure case");
    /// ```
    pub fn error(&mut self, kind: ErrorKind, message: impl fmt::Display) -> Error {
        Error::raw(kind, message).format(self)
    }

    /// Parse [`env::args_os`], [exiting][Error::exit] on failure.
    ///
    /// # Panics
    ///
    /// If contradictory arguments or settings exist (debug builds).
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let matches = Command::new("myprog")
    ///     // Args and options go here...
    ///     .get_matches();
    /// ```
    /// [`env::args_os`]: std::env::args_os()
    /// [`Command::try_get_matches_from_mut`]: Command::try_get_matches_from_mut()
    #[inline]
    pub fn get_matches(self) -> ArgMatches {
        self.get_matches_from(env::args_os())
    }

    /// Parse [`env::args_os`], [exiting][Error::exit] on failure.
    ///
    /// Like [`Command::get_matches`] but doesn't consume the `Command`.
    ///
    /// # Panics
    ///
    /// If contradictory arguments or settings exist (debug builds).
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let mut cmd = Command::new("myprog")
    ///     // Args and options go here...
    ///     ;
    /// let matches = cmd.get_matches_mut();
    /// ```
    /// [`env::args_os`]: std::env::args_os()
    /// [`Command::get_matches`]: Command::get_matches()
    pub fn get_matches_mut(&mut self) -> ArgMatches {
        self.try_get_matches_from_mut(env::args_os())
            .unwrap_or_else(|e| e.exit())
    }

    /// Parse [`env::args_os`], returning a [`clap::Result`] on failure.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This method WILL NOT exit when `--help` or `--version` (or short versions) are
    /// used. It will return a [`clap::Error`], where the [`kind`] is a
    /// [`ErrorKind::DisplayHelp`] or [`ErrorKind::DisplayVersion`] respectively. You must call
    /// [`Error::exit`] or perform a [`std::process::exit`].
    ///
    /// </div>
    ///
    /// # Panics
    ///
    /// If contradictory arguments or settings exist (debug builds).
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let matches = Command::new("myprog")
    ///     // Args and options go here...
    ///     .try_get_matches()
    ///     .unwrap_or_else(|e| e.exit());
    /// ```
    /// [`env::args_os`]: std::env::args_os()
    /// [`Error::exit`]: crate::Error::exit()
    /// [`std::process::exit`]: std::process::exit()
    /// [`clap::Result`]: Result
    /// [`clap::Error`]: crate::Error
    /// [`kind`]: crate::Error
    /// [`ErrorKind::DisplayHelp`]: crate::error::ErrorKind::DisplayHelp
    /// [`ErrorKind::DisplayVersion`]: crate::error::ErrorKind::DisplayVersion
    #[inline]
    pub fn try_get_matches(self) -> ClapResult<ArgMatches> {
        // Start the parsing
        self.try_get_matches_from(env::args_os())
    }

    /// Parse the specified arguments, [exiting][Error::exit] on failure.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The first argument will be parsed as the binary name unless
    /// [`Command::no_binary_name`] is used.
    ///
    /// </div>
    ///
    /// # Panics
    ///
    /// If contradictory arguments or settings exist (debug builds).
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let arg_vec = vec!["my_prog", "some", "args", "to", "parse"];
    ///
    /// let matches = Command::new("myprog")
    ///     // Args and options go here...
    ///     .get_matches_from(arg_vec);
    /// ```
    /// [`Command::get_matches`]: Command::get_matches()
    /// [`clap::Result`]: Result
    /// [`Vec`]: std::vec::Vec
    pub fn get_matches_from<I, T>(mut self, itr: I) -> ArgMatches
    where
        I: IntoIterator<Item = T>,
        T: Into<OsString> + Clone,
    {
        self.try_get_matches_from_mut(itr).unwrap_or_else(|e| {
            drop(self);
            e.exit()
        })
    }

    /// Parse the specified arguments, returning a [`clap::Result`] on failure.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This method WILL NOT exit when `--help` or `--version` (or short versions) are
    /// used. It will return a [`clap::Error`], where the [`kind`] is a [`ErrorKind::DisplayHelp`]
    /// or [`ErrorKind::DisplayVersion`] respectively. You must call [`Error::exit`] or
    /// perform a [`std::process::exit`] yourself.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The first argument will be parsed as the binary name unless
    /// [`Command::no_binary_name`] is used.
    ///
    /// </div>
    ///
    /// # Panics
    ///
    /// If contradictory arguments or settings exist (debug builds).
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let arg_vec = vec!["my_prog", "some", "args", "to", "parse"];
    ///
    /// let matches = Command::new("myprog")
    ///     // Args and options go here...
    ///     .try_get_matches_from(arg_vec)
    ///     .unwrap_or_else(|e| e.exit());
    /// ```
    /// [`Command::get_matches_from`]: Command::get_matches_from()
    /// [`Command::try_get_matches`]: Command::try_get_matches()
    /// [`Error::exit`]: crate::Error::exit()
    /// [`std::process::exit`]: std::process::exit()
    /// [`clap::Error`]: crate::Error
    /// [`Error::exit`]: crate::Error::exit()
    /// [`kind`]: crate::Error
    /// [`ErrorKind::DisplayHelp`]: crate::error::ErrorKind::DisplayHelp
    /// [`ErrorKind::DisplayVersion`]: crate::error::ErrorKind::DisplayVersion
    /// [`clap::Result`]: Result
    pub fn try_get_matches_from<I, T>(mut self, itr: I) -> ClapResult<ArgMatches>
    where
        I: IntoIterator<Item = T>,
        T: Into<OsString> + Clone,
    {
        self.try_get_matches_from_mut(itr)
    }

    /// Parse the specified arguments, returning a [`clap::Result`] on failure.
    ///
    /// Like [`Command::try_get_matches_from`] but doesn't consume the `Command`.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This method WILL NOT exit when `--help` or `--version` (or short versions) are
    /// used. It will return a [`clap::Error`], where the [`kind`] is a [`ErrorKind::DisplayHelp`]
    /// or [`ErrorKind::DisplayVersion`] respectively. You must call [`Error::exit`] or
    /// perform a [`std::process::exit`] yourself.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The first argument will be parsed as the binary name unless
    /// [`Command::no_binary_name`] is used.
    ///
    /// </div>
    ///
    /// # Panics
    ///
    /// If contradictory arguments or settings exist (debug builds).
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let arg_vec = vec!["my_prog", "some", "args", "to", "parse"];
    ///
    /// let mut cmd = Command::new("myprog");
    ///     // Args and options go here...
    /// let matches = cmd.try_get_matches_from_mut(arg_vec)
    ///     .unwrap_or_else(|e| e.exit());
    /// ```
    /// [`Command::try_get_matches_from`]: Command::try_get_matches_from()
    /// [`clap::Result`]: Result
    /// [`clap::Error`]: crate::Error
    /// [`kind`]: crate::Error
    pub fn try_get_matches_from_mut<I, T>(&mut self, itr: I) -> ClapResult<ArgMatches>
    where
        I: IntoIterator<Item = T>,
        T: Into<OsString> + Clone,
    {
        let mut raw_args = clap_lex::RawArgs::new(itr);
        let mut cursor = raw_args.cursor();

        if self.settings.is_set(AppSettings::Multicall) {
            if let Some(argv0) = raw_args.next_os(&mut cursor) {
                let argv0 = Path::new(&argv0);
                if let Some(command) = argv0.file_stem().and_then(|f| f.to_str()) {
                    // Stop borrowing command so we can get another mut ref to it.
                    let command = command.to_owned();
                    debug!("Command::try_get_matches_from_mut: Parsed command {command} from argv");

                    debug!("Command::try_get_matches_from_mut: Reinserting command into arguments so subcommand parser matches it");
                    raw_args.insert(&cursor, [&command]);
                    debug!("Command::try_get_matches_from_mut: Clearing name and bin_name so that displayed command name starts with applet name");
                    self.name = "".into();
                    self.bin_name = None;
                    return self._do_parse(&mut raw_args, cursor);
                }
            }
        };

        // Get the name of the program (argument 1 of env::args()) and determine the
        // actual file
        // that was used to execute the program. This is because a program called
        // ./target/release/my_prog -a
        // will have two arguments, './target/release/my_prog', '-a' but we don't want
        // to display
        // the full path when displaying help messages and such
        if !self.settings.is_set(AppSettings::NoBinaryName) {
            if let Some(name) = raw_args.next_os(&mut cursor) {
                let p = Path::new(name);

                if let Some(f) = p.file_name() {
                    if let Some(s) = f.to_str() {
                        if self.bin_name.is_none() {
                            self.bin_name = Some(s.to_owned());
                        }
                    }
                }
            }
        }

        self._do_parse(&mut raw_args, cursor)
    }

    /// Prints the short help message (`-h`) to [`io::stdout()`].
    ///
    /// See also [`Command::print_long_help`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// let mut cmd = Command::new("myprog");
    /// cmd.print_help();
    /// ```
    /// [`io::stdout()`]: std::io::stdout()
    pub fn print_help(&mut self) -> io::Result<()> {
        self._build_self(false);
        let color = self.color_help();

        let mut styled = StyledStr::new();
        let usage = Usage::new(self);
        write_help(&mut styled, self, &usage, false);

        let c = Colorizer::new(Stream::Stdout, color).with_content(styled);
        c.print()
    }

    /// Prints the long help message (`--help`) to [`io::stdout()`].
    ///
    /// See also [`Command::print_help`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// let mut cmd = Command::new("myprog");
    /// cmd.print_long_help();
    /// ```
    /// [`io::stdout()`]: std::io::stdout()
    /// [`BufWriter`]: std::io::BufWriter
    /// [`-h` (short)]: Arg::help()
    /// [`--help` (long)]: Arg::long_help()
    pub fn print_long_help(&mut self) -> io::Result<()> {
        self._build_self(false);
        let color = self.color_help();

        let mut styled = StyledStr::new();
        let usage = Usage::new(self);
        write_help(&mut styled, self, &usage, true);

        let c = Colorizer::new(Stream::Stdout, color).with_content(styled);
        c.print()
    }

    /// Render the short help message (`-h`) to a [`StyledStr`]
    ///
    /// See also [`Command::render_long_help`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// use std::io;
    /// let mut cmd = Command::new("myprog");
    /// let mut out = io::stdout();
    /// let help = cmd.render_help();
    /// println!("{help}");
    /// ```
    /// [`io::Write`]: std::io::Write
    /// [`-h` (short)]: Arg::help()
    /// [`--help` (long)]: Arg::long_help()
    pub fn render_help(&mut self) -> StyledStr {
        self._build_self(false);

        let mut styled = StyledStr::new();
        let usage = Usage::new(self);
        write_help(&mut styled, self, &usage, false);
        styled
    }

    /// Render the long help message (`--help`) to a [`StyledStr`].
    ///
    /// See also [`Command::render_help`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// use std::io;
    /// let mut cmd = Command::new("myprog");
    /// let mut out = io::stdout();
    /// let help = cmd.render_long_help();
    /// println!("{help}");
    /// ```
    /// [`io::Write`]: std::io::Write
    /// [`-h` (short)]: Arg::help()
    /// [`--help` (long)]: Arg::long_help()
    pub fn render_long_help(&mut self) -> StyledStr {
        self._build_self(false);

        let mut styled = StyledStr::new();
        let usage = Usage::new(self);
        write_help(&mut styled, self, &usage, true);
        styled
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Command::render_help`")
    )]
    pub fn write_help<W: io::Write>(&mut self, w: &mut W) -> io::Result<()> {
        self._build_self(false);

        let mut styled = StyledStr::new();
        let usage = Usage::new(self);
        write_help(&mut styled, self, &usage, false);
        ok!(write!(w, "{styled}"));
        w.flush()
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Command::render_long_help`")
    )]
    pub fn write_long_help<W: io::Write>(&mut self, w: &mut W) -> io::Result<()> {
        self._build_self(false);

        let mut styled = StyledStr::new();
        let usage = Usage::new(self);
        write_help(&mut styled, self, &usage, true);
        ok!(write!(w, "{styled}"));
        w.flush()
    }

    /// Version message rendered as if the user ran `-V`.
    ///
    /// See also [`Command::render_long_version`].
    ///
    /// ### Coloring
    ///
    /// This function does not try to color the message nor it inserts any [ANSI escape codes].
    ///
    /// ### Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// use std::io;
    /// let cmd = Command::new("myprog");
    /// println!("{}", cmd.render_version());
    /// ```
    /// [`io::Write`]: std::io::Write
    /// [`-V` (short)]: Command::version()
    /// [`--version` (long)]: Command::long_version()
    /// [ANSI escape codes]: https://en.wikipedia.org/wiki/ANSI_escape_code
    pub fn render_version(&self) -> String {
        self._render_version(false)
    }

    /// Version message rendered as if the user ran `--version`.
    ///
    /// See also [`Command::render_version`].
    ///
    /// ### Coloring
    ///
    /// This function does not try to color the message nor it inserts any [ANSI escape codes].
    ///
    /// ### Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// use std::io;
    /// let cmd = Command::new("myprog");
    /// println!("{}", cmd.render_long_version());
    /// ```
    /// [`io::Write`]: std::io::Write
    /// [`-V` (short)]: Command::version()
    /// [`--version` (long)]: Command::long_version()
    /// [ANSI escape codes]: https://en.wikipedia.org/wiki/ANSI_escape_code
    pub fn render_long_version(&self) -> String {
        self._render_version(true)
    }

    /// Usage statement
    ///
    /// ### Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// use std::io;
    /// let mut cmd = Command::new("myprog");
    /// println!("{}", cmd.render_usage());
    /// ```
    pub fn render_usage(&mut self) -> StyledStr {
        self.render_usage_().unwrap_or_default()
    }

    pub(crate) fn render_usage_(&mut self) -> Option<StyledStr> {
        // If there are global arguments, or settings we need to propagate them down to subcommands
        // before parsing incase we run into a subcommand
        self._build_self(false);

        Usage::new(self).create_usage_with_title(&[])
    }

    /// Extend [`Command`] with [`CommandExt`] data
    #[cfg(feature = "unstable-ext")]
    #[allow(clippy::should_implement_trait)]
    pub fn add<T: CommandExt + Extension>(mut self, tagged: T) -> Self {
        self.ext.set(tagged);
        self
    }
}

/// # Application-wide Settings
///
/// These settings will apply to the top-level command and all subcommands, by default.  Some
/// settings can be overridden in subcommands.
impl Command {
    /// Specifies that the parser should not assume the first argument passed is the binary name.
    ///
    /// This is normally the case when using a "daemon" style mode.  For shells / REPLs, see
    /// [`Command::multicall`][Command::multicall].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg};
    /// let m = Command::new("myprog")
    ///     .no_binary_name(true)
    ///     .arg(arg!(<cmd> ... "commands to run"))
    ///     .get_matches_from(vec!["command", "set"]);
    ///
    /// let cmds: Vec<_> = m.get_many::<String>("cmd").unwrap().collect();
    /// assert_eq!(cmds, ["command", "set"]);
    /// ```
    /// [`try_get_matches_from_mut`]: crate::Command::try_get_matches_from_mut()
    #[inline]
    pub fn no_binary_name(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::NoBinaryName)
        } else {
            self.unset_global_setting(AppSettings::NoBinaryName)
        }
    }

    /// Try not to fail on parse errors, like missing option values.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg};
    /// let cmd = Command::new("cmd")
    ///   .ignore_errors(true)
    ///   .arg(arg!(-c --config <FILE> "Sets a custom config file"))
    ///   .arg(arg!(-x --stuff <FILE> "Sets a custom stuff file"))
    ///   .arg(arg!(f: -f "Flag"));
    ///
    /// let r = cmd.try_get_matches_from(vec!["cmd", "-c", "file", "-f", "-x"]);
    ///
    /// assert!(r.is_ok(), "unexpected error: {r:?}");
    /// let m = r.unwrap();
    /// assert_eq!(m.get_one::<String>("config").unwrap(), "file");
    /// assert!(m.get_flag("f"));
    /// assert_eq!(m.get_one::<String>("stuff"), None);
    /// ```
    #[inline]
    pub fn ignore_errors(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::IgnoreErrors)
        } else {
            self.unset_global_setting(AppSettings::IgnoreErrors)
        }
    }

    /// Replace prior occurrences of arguments rather than error
    ///
    /// For any argument that would conflict with itself by default (e.g.
    /// [`ArgAction::Set`], it will now override itself.
    ///
    /// This is the equivalent to saying the `foo` arg using [`Arg::overrides_with("foo")`] for all
    /// defined arguments.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// [`Arg::overrides_with("foo")`]: crate::Arg::overrides_with()
    #[inline]
    pub fn args_override_self(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::AllArgsOverrideSelf)
        } else {
            self.unset_global_setting(AppSettings::AllArgsOverrideSelf)
        }
    }

    /// Disables the automatic delimiting of values after `--` or when [`Arg::trailing_var_arg`]
    /// was used.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The same thing can be done manually by setting the final positional argument to
    /// [`Arg::value_delimiter(None)`]. Using this setting is safer, because it's easier to locate
    /// when making changes.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .dont_delimit_trailing_values(true)
    ///     .get_matches();
    /// ```
    ///
    /// [`Arg::value_delimiter(None)`]: crate::Arg::value_delimiter()
    #[inline]
    pub fn dont_delimit_trailing_values(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::DontDelimitTrailingValues)
        } else {
            self.unset_global_setting(AppSettings::DontDelimitTrailingValues)
        }
    }

    /// Sets when to color output.
    ///
    /// To customize how the output is styled, see [`Command::styles`].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Default behaviour is [`ColorChoice::Auto`].
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, ColorChoice};
    /// Command::new("myprog")
    ///     .color(ColorChoice::Never)
    ///     .get_matches();
    /// ```
    /// [`ColorChoice::Auto`]: crate::ColorChoice::Auto
    #[cfg(feature = "color")]
    #[inline]
    #[must_use]
    pub fn color(self, color: ColorChoice) -> Self {
        let cmd = self
            .unset_global_setting(AppSettings::ColorAuto)
            .unset_global_setting(AppSettings::ColorAlways)
            .unset_global_setting(AppSettings::ColorNever);
        match color {
            ColorChoice::Auto => cmd.global_setting(AppSettings::ColorAuto),
            ColorChoice::Always => cmd.global_setting(AppSettings::ColorAlways),
            ColorChoice::Never => cmd.global_setting(AppSettings::ColorNever),
        }
    }

    /// Sets the [`Styles`] for terminal output
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Default behaviour is [`Styles::default`].
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, ColorChoice, builder::styling};
    /// const STYLES: styling::Styles = styling::Styles::styled()
    ///     .header(styling::AnsiColor::Green.on_default().bold())
    ///     .usage(styling::AnsiColor::Green.on_default().bold())
    ///     .literal(styling::AnsiColor::Blue.on_default().bold())
    ///     .placeholder(styling::AnsiColor::Cyan.on_default());
    /// Command::new("myprog")
    ///     .styles(STYLES)
    ///     .get_matches();
    /// ```
    #[cfg(feature = "color")]
    #[inline]
    #[must_use]
    pub fn styles(mut self, styles: Styles) -> Self {
        self.app_ext.set(styles);
        self
    }

    /// Sets the terminal width at which to wrap help messages.
    ///
    /// Using `0` will ignore terminal widths and use source formatting.
    ///
    /// Defaults to current terminal width when `wrap_help` feature flag is enabled.  If current
    /// width cannot be determined, the default is 100.
    ///
    /// **`unstable-v5` feature**: Defaults to unbound, being subject to
    /// [`Command::max_term_width`].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This setting applies globally and *not* on a per-command basis.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This requires the `wrap_help` feature
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .term_width(80)
    /// # ;
    /// ```
    #[inline]
    #[must_use]
    #[cfg(any(not(feature = "unstable-v5"), feature = "wrap_help"))]
    pub fn term_width(mut self, width: usize) -> Self {
        self.app_ext.set(TermWidth(width));
        self
    }

    /// Limit the line length for wrapping help when using the current terminal's width.
    ///
    /// This only applies when [`term_width`][Command::term_width] is unset so that the current
    /// terminal's width will be used.  See [`Command::term_width`] for more details.
    ///
    /// Using `0` will ignore this, always respecting [`Command::term_width`] (default).
    ///
    /// **`unstable-v5` feature**: Defaults to 100.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This setting applies globally and *not* on a per-command basis.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This requires the `wrap_help` feature
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .max_term_width(100)
    /// # ;
    /// ```
    #[inline]
    #[must_use]
    #[cfg(any(not(feature = "unstable-v5"), feature = "wrap_help"))]
    pub fn max_term_width(mut self, width: usize) -> Self {
        self.app_ext.set(MaxTermWidth(width));
        self
    }

    /// Disables `-V` and `--version` flag.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, error::ErrorKind};
    /// let res = Command::new("myprog")
    ///     .version("1.0.0")
    ///     .disable_version_flag(true)
    ///     .try_get_matches_from(vec![
    ///         "myprog", "--version"
    ///     ]);
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::UnknownArgument);
    /// ```
    ///
    /// You can create a custom version flag with [`ArgAction::Version`]
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction, error::ErrorKind};
    /// let mut cmd = Command::new("myprog")
    ///     .version("1.0.0")
    ///     // Remove the `-V` short flag
    ///     .disable_version_flag(true)
    ///     .arg(
    ///         Arg::new("version")
    ///             .long("version")
    ///             .action(ArgAction::Version)
    ///             .help("Print version")
    ///     );
    ///
    /// let res = cmd.try_get_matches_from_mut(vec![
    ///         "myprog", "-V"
    ///     ]);
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::UnknownArgument);
    ///
    /// let res = cmd.try_get_matches_from_mut(vec![
    ///         "myprog", "--version"
    ///     ]);
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::DisplayVersion);
    /// ```
    #[inline]
    pub fn disable_version_flag(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::DisableVersionFlag)
        } else {
            self.unset_global_setting(AppSettings::DisableVersionFlag)
        }
    }

    /// Specifies to use the version of the current command for all [`subcommands`].
    ///
    /// Defaults to `false`; subcommands have independent version strings from their parents.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .version("v1.1")
    ///     .propagate_version(true)
    ///     .subcommand(Command::new("test"))
    ///     .get_matches();
    /// // running `$ myprog test --version` will display
    /// // "myprog-test v1.1"
    /// ```
    ///
    /// [`subcommands`]: crate::Command::subcommand()
    #[inline]
    pub fn propagate_version(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::PropagateVersion)
        } else {
            self.unset_global_setting(AppSettings::PropagateVersion)
        }
    }

    /// Places the help string for all arguments and subcommands on the line after them.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .next_line_help(true)
    ///     .get_matches();
    /// ```
    #[inline]
    pub fn next_line_help(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::NextLineHelp)
        } else {
            self.unset_global_setting(AppSettings::NextLineHelp)
        }
    }

    /// Disables `-h` and `--help` flag.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, error::ErrorKind};
    /// let res = Command::new("myprog")
    ///     .disable_help_flag(true)
    ///     .try_get_matches_from(vec![
    ///         "myprog", "-h"
    ///     ]);
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::UnknownArgument);
    /// ```
    ///
    /// You can create a custom help flag with [`ArgAction::Help`], [`ArgAction::HelpShort`], or
    /// [`ArgAction::HelpLong`]
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction, error::ErrorKind};
    /// let mut cmd = Command::new("myprog")
    ///     // Change help short flag to `?`
    ///     .disable_help_flag(true)
    ///     .arg(
    ///         Arg::new("help")
    ///             .short('?')
    ///             .long("help")
    ///             .action(ArgAction::Help)
    ///             .help("Print help")
    ///     );
    ///
    /// let res = cmd.try_get_matches_from_mut(vec![
    ///         "myprog", "-h"
    ///     ]);
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::UnknownArgument);
    ///
    /// let res = cmd.try_get_matches_from_mut(vec![
    ///         "myprog", "-?"
    ///     ]);
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::DisplayHelp);
    /// ```
    #[inline]
    pub fn disable_help_flag(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::DisableHelpFlag)
        } else {
            self.unset_global_setting(AppSettings::DisableHelpFlag)
        }
    }

    /// Disables the `help` [`subcommand`].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, error::ErrorKind};
    /// let res = Command::new("myprog")
    ///     .disable_help_subcommand(true)
    ///     // Normally, creating a subcommand causes a `help` subcommand to automatically
    ///     // be generated as well
    ///     .subcommand(Command::new("test"))
    ///     .try_get_matches_from(vec![
    ///         "myprog", "help"
    ///     ]);
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::InvalidSubcommand);
    /// ```
    ///
    /// [`subcommand`]: crate::Command::subcommand()
    #[inline]
    pub fn disable_help_subcommand(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::DisableHelpSubcommand)
        } else {
            self.unset_global_setting(AppSettings::DisableHelpSubcommand)
        }
    }

    /// Disables colorized help messages.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .disable_colored_help(true)
    ///     .get_matches();
    /// ```
    #[inline]
    pub fn disable_colored_help(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::DisableColoredHelp)
        } else {
            self.unset_global_setting(AppSettings::DisableColoredHelp)
        }
    }

    /// Panic if help descriptions are omitted.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** When deriving [`Parser`][crate::Parser], you could instead check this at
    /// compile-time with `#![deny(missing_docs)]`
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .help_expected(true)
    ///     .arg(
    ///         Arg::new("foo").help("It does foo stuff")
    ///         // As required via `help_expected`, a help message was supplied
    ///      )
    /// #    .get_matches();
    /// ```
    ///
    /// # Panics
    ///
    /// On debug builds:
    /// ```rust,no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myapp")
    ///     .help_expected(true)
    ///     .arg(
    ///         Arg::new("foo")
    ///         // Someone forgot to put .about("...") here
    ///         // Since the setting `help_expected` is activated, this will lead to
    ///         // a panic (if you are in debug mode)
    ///     )
    /// #   .get_matches();
    ///```
    #[inline]
    pub fn help_expected(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::HelpExpected)
        } else {
            self.unset_global_setting(AppSettings::HelpExpected)
        }
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "This is now the default")
    )]
    pub fn dont_collapse_args_in_usage(self, _yes: bool) -> Self {
        self
    }

    /// Tells `clap` *not* to print possible values when displaying help information.
    ///
    /// This can be useful if there are many values, or they are explained elsewhere.
    ///
    /// To set this per argument, see
    /// [`Arg::hide_possible_values`][crate::Arg::hide_possible_values].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    #[inline]
    pub fn hide_possible_values(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::HidePossibleValues)
        } else {
            self.unset_global_setting(AppSettings::HidePossibleValues)
        }
    }

    /// Allow partial matches of long arguments or their [aliases].
    ///
    /// For example, to match an argument named `--test`, one could use `--t`, `--te`, `--tes`, and
    /// `--test`.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The match *must not* be ambiguous at all in order to succeed. i.e. to match
    /// `--te` to `--test` there could not also be another argument or alias `--temp` because both
    /// start with `--te`
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// [aliases]: crate::Command::aliases()
    #[inline]
    pub fn infer_long_args(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::InferLongArgs)
        } else {
            self.unset_global_setting(AppSettings::InferLongArgs)
        }
    }

    /// Allow partial matches of [subcommand] names and their [aliases].
    ///
    /// For example, to match a subcommand named `test`, one could use `t`, `te`, `tes`, and
    /// `test`.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The match *must not* be ambiguous at all in order to succeed. i.e. to match `te`
    /// to `test` there could not also be a subcommand or alias `temp` because both start with `te`
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **WARNING:** This setting can interfere with [positional/free arguments], take care when
    /// designing CLIs which allow inferred subcommands and have potential positional/free
    /// arguments whose values could start with the same characters as subcommands. If this is the
    /// case, it's recommended to use settings such as [`Command::args_conflicts_with_subcommands`] in
    /// conjunction with this setting.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This choice is propagated to all child subcommands.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("prog")
    ///     .infer_subcommands(true)
    ///     .subcommand(Command::new("test"))
    ///     .get_matches_from(vec![
    ///         "prog", "te"
    ///     ]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    ///
    /// [subcommand]: crate::Command::subcommand()
    /// [positional/free arguments]: crate::Arg::index()
    /// [aliases]: crate::Command::aliases()
    #[inline]
    pub fn infer_subcommands(self, yes: bool) -> Self {
        if yes {
            self.global_setting(AppSettings::InferSubcommands)
        } else {
            self.unset_global_setting(AppSettings::InferSubcommands)
        }
    }
}

/// # Command-specific Settings
///
/// These apply only to the current command and are not inherited by subcommands.
impl Command {
    /// (Re)Sets the program's name.
    ///
    /// See [`Command::new`] for more details.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let cmd = clap::command!()
    ///     .name("foo");
    ///
    /// // continued logic goes here, such as `cmd.get_matches()` etc.
    /// ```
    #[must_use]
    pub fn name(mut self, name: impl Into<Str>) -> Self {
        self.name = name.into();
        self
    }

    /// Overrides the runtime-determined name of the binary for help and error messages.
    ///
    /// This should only be used when absolutely necessary, such as when the binary name for your
    /// application is misleading, or perhaps *not* how the user should invoke your program.
    ///
    /// <div class="warning">
    ///
    /// **TIP:** When building things such as third party `cargo`
    /// subcommands, this setting **should** be used!
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This *does not* change or set the name of the binary file on
    /// disk. It only changes what clap thinks the name is for the purposes of
    /// error or help messages.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("My Program")
    ///      .bin_name("my_binary")
    /// # ;
    /// ```
    #[must_use]
    pub fn bin_name(mut self, name: impl IntoResettable<String>) -> Self {
        self.bin_name = name.into_resettable().into_option();
        self
    }

    /// Overrides the runtime-determined display name of the program for help and error messages.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("My Program")
    ///      .display_name("my_program")
    /// # ;
    /// ```
    #[must_use]
    pub fn display_name(mut self, name: impl IntoResettable<String>) -> Self {
        self.display_name = name.into_resettable().into_option();
        self
    }

    /// Sets the author(s) for the help message.
    ///
    /// <div class="warning">
    ///
    /// **TIP:** Use `clap`s convenience macro [`crate_authors!`] to
    /// automatically set your application's author(s) to the same thing as your
    /// crate at compile time.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** A custom [`help_template`][Command::help_template] is needed for author to show
    /// up.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///      .author("Me, me@mymain.com")
    /// # ;
    /// ```
    #[must_use]
    pub fn author(mut self, author: impl IntoResettable<Str>) -> Self {
        self.author = author.into_resettable().into_option();
        self
    }

    /// Sets the program's description for the short help (`-h`).
    ///
    /// If [`Command::long_about`] is not specified, this message will be displayed for `--help`.
    ///
    /// See also [`crate_description!`](crate::crate_description!).
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .about("Does really amazing things for great people")
    /// # ;
    /// ```
    #[must_use]
    pub fn about(mut self, about: impl IntoResettable<StyledStr>) -> Self {
        self.about = about.into_resettable().into_option();
        self
    }

    /// Sets the program's description for the long help (`--help`).
    ///
    /// If not set, [`Command::about`] will be used for long help in addition to short help
    /// (`-h`).
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Only [`Command::about`] (short format) is used in completion
    /// script generation in order to be concise.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .long_about(
    /// "Does really amazing things to great people. Now let's talk a little
    ///  more in depth about how this subcommand really works. It may take about
    ///  a few lines of text, but that's ok!")
    /// # ;
    /// ```
    /// [`Command::about`]: Command::about()
    #[must_use]
    pub fn long_about(mut self, long_about: impl IntoResettable<StyledStr>) -> Self {
        self.long_about = long_about.into_resettable().into_option();
        self
    }

    /// Free-form help text for after auto-generated short help (`-h`).
    ///
    /// This is often used to describe how to use the arguments, caveats to be noted, or license
    /// and contact information.
    ///
    /// If [`Command::after_long_help`] is not specified, this message will be displayed for `--help`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .after_help("Does really amazing things for great people... but be careful with -R!")
    /// # ;
    /// ```
    ///
    #[must_use]
    pub fn after_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
        self.after_help = help.into_resettable().into_option();
        self
    }

    /// Free-form help text for after auto-generated long help (`--help`).
    ///
    /// This is often used to describe how to use the arguments, caveats to be noted, or license
    /// and contact information.
    ///
    /// If not set, [`Command::after_help`] will be used for long help in addition to short help
    /// (`-h`).
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .after_long_help("Does really amazing things to great people... but be careful with -R, \
    ///                      like, for real, be careful with this!")
    /// # ;
    /// ```
    #[must_use]
    pub fn after_long_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
        self.after_long_help = help.into_resettable().into_option();
        self
    }

    /// Free-form help text for before auto-generated short help (`-h`).
    ///
    /// This is often used for header, copyright, or license information.
    ///
    /// If [`Command::before_long_help`] is not specified, this message will be displayed for `--help`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .before_help("Some info I'd like to appear before the help info")
    /// # ;
    /// ```
    #[must_use]
    pub fn before_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
        self.before_help = help.into_resettable().into_option();
        self
    }

    /// Free-form help text for before auto-generated long help (`--help`).
    ///
    /// This is often used for header, copyright, or license information.
    ///
    /// If not set, [`Command::before_help`] will be used for long help in addition to short help
    /// (`-h`).
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .before_long_help("Some verbose and long info I'd like to appear before the help info")
    /// # ;
    /// ```
    #[must_use]
    pub fn before_long_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
        self.before_long_help = help.into_resettable().into_option();
        self
    }

    /// Sets the version for the short version (`-V`) and help messages.
    ///
    /// If [`Command::long_version`] is not specified, this message will be displayed for `--version`.
    ///
    /// <div class="warning">
    ///
    /// **TIP:** Use `clap`s convenience macro [`crate_version!`] to
    /// automatically set your application's version to the same thing as your
    /// crate at compile time.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .version("v0.1.24")
    /// # ;
    /// ```
    #[must_use]
    pub fn version(mut self, ver: impl IntoResettable<Str>) -> Self {
        self.version = ver.into_resettable().into_option();
        self
    }

    /// Sets the version for the long version (`--version`) and help messages.
    ///
    /// If [`Command::version`] is not specified, this message will be displayed for `-V`.
    ///
    /// <div class="warning">
    ///
    /// **TIP:** Use `clap`s convenience macro [`crate_version!`] to
    /// automatically set your application's version to the same thing as your
    /// crate at compile time.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .long_version(
    /// "v0.1.24
    ///  commit: abcdef89726d
    ///  revision: 123
    ///  release: 2
    ///  binary: myprog")
    /// # ;
    /// ```
    #[must_use]
    pub fn long_version(mut self, ver: impl IntoResettable<Str>) -> Self {
        self.long_version = ver.into_resettable().into_option();
        self
    }

    /// Overrides the `clap` generated usage string for help and error messages.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Using this setting disables `clap`s "context-aware" usage
    /// strings. After this setting is set, this will be *the only* usage string
    /// displayed to the user!
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Multiple usage lines may be present in the usage argument, but
    /// some rules need to be followed to ensure the usage lines are formatted
    /// correctly by the default help formatter:
    ///
    /// - Do not indent the first usage line.
    /// - Indent all subsequent usage lines with seven spaces.
    /// - The last line must not end with a newline.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .override_usage("myapp [-clDas] <some_file>")
    /// # ;
    /// ```
    ///
    /// Or for multiple usage lines:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .override_usage(
    ///         "myapp -X [-a] [-b] <file>\n       \
    ///          myapp -Y [-c] <file1> <file2>\n       \
    ///          myapp -Z [-d|-e]"
    ///     )
    /// # ;
    /// ```
    ///
    /// [`ArgMatches::usage`]: ArgMatches::usage()
    #[must_use]
    pub fn override_usage(mut self, usage: impl IntoResettable<StyledStr>) -> Self {
        self.usage_str = usage.into_resettable().into_option();
        self
    }

    /// Overrides the `clap` generated help message (both `-h` and `--help`).
    ///
    /// This should only be used when the auto-generated message does not suffice.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This **only** replaces the help message for the current
    /// command, meaning if you are using subcommands, those help messages will
    /// still be auto-generated unless you specify a [`Command::override_help`] for
    /// them as well.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myapp")
    ///     .override_help("myapp v1.0\n\
    ///            Does awesome things\n\
    ///            (C) me@mail.com\n\n\
    ///
    ///            Usage: myapp <opts> <command>\n\n\
    ///
    ///            Options:\n\
    ///            -h, --help       Display this message\n\
    ///            -V, --version    Display version info\n\
    ///            -s <stuff>       Do something with stuff\n\
    ///            -v               Be verbose\n\n\
    ///
    ///            Commands:\n\
    ///            help             Print this message\n\
    ///            work             Do some work")
    /// # ;
    /// ```
    #[must_use]
    pub fn override_help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
        self.help_str = help.into_resettable().into_option();
        self
    }

    /// Sets the help template to be used, overriding the default format.
    ///
    /// Tags are given inside curly brackets.
    ///
    /// Valid tags are:
    ///
    ///   * `{name}`                - Display name for the (sub-)command.
    ///   * `{bin}`                 - Binary name.(deprecated)
    ///   * `{version}`             - Version number.
    ///   * `{author}`              - Author information.
    ///   * `{author-with-newline}` - Author followed by `\n`.
    ///   * `{author-section}`      - Author preceded and followed by `\n`.
    ///   * `{about}`               - General description (from [`Command::about`] or
    ///     [`Command::long_about`]).
    ///   * `{about-with-newline}`  - About followed by `\n`.
    ///   * `{about-section}`       - About preceded and followed by '\n'.
    ///   * `{usage-heading}`       - Automatically generated usage heading.
    ///   * `{usage}`               - Automatically generated or given usage string.
    ///   * `{all-args}`            - Help for all arguments (options, flags, positional
    ///     arguments, and subcommands) including titles.
    ///   * `{options}`             - Help for options.
    ///   * `{positionals}`         - Help for positional arguments.
    ///   * `{subcommands}`         - Help for subcommands.
    ///   * `{tab}`                 - Standard tab sized used within clap
    ///   * `{after-help}`          - Help from [`Command::after_help`] or [`Command::after_long_help`].
    ///   * `{before-help}`         - Help from [`Command::before_help`] or [`Command::before_long_help`].
    ///
    /// # Examples
    ///
    /// For a very brief help:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .version("1.0")
    ///     .help_template("{name} ({version}) - {usage}")
    /// # ;
    /// ```
    ///
    /// For showing more application context:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .version("1.0")
    ///     .help_template("\
    /// {before-help}{name} {version}
    /// {author-with-newline}{about-with-newline}
    /// {usage-heading} {usage}
    ///
    /// {all-args}{after-help}
    /// ")
    /// # ;
    /// ```
    /// [`Command::about`]: Command::about()
    /// [`Command::long_about`]: Command::long_about()
    /// [`Command::after_help`]: Command::after_help()
    /// [`Command::after_long_help`]: Command::after_long_help()
    /// [`Command::before_help`]: Command::before_help()
    /// [`Command::before_long_help`]: Command::before_long_help()
    #[must_use]
    #[cfg(feature = "help")]
    pub fn help_template(mut self, s: impl IntoResettable<StyledStr>) -> Self {
        self.template = s.into_resettable().into_option();
        self
    }

    #[inline]
    #[must_use]
    pub(crate) fn setting(mut self, setting: AppSettings) -> Self {
        self.settings.set(setting);
        self
    }

    #[inline]
    #[must_use]
    pub(crate) fn unset_setting(mut self, setting: AppSettings) -> Self {
        self.settings.unset(setting);
        self
    }

    #[inline]
    #[must_use]
    pub(crate) fn global_setting(mut self, setting: AppSettings) -> Self {
        self.settings.set(setting);
        self.g_settings.set(setting);
        self
    }

    #[inline]
    #[must_use]
    pub(crate) fn unset_global_setting(mut self, setting: AppSettings) -> Self {
        self.settings.unset(setting);
        self.g_settings.unset(setting);
        self
    }

    /// Flatten subcommand help into the current command's help
    ///
    /// This shows a summary of subcommands within the usage and help for the current command, similar to
    /// `git stash --help` showing information on `push`, `pop`, etc.
    /// To see more information, a user can still pass `--help` to the individual subcommands.
    #[inline]
    #[must_use]
    pub fn flatten_help(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::FlattenHelp)
        } else {
            self.unset_setting(AppSettings::FlattenHelp)
        }
    }

    /// Set the default section heading for future args.
    ///
    /// This will be used for any arg that hasn't had [`Arg::help_heading`] called.
    ///
    /// This is useful if the default `Options` or `Arguments` headings are
    /// not specific enough for one's use case.
    ///
    /// For subcommands, see [`Command::subcommand_help_heading`]
    ///
    /// [`Command::arg`]: Command::arg()
    /// [`Arg::help_heading`]: crate::Arg::help_heading()
    #[inline]
    #[must_use]
    pub fn next_help_heading(mut self, heading: impl IntoResettable<Str>) -> Self {
        self.current_help_heading = heading.into_resettable().into_option();
        self
    }

    /// Change the starting value for assigning future display orders for args.
    ///
    /// This will be used for any arg that hasn't had [`Arg::display_order`] called.
    #[inline]
    #[must_use]
    pub fn next_display_order(mut self, disp_ord: impl IntoResettable<usize>) -> Self {
        self.current_disp_ord = disp_ord.into_resettable().into_option();
        self
    }

    /// Exit gracefully if no arguments are present (e.g. `$ myprog`).
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** [`subcommands`] count as arguments
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command};
    /// Command::new("myprog")
    ///     .arg_required_else_help(true);
    /// ```
    ///
    /// [`subcommands`]: crate::Command::subcommand()
    /// [`Arg::default_value`]: crate::Arg::default_value()
    #[inline]
    pub fn arg_required_else_help(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::ArgRequiredElseHelp)
        } else {
            self.unset_setting(AppSettings::ArgRequiredElseHelp)
        }
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::allow_hyphen_values`")
    )]
    pub fn allow_hyphen_values(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::AllowHyphenValues)
        } else {
            self.unset_setting(AppSettings::AllowHyphenValues)
        }
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::allow_negative_numbers`")
    )]
    pub fn allow_negative_numbers(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::AllowNegativeNumbers)
        } else {
            self.unset_setting(AppSettings::AllowNegativeNumbers)
        }
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::trailing_var_arg`")
    )]
    pub fn trailing_var_arg(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::TrailingVarArg)
        } else {
            self.unset_setting(AppSettings::TrailingVarArg)
        }
    }

    /// Allows one to implement two styles of CLIs where positionals can be used out of order.
    ///
    /// The first example is a CLI where the second to last positional argument is optional, but
    /// the final positional argument is required. Such as `$ prog [optional] <required>` where one
    /// of the two following usages is allowed:
    ///
    /// * `$ prog [optional] <required>`
    /// * `$ prog <required>`
    ///
    /// This would otherwise not be allowed. This is useful when `[optional]` has a default value.
    ///
    /// **Note:** when using this style of "missing positionals" the final positional *must* be
    /// [required] if `--` will not be used to skip to the final positional argument.
    ///
    /// **Note:** This style also only allows a single positional argument to be "skipped" without
    /// the use of `--`. To skip more than one, see the second example.
    ///
    /// The second example is when one wants to skip multiple optional positional arguments, and use
    /// of the `--` operator is OK (but not required if all arguments will be specified anyways).
    ///
    /// For example, imagine a CLI which has three positional arguments `[foo] [bar] [baz]...` where
    /// `baz` accepts multiple values (similar to man `ARGS...` style training arguments).
    ///
    /// With this setting the following invocations are possible:
    ///
    /// * `$ prog foo bar baz1 baz2 baz3`
    /// * `$ prog foo -- baz1 baz2 baz3`
    /// * `$ prog -- baz1 baz2 baz3`
    ///
    /// # Examples
    ///
    /// Style number one from above:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// // Assume there is an external subcommand named "subcmd"
    /// let m = Command::new("myprog")
    ///     .allow_missing_positional(true)
    ///     .arg(Arg::new("arg1"))
    ///     .arg(Arg::new("arg2")
    ///         .required(true))
    ///     .get_matches_from(vec![
    ///         "prog", "other"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("arg1"), None);
    /// assert_eq!(m.get_one::<String>("arg2").unwrap(), "other");
    /// ```
    ///
    /// Now the same example, but using a default value for the first optional positional argument
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// // Assume there is an external subcommand named "subcmd"
    /// let m = Command::new("myprog")
    ///     .allow_missing_positional(true)
    ///     .arg(Arg::new("arg1")
    ///         .default_value("something"))
    ///     .arg(Arg::new("arg2")
    ///         .required(true))
    ///     .get_matches_from(vec![
    ///         "prog", "other"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("arg1").unwrap(), "something");
    /// assert_eq!(m.get_one::<String>("arg2").unwrap(), "other");
    /// ```
    ///
    /// Style number two from above:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// // Assume there is an external subcommand named "subcmd"
    /// let m = Command::new("myprog")
    ///     .allow_missing_positional(true)
    ///     .arg(Arg::new("foo"))
    ///     .arg(Arg::new("bar"))
    ///     .arg(Arg::new("baz").action(ArgAction::Set).num_args(1..))
    ///     .get_matches_from(vec![
    ///         "prog", "foo", "bar", "baz1", "baz2", "baz3"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("foo").unwrap(), "foo");
    /// assert_eq!(m.get_one::<String>("bar").unwrap(), "bar");
    /// assert_eq!(m.get_many::<String>("baz").unwrap().collect::<Vec<_>>(), &["baz1", "baz2", "baz3"]);
    /// ```
    ///
    /// Now nofice if we don't specify `foo` or `baz` but use the `--` operator.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// // Assume there is an external subcommand named "subcmd"
    /// let m = Command::new("myprog")
    ///     .allow_missing_positional(true)
    ///     .arg(Arg::new("foo"))
    ///     .arg(Arg::new("bar"))
    ///     .arg(Arg::new("baz").action(ArgAction::Set).num_args(1..))
    ///     .get_matches_from(vec![
    ///         "prog", "--", "baz1", "baz2", "baz3"
    ///     ]);
    ///
    /// assert_eq!(m.get_one::<String>("foo"), None);
    /// assert_eq!(m.get_one::<String>("bar"), None);
    /// assert_eq!(m.get_many::<String>("baz").unwrap().collect::<Vec<_>>(), &["baz1", "baz2", "baz3"]);
    /// ```
    ///
    /// [required]: crate::Arg::required()
    #[inline]
    pub fn allow_missing_positional(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::AllowMissingPositional)
        } else {
            self.unset_setting(AppSettings::AllowMissingPositional)
        }
    }
}

/// # Subcommand-specific Settings
impl Command {
    /// Sets the short version of the subcommand flag without the preceding `-`.
    ///
    /// Allows the subcommand to be used as if it were an [`Arg::short`].
    ///
    /// # Examples
    ///
    /// ```
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let matches = Command::new("pacman")
    ///     .subcommand(
    ///         Command::new("sync").short_flag('S').arg(
    ///             Arg::new("search")
    ///                 .short('s')
    ///                 .long("search")
    ///                 .action(ArgAction::SetTrue)
    ///                 .help("search remote repositories for matching strings"),
    ///         ),
    ///     )
    ///     .get_matches_from(vec!["pacman", "-Ss"]);
    ///
    /// assert_eq!(matches.subcommand_name().unwrap(), "sync");
    /// let sync_matches = matches.subcommand_matches("sync").unwrap();
    /// assert!(sync_matches.get_flag("search"));
    /// ```
    /// [`Arg::short`]: Arg::short()
    #[must_use]
    pub fn short_flag(mut self, short: impl IntoResettable<char>) -> Self {
        self.short_flag = short.into_resettable().into_option();
        self
    }

    /// Sets the long version of the subcommand flag without the preceding `--`.
    ///
    /// Allows the subcommand to be used as if it were an [`Arg::long`].
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Any leading `-` characters will be stripped.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// To set `long_flag` use a word containing valid UTF-8 codepoints. If you supply a double leading
    /// `--` such as `--sync` they will be stripped. Hyphens in the middle of the word; however,
    /// will *not* be stripped (i.e. `sync-file` is allowed).
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let matches = Command::new("pacman")
    ///     .subcommand(
    ///         Command::new("sync").long_flag("sync").arg(
    ///             Arg::new("search")
    ///                 .short('s')
    ///                 .long("search")
    ///                 .action(ArgAction::SetTrue)
    ///                 .help("search remote repositories for matching strings"),
    ///         ),
    ///     )
    ///     .get_matches_from(vec!["pacman", "--sync", "--search"]);
    ///
    /// assert_eq!(matches.subcommand_name().unwrap(), "sync");
    /// let sync_matches = matches.subcommand_matches("sync").unwrap();
    /// assert!(sync_matches.get_flag("search"));
    /// ```
    ///
    /// [`Arg::long`]: Arg::long()
    #[must_use]
    pub fn long_flag(mut self, long: impl Into<Str>) -> Self {
        self.long_flag = Some(long.into());
        self
    }

    /// Sets a hidden alias to this subcommand.
    ///
    /// This allows the subcommand to be accessed via *either* the original name, or this given
    /// alias. This is more efficient and easier than creating multiple hidden subcommands as one
    /// only needs to check for the existence of this command, and not all aliased variants.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Aliases defined with this method are *hidden* from the help
    /// message. If you're looking for aliases that will be displayed in the help
    /// message, see [`Command::visible_alias`].
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** When using aliases and checking for the existence of a
    /// particular subcommand within an [`ArgMatches`] struct, one only needs to
    /// search for the original name and not all aliases.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///     .subcommand(Command::new("test")
    ///         .alias("do-stuff"))
    ///     .get_matches_from(vec!["myprog", "do-stuff"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    /// [`Command::visible_alias`]: Command::visible_alias()
    #[must_use]
    pub fn alias(mut self, name: impl IntoResettable<Str>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            self.aliases.push((name, false));
        } else {
            self.aliases.clear();
        }
        self
    }

    /// Add an alias, which functions as  "hidden" short flag subcommand
    ///
    /// This will automatically dispatch as if this subcommand was used. This is more efficient,
    /// and easier than creating multiple hidden subcommands as one only needs to check for the
    /// existence of this command, and not all variants.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///             .subcommand(Command::new("test").short_flag('t')
    ///                 .short_flag_alias('d'))
    ///             .get_matches_from(vec!["myprog", "-d"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    #[must_use]
    pub fn short_flag_alias(mut self, name: impl IntoResettable<char>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            debug_assert!(name != '-', "short alias name cannot be `-`");
            self.short_flag_aliases.push((name, false));
        } else {
            self.short_flag_aliases.clear();
        }
        self
    }

    /// Add an alias, which functions as a "hidden" long flag subcommand.
    ///
    /// This will automatically dispatch as if this subcommand was used. This is more efficient,
    /// and easier than creating multiple hidden subcommands as one only needs to check for the
    /// existence of this command, and not all variants.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///             .subcommand(Command::new("test").long_flag("test")
    ///                 .long_flag_alias("testing"))
    ///             .get_matches_from(vec!["myprog", "--testing"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    #[must_use]
    pub fn long_flag_alias(mut self, name: impl IntoResettable<Str>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            self.long_flag_aliases.push((name, false));
        } else {
            self.long_flag_aliases.clear();
        }
        self
    }

    /// Sets multiple hidden aliases to this subcommand.
    ///
    /// This allows the subcommand to be accessed via *either* the original name or any of the
    /// given aliases. This is more efficient, and easier than creating multiple hidden subcommands
    /// as one only needs to check for the existence of this command and not all aliased variants.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Aliases defined with this method are *hidden* from the help
    /// message. If looking for aliases that will be displayed in the help
    /// message, see [`Command::visible_aliases`].
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** When using aliases and checking for the existence of a
    /// particular subcommand within an [`ArgMatches`] struct, one only needs to
    /// search for the original name and not all aliases.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("myprog")
    ///     .subcommand(Command::new("test")
    ///         .aliases(["do-stuff", "do-tests", "tests"]))
    ///         .arg(Arg::new("input")
    ///             .help("the file to add")
    ///             .required(false))
    ///     .get_matches_from(vec!["myprog", "do-tests"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    /// [`Command::visible_aliases`]: Command::visible_aliases()
    #[must_use]
    pub fn aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
        self.aliases
            .extend(names.into_iter().map(|n| (n.into(), false)));
        self
    }

    /// Add aliases, which function as "hidden" short flag subcommands.
    ///
    /// These will automatically dispatch as if this subcommand was used. This is more efficient,
    /// and easier than creating multiple hidden subcommands as one only needs to check for the
    /// existence of this command, and not all variants.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///     .subcommand(Command::new("test").short_flag('t')
    ///         .short_flag_aliases(['a', 'b', 'c']))
    ///         .arg(Arg::new("input")
    ///             .help("the file to add")
    ///             .required(false))
    ///     .get_matches_from(vec!["myprog", "-a"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    #[must_use]
    pub fn short_flag_aliases(mut self, names: impl IntoIterator<Item = char>) -> Self {
        for s in names {
            debug_assert!(s != '-', "short alias name cannot be `-`");
            self.short_flag_aliases.push((s, false));
        }
        self
    }

    /// Add aliases, which function as "hidden" long flag subcommands.
    ///
    /// These will automatically dispatch as if this subcommand was used. This is more efficient,
    /// and easier than creating multiple hidden subcommands as one only needs to check for the
    /// existence of this command, and not all variants.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///             .subcommand(Command::new("test").long_flag("test")
    ///                 .long_flag_aliases(["testing", "testall", "test_all"]))
    ///                 .arg(Arg::new("input")
    ///                             .help("the file to add")
    ///                             .required(false))
    ///             .get_matches_from(vec!["myprog", "--testing"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    #[must_use]
    pub fn long_flag_aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
        for s in names {
            self = self.long_flag_alias(s);
        }
        self
    }

    /// Sets a visible alias to this subcommand.
    ///
    /// This allows the subcommand to be accessed via *either* the
    /// original name or the given alias. This is more efficient and easier
    /// than creating hidden subcommands as one only needs to check for
    /// the existence of this command and not all aliased variants.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The alias defined with this method is *visible* from the help
    /// message and displayed as if it were just another regular subcommand. If
    /// looking for an alias that will not be displayed in the help message, see
    /// [`Command::alias`].
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** When using aliases and checking for the existence of a
    /// particular subcommand within an [`ArgMatches`] struct, one only needs to
    /// search for the original name and not all aliases.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("myprog")
    ///     .subcommand(Command::new("test")
    ///         .visible_alias("do-stuff"))
    ///     .get_matches_from(vec!["myprog", "do-stuff"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    /// [`Command::alias`]: Command::alias()
    #[must_use]
    pub fn visible_alias(mut self, name: impl IntoResettable<Str>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            self.aliases.push((name, true));
        } else {
            self.aliases.clear();
        }
        self
    }

    /// Add an alias, which functions as  "visible" short flag subcommand
    ///
    /// This will automatically dispatch as if this subcommand was used. This is more efficient,
    /// and easier than creating multiple hidden subcommands as one only needs to check for the
    /// existence of this command, and not all variants.
    ///
    /// See also [`Command::short_flag_alias`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///             .subcommand(Command::new("test").short_flag('t')
    ///                 .visible_short_flag_alias('d'))
    ///             .get_matches_from(vec!["myprog", "-d"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    /// [`Command::short_flag_alias`]: Command::short_flag_alias()
    #[must_use]
    pub fn visible_short_flag_alias(mut self, name: impl IntoResettable<char>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            debug_assert!(name != '-', "short alias name cannot be `-`");
            self.short_flag_aliases.push((name, true));
        } else {
            self.short_flag_aliases.clear();
        }
        self
    }

    /// Add an alias, which functions as a "visible" long flag subcommand.
    ///
    /// This will automatically dispatch as if this subcommand was used. This is more efficient,
    /// and easier than creating multiple hidden subcommands as one only needs to check for the
    /// existence of this command, and not all variants.
    ///
    /// See also [`Command::long_flag_alias`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///             .subcommand(Command::new("test").long_flag("test")
    ///                 .visible_long_flag_alias("testing"))
    ///             .get_matches_from(vec!["myprog", "--testing"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    /// [`Command::long_flag_alias`]: Command::long_flag_alias()
    #[must_use]
    pub fn visible_long_flag_alias(mut self, name: impl IntoResettable<Str>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            self.long_flag_aliases.push((name, true));
        } else {
            self.long_flag_aliases.clear();
        }
        self
    }

    /// Sets multiple visible aliases to this subcommand.
    ///
    /// This allows the subcommand to be accessed via *either* the
    /// original name or any of the given aliases. This is more efficient and easier
    /// than creating multiple hidden subcommands as one only needs to check for
    /// the existence of this command and not all aliased variants.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The alias defined with this method is *visible* from the help
    /// message and displayed as if it were just another regular subcommand. If
    /// looking for an alias that will not be displayed in the help message, see
    /// [`Command::alias`].
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** When using aliases, and checking for the existence of a
    /// particular subcommand within an [`ArgMatches`] struct, one only needs to
    /// search for the original name and not all aliases.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///     .subcommand(Command::new("test")
    ///         .visible_aliases(["do-stuff", "tests"]))
    ///     .get_matches_from(vec!["myprog", "do-stuff"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    /// [`Command::alias`]: Command::alias()
    #[must_use]
    pub fn visible_aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
        self.aliases
            .extend(names.into_iter().map(|n| (n.into(), true)));
        self
    }

    /// Add aliases, which function as *visible* short flag subcommands.
    ///
    /// See [`Command::short_flag_aliases`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///             .subcommand(Command::new("test").short_flag('b')
    ///                 .visible_short_flag_aliases(['t']))
    ///             .get_matches_from(vec!["myprog", "-t"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    /// [`Command::short_flag_aliases`]: Command::short_flag_aliases()
    #[must_use]
    pub fn visible_short_flag_aliases(mut self, names: impl IntoIterator<Item = char>) -> Self {
        for s in names {
            debug_assert!(s != '-', "short alias name cannot be `-`");
            self.short_flag_aliases.push((s, true));
        }
        self
    }

    /// Add aliases, which function as *visible* long flag subcommands.
    ///
    /// See [`Command::long_flag_aliases`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    /// let m = Command::new("myprog")
    ///             .subcommand(Command::new("test").long_flag("test")
    ///                 .visible_long_flag_aliases(["testing", "testall", "test_all"]))
    ///             .get_matches_from(vec!["myprog", "--testing"]);
    /// assert_eq!(m.subcommand_name(), Some("test"));
    /// ```
    /// [`Command::long_flag_aliases`]: Command::long_flag_aliases()
    #[must_use]
    pub fn visible_long_flag_aliases(
        mut self,
        names: impl IntoIterator<Item = impl Into<Str>>,
    ) -> Self {
        for s in names {
            self = self.visible_long_flag_alias(s);
        }
        self
    }

    /// Set the placement of this subcommand within the help.
    ///
    /// Subcommands with a lower value will be displayed first in the help message.
    /// Those with the same display order will be sorted.
    ///
    /// `Command`s are automatically assigned a display order based on the order they are added to
    /// their parent [`Command`].
    /// Overriding this is helpful when the order commands are added in isn't the same as the
    /// display order, whether in one-off cases or to automatically sort commands.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, };
    /// let m = Command::new("cust-ord")
    ///     .subcommand(Command::new("beta")
    ///         .display_order(0)  // Sort
    ///         .about("Some help and text"))
    ///     .subcommand(Command::new("alpha")
    ///         .display_order(0)  // Sort
    ///         .about("I should be first!"))
    ///     .get_matches_from(vec![
    ///         "cust-ord", "--help"
    ///     ]);
    /// # }
    /// ```
    ///
    /// The above example displays the following help message
    ///
    /// ```text
    /// cust-ord
    ///
    /// Usage: cust-ord [OPTIONS]
    ///
    /// Commands:
    ///     alpha    I should be first!
    ///     beta     Some help and text
    ///     help     Print help for the subcommand(s)
    ///
    /// Options:
    ///     -h, --help       Print help
    ///     -V, --version    Print version
    /// ```
    #[inline]
    #[must_use]
    pub fn display_order(mut self, ord: impl IntoResettable<usize>) -> Self {
        self.disp_ord = ord.into_resettable().into_option();
        self
    }

    /// Specifies that this [`subcommand`] should be hidden from help messages
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .subcommand(
    ///         Command::new("test").hide(true)
    ///     )
    /// # ;
    /// ```
    ///
    /// [`subcommand`]: crate::Command::subcommand()
    #[inline]
    pub fn hide(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::Hidden)
        } else {
            self.unset_setting(AppSettings::Hidden)
        }
    }

    /// If no [`subcommand`] is present at runtime, error and exit gracefully.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, error::ErrorKind};
    /// let err = Command::new("myprog")
    ///     .subcommand_required(true)
    ///     .subcommand(Command::new("test"))
    ///     .try_get_matches_from(vec![
    ///         "myprog",
    ///     ]);
    /// assert!(err.is_err());
    /// assert_eq!(err.unwrap_err().kind(), ErrorKind::MissingSubcommand);
    /// # ;
    /// ```
    ///
    /// [`subcommand`]: crate::Command::subcommand()
    pub fn subcommand_required(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::SubcommandRequired)
        } else {
            self.unset_setting(AppSettings::SubcommandRequired)
        }
    }

    /// Assume unexpected positional arguments are a [`subcommand`].
    ///
    /// Arguments will be stored in the `""` argument in the [`ArgMatches`]
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Use this setting with caution,
    /// as a truly unexpected argument (i.e. one that is *NOT* an external subcommand)
    /// will **not** cause an error and instead be treated as a potential subcommand.
    /// One should check for such cases manually and inform the user appropriately.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** A built-in subcommand will be parsed as an external subcommand when escaped with
    /// `--`.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::ffi::OsString;
    /// # use clap::Command;
    /// // Assume there is an external subcommand named "subcmd"
    /// let m = Command::new("myprog")
    ///     .allow_external_subcommands(true)
    ///     .get_matches_from(vec![
    ///         "myprog", "subcmd", "--option", "value", "-fff", "--flag"
    ///     ]);
    ///
    /// // All trailing arguments will be stored under the subcommand's sub-matches using an empty
    /// // string argument name
    /// match m.subcommand() {
    ///     Some((external, ext_m)) => {
    ///          let ext_args: Vec<_> = ext_m.get_many::<OsString>("").unwrap().collect();
    ///          assert_eq!(external, "subcmd");
    ///          assert_eq!(ext_args, ["--option", "value", "-fff", "--flag"]);
    ///     },
    ///     _ => {},
    /// }
    /// ```
    ///
    /// [`subcommand`]: crate::Command::subcommand()
    /// [`ArgMatches`]: crate::ArgMatches
    /// [`ErrorKind::UnknownArgument`]: crate::error::ErrorKind::UnknownArgument
    pub fn allow_external_subcommands(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::AllowExternalSubcommands)
        } else {
            self.unset_setting(AppSettings::AllowExternalSubcommands)
        }
    }

    /// Specifies how to parse external subcommand arguments.
    ///
    /// The default parser is for `OsString`.  This can be used to switch it to `String` or another
    /// type.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Setting this requires [`Command::allow_external_subcommands`]
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(unix)] {
    /// # use clap_builder as clap;
    /// # use std::ffi::OsString;
    /// # use clap::Command;
    /// # use clap::value_parser;
    /// // Assume there is an external subcommand named "subcmd"
    /// let m = Command::new("myprog")
    ///     .allow_external_subcommands(true)
    ///     .get_matches_from(vec![
    ///         "myprog", "subcmd", "--option", "value", "-fff", "--flag"
    ///     ]);
    ///
    /// // All trailing arguments will be stored under the subcommand's sub-matches using an empty
    /// // string argument name
    /// match m.subcommand() {
    ///     Some((external, ext_m)) => {
    ///          let ext_args: Vec<_> = ext_m.get_many::<OsString>("").unwrap().collect();
    ///          assert_eq!(external, "subcmd");
    ///          assert_eq!(ext_args, ["--option", "value", "-fff", "--flag"]);
    ///     },
    ///     _ => {},
    /// }
    /// # }
    /// ```
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::value_parser;
    /// // Assume there is an external subcommand named "subcmd"
    /// let m = Command::new("myprog")
    ///     .external_subcommand_value_parser(value_parser!(String))
    ///     .get_matches_from(vec![
    ///         "myprog", "subcmd", "--option", "value", "-fff", "--flag"
    ///     ]);
    ///
    /// // All trailing arguments will be stored under the subcommand's sub-matches using an empty
    /// // string argument name
    /// match m.subcommand() {
    ///     Some((external, ext_m)) => {
    ///          let ext_args: Vec<_> = ext_m.get_many::<String>("").unwrap().collect();
    ///          assert_eq!(external, "subcmd");
    ///          assert_eq!(ext_args, ["--option", "value", "-fff", "--flag"]);
    ///     },
    ///     _ => {},
    /// }
    /// ```
    ///
    /// [`subcommands`]: crate::Command::subcommand()
    pub fn external_subcommand_value_parser(
        mut self,
        parser: impl IntoResettable<super::ValueParser>,
    ) -> Self {
        self.external_value_parser = parser.into_resettable().into_option();
        self
    }

    /// Specifies that use of an argument prevents the use of [`subcommands`].
    ///
    /// By default `clap` allows arguments between subcommands such
    /// as `<cmd> [cmd_args] <subcmd> [subcmd_args] <subsubcmd> [subsubcmd_args]`.
    ///
    /// This setting disables that functionality and says that arguments can
    /// only follow the *final* subcommand. For instance using this setting
    /// makes only the following invocations possible:
    ///
    /// * `<cmd> <subcmd> <subsubcmd> [subsubcmd_args]`
    /// * `<cmd> <subcmd> [subcmd_args]`
    /// * `<cmd> [cmd_args]`
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// Command::new("myprog")
    ///     .args_conflicts_with_subcommands(true);
    /// ```
    ///
    /// [`subcommands`]: crate::Command::subcommand()
    pub fn args_conflicts_with_subcommands(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::ArgsNegateSubcommands)
        } else {
            self.unset_setting(AppSettings::ArgsNegateSubcommands)
        }
    }

    /// Prevent subcommands from being consumed as an arguments value.
    ///
    /// By default, if an option taking multiple values is followed by a subcommand, the
    /// subcommand will be parsed as another value.
    ///
    /// ```text
    /// cmd --foo val1 val2 subcommand
    ///           --------- ----------
    ///             values   another value
    /// ```
    ///
    /// This setting instructs the parser to stop when encountering a subcommand instead of
    /// greedily consuming arguments.
    ///
    /// ```text
    /// cmd --foo val1 val2 subcommand
    ///           --------- ----------
    ///             values   subcommand
    /// ```
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let cmd = Command::new("cmd").subcommand(Command::new("sub")).arg(
    ///     Arg::new("arg")
    ///         .long("arg")
    ///         .num_args(1..)
    ///         .action(ArgAction::Set),
    /// );
    ///
    /// let matches = cmd
    ///     .clone()
    ///     .try_get_matches_from(&["cmd", "--arg", "1", "2", "3", "sub"])
    ///     .unwrap();
    /// assert_eq!(
    ///     matches.get_many::<String>("arg").unwrap().collect::<Vec<_>>(),
    ///     &["1", "2", "3", "sub"]
    /// );
    /// assert!(matches.subcommand_matches("sub").is_none());
    ///
    /// let matches = cmd
    ///     .subcommand_precedence_over_arg(true)
    ///     .try_get_matches_from(&["cmd", "--arg", "1", "2", "3", "sub"])
    ///     .unwrap();
    /// assert_eq!(
    ///     matches.get_many::<String>("arg").unwrap().collect::<Vec<_>>(),
    ///     &["1", "2", "3"]
    /// );
    /// assert!(matches.subcommand_matches("sub").is_some());
    /// ```
    pub fn subcommand_precedence_over_arg(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::SubcommandPrecedenceOverArg)
        } else {
            self.unset_setting(AppSettings::SubcommandPrecedenceOverArg)
        }
    }

    /// Allows [`subcommands`] to override all requirements of the parent command.
    ///
    /// For example, if you had a subcommand or top level application with a required argument
    /// that is only required as long as there is no subcommand present,
    /// using this setting would allow you to set those arguments to [`Arg::required(true)`]
    /// and yet receive no error so long as the user uses a valid subcommand instead.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This defaults to false (using subcommand does *not* negate requirements)
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// This first example shows that it is an error to not use a required argument
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind};
    /// let err = Command::new("myprog")
    ///     .subcommand_negates_reqs(true)
    ///     .arg(Arg::new("opt").required(true))
    ///     .subcommand(Command::new("test"))
    ///     .try_get_matches_from(vec![
    ///         "myprog"
    ///     ]);
    /// assert!(err.is_err());
    /// assert_eq!(err.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// # ;
    /// ```
    ///
    /// This next example shows that it is no longer error to not use a required argument if a
    /// valid subcommand is used.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind};
    /// let noerr = Command::new("myprog")
    ///     .subcommand_negates_reqs(true)
    ///     .arg(Arg::new("opt").required(true))
    ///     .subcommand(Command::new("test"))
    ///     .try_get_matches_from(vec![
    ///         "myprog", "test"
    ///     ]);
    /// assert!(noerr.is_ok());
    /// # ;
    /// ```
    ///
    /// [`Arg::required(true)`]: crate::Arg::required()
    /// [`subcommands`]: crate::Command::subcommand()
    pub fn subcommand_negates_reqs(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::SubcommandsNegateReqs)
        } else {
            self.unset_setting(AppSettings::SubcommandsNegateReqs)
        }
    }

    /// Multiple-personality program dispatched on the binary name (`argv[0]`)
    ///
    /// A "multicall" executable is a single executable
    /// that contains a variety of applets,
    /// and decides which applet to run based on the name of the file.
    /// The executable can be called from different names by creating hard links
    /// or symbolic links to it.
    ///
    /// This is desirable for:
    /// - Easy distribution, a single binary that can install hardlinks to access the different
    ///   personalities.
    /// - Minimal binary size by sharing common code (e.g. standard library, clap)
    /// - Custom shells or REPLs where there isn't a single top-level command
    ///
    /// Setting `multicall` will cause
    /// - `argv[0]` to be stripped to the base name and parsed as the first argument, as if
    ///   [`Command::no_binary_name`][Command::no_binary_name] was set.
    /// - Help and errors to report subcommands as if they were the top-level command
    ///
    /// When the subcommand is not present, there are several strategies you may employ, depending
    /// on your needs:
    /// - Let the error percolate up normally
    /// - Print a specialized error message using the
    ///   [`Error::context`][crate::Error::context]
    /// - Print the [help][Command::write_help] but this might be ambiguous
    /// - Disable `multicall` and re-parse it
    /// - Disable `multicall` and re-parse it with a specific subcommand
    ///
    /// When detecting the error condition, the [`ErrorKind`] isn't sufficient as a sub-subcommand
    /// might report the same error.  Enable
    /// [`allow_external_subcommands`][Command::allow_external_subcommands] if you want to specifically
    /// get the unrecognized binary name.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Multicall can't be used with [`no_binary_name`] since they interpret
    /// the command name in incompatible ways.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The multicall command cannot have arguments.
    ///
    /// </div>
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** Applets are slightly semantically different from subcommands,
    /// so it's recommended to use [`Command::subcommand_help_heading`] and
    /// [`Command::subcommand_value_name`] to change the descriptive text as above.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// `hostname` is an example of a multicall executable.
    /// Both `hostname` and `dnsdomainname` are provided by the same executable
    /// and which behaviour to use is based on the executable file name.
    ///
    /// This is desirable when the executable has a primary purpose
    /// but there is related functionality that would be convenient to provide
    /// and implement it to be in the same executable.
    ///
    /// The name of the cmd is essentially unused
    /// and may be the same as the name of a subcommand.
    ///
    /// The names of the immediate subcommands of the Command
    /// are matched against the basename of the first argument,
    /// which is conventionally the path of the executable.
    ///
    /// This does not allow the subcommand to be passed as the first non-path argument.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, error::ErrorKind};
    /// let mut cmd = Command::new("hostname")
    ///     .multicall(true)
    ///     .subcommand(Command::new("hostname"))
    ///     .subcommand(Command::new("dnsdomainname"));
    /// let m = cmd.try_get_matches_from_mut(&["/usr/bin/hostname", "dnsdomainname"]);
    /// assert!(m.is_err());
    /// assert_eq!(m.unwrap_err().kind(), ErrorKind::UnknownArgument);
    /// let m = cmd.get_matches_from(&["/usr/bin/dnsdomainname"]);
    /// assert_eq!(m.subcommand_name(), Some("dnsdomainname"));
    /// ```
    ///
    /// Busybox is another common example of a multicall executable
    /// with a subcommmand for each applet that can be run directly,
    /// e.g. with the `cat` applet being run by running `busybox cat`,
    /// or with `cat` as a link to the `busybox` binary.
    ///
    /// This is desirable when the launcher program has additional options
    /// or it is useful to run the applet without installing a symlink
    /// e.g. to test the applet without installing it
    /// or there may already be a command of that name installed.
    ///
    /// To make an applet usable as both a multicall link and a subcommand
    /// the subcommands must be defined both in the top-level Command
    /// and as subcommands of the "main" applet.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// fn applet_commands() -> [Command; 2] {
    ///     [Command::new("true"), Command::new("false")]
    /// }
    /// let mut cmd = Command::new("busybox")
    ///     .multicall(true)
    ///     .subcommand(
    ///         Command::new("busybox")
    ///             .subcommand_value_name("APPLET")
    ///             .subcommand_help_heading("APPLETS")
    ///             .subcommands(applet_commands()),
    ///     )
    ///     .subcommands(applet_commands());
    /// // When called from the executable's canonical name
    /// // its applets can be matched as subcommands.
    /// let m = cmd.try_get_matches_from_mut(&["/usr/bin/busybox", "true"]).unwrap();
    /// assert_eq!(m.subcommand_name(), Some("busybox"));
    /// assert_eq!(m.subcommand().unwrap().1.subcommand_name(), Some("true"));
    /// // When called from a link named after an applet that applet is matched.
    /// let m = cmd.get_matches_from(&["/usr/bin/true"]);
    /// assert_eq!(m.subcommand_name(), Some("true"));
    /// ```
    ///
    /// [`no_binary_name`]: crate::Command::no_binary_name
    /// [`Command::subcommand_value_name`]: crate::Command::subcommand_value_name
    /// [`Command::subcommand_help_heading`]: crate::Command::subcommand_help_heading
    #[inline]
    pub fn multicall(self, yes: bool) -> Self {
        if yes {
            self.setting(AppSettings::Multicall)
        } else {
            self.unset_setting(AppSettings::Multicall)
        }
    }

    /// Sets the value name used for subcommands when printing usage and help.
    ///
    /// By default, this is "COMMAND".
    ///
    /// See also [`Command::subcommand_help_heading`]
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .subcommand(Command::new("sub1"))
    ///     .print_help()
    /// # ;
    /// ```
    ///
    /// will produce
    ///
    /// ```text
    /// myprog
    ///
    /// Usage: myprog [COMMAND]
    ///
    /// Commands:
    ///     help    Print this message or the help of the given subcommand(s)
    ///     sub1
    ///
    /// Options:
    ///     -h, --help       Print help
    ///     -V, --version    Print version
    /// ```
    ///
    /// but usage of `subcommand_value_name`
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .subcommand(Command::new("sub1"))
    ///     .subcommand_value_name("THING")
    ///     .print_help()
    /// # ;
    /// ```
    ///
    /// will produce
    ///
    /// ```text
    /// myprog
    ///
    /// Usage: myprog [THING]
    ///
    /// Commands:
    ///     help    Print this message or the help of the given subcommand(s)
    ///     sub1
    ///
    /// Options:
    ///     -h, --help       Print help
    ///     -V, --version    Print version
    /// ```
    #[must_use]
    pub fn subcommand_value_name(mut self, value_name: impl IntoResettable<Str>) -> Self {
        self.subcommand_value_name = value_name.into_resettable().into_option();
        self
    }

    /// Sets the help heading used for subcommands when printing usage and help.
    ///
    /// By default, this is "Commands".
    ///
    /// See also [`Command::subcommand_value_name`]
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .subcommand(Command::new("sub1"))
    ///     .print_help()
    /// # ;
    /// ```
    ///
    /// will produce
    ///
    /// ```text
    /// myprog
    ///
    /// Usage: myprog [COMMAND]
    ///
    /// Commands:
    ///     help    Print this message or the help of the given subcommand(s)
    ///     sub1
    ///
    /// Options:
    ///     -h, --help       Print help
    ///     -V, --version    Print version
    /// ```
    ///
    /// but usage of `subcommand_help_heading`
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// Command::new("myprog")
    ///     .subcommand(Command::new("sub1"))
    ///     .subcommand_help_heading("Things")
    ///     .print_help()
    /// # ;
    /// ```
    ///
    /// will produce
    ///
    /// ```text
    /// myprog
    ///
    /// Usage: myprog [COMMAND]
    ///
    /// Things:
    ///     help    Print this message or the help of the given subcommand(s)
    ///     sub1
    ///
    /// Options:
    ///     -h, --help       Print help
    ///     -V, --version    Print version
    /// ```
    #[must_use]
    pub fn subcommand_help_heading(mut self, heading: impl IntoResettable<Str>) -> Self {
        self.subcommand_heading = heading.into_resettable().into_option();
        self
    }
}

/// # Reflection
impl Command {
    #[inline]
    #[cfg(feature = "usage")]
    pub(crate) fn get_usage_name(&self) -> Option<&str> {
        self.usage_name.as_deref()
    }

    #[inline]
    #[cfg(feature = "usage")]
    pub(crate) fn get_usage_name_fallback(&self) -> &str {
        self.get_usage_name()
            .unwrap_or_else(|| self.get_bin_name_fallback())
    }

    #[inline]
    #[cfg(not(feature = "usage"))]
    #[allow(dead_code)]
    pub(crate) fn get_usage_name_fallback(&self) -> &str {
        self.get_bin_name_fallback()
    }

    /// Get the name of the binary.
    #[inline]
    pub fn get_display_name(&self) -> Option<&str> {
        self.display_name.as_deref()
    }

    /// Get the name of the binary.
    #[inline]
    pub fn get_bin_name(&self) -> Option<&str> {
        self.bin_name.as_deref()
    }

    /// Get the name of the binary.
    #[inline]
    pub(crate) fn get_bin_name_fallback(&self) -> &str {
        self.bin_name.as_deref().unwrap_or_else(|| self.get_name())
    }

    /// Set binary name. Uses `&mut self` instead of `self`.
    pub fn set_bin_name(&mut self, name: impl Into<String>) {
        self.bin_name = Some(name.into());
    }

    /// Get the name of the cmd.
    #[inline]
    pub fn get_name(&self) -> &str {
        self.name.as_str()
    }

    #[inline]
    #[cfg(debug_assertions)]
    pub(crate) fn get_name_str(&self) -> &Str {
        &self.name
    }

    /// Get all known names of the cmd (i.e. primary name and visible aliases).
    pub fn get_name_and_visible_aliases(&self) -> Vec<&str> {
        let mut names = vec![self.name.as_str()];
        names.extend(self.get_visible_aliases());
        names
    }

    /// Get the version of the cmd.
    #[inline]
    pub fn get_version(&self) -> Option<&str> {
        self.version.as_deref()
    }

    /// Get the long version of the cmd.
    #[inline]
    pub fn get_long_version(&self) -> Option<&str> {
        self.long_version.as_deref()
    }

    /// Get the placement within help
    #[inline]
    pub fn get_display_order(&self) -> usize {
        self.disp_ord.unwrap_or(999)
    }

    /// Get the authors of the cmd.
    #[inline]
    pub fn get_author(&self) -> Option<&str> {
        self.author.as_deref()
    }

    /// Get the short flag of the subcommand.
    #[inline]
    pub fn get_short_flag(&self) -> Option<char> {
        self.short_flag
    }

    /// Get the long flag of the subcommand.
    #[inline]
    pub fn get_long_flag(&self) -> Option<&str> {
        self.long_flag.as_deref()
    }

    /// Get the help message specified via [`Command::about`].
    ///
    /// [`Command::about`]: Command::about()
    #[inline]
    pub fn get_about(&self) -> Option<&StyledStr> {
        self.about.as_ref()
    }

    /// Get the help message specified via [`Command::long_about`].
    ///
    /// [`Command::long_about`]: Command::long_about()
    #[inline]
    pub fn get_long_about(&self) -> Option<&StyledStr> {
        self.long_about.as_ref()
    }

    /// Get the custom section heading specified via [`Command::flatten_help`].
    #[inline]
    pub fn is_flatten_help_set(&self) -> bool {
        self.is_set(AppSettings::FlattenHelp)
    }

    /// Get the custom section heading specified via [`Command::next_help_heading`].
    ///
    /// [`Command::help_heading`]: Command::help_heading()
    #[inline]
    pub fn get_next_help_heading(&self) -> Option<&str> {
        self.current_help_heading.as_deref()
    }

    /// Iterate through the *visible* aliases for this subcommand.
    #[inline]
    pub fn get_visible_aliases(&self) -> impl Iterator<Item = &str> + '_ {
        self.aliases
            .iter()
            .filter(|(_, vis)| *vis)
            .map(|a| a.0.as_str())
    }

    /// Iterate through the *visible* short aliases for this subcommand.
    #[inline]
    pub fn get_visible_short_flag_aliases(&self) -> impl Iterator<Item = char> + '_ {
        self.short_flag_aliases
            .iter()
            .filter(|(_, vis)| *vis)
            .map(|a| a.0)
    }

    /// Iterate through the *visible* long aliases for this subcommand.
    #[inline]
    pub fn get_visible_long_flag_aliases(&self) -> impl Iterator<Item = &str> + '_ {
        self.long_flag_aliases
            .iter()
            .filter(|(_, vis)| *vis)
            .map(|a| a.0.as_str())
    }

    /// Iterate through the set of *all* the aliases for this subcommand, both visible and hidden.
    #[inline]
    pub fn get_all_aliases(&self) -> impl Iterator<Item = &str> + '_ {
        self.aliases.iter().map(|a| a.0.as_str())
    }

    /// Iterate through the set of *all* the short aliases for this subcommand, both visible and hidden.
    #[inline]
    pub fn get_all_short_flag_aliases(&self) -> impl Iterator<Item = char> + '_ {
        self.short_flag_aliases.iter().map(|a| a.0)
    }

    /// Iterate through the set of *all* the long aliases for this subcommand, both visible and hidden.
    #[inline]
    pub fn get_all_long_flag_aliases(&self) -> impl Iterator<Item = &str> + '_ {
        self.long_flag_aliases.iter().map(|a| a.0.as_str())
    }

    /// Iterate through the *hidden* aliases for this subcommand.
    #[inline]
    pub fn get_aliases(&self) -> impl Iterator<Item = &str> + '_ {
        self.aliases
            .iter()
            .filter(|(_, vis)| !*vis)
            .map(|a| a.0.as_str())
    }

    #[inline]
    pub(crate) fn is_set(&self, s: AppSettings) -> bool {
        self.settings.is_set(s) || self.g_settings.is_set(s)
    }

    /// Should we color the output?
    pub fn get_color(&self) -> ColorChoice {
        debug!("Command::color: Color setting...");

        if cfg!(feature = "color") {
            if self.is_set(AppSettings::ColorNever) {
                debug!("Never");
                ColorChoice::Never
            } else if self.is_set(AppSettings::ColorAlways) {
                debug!("Always");
                ColorChoice::Always
            } else {
                debug!("Auto");
                ColorChoice::Auto
            }
        } else {
            ColorChoice::Never
        }
    }

    /// Return the current `Styles` for the `Command`
    #[inline]
    pub fn get_styles(&self) -> &Styles {
        self.app_ext.get().unwrap_or_default()
    }

    /// Iterate through the set of subcommands, getting a reference to each.
    #[inline]
    pub fn get_subcommands(&self) -> impl Iterator<Item = &Command> {
        self.subcommands.iter()
    }

    /// Iterate through the set of subcommands, getting a mutable reference to each.
    #[inline]
    pub fn get_subcommands_mut(&mut self) -> impl Iterator<Item = &mut Command> {
        self.subcommands.iter_mut()
    }

    /// Returns `true` if this `Command` has subcommands.
    #[inline]
    pub fn has_subcommands(&self) -> bool {
        !self.subcommands.is_empty()
    }

    /// Returns the help heading for listing subcommands.
    #[inline]
    pub fn get_subcommand_help_heading(&self) -> Option<&str> {
        self.subcommand_heading.as_deref()
    }

    /// Returns the subcommand value name.
    #[inline]
    pub fn get_subcommand_value_name(&self) -> Option<&str> {
        self.subcommand_value_name.as_deref()
    }

    /// Returns the help heading for listing subcommands.
    #[inline]
    pub fn get_before_help(&self) -> Option<&StyledStr> {
        self.before_help.as_ref()
    }

    /// Returns the help heading for listing subcommands.
    #[inline]
    pub fn get_before_long_help(&self) -> Option<&StyledStr> {
        self.before_long_help.as_ref()
    }

    /// Returns the help heading for listing subcommands.
    #[inline]
    pub fn get_after_help(&self) -> Option<&StyledStr> {
        self.after_help.as_ref()
    }

    /// Returns the help heading for listing subcommands.
    #[inline]
    pub fn get_after_long_help(&self) -> Option<&StyledStr> {
        self.after_long_help.as_ref()
    }

    /// Find subcommand such that its name or one of aliases equals `name`.
    ///
    /// This does not recurse through subcommands of subcommands.
    #[inline]
    pub fn find_subcommand(&self, name: impl AsRef<std::ffi::OsStr>) -> Option<&Command> {
        let name = name.as_ref();
        self.get_subcommands().find(|s| s.aliases_to(name))
    }

    /// Find subcommand such that its name or one of aliases equals `name`, returning
    /// a mutable reference to the subcommand.
    ///
    /// This does not recurse through subcommands of subcommands.
    #[inline]
    pub fn find_subcommand_mut(
        &mut self,
        name: impl AsRef<std::ffi::OsStr>,
    ) -> Option<&mut Command> {
        let name = name.as_ref();
        self.get_subcommands_mut().find(|s| s.aliases_to(name))
    }

    /// Iterate through the set of groups.
    #[inline]
    pub fn get_groups(&self) -> impl Iterator<Item = &ArgGroup> {
        self.groups.iter()
    }

    /// Iterate through the set of arguments.
    #[inline]
    pub fn get_arguments(&self) -> impl Iterator<Item = &Arg> {
        self.args.args()
    }

    /// Iterate through the *positionals* arguments.
    #[inline]
    pub fn get_positionals(&self) -> impl Iterator<Item = &Arg> {
        self.get_arguments().filter(|a| a.is_positional())
    }

    /// Iterate through the *options*.
    pub fn get_opts(&self) -> impl Iterator<Item = &Arg> {
        self.get_arguments()
            .filter(|a| a.is_takes_value_set() && !a.is_positional())
    }

    /// Get a list of all arguments the given argument conflicts with.
    ///
    /// If the provided argument is declared as global, the conflicts will be determined
    /// based on the propagation rules of global arguments.
    ///
    /// ### Panics
    ///
    /// If the given arg contains a conflict with an argument that is unknown to
    /// this `Command`.
    pub fn get_arg_conflicts_with(&self, arg: &Arg) -> Vec<&Arg> // FIXME: This could probably have been an iterator
    {
        if arg.is_global_set() {
            self.get_global_arg_conflicts_with(arg)
        } else {
            let mut result = Vec::new();
            for id in arg.blacklist.iter() {
                if let Some(arg) = self.find(id) {
                    result.push(arg);
                } else if let Some(group) = self.find_group(id) {
                    result.extend(
                        self.unroll_args_in_group(&group.id)
                            .iter()
                            .map(|id| self.find(id).expect(INTERNAL_ERROR_MSG)),
                    );
                } else {
                    panic!("Command::get_arg_conflicts_with: The passed arg conflicts with an arg unknown to the cmd");
                }
            }
            result
        }
    }

    /// Get a unique list of all arguments of all commands and continuous subcommands the given argument conflicts with.
    ///
    /// This behavior follows the propagation rules of global arguments.
    /// It is useful for finding conflicts for arguments declared as global.
    ///
    /// ### Panics
    ///
    /// If the given arg contains a conflict with an argument that is unknown to
    /// this `Command`.
    fn get_global_arg_conflicts_with(&self, arg: &Arg) -> Vec<&Arg> // FIXME: This could probably have been an iterator
    {
        arg.blacklist
            .iter()
            .map(|id| {
                self.args
                    .args()
                    .chain(
                        self.get_subcommands_containing(arg)
                            .iter()
                            .flat_map(|x| x.args.args()),
                    )
                    .find(|arg| arg.get_id() == id)
                    .expect(
                        "Command::get_arg_conflicts_with: \
                    The passed arg conflicts with an arg unknown to the cmd",
                    )
            })
            .collect()
    }

    /// Get a list of subcommands which contain the provided Argument
    ///
    /// This command will only include subcommands in its list for which the subcommands
    /// parent also contains the Argument.
    ///
    /// This search follows the propagation rules of global arguments.
    /// It is useful to finding subcommands, that have inherited a global argument.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** In this case only `Sucommand_1` will be included
    /// ```text
    ///   Subcommand_1 (contains Arg)
    ///     Subcommand_1.1 (doesn't contain Arg)
    ///       Subcommand_1.1.1 (contains Arg)
    /// ```
    ///
    /// </div>
    fn get_subcommands_containing(&self, arg: &Arg) -> Vec<&Self> {
        let mut vec = Vec::new();
        for idx in 0..self.subcommands.len() {
            if self.subcommands[idx]
                .args
                .args()
                .any(|ar| ar.get_id() == arg.get_id())
            {
                vec.push(&self.subcommands[idx]);
                vec.append(&mut self.subcommands[idx].get_subcommands_containing(arg));
            }
        }
        vec
    }

    /// Report whether [`Command::no_binary_name`] is set
    pub fn is_no_binary_name_set(&self) -> bool {
        self.is_set(AppSettings::NoBinaryName)
    }

    /// Report whether [`Command::ignore_errors`] is set
    pub(crate) fn is_ignore_errors_set(&self) -> bool {
        self.is_set(AppSettings::IgnoreErrors)
    }

    /// Report whether [`Command::dont_delimit_trailing_values`] is set
    pub fn is_dont_delimit_trailing_values_set(&self) -> bool {
        self.is_set(AppSettings::DontDelimitTrailingValues)
    }

    /// Report whether [`Command::disable_version_flag`] is set
    pub fn is_disable_version_flag_set(&self) -> bool {
        self.is_set(AppSettings::DisableVersionFlag)
            || (self.version.is_none() && self.long_version.is_none())
    }

    /// Report whether [`Command::propagate_version`] is set
    pub fn is_propagate_version_set(&self) -> bool {
        self.is_set(AppSettings::PropagateVersion)
    }

    /// Report whether [`Command::next_line_help`] is set
    pub fn is_next_line_help_set(&self) -> bool {
        self.is_set(AppSettings::NextLineHelp)
    }

    /// Report whether [`Command::disable_help_flag`] is set
    pub fn is_disable_help_flag_set(&self) -> bool {
        self.is_set(AppSettings::DisableHelpFlag)
    }

    /// Report whether [`Command::disable_help_subcommand`] is set
    pub fn is_disable_help_subcommand_set(&self) -> bool {
        self.is_set(AppSettings::DisableHelpSubcommand)
    }

    /// Report whether [`Command::disable_colored_help`] is set
    pub fn is_disable_colored_help_set(&self) -> bool {
        self.is_set(AppSettings::DisableColoredHelp)
    }

    /// Report whether [`Command::help_expected`] is set
    #[cfg(debug_assertions)]
    pub(crate) fn is_help_expected_set(&self) -> bool {
        self.is_set(AppSettings::HelpExpected)
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "This is now the default")
    )]
    pub fn is_dont_collapse_args_in_usage_set(&self) -> bool {
        true
    }

    /// Report whether [`Command::infer_long_args`] is set
    pub(crate) fn is_infer_long_args_set(&self) -> bool {
        self.is_set(AppSettings::InferLongArgs)
    }

    /// Report whether [`Command::infer_subcommands`] is set
    pub(crate) fn is_infer_subcommands_set(&self) -> bool {
        self.is_set(AppSettings::InferSubcommands)
    }

    /// Report whether [`Command::arg_required_else_help`] is set
    pub fn is_arg_required_else_help_set(&self) -> bool {
        self.is_set(AppSettings::ArgRequiredElseHelp)
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(
            since = "4.0.0",
            note = "Replaced with `Arg::is_allow_hyphen_values_set`"
        )
    )]
    pub(crate) fn is_allow_hyphen_values_set(&self) -> bool {
        self.is_set(AppSettings::AllowHyphenValues)
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(
            since = "4.0.0",
            note = "Replaced with `Arg::is_allow_negative_numbers_set`"
        )
    )]
    pub fn is_allow_negative_numbers_set(&self) -> bool {
        self.is_set(AppSettings::AllowNegativeNumbers)
    }

    #[doc(hidden)]
    #[cfg_attr(
        feature = "deprecated",
        deprecated(since = "4.0.0", note = "Replaced with `Arg::is_trailing_var_arg_set`")
    )]
    pub fn is_trailing_var_arg_set(&self) -> bool {
        self.is_set(AppSettings::TrailingVarArg)
    }

    /// Report whether [`Command::allow_missing_positional`] is set
    pub fn is_allow_missing_positional_set(&self) -> bool {
        self.is_set(AppSettings::AllowMissingPositional)
    }

    /// Report whether [`Command::hide`] is set
    pub fn is_hide_set(&self) -> bool {
        self.is_set(AppSettings::Hidden)
    }

    /// Report whether [`Command::subcommand_required`] is set
    pub fn is_subcommand_required_set(&self) -> bool {
        self.is_set(AppSettings::SubcommandRequired)
    }

    /// Report whether [`Command::allow_external_subcommands`] is set
    pub fn is_allow_external_subcommands_set(&self) -> bool {
        self.is_set(AppSettings::AllowExternalSubcommands)
    }

    /// Configured parser for values passed to an external subcommand
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// let cmd = clap::Command::new("raw")
    ///     .external_subcommand_value_parser(clap::value_parser!(String));
    /// let value_parser = cmd.get_external_subcommand_value_parser();
    /// println!("{value_parser:?}");
    /// ```
    pub fn get_external_subcommand_value_parser(&self) -> Option<&super::ValueParser> {
        if !self.is_allow_external_subcommands_set() {
            None
        } else {
            static DEFAULT: super::ValueParser = super::ValueParser::os_string();
            Some(self.external_value_parser.as_ref().unwrap_or(&DEFAULT))
        }
    }

    /// Report whether [`Command::args_conflicts_with_subcommands`] is set
    pub fn is_args_conflicts_with_subcommands_set(&self) -> bool {
        self.is_set(AppSettings::ArgsNegateSubcommands)
    }

    #[doc(hidden)]
    pub fn is_args_override_self(&self) -> bool {
        self.is_set(AppSettings::AllArgsOverrideSelf)
    }

    /// Report whether [`Command::subcommand_precedence_over_arg`] is set
    pub fn is_subcommand_precedence_over_arg_set(&self) -> bool {
        self.is_set(AppSettings::SubcommandPrecedenceOverArg)
    }

    /// Report whether [`Command::subcommand_negates_reqs`] is set
    pub fn is_subcommand_negates_reqs_set(&self) -> bool {
        self.is_set(AppSettings::SubcommandsNegateReqs)
    }

    /// Report whether [`Command::multicall`] is set
    pub fn is_multicall_set(&self) -> bool {
        self.is_set(AppSettings::Multicall)
    }

    /// Access an [`CommandExt`]
    #[cfg(feature = "unstable-ext")]
    pub fn get<T: CommandExt + Extension>(&self) -> Option<&T> {
        self.ext.get::<T>()
    }

    /// Remove an [`CommandExt`]
    #[cfg(feature = "unstable-ext")]
    pub fn remove<T: CommandExt + Extension>(mut self) -> Option<T> {
        self.ext.remove::<T>()
    }
}

// Internally used only
impl Command {
    pub(crate) fn get_override_usage(&self) -> Option<&StyledStr> {
        self.usage_str.as_ref()
    }

    pub(crate) fn get_override_help(&self) -> Option<&StyledStr> {
        self.help_str.as_ref()
    }

    #[cfg(feature = "help")]
    pub(crate) fn get_help_template(&self) -> Option<&StyledStr> {
        self.template.as_ref()
    }

    #[cfg(feature = "help")]
    pub(crate) fn get_term_width(&self) -> Option<usize> {
        self.app_ext.get::<TermWidth>().map(|e| e.0)
    }

    #[cfg(feature = "help")]
    pub(crate) fn get_max_term_width(&self) -> Option<usize> {
        self.app_ext.get::<MaxTermWidth>().map(|e| e.0)
    }

    pub(crate) fn get_keymap(&self) -> &MKeyMap {
        &self.args
    }

    fn get_used_global_args(&self, matches: &ArgMatches, global_arg_vec: &mut Vec<Id>) {
        global_arg_vec.extend(
            self.args
                .args()
                .filter(|a| a.is_global_set())
                .map(|ga| ga.id.clone()),
        );
        if let Some((id, matches)) = matches.subcommand() {
            if let Some(used_sub) = self.find_subcommand(id) {
                used_sub.get_used_global_args(matches, global_arg_vec);
            }
        }
    }

    fn _do_parse(
        &mut self,
        raw_args: &mut clap_lex::RawArgs,
        args_cursor: clap_lex::ArgCursor,
    ) -> ClapResult<ArgMatches> {
        debug!("Command::_do_parse");

        // If there are global arguments, or settings we need to propagate them down to subcommands
        // before parsing in case we run into a subcommand
        self._build_self(false);

        let mut matcher = ArgMatcher::new(self);

        // do the real parsing
        let mut parser = Parser::new(self);
        if let Err(error) = parser.get_matches_with(&mut matcher, raw_args, args_cursor) {
            if self.is_set(AppSettings::IgnoreErrors) && error.use_stderr() {
                debug!("Command::_do_parse: ignoring error: {error}");
            } else {
                return Err(error);
            }
        }

        let mut global_arg_vec = Default::default();
        self.get_used_global_args(&matcher, &mut global_arg_vec);

        matcher.propagate_globals(&global_arg_vec);

        Ok(matcher.into_inner())
    }

    /// Prepare for introspecting on all included [`Command`]s
    ///
    /// Call this on the top-level [`Command`] when done building and before reading state for
    /// cases like completions, custom help output, etc.
    pub fn build(&mut self) {
        self._build_recursive(true);
        self._build_bin_names_internal();
    }

    pub(crate) fn _build_recursive(&mut self, expand_help_tree: bool) {
        self._build_self(expand_help_tree);
        for subcmd in self.get_subcommands_mut() {
            subcmd._build_recursive(expand_help_tree);
        }
    }

    pub(crate) fn _build_self(&mut self, expand_help_tree: bool) {
        debug!("Command::_build: name={:?}", self.get_name());
        if !self.settings.is_set(AppSettings::Built) {
            if let Some(deferred) = self.deferred.take() {
                *self = (deferred)(std::mem::take(self));
            }

            // Make sure all the globally set flags apply to us as well
            self.settings = self.settings | self.g_settings;

            if self.is_multicall_set() {
                self.settings.set(AppSettings::SubcommandRequired);
                self.settings.set(AppSettings::DisableHelpFlag);
                self.settings.set(AppSettings::DisableVersionFlag);
            }
            if !cfg!(feature = "help") && self.get_override_help().is_none() {
                self.settings.set(AppSettings::DisableHelpFlag);
                self.settings.set(AppSettings::DisableHelpSubcommand);
            }
            if self.is_set(AppSettings::ArgsNegateSubcommands) {
                self.settings.set(AppSettings::SubcommandsNegateReqs);
            }
            if self.external_value_parser.is_some() {
                self.settings.set(AppSettings::AllowExternalSubcommands);
            }
            if !self.has_subcommands() {
                self.settings.set(AppSettings::DisableHelpSubcommand);
            }

            self._propagate();
            self._check_help_and_version(expand_help_tree);
            self._propagate_global_args();

            let mut pos_counter = 1;
            let hide_pv = self.is_set(AppSettings::HidePossibleValues);
            for a in self.args.args_mut() {
                // Fill in the groups
                for g in &a.groups {
                    if let Some(ag) = self.groups.iter_mut().find(|grp| grp.id == *g) {
                        ag.args.push(a.get_id().clone());
                    } else {
                        let mut ag = ArgGroup::new(g);
                        ag.args.push(a.get_id().clone());
                        self.groups.push(ag);
                    }
                }

                // Figure out implied settings
                a._build();
                if hide_pv && a.is_takes_value_set() {
                    a.settings.set(ArgSettings::HidePossibleValues);
                }
                if a.is_positional() && a.index.is_none() {
                    a.index = Some(pos_counter);
                    pos_counter += 1;
                }
            }

            self.args._build();

            #[allow(deprecated)]
            {
                let highest_idx = self
                    .get_keymap()
                    .keys()
                    .filter_map(|x| {
                        if let crate::mkeymap::KeyType::Position(n) = x {
                            Some(*n)
                        } else {
                            None
                        }
                    })
                    .max()
                    .unwrap_or(0);
                let is_trailing_var_arg_set = self.is_trailing_var_arg_set();
                let is_allow_hyphen_values_set = self.is_allow_hyphen_values_set();
                let is_allow_negative_numbers_set = self.is_allow_negative_numbers_set();
                for arg in self.args.args_mut() {
                    if is_allow_hyphen_values_set && arg.is_takes_value_set() {
                        arg.settings.set(ArgSettings::AllowHyphenValues);
                    }
                    if is_allow_negative_numbers_set && arg.is_takes_value_set() {
                        arg.settings.set(ArgSettings::AllowNegativeNumbers);
                    }
                    if is_trailing_var_arg_set && arg.get_index() == Some(highest_idx) {
                        arg.settings.set(ArgSettings::TrailingVarArg);
                    }
                }
            }

            #[cfg(debug_assertions)]
            assert_app(self);
            self.settings.set(AppSettings::Built);
        } else {
            debug!("Command::_build: already built");
        }
    }

    pub(crate) fn _build_subcommand(&mut self, name: &str) -> Option<&mut Self> {
        use std::fmt::Write;

        let mut mid_string = String::from(" ");
        #[cfg(feature = "usage")]
        if !self.is_subcommand_negates_reqs_set() && !self.is_args_conflicts_with_subcommands_set()
        {
            let reqs = Usage::new(self).get_required_usage_from(&[], None, true); // maybe Some(m)

            for s in &reqs {
                mid_string.push_str(&s.to_string());
                mid_string.push(' ');
            }
        }
        let is_multicall_set = self.is_multicall_set();

        let sc = some!(self.subcommands.iter_mut().find(|s| s.name == name));

        // Display subcommand name, short and long in usage
        let mut sc_names = String::new();
        sc_names.push_str(sc.name.as_str());
        let mut flag_subcmd = false;
        if let Some(l) = sc.get_long_flag() {
            write!(sc_names, "|--{l}").unwrap();
            flag_subcmd = true;
        }
        if let Some(s) = sc.get_short_flag() {
            write!(sc_names, "|-{s}").unwrap();
            flag_subcmd = true;
        }

        if flag_subcmd {
            sc_names = format!("{{{sc_names}}}");
        }

        let usage_name = self
            .bin_name
            .as_ref()
            .map(|bin_name| format!("{bin_name}{mid_string}{sc_names}"))
            .unwrap_or(sc_names);
        sc.usage_name = Some(usage_name);

        // bin_name should be parent's bin_name + [<reqs>] + the sc's name separated by
        // a space
        let bin_name = format!(
            "{}{}{}",
            self.bin_name.as_deref().unwrap_or_default(),
            if self.bin_name.is_some() { " " } else { "" },
            &*sc.name
        );
        debug!(
            "Command::_build_subcommand Setting bin_name of {} to {:?}",
            sc.name, bin_name
        );
        sc.bin_name = Some(bin_name);

        if sc.display_name.is_none() {
            let self_display_name = if is_multicall_set {
                self.display_name.as_deref().unwrap_or("")
            } else {
                self.display_name.as_deref().unwrap_or(&self.name)
            };
            let display_name = format!(
                "{}{}{}",
                self_display_name,
                if !self_display_name.is_empty() {
                    "-"
                } else {
                    ""
                },
                &*sc.name
            );
            debug!(
                "Command::_build_subcommand Setting display_name of {} to {:?}",
                sc.name, display_name
            );
            sc.display_name = Some(display_name);
        }

        // Ensure all args are built and ready to parse
        sc._build_self(false);

        Some(sc)
    }

    fn _build_bin_names_internal(&mut self) {
        debug!("Command::_build_bin_names");

        if !self.is_set(AppSettings::BinNameBuilt) {
            let mut mid_string = String::from(" ");
            #[cfg(feature = "usage")]
            if !self.is_subcommand_negates_reqs_set()
                && !self.is_args_conflicts_with_subcommands_set()
            {
                let reqs = Usage::new(self).get_required_usage_from(&[], None, true); // maybe Some(m)

                for s in &reqs {
                    mid_string.push_str(&s.to_string());
                    mid_string.push(' ');
                }
            }
            let is_multicall_set = self.is_multicall_set();

            let self_bin_name = if is_multicall_set {
                self.bin_name.as_deref().unwrap_or("")
            } else {
                self.bin_name.as_deref().unwrap_or(&self.name)
            }
            .to_owned();

            for sc in &mut self.subcommands {
                debug!("Command::_build_bin_names:iter: bin_name set...");

                if sc.usage_name.is_none() {
                    use std::fmt::Write;
                    // Display subcommand name, short and long in usage
                    let mut sc_names = String::new();
                    sc_names.push_str(sc.name.as_str());
                    let mut flag_subcmd = false;
                    if let Some(l) = sc.get_long_flag() {
                        write!(sc_names, "|--{l}").unwrap();
                        flag_subcmd = true;
                    }
                    if let Some(s) = sc.get_short_flag() {
                        write!(sc_names, "|-{s}").unwrap();
                        flag_subcmd = true;
                    }

                    if flag_subcmd {
                        sc_names = format!("{{{sc_names}}}");
                    }

                    let usage_name = format!("{self_bin_name}{mid_string}{sc_names}");
                    debug!(
                        "Command::_build_bin_names:iter: Setting usage_name of {} to {:?}",
                        sc.name, usage_name
                    );
                    sc.usage_name = Some(usage_name);
                } else {
                    debug!(
                        "Command::_build_bin_names::iter: Using existing usage_name of {} ({:?})",
                        sc.name, sc.usage_name
                    );
                }

                if sc.bin_name.is_none() {
                    let bin_name = format!(
                        "{}{}{}",
                        self_bin_name,
                        if !self_bin_name.is_empty() { " " } else { "" },
                        &*sc.name
                    );
                    debug!(
                        "Command::_build_bin_names:iter: Setting bin_name of {} to {:?}",
                        sc.name, bin_name
                    );
                    sc.bin_name = Some(bin_name);
                } else {
                    debug!(
                        "Command::_build_bin_names::iter: Using existing bin_name of {} ({:?})",
                        sc.name, sc.bin_name
                    );
                }

                if sc.display_name.is_none() {
                    let self_display_name = if is_multicall_set {
                        self.display_name.as_deref().unwrap_or("")
                    } else {
                        self.display_name.as_deref().unwrap_or(&self.name)
                    };
                    let display_name = format!(
                        "{}{}{}",
                        self_display_name,
                        if !self_display_name.is_empty() {
                            "-"
                        } else {
                            ""
                        },
                        &*sc.name
                    );
                    debug!(
                        "Command::_build_bin_names:iter: Setting display_name of {} to {:?}",
                        sc.name, display_name
                    );
                    sc.display_name = Some(display_name);
                } else {
                    debug!(
                        "Command::_build_bin_names::iter: Using existing display_name of {} ({:?})",
                        sc.name, sc.display_name
                    );
                }

                sc._build_bin_names_internal();
            }
            self.set(AppSettings::BinNameBuilt);
        } else {
            debug!("Command::_build_bin_names: already built");
        }
    }

    pub(crate) fn _panic_on_missing_help(&self, help_required_globally: bool) {
        if self.is_set(AppSettings::HelpExpected) || help_required_globally {
            let args_missing_help: Vec<Id> = self
                .args
                .args()
                .filter(|arg| arg.get_help().is_none() && arg.get_long_help().is_none())
                .map(|arg| arg.get_id().clone())
                .collect();

            debug_assert!(args_missing_help.is_empty(),
                    "Command::help_expected is enabled for the Command {}, but at least one of its arguments does not have either `help` or `long_help` set. List of such arguments: {}",
                    self.name,
                    args_missing_help.join(", ")
                );
        }

        for sub_app in &self.subcommands {
            sub_app._panic_on_missing_help(help_required_globally);
        }
    }

    #[cfg(debug_assertions)]
    pub(crate) fn two_args_of<F>(&self, condition: F) -> Option<(&Arg, &Arg)>
    where
        F: Fn(&Arg) -> bool,
    {
        two_elements_of(self.args.args().filter(|a: &&Arg| condition(a)))
    }

    // just in case
    #[allow(unused)]
    fn two_groups_of<F>(&self, condition: F) -> Option<(&ArgGroup, &ArgGroup)>
    where
        F: Fn(&ArgGroup) -> bool,
    {
        two_elements_of(self.groups.iter().filter(|a| condition(a)))
    }

    /// Propagate global args
    pub(crate) fn _propagate_global_args(&mut self) {
        debug!("Command::_propagate_global_args:{}", self.name);

        let autogenerated_help_subcommand = !self.is_disable_help_subcommand_set();

        for sc in &mut self.subcommands {
            if sc.get_name() == "help" && autogenerated_help_subcommand {
                // Avoid propagating args to the autogenerated help subtrees used in completion.
                // This prevents args from showing up during help completions like
                // `myapp help subcmd <TAB>`, which should only suggest subcommands and not args,
                // while still allowing args to show up properly on the generated help message.
                continue;
            }

            for a in self.args.args().filter(|a| a.is_global_set()) {
                if sc.find(&a.id).is_some() {
                    debug!(
                        "Command::_propagate skipping {:?} to {}, already exists",
                        a.id,
                        sc.get_name(),
                    );
                    continue;
                }

                debug!(
                    "Command::_propagate pushing {:?} to {}",
                    a.id,
                    sc.get_name(),
                );
                sc.args.push(a.clone());
            }
        }
    }

    /// Propagate settings
    pub(crate) fn _propagate(&mut self) {
        debug!("Command::_propagate:{}", self.name);
        let mut subcommands = std::mem::take(&mut self.subcommands);
        for sc in &mut subcommands {
            self._propagate_subcommand(sc);
        }
        self.subcommands = subcommands;
    }

    fn _propagate_subcommand(&self, sc: &mut Self) {
        // We have to create a new scope in order to tell rustc the borrow of `sc` is
        // done and to recursively call this method
        {
            if self.settings.is_set(AppSettings::PropagateVersion) {
                if let Some(version) = self.version.as_ref() {
                    sc.version.get_or_insert_with(|| version.clone());
                }
                if let Some(long_version) = self.long_version.as_ref() {
                    sc.long_version.get_or_insert_with(|| long_version.clone());
                }
            }

            sc.settings = sc.settings | self.g_settings;
            sc.g_settings = sc.g_settings | self.g_settings;
            sc.app_ext.update(&self.app_ext);
        }
    }

    pub(crate) fn _check_help_and_version(&mut self, expand_help_tree: bool) {
        debug!(
            "Command::_check_help_and_version:{} expand_help_tree={}",
            self.name, expand_help_tree
        );

        self.long_help_exists = self.long_help_exists_();

        if !self.is_disable_help_flag_set() {
            debug!("Command::_check_help_and_version: Building default --help");
            let mut arg = Arg::new(Id::HELP)
                .short('h')
                .long("help")
                .action(ArgAction::Help);
            if self.long_help_exists {
                arg = arg
                    .help("Print help (see more with '--help')")
                    .long_help("Print help (see a summary with '-h')");
            } else {
                arg = arg.help("Print help");
            }
            // Avoiding `arg_internal` to not be sensitive to `next_help_heading` /
            // `next_display_order`
            self.args.push(arg);
        }
        if !self.is_disable_version_flag_set() {
            debug!("Command::_check_help_and_version: Building default --version");
            let arg = Arg::new(Id::VERSION)
                .short('V')
                .long("version")
                .action(ArgAction::Version)
                .help("Print version");
            // Avoiding `arg_internal` to not be sensitive to `next_help_heading` /
            // `next_display_order`
            self.args.push(arg);
        }

        if !self.is_set(AppSettings::DisableHelpSubcommand) {
            debug!("Command::_check_help_and_version: Building help subcommand");
            let help_about = "Print this message or the help of the given subcommand(s)";

            let mut help_subcmd = if expand_help_tree {
                // Slow code path to recursively clone all other subcommand subtrees under help
                let help_subcmd = Command::new("help")
                    .about(help_about)
                    .global_setting(AppSettings::DisableHelpSubcommand)
                    .subcommands(self.get_subcommands().map(Command::_copy_subtree_for_help));

                let mut help_help_subcmd = Command::new("help").about(help_about);
                help_help_subcmd.version = None;
                help_help_subcmd.long_version = None;
                help_help_subcmd = help_help_subcmd
                    .setting(AppSettings::DisableHelpFlag)
                    .setting(AppSettings::DisableVersionFlag);

                help_subcmd.subcommand(help_help_subcmd)
            } else {
                Command::new("help").about(help_about).arg(
                    Arg::new("subcommand")
                        .action(ArgAction::Append)
                        .num_args(..)
                        .value_name("COMMAND")
                        .help("Print help for the subcommand(s)"),
                )
            };
            self._propagate_subcommand(&mut help_subcmd);

            // The parser acts like this is set, so let's set it so we don't falsely
            // advertise it to the user
            help_subcmd.version = None;
            help_subcmd.long_version = None;
            help_subcmd = help_subcmd
                .setting(AppSettings::DisableHelpFlag)
                .setting(AppSettings::DisableVersionFlag)
                .unset_global_setting(AppSettings::PropagateVersion);

            self.subcommands.push(help_subcmd);
        }
    }

    fn _copy_subtree_for_help(&self) -> Command {
        let mut cmd = Command::new(self.name.clone())
            .hide(self.is_hide_set())
            .global_setting(AppSettings::DisableHelpFlag)
            .global_setting(AppSettings::DisableVersionFlag)
            .subcommands(self.get_subcommands().map(Command::_copy_subtree_for_help));
        if self.get_about().is_some() {
            cmd = cmd.about(self.get_about().unwrap().clone());
        }
        cmd
    }

    pub(crate) fn _render_version(&self, use_long: bool) -> String {
        debug!("Command::_render_version");

        let ver = if use_long {
            self.long_version
                .as_deref()
                .or(self.version.as_deref())
                .unwrap_or_default()
        } else {
            self.version
                .as_deref()
                .or(self.long_version.as_deref())
                .unwrap_or_default()
        };
        let display_name = self.get_display_name().unwrap_or_else(|| self.get_name());
        format!("{display_name} {ver}\n")
    }

    pub(crate) fn format_group(&self, g: &Id) -> StyledStr {
        use std::fmt::Write as _;

        let g_string = self
            .unroll_args_in_group(g)
            .iter()
            .filter_map(|x| self.find(x))
            .map(|x| {
                if x.is_positional() {
                    // Print val_name for positional arguments. e.g. <file_name>
                    x.name_no_brackets()
                } else {
                    // Print usage string for flags arguments, e.g. <--help>
                    x.to_string()
                }
            })
            .collect::<Vec<_>>()
            .join("|");
        let placeholder = self.get_styles().get_placeholder();
        let mut styled = StyledStr::new();
        write!(&mut styled, "{placeholder}<{g_string}>{placeholder:#}").unwrap();
        styled
    }
}

/// A workaround:
/// <https://github.com/rust-lang/rust/issues/34511#issuecomment-373423999>
pub(crate) trait Captures<'a> {}
impl<T> Captures<'_> for T {}

// Internal Query Methods
impl Command {
    /// Iterate through the *flags* & *options* arguments.
    #[cfg(any(feature = "usage", feature = "help"))]
    pub(crate) fn get_non_positionals(&self) -> impl Iterator<Item = &Arg> {
        self.get_arguments().filter(|a| !a.is_positional())
    }

    pub(crate) fn find(&self, arg_id: &Id) -> Option<&Arg> {
        self.args.args().find(|a| a.get_id() == arg_id)
    }

    #[inline]
    pub(crate) fn contains_short(&self, s: char) -> bool {
        debug_assert!(
            self.is_set(AppSettings::Built),
            "If Command::_build hasn't been called, manually search through Arg shorts"
        );

        self.args.contains(s)
    }

    #[inline]
    pub(crate) fn set(&mut self, s: AppSettings) {
        self.settings.set(s);
    }

    #[inline]
    pub(crate) fn has_positionals(&self) -> bool {
        self.get_positionals().next().is_some()
    }

    #[cfg(any(feature = "usage", feature = "help"))]
    pub(crate) fn has_visible_subcommands(&self) -> bool {
        self.subcommands
            .iter()
            .any(|sc| sc.name != "help" && !sc.is_set(AppSettings::Hidden))
    }

    /// Check if this subcommand can be referred to as `name`. In other words,
    /// check if `name` is the name of this subcommand or is one of its aliases.
    #[inline]
    pub(crate) fn aliases_to(&self, name: impl AsRef<std::ffi::OsStr>) -> bool {
        let name = name.as_ref();
        self.get_name() == name || self.get_all_aliases().any(|alias| alias == name)
    }

    /// Check if this subcommand can be referred to as `name`. In other words,
    /// check if `name` is the name of this short flag subcommand or is one of its short flag aliases.
    #[inline]
    pub(crate) fn short_flag_aliases_to(&self, flag: char) -> bool {
        Some(flag) == self.short_flag
            || self.get_all_short_flag_aliases().any(|alias| flag == alias)
    }

    /// Check if this subcommand can be referred to as `name`. In other words,
    /// check if `name` is the name of this long flag subcommand or is one of its long flag aliases.
    #[inline]
    pub(crate) fn long_flag_aliases_to(&self, flag: &str) -> bool {
        match self.long_flag.as_ref() {
            Some(long_flag) => {
                long_flag == flag || self.get_all_long_flag_aliases().any(|alias| alias == flag)
            }
            None => self.get_all_long_flag_aliases().any(|alias| alias == flag),
        }
    }

    #[cfg(debug_assertions)]
    pub(crate) fn id_exists(&self, id: &Id) -> bool {
        self.args.args().any(|x| x.get_id() == id) || self.groups.iter().any(|x| x.id == *id)
    }

    /// Iterate through the groups this arg is member of.
    pub(crate) fn groups_for_arg<'a>(&'a self, arg: &Id) -> impl Iterator<Item = Id> + 'a {
        debug!("Command::groups_for_arg: id={arg:?}");
        let arg = arg.clone();
        self.groups
            .iter()
            .filter(move |grp| grp.args.iter().any(|a| a == &arg))
            .map(|grp| grp.id.clone())
    }

    pub(crate) fn find_group(&self, group_id: &Id) -> Option<&ArgGroup> {
        self.groups.iter().find(|g| g.id == *group_id)
    }

    /// Iterate through all the names of all subcommands (not recursively), including aliases.
    /// Used for suggestions.
    pub(crate) fn all_subcommand_names(&self) -> impl Iterator<Item = &str> + Captures<'_> {
        self.get_subcommands().flat_map(|sc| {
            let name = sc.get_name();
            let aliases = sc.get_all_aliases();
            std::iter::once(name).chain(aliases)
        })
    }

    pub(crate) fn required_graph(&self) -> ChildGraph<Id> {
        let mut reqs = ChildGraph::with_capacity(5);
        for a in self.args.args().filter(|a| a.is_required_set()) {
            reqs.insert(a.get_id().clone());
        }
        for group in &self.groups {
            if group.required {
                let idx = reqs.insert(group.id.clone());
                for a in &group.requires {
                    reqs.insert_child(idx, a.clone());
                }
            }
        }

        reqs
    }

    pub(crate) fn unroll_args_in_group(&self, group: &Id) -> Vec<Id> {
        debug!("Command::unroll_args_in_group: group={group:?}");
        let mut g_vec = vec![group];
        let mut args = vec![];

        while let Some(g) = g_vec.pop() {
            for n in self
                .groups
                .iter()
                .find(|grp| grp.id == *g)
                .expect(INTERNAL_ERROR_MSG)
                .args
                .iter()
            {
                debug!("Command::unroll_args_in_group:iter: entity={n:?}");
                if !args.contains(n) {
                    if self.find(n).is_some() {
                        debug!("Command::unroll_args_in_group:iter: this is an arg");
                        args.push(n.clone());
                    } else {
                        debug!("Command::unroll_args_in_group:iter: this is a group");
                        g_vec.push(n);
                    }
                }
            }
        }

        args
    }

    pub(crate) fn unroll_arg_requires<F>(&self, func: F, arg: &Id) -> Vec<Id>
    where
        F: Fn(&(ArgPredicate, Id)) -> Option<Id>,
    {
        let mut processed = vec![];
        let mut r_vec = vec![arg];
        let mut args = vec![];

        while let Some(a) = r_vec.pop() {
            if processed.contains(&a) {
                continue;
            }

            processed.push(a);

            if let Some(arg) = self.find(a) {
                for r in arg.requires.iter().filter_map(&func) {
                    if let Some(req) = self.find(&r) {
                        if !req.requires.is_empty() {
                            r_vec.push(req.get_id());
                        }
                    }
                    args.push(r);
                }
            }
        }

        args
    }

    /// Find a flag subcommand name by short flag or an alias
    pub(crate) fn find_short_subcmd(&self, c: char) -> Option<&str> {
        self.get_subcommands()
            .find(|sc| sc.short_flag_aliases_to(c))
            .map(|sc| sc.get_name())
    }

    /// Find a flag subcommand name by long flag or an alias
    pub(crate) fn find_long_subcmd(&self, long: &str) -> Option<&str> {
        self.get_subcommands()
            .find(|sc| sc.long_flag_aliases_to(long))
            .map(|sc| sc.get_name())
    }

    pub(crate) fn write_help_err(&self, mut use_long: bool) -> StyledStr {
        debug!(
            "Command::write_help_err: {}, use_long={:?}",
            self.get_display_name().unwrap_or_else(|| self.get_name()),
            use_long && self.long_help_exists(),
        );

        use_long = use_long && self.long_help_exists();
        let usage = Usage::new(self);

        let mut styled = StyledStr::new();
        write_help(&mut styled, self, &usage, use_long);

        styled
    }

    pub(crate) fn write_version_err(&self, use_long: bool) -> StyledStr {
        let msg = self._render_version(use_long);
        StyledStr::from(msg)
    }

    pub(crate) fn long_help_exists(&self) -> bool {
        debug!("Command::long_help_exists: {}", self.long_help_exists);
        self.long_help_exists
    }

    fn long_help_exists_(&self) -> bool {
        debug!("Command::long_help_exists");
        // In this case, both must be checked. This allows the retention of
        // original formatting, but also ensures that the actual -h or --help
        // specified by the user is sent through. If hide_short_help is not included,
        // then items specified with hidden_short_help will also be hidden.
        let should_long = |v: &Arg| {
            !v.is_hide_set()
                && (v.get_long_help().is_some()
                    || v.is_hide_long_help_set()
                    || v.is_hide_short_help_set()
                    || (!v.is_hide_possible_values_set()
                        && v.get_possible_values()
                            .iter()
                            .any(PossibleValue::should_show_help)))
        };

        // Subcommands aren't checked because we prefer short help for them, deferring to
        // `cmd subcmd --help` for more.
        self.get_long_about().is_some()
            || self.get_before_long_help().is_some()
            || self.get_after_long_help().is_some()
            || self.get_arguments().any(should_long)
    }

    // Should we color the help?
    pub(crate) fn color_help(&self) -> ColorChoice {
        #[cfg(feature = "color")]
        if self.is_disable_colored_help_set() {
            return ColorChoice::Never;
        }

        self.get_color()
    }
}

impl Default for Command {
    fn default() -> Self {
        Self {
            name: Default::default(),
            long_flag: Default::default(),
            short_flag: Default::default(),
            display_name: Default::default(),
            bin_name: Default::default(),
            author: Default::default(),
            version: Default::default(),
            long_version: Default::default(),
            about: Default::default(),
            long_about: Default::default(),
            before_help: Default::default(),
            before_long_help: Default::default(),
            after_help: Default::default(),
            after_long_help: Default::default(),
            aliases: Default::default(),
            short_flag_aliases: Default::default(),
            long_flag_aliases: Default::default(),
            usage_str: Default::default(),
            usage_name: Default::default(),
            help_str: Default::default(),
            disp_ord: Default::default(),
            #[cfg(feature = "help")]
            template: Default::default(),
            settings: Default::default(),
            g_settings: Default::default(),
            args: Default::default(),
            subcommands: Default::default(),
            groups: Default::default(),
            current_help_heading: Default::default(),
            current_disp_ord: Some(0),
            subcommand_value_name: Default::default(),
            subcommand_heading: Default::default(),
            external_value_parser: Default::default(),
            long_help_exists: false,
            deferred: None,
            #[cfg(feature = "unstable-ext")]
            ext: Default::default(),
            app_ext: Default::default(),
        }
    }
}

impl Index<&'_ Id> for Command {
    type Output = Arg;

    fn index(&self, key: &Id) -> &Self::Output {
        self.find(key).expect(INTERNAL_ERROR_MSG)
    }
}

impl From<&'_ Command> for Command {
    fn from(cmd: &'_ Command) -> Self {
        cmd.clone()
    }
}

impl fmt::Display for Command {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.name)
    }
}

/// User-provided data that can be attached to an [`Arg`]
#[cfg(feature = "unstable-ext")]
pub trait CommandExt: Extension {}

#[allow(dead_code)] // atm dependent on features enabled
pub(crate) trait AppExt: Extension {}

#[allow(dead_code)] // atm dependent on features enabled
#[derive(Default, Copy, Clone, Debug)]
struct TermWidth(usize);

impl AppExt for TermWidth {}

#[allow(dead_code)] // atm dependent on features enabled
#[derive(Default, Copy, Clone, Debug)]
struct MaxTermWidth(usize);

impl AppExt for MaxTermWidth {}

fn two_elements_of<I, T>(mut iter: I) -> Option<(T, T)>
where
    I: Iterator<Item = T>,
{
    let first = iter.next();
    let second = iter.next();

    match (first, second) {
        (Some(first), Some(second)) => Some((first, second)),
        _ => None,
    }
}

#[test]
fn check_auto_traits() {
    static_assertions::assert_impl_all!(Command: Send, Sync, Unpin);
}

```

`clap/clap_builder/src/builder/debug_asserts.rs`:

```rs
use std::cmp::Ordering;

use crate::builder::ValueRange;
use crate::mkeymap::KeyType;
use crate::util::FlatSet;
use crate::util::Id;
use crate::ArgAction;
use crate::INTERNAL_ERROR_MSG;
use crate::{Arg, Command, ValueHint};

pub(crate) fn assert_app(cmd: &Command) {
    debug!("Command::_debug_asserts");

    let mut short_flags = vec![];
    let mut long_flags = vec![];

    // Invalid version flag settings
    if cmd.get_version().is_none() && cmd.get_long_version().is_none() {
        // PropagateVersion is meaningless if there is no version
        assert!(
            !cmd.is_propagate_version_set(),
            "Command {}: No version information via Command::version or Command::long_version to propagate",
            cmd.get_name(),
        );

        // Used `Command::mut_arg("version", ..) but did not provide any version information to display
        let version_needed = cmd
            .get_arguments()
            .filter(|x| matches!(x.get_action(), ArgAction::Version))
            .map(|x| x.get_id())
            .collect::<Vec<_>>();

        assert_eq!(version_needed, Vec::<&str>::new(), "Command {}: `ArgAction::Version` used without providing Command::version or Command::long_version"
            ,cmd.get_name()
        );
    }

    for sc in cmd.get_subcommands() {
        if let Some(s) = sc.get_short_flag().as_ref() {
            short_flags.push(Flag::Command(format!("-{s}"), sc.get_name()));
        }

        for short_alias in sc.get_all_short_flag_aliases() {
            short_flags.push(Flag::Command(format!("-{short_alias}"), sc.get_name()));
        }

        if let Some(l) = sc.get_long_flag().as_ref() {
            assert!(!l.starts_with('-'), "Command {}: long_flag {:?} must not start with a `-`, that will be handled by the parser", sc.get_name(), l);
            long_flags.push(Flag::Command(format!("--{l}"), sc.get_name()));
        }

        for long_alias in sc.get_all_long_flag_aliases() {
            long_flags.push(Flag::Command(format!("--{long_alias}"), sc.get_name()));
        }
    }

    for arg in cmd.get_arguments() {
        assert_arg(arg);

        assert!(
            !cmd.is_multicall_set(),
            "Command {}: Arguments like {} cannot be set on a multicall command",
            cmd.get_name(),
            arg.get_id()
        );

        if let Some(s) = arg.get_short() {
            short_flags.push(Flag::Arg(format!("-{s}"), arg.get_id().as_str()));
        }

        for (short_alias, _) in &arg.short_aliases {
            short_flags.push(Flag::Arg(format!("-{short_alias}"), arg.get_id().as_str()));
        }

        if let Some(l) = arg.get_long() {
            assert!(!l.starts_with('-'), "Argument {}: long {:?} must not start with a `-`, that will be handled by the parser", arg.get_id(), l);
            long_flags.push(Flag::Arg(format!("--{l}"), arg.get_id().as_str()));
        }

        for (long_alias, _) in &arg.aliases {
            long_flags.push(Flag::Arg(format!("--{long_alias}"), arg.get_id().as_str()));
        }

        // Name conflicts
        if let Some((first, second)) = cmd.two_args_of(|x| x.get_id() == arg.get_id()) {
            panic!(
            "Command {}: Argument names must be unique, but '{}' is in use by more than one argument or group{}",
            cmd.get_name(),
            arg.get_id(),
            duplicate_tip(cmd, first, second),
        );
        }

        // Long conflicts
        if let Some(l) = arg.get_long() {
            if let Some((first, second)) = cmd.two_args_of(|x| x.get_long() == Some(l)) {
                panic!(
                    "Command {}: Long option names must be unique for each argument, \
                            but '--{}' is in use by both '{}' and '{}'{}",
                    cmd.get_name(),
                    l,
                    first.get_id(),
                    second.get_id(),
                    duplicate_tip(cmd, first, second)
                )
            }
        }

        // Short conflicts
        if let Some(s) = arg.get_short() {
            if let Some((first, second)) = cmd.two_args_of(|x| x.get_short() == Some(s)) {
                panic!(
                    "Command {}: Short option names must be unique for each argument, \
                            but '-{}' is in use by both '{}' and '{}'{}",
                    cmd.get_name(),
                    s,
                    first.get_id(),
                    second.get_id(),
                    duplicate_tip(cmd, first, second),
                )
            }
        }

        // Index conflicts
        if let Some(idx) = arg.index {
            if let Some((first, second)) =
                cmd.two_args_of(|x| x.is_positional() && x.get_index() == Some(idx))
            {
                panic!(
                    "Command {}: Argument '{}' has the same index as '{}' \
                    and they are both positional arguments\n\n\t \
                    Use `Arg::num_args(1..)` to allow one \
                    positional argument to take multiple values",
                    cmd.get_name(),
                    first.get_id(),
                    second.get_id()
                )
            }
        }

        // requires, r_if, r_unless
        for (_predicate, req_id) in &arg.requires {
            assert!(
                &arg.id != req_id,
                "Argument {} cannot require itself",
                arg.get_id()
            );

            assert!(
                cmd.id_exists(req_id),
                "Command {}: Argument or group '{}' specified in 'requires*' for '{}' does not exist",
                cmd.get_name(),
                req_id,
                arg.get_id(),
            );
        }

        for req in &arg.r_ifs {
            assert!(
                !arg.is_required_set(),
                "Argument {}: `required` conflicts with `required_if_eq*`",
                arg.get_id()
            );
            assert!(
                cmd.id_exists(&req.0),
                "Command {}: Argument or group '{}' specified in 'required_if_eq*' for '{}' does not exist",
                    cmd.get_name(),
                req.0,
                arg.get_id()
            );
        }

        for req in &arg.r_ifs_all {
            assert!(
                !arg.is_required_set(),
                "Argument {}: `required` conflicts with `required_if_eq_all`",
                arg.get_id()
            );
            assert!(
                cmd.id_exists(&req.0),
                "Command {}: Argument or group '{}' specified in 'required_if_eq_all' for '{}' does not exist",
                    cmd.get_name(),
                req.0,
                arg.get_id()
            );
        }

        for req in &arg.r_unless {
            assert!(
                !arg.is_required_set(),
                "Argument {}: `required` conflicts with `required_unless*`",
                arg.get_id()
            );
            assert!(
                cmd.id_exists(req),
                "Command {}: Argument or group '{}' specified in 'required_unless*' for '{}' does not exist",
                    cmd.get_name(),
                req,
                arg.get_id(),
            );
        }

        for req in &arg.r_unless_all {
            assert!(
                !arg.is_required_set(),
                "Argument {}: `required` conflicts with `required_unless*`",
                arg.get_id()
            );
            assert!(
                cmd.id_exists(req),
                "Command {}: Argument or group '{}' specified in 'required_unless*' for '{}' does not exist",
                    cmd.get_name(),
                req,
                arg.get_id(),
            );
        }

        // blacklist
        for req in &arg.blacklist {
            assert!(
                cmd.id_exists(req),
                "Command {}: Argument or group '{}' specified in 'conflicts_with*' for '{}' does not exist",
                    cmd.get_name(),
                req,
                arg.get_id(),
            );
        }

        // overrides
        for req in &arg.overrides {
            assert!(
                cmd.id_exists(req),
                "Command {}: Argument or group '{}' specified in 'overrides_with*' for '{}' does not exist",
                    cmd.get_name(),
                req,
                arg.get_id(),
            );
        }

        if arg.is_last_set() {
            assert!(
                arg.get_long().is_none(),
                "Command {}: Flags or Options cannot have last(true) set. '{}' has both a long and last(true) set.",
                    cmd.get_name(),
                arg.get_id()
            );
            assert!(
                arg.get_short().is_none(),
                "Command {}: Flags or Options cannot have last(true) set. '{}' has both a short and last(true) set.",
                    cmd.get_name(),
                arg.get_id()
            );
        }

        assert!(
            !(arg.is_required_set() && arg.is_global_set()),
            "Command {}: Global arguments cannot be required.\n\n\t'{}' is marked as both global and required",
                    cmd.get_name(),
            arg.get_id()
        );

        if arg.get_value_hint() == ValueHint::CommandWithArguments {
            assert!(
                arg.is_positional(),
                "Command {}: Argument '{}' has hint CommandWithArguments and must be positional.",
                cmd.get_name(),
                arg.get_id()
            );

            assert!(
                arg.is_trailing_var_arg_set() || arg.is_last_set(),
                "Command {}: Positional argument '{}' has hint CommandWithArguments, so Command must have `trailing_var_arg(true)` or `last(true)` set.",
                    cmd.get_name(),
                arg.get_id()
            );
        }
    }

    for group in cmd.get_groups() {
        // Name conflicts
        assert!(
            cmd.get_groups().filter(|x| x.id == group.id).count() < 2,
            "Command {}: Argument group name must be unique\n\n\t'{}' is already in use",
            cmd.get_name(),
            group.get_id(),
        );

        // Groups should not have naming conflicts with Args
        assert!(
            !cmd.get_arguments().any(|x| x.get_id() == group.get_id()),
            "Command {}: Argument group name '{}' must not conflict with argument name",
            cmd.get_name(),
            group.get_id(),
        );

        for arg in &group.args {
            // Args listed inside groups should exist
            assert!(
                cmd.get_arguments().any(|x| x.get_id() == arg),
                "Command {}: Argument group '{}' contains non-existent argument '{}'",
                cmd.get_name(),
                group.get_id(),
                arg
            );
        }

        for arg in &group.requires {
            // Args listed inside groups should exist
            assert!(
                cmd.id_exists(arg),
                "Command {}: Argument group '{}' requires non-existent '{}' id",
                cmd.get_name(),
                group.get_id(),
                arg
            );
        }

        for arg in &group.conflicts {
            // Args listed inside groups should exist
            assert!(
                cmd.id_exists(arg),
                "Command {}: Argument group '{}' conflicts with non-existent '{}' id",
                cmd.get_name(),
                group.get_id(),
                arg
            );
        }
    }

    // Conflicts between flags and subcommands

    long_flags.sort_unstable();
    short_flags.sort_unstable();

    detect_duplicate_flags(&long_flags, "long");
    detect_duplicate_flags(&short_flags, "short");

    let mut subs = FlatSet::new();
    for sc in cmd.get_subcommands() {
        assert!(
            subs.insert(sc.get_name()),
            "Command {}: command name `{}` is duplicated",
            cmd.get_name(),
            sc.get_name()
        );
        for alias in sc.get_all_aliases() {
            assert!(
                subs.insert(alias),
                "Command {}: command `{}` alias `{}` is duplicated",
                cmd.get_name(),
                sc.get_name(),
                alias
            );
        }
    }

    _verify_positionals(cmd);

    #[cfg(feature = "help")]
    if let Some(help_template) = cmd.get_help_template() {
        assert!(
            !help_template.to_string().contains("{flags}"),
            "Command {}: {}",
                    cmd.get_name(),
            "`{flags}` template variable was removed in clap3, they are now included in `{options}`",
        );
        assert!(
            !help_template.to_string().contains("{unified}"),
            "Command {}: {}",
            cmd.get_name(),
            "`{unified}` template variable was removed in clap3, use `{options}` instead"
        );
        #[cfg(feature = "unstable-v5")]
        assert!(
            !help_template.to_string().contains("{bin}"),
            "Command {}: {}",
            cmd.get_name(),
            "`{bin}` template variable was removed in clap5, use `{name}` instead"
        );
    }

    cmd._panic_on_missing_help(cmd.is_help_expected_set());
    assert_app_flags(cmd);
}

fn duplicate_tip(cmd: &Command, first: &Arg, second: &Arg) -> &'static str {
    if !cmd.is_disable_help_flag_set()
        && (first.get_id() == Id::HELP || second.get_id() == Id::HELP)
    {
        " (call `cmd.disable_help_flag(true)` to remove the auto-generated `--help`)"
    } else if !cmd.is_disable_version_flag_set()
        && (first.get_id() == Id::VERSION || second.get_id() == Id::VERSION)
    {
        " (call `cmd.disable_version_flag(true)` to remove the auto-generated `--version`)"
    } else {
        ""
    }
}

#[derive(Eq)]
enum Flag<'a> {
    Command(String, &'a str),
    Arg(String, &'a str),
}

impl PartialEq for Flag<'_> {
    fn eq(&self, other: &Flag<'_>) -> bool {
        self.cmp(other) == Ordering::Equal
    }
}

impl PartialOrd for Flag<'_> {
    fn partial_cmp(&self, other: &Flag<'_>) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Flag<'_> {
    fn cmp(&self, other: &Self) -> Ordering {
        match (self, other) {
            (Flag::Command(s1, _), Flag::Command(s2, _))
            | (Flag::Arg(s1, _), Flag::Arg(s2, _))
            | (Flag::Command(s1, _), Flag::Arg(s2, _))
            | (Flag::Arg(s1, _), Flag::Command(s2, _)) => {
                if s1 == s2 {
                    Ordering::Equal
                } else {
                    s1.cmp(s2)
                }
            }
        }
    }
}

fn detect_duplicate_flags(flags: &[Flag<'_>], short_or_long: &str) {
    for (one, two) in find_duplicates(flags) {
        match (one, two) {
            (Flag::Command(flag, one), Flag::Command(_, another)) if one != another => panic!(
                "the '{flag}' {short_or_long} flag is specified for both '{one}' and '{another}' subcommands"
            ),

            (Flag::Arg(flag, one), Flag::Arg(_, another)) if one != another => panic!(
                "{short_or_long} option names must be unique, but '{flag}' is in use by both '{one}' and '{another}'"
            ),

            (Flag::Arg(flag, arg), Flag::Command(_, sub)) | (Flag::Command(flag, sub), Flag::Arg(_, arg)) => panic!(
                "the '{flag}' {short_or_long} flag for the '{arg}' argument conflicts with the short flag \
                     for '{sub}' subcommand"
            ),

            _ => {}
        }
    }
}

/// Find duplicates in a sorted array.
///
/// The algorithm is simple: the array is sorted, duplicates
/// must be placed next to each other, we can check only adjacent elements.
fn find_duplicates<T: PartialEq>(slice: &[T]) -> impl Iterator<Item = (&T, &T)> {
    slice.windows(2).filter_map(|w| {
        if w[0] == w[1] {
            Some((&w[0], &w[1]))
        } else {
            None
        }
    })
}

fn assert_app_flags(cmd: &Command) {
    macro_rules! checker {
        ($a:ident conflicts $($b:ident)|+) => {
            if cmd.$a() {
                let mut s = String::new();

                $(
                    if cmd.$b() {
                        use std::fmt::Write;
                        write!(&mut s, "  AppSettings::{} conflicts with AppSettings::{}.\n", std::stringify!($b), std::stringify!($a)).unwrap();
                    }
                )+

                if !s.is_empty() {
                    panic!("{}\n{}", cmd.get_name(), s)
                }
            }
        };
    }

    checker!(is_multicall_set conflicts is_no_binary_name_set);
}

#[cfg(debug_assertions)]
fn _verify_positionals(cmd: &Command) -> bool {
    debug!("Command::_verify_positionals");
    // Because you must wait until all arguments have been supplied, this is the first chance
    // to make assertions on positional argument indexes
    //
    // First we verify that the index highest supplied index, is equal to the number of
    // positional arguments to verify there are no gaps (i.e. supplying an index of 1 and 3
    // but no 2)

    let highest_idx = cmd
        .get_keymap()
        .keys()
        .filter_map(|x| {
            if let KeyType::Position(n) = x {
                Some(*n)
            } else {
                None
            }
        })
        .max()
        .unwrap_or(0);

    let num_p = cmd.get_keymap().keys().filter(|x| x.is_position()).count();

    assert!(
        highest_idx == num_p,
        "Found positional argument whose index is {highest_idx} but there \
             are only {num_p} positional arguments defined",
    );

    for arg in cmd.get_arguments() {
        if arg.index.unwrap_or(0) == highest_idx {
            assert!(
                !arg.is_trailing_var_arg_set() || !arg.is_last_set(),
                "{}:{}: `Arg::trailing_var_arg` and `Arg::last` cannot be used together",
                cmd.get_name(),
                arg.get_id()
            );

            if arg.is_trailing_var_arg_set() {
                assert!(
                    arg.is_multiple(),
                    "{}:{}: `Arg::trailing_var_arg` must accept multiple values",
                    cmd.get_name(),
                    arg.get_id()
                );
            }
        } else {
            assert!(
                !arg.is_trailing_var_arg_set(),
                "{}:{}: `Arg::trailing_var_arg` can only apply to last positional",
                cmd.get_name(),
                arg.get_id()
            );
        }
    }

    // Next we verify that only the highest index has takes multiple arguments (if any)
    let only_highest = |a: &Arg| a.is_multiple() && (a.get_index().unwrap_or(0) != highest_idx);
    if cmd.get_positionals().any(only_highest) {
        // First we make sure if there is a positional that allows multiple values
        // the one before it (second to last) has one of these:
        //  * a value terminator
        //  * ArgSettings::Last
        //  * The last arg is Required

        // We can't pass the closure (it.next()) to the macro directly because each call to
        // find() (iterator, not macro) gets called repeatedly.
        let last = &cmd.get_keymap()[&KeyType::Position(highest_idx)];
        let second_to_last = &cmd.get_keymap()[&KeyType::Position(highest_idx - 1)];

        // Either the final positional is required
        // Or the second to last has a terminator or .last(true) set
        let ok = last.is_required_set()
            || (second_to_last.terminator.is_some() || second_to_last.is_last_set())
            || last.is_last_set();
        assert!(
            ok,
            "Positional argument `{last}` *must* have `required(true)` or `last(true)` set \
            because a prior positional argument (`{second_to_last}`) has `num_args(1..)`"
        );

        // We make sure if the second to last is Multiple the last is ArgSettings::Last
        let ok = second_to_last.is_multiple() || last.is_last_set();
        assert!(
            ok,
            "Only the last positional argument, or second to last positional \
                 argument may be set to `.num_args(1..)`"
        );

        // Next we check how many have both Multiple and not a specific number of values set
        let count = cmd
            .get_positionals()
            .filter(|p| {
                p.is_multiple_values_set()
                    && p.get_value_terminator().is_none()
                    && !p.get_num_args().expect(INTERNAL_ERROR_MSG).is_fixed()
            })
            .count();
        let ok = count <= 1
            || (last.is_last_set()
                && last.is_multiple()
                && second_to_last.is_multiple()
                && count == 2);
        assert!(
            ok,
            "Only one positional argument with `.num_args(1..)` set is allowed per \
                 command, unless the second one also has .last(true) set"
        );
    }

    let mut found = false;

    if cmd.is_allow_missing_positional_set() {
        // Check that if a required positional argument is found, all positions with a lower
        // index are also required.
        let mut foundx2 = false;

        for p in cmd.get_positionals() {
            if foundx2 && !p.is_required_set() {
                assert!(
                    p.is_required_set(),
                    "Found non-required positional argument with a lower \
                         index than a required positional argument by two or more: {:?} \
                         index {:?}",
                    p.get_id(),
                    p.get_index()
                );
            } else if p.is_required_set() && !p.is_last_set() {
                // Args that .last(true) don't count since they can be required and have
                // positionals with a lower index that aren't required
                // Imagine: prog <req1> [opt1] -- <req2>
                // Both of these are valid invocations:
                //      $ prog r1 -- r2
                //      $ prog r1 o1 -- r2
                if found {
                    foundx2 = true;
                    continue;
                }
                found = true;
            } else {
                found = false;
            }
        }
    } else {
        // Check that if a required positional argument is found, all positions with a lower
        // index are also required
        for p in (1..=num_p).rev().filter_map(|n| cmd.get_keymap().get(&n)) {
            if found {
                assert!(
                    p.is_required_set(),
                    "Found non-required positional argument with a lower \
                         index than a required positional argument: {:?} index {:?}",
                    p.get_id(),
                    p.get_index()
                );
            } else if p.is_required_set() && !p.is_last_set() {
                // Args that .last(true) don't count since they can be required and have
                // positionals with a lower index that aren't required
                // Imagine: prog <req1> [opt1] -- <req2>
                // Both of these are valid invocations:
                //      $ prog r1 -- r2
                //      $ prog r1 o1 -- r2
                found = true;
            }
        }
    }
    assert!(
        cmd.get_positionals().filter(|p| p.is_last_set()).count() < 2,
        "Only one positional argument may have last(true) set. Found two."
    );
    if cmd
        .get_positionals()
        .any(|p| p.is_last_set() && p.is_required_set())
        && cmd.has_subcommands()
        && !cmd.is_subcommand_negates_reqs_set()
    {
        panic!(
            "Having a required positional argument with .last(true) set *and* child \
                 subcommands without setting SubcommandsNegateReqs isn't compatible."
        );
    }

    true
}

fn assert_arg(arg: &Arg) {
    debug!("Arg::_debug_asserts:{}", arg.get_id());

    // Self conflict
    // TODO: this check should be recursive
    assert!(
        !arg.blacklist.iter().any(|x| x == arg.get_id()),
        "Argument '{}' cannot conflict with itself",
        arg.get_id(),
    );

    assert!(
        arg.get_num_args().unwrap_or(1.into()).max_values()
            <= arg.get_action().max_num_args().max_values(),
        "Argument `{}`'s action {:?} is incompatible with `num_args({:?})`",
        arg.get_id(),
        arg.get_action(),
        arg.get_num_args().unwrap_or(1.into())
    );
    if let Some(action_type_id) = arg.get_action().value_type_id() {
        assert_eq!(
            action_type_id,
            arg.get_value_parser().type_id(),
            "Argument `{}`'s selected action {:?} contradicts `value_parser` ({:?})",
            arg.get_id(),
            arg.get_action(),
            arg.get_value_parser()
        );
    }

    if arg.get_value_hint() != ValueHint::Unknown {
        assert!(
            arg.is_takes_value_set(),
            "Argument '{}' has value hint but takes no value",
            arg.get_id()
        );

        if arg.get_value_hint() == ValueHint::CommandWithArguments {
            assert!(
                arg.is_multiple_values_set(),
                "Argument '{}' uses hint CommandWithArguments and must accept multiple values",
                arg.get_id()
            );
        }
    }

    if arg.index.is_some() {
        assert!(
            arg.is_positional(),
            "Argument '{}' is a positional argument and can't have short or long name versions",
            arg.get_id()
        );
        assert!(
            arg.is_takes_value_set(),
            "Argument '{}' is positional and it must take a value but action is {:?}{}",
            arg.get_id(),
            arg.get_action(),
            if arg.get_id() == Id::HELP {
                " (`mut_arg` no longer works with implicit `--help`)"
            } else if arg.get_id() == Id::VERSION {
                " (`mut_arg` no longer works with implicit `--version`)"
            } else {
                ""
            }
        );
    }

    let num_vals = arg.get_num_args().expect(INTERNAL_ERROR_MSG);
    // This can be the cause of later asserts, so put this first
    if num_vals != ValueRange::EMPTY {
        // HACK: Don't check for flags to make the derive easier
        let num_val_names = arg.get_value_names().unwrap_or(&[]).len();
        if num_vals.max_values() < num_val_names {
            panic!(
                "Argument {}: Too many value names ({}) compared to `num_args` ({})",
                arg.get_id(),
                num_val_names,
                num_vals
            );
        }
    }

    assert_eq!(
        num_vals.is_multiple(),
        arg.is_multiple_values_set(),
        "Argument {}: mismatch between `num_args` ({}) and `multiple_values`",
        arg.get_id(),
        num_vals,
    );

    if 1 < num_vals.min_values() {
        assert!(
            !arg.is_require_equals_set(),
            "Argument {}: cannot accept more than 1 arg (num_args={}) with require_equals",
            arg.get_id(),
            num_vals
        );
    }

    if num_vals == ValueRange::SINGLE {
        assert!(
            !arg.is_multiple_values_set(),
            "Argument {}: mismatch between `num_args` and `multiple_values`",
            arg.get_id()
        );
    }

    assert_arg_flags(arg);
}

fn assert_arg_flags(arg: &Arg) {
    macro_rules! checker {
        ($a:ident requires $($b:ident)|+) => {
            if arg.$a() {
                let mut s = String::new();

                $(
                    if !arg.$b() {
                        use std::fmt::Write;
                        write!(&mut s, "  Arg::{} is required when Arg::{} is set.\n", std::stringify!($b), std::stringify!($a)).unwrap();
                    }
                )+

                if !s.is_empty() {
                    panic!("Argument {:?}\n{}", arg.get_id(), s)
                }
            }
        }
    }

    checker!(is_hide_possible_values_set requires is_takes_value_set);
    checker!(is_allow_hyphen_values_set requires is_takes_value_set);
    checker!(is_allow_negative_numbers_set requires is_takes_value_set);
    checker!(is_require_equals_set requires is_takes_value_set);
    checker!(is_last_set requires is_takes_value_set);
    checker!(is_hide_default_value_set requires is_takes_value_set);
    checker!(is_multiple_values_set requires is_takes_value_set);
    checker!(is_ignore_case_set requires is_takes_value_set);
}

```

`clap/clap_builder/src/builder/ext.rs`:

```rs
use crate::util::AnyValue;
use crate::util::AnyValueId;
use crate::util::FlatMap;

#[derive(Default, Clone, Debug)]
pub(crate) struct Extensions {
    extensions: FlatMap<AnyValueId, AnyValue>,
}

impl Extensions {
    #[allow(dead_code)]
    pub(crate) fn get<T: Extension>(&self) -> Option<&T> {
        let id = AnyValueId::of::<T>();
        self.extensions.get(&id).map(|e| {
            e.downcast_ref::<T>()
                .expect("`Extensions` tracks values by type")
        })
    }

    #[allow(dead_code)]
    pub(crate) fn set<T: Extension>(&mut self, tagged: T) -> bool {
        let value = AnyValue::new(tagged);
        let id = value.type_id();
        self.extensions.insert(id, value).is_some()
    }

    #[allow(dead_code)]
    pub(crate) fn remove<T: Extension>(&mut self) -> Option<T> {
        let id = AnyValueId::of::<T>();
        self.extensions.remove(&id).map(|e| {
            e.downcast_into::<T>()
                .expect("`Extensions` tracks values by type")
        })
    }

    pub(crate) fn update(&mut self, other: &Self) {
        for (key, value) in other.extensions.iter() {
            self.extensions.insert(*key, value.clone());
        }
    }
}

#[allow(unreachable_pub)]
pub trait Extension: std::fmt::Debug + Clone + std::any::Any + Send + Sync + 'static {}

impl<T> Extension for T where T: std::fmt::Debug + Clone + std::any::Any + Send + Sync + 'static {}

```

`clap/clap_builder/src/builder/mod.rs`:

```rs
//! Define [`Command`] line [arguments][`Arg`]

mod action;
mod app_settings;
mod arg;
mod arg_group;
mod arg_predicate;
mod arg_settings;
mod command;
mod ext;
mod os_str;
mod possible_value;
mod range;
mod resettable;
mod str;
mod styled_str;
mod value_hint;
mod value_parser;

#[cfg(debug_assertions)]
mod debug_asserts;

#[cfg(test)]
mod tests;

pub mod styling;

pub use self::str::Str;
pub use action::ArgAction;
pub use arg::Arg;
#[cfg(feature = "unstable-ext")]
pub use arg::ArgExt;
pub use arg_group::ArgGroup;
pub use arg_predicate::ArgPredicate;
pub use command::Command;
#[cfg(feature = "unstable-ext")]
pub use command::CommandExt;
pub use os_str::OsStr;
pub use possible_value::PossibleValue;
pub use range::ValueRange;
pub use resettable::IntoResettable;
pub use resettable::Resettable;
pub use styled_str::StyledStr;
pub use styling::Styles;
pub use value_hint::ValueHint;
pub use value_parser::BoolValueParser;
pub use value_parser::_infer_ValueParser_for;
pub use value_parser::impl_prelude;
pub use value_parser::BoolishValueParser;
pub use value_parser::EnumValueParser;
pub use value_parser::FalseyValueParser;
pub use value_parser::MapValueParser;
pub use value_parser::NonEmptyStringValueParser;
pub use value_parser::OsStringValueParser;
pub use value_parser::PathBufValueParser;
pub use value_parser::PossibleValuesParser;
pub use value_parser::RangedI64ValueParser;
pub use value_parser::RangedU64ValueParser;
pub use value_parser::StringValueParser;
pub use value_parser::TryMapValueParser;
pub use value_parser::TypedValueParser;
pub use value_parser::UnknownArgumentValueParser;
pub use value_parser::ValueParser;
pub use value_parser::ValueParserFactory;
pub use value_parser::_AnonymousValueParser;

#[allow(unused_imports)]
pub(crate) use self::str::Inner as StrInner;
pub(crate) use action::CountType;
pub(crate) use arg_settings::{ArgFlags, ArgSettings};
pub(crate) use command::AppExt;

```

`clap/clap_builder/src/builder/os_str.rs`:

```rs
use crate::builder::Str;

/// A UTF-8-encoded fixed string
///
/// <div class="warning">
///
/// **NOTE:** To support dynamic values (i.e. `OsString`), enable the `string`
/// feature
///
/// </div>
#[derive(Default, Clone, Eq, PartialEq, PartialOrd, Ord, Hash)]
pub struct OsStr {
    name: Inner,
}

impl OsStr {
    #[cfg(feature = "string")]
    pub(crate) fn from_string(name: std::ffi::OsString) -> Self {
        Self {
            name: Inner::from_string(name),
        }
    }

    #[cfg(feature = "string")]
    pub(crate) fn from_ref(name: &std::ffi::OsStr) -> Self {
        Self {
            name: Inner::from_ref(name),
        }
    }

    pub(crate) fn from_static_ref(name: &'static std::ffi::OsStr) -> Self {
        Self {
            name: Inner::from_static_ref(name),
        }
    }

    /// Get the raw string as an `std::ffi::OsStr`
    pub fn as_os_str(&self) -> &std::ffi::OsStr {
        self.name.as_os_str()
    }

    /// Get the raw string as an `OsString`
    pub fn to_os_string(&self) -> std::ffi::OsString {
        self.as_os_str().to_owned()
    }
}

impl From<&'_ OsStr> for OsStr {
    fn from(id: &'_ OsStr) -> Self {
        id.clone()
    }
}

#[cfg(feature = "string")]
impl From<Str> for OsStr {
    fn from(id: Str) -> Self {
        match id.into_inner() {
            crate::builder::StrInner::Static(s) => Self::from_static_ref(std::ffi::OsStr::new(s)),
            crate::builder::StrInner::Owned(s) => Self::from_ref(std::ffi::OsStr::new(s.as_ref())),
        }
    }
}

#[cfg(not(feature = "string"))]
impl From<Str> for OsStr {
    fn from(id: Str) -> Self {
        Self::from_static_ref(std::ffi::OsStr::new(id.into_inner().0))
    }
}

impl From<&'_ Str> for OsStr {
    fn from(id: &'_ Str) -> Self {
        id.clone().into()
    }
}

#[cfg(feature = "string")]
impl From<std::ffi::OsString> for OsStr {
    fn from(name: std::ffi::OsString) -> Self {
        Self::from_string(name)
    }
}

#[cfg(feature = "string")]
impl From<&'_ std::ffi::OsString> for OsStr {
    fn from(name: &'_ std::ffi::OsString) -> Self {
        Self::from_ref(name.as_os_str())
    }
}

#[cfg(feature = "string")]
impl From<String> for OsStr {
    fn from(name: String) -> Self {
        Self::from_string(name.into())
    }
}

#[cfg(feature = "string")]
impl From<&'_ String> for OsStr {
    fn from(name: &'_ String) -> Self {
        Self::from_ref(name.as_str().as_ref())
    }
}

impl From<&'static std::ffi::OsStr> for OsStr {
    fn from(name: &'static std::ffi::OsStr) -> Self {
        Self::from_static_ref(name)
    }
}

impl From<&'_ &'static std::ffi::OsStr> for OsStr {
    fn from(name: &'_ &'static std::ffi::OsStr) -> Self {
        Self::from_static_ref(name)
    }
}

impl From<&'static str> for OsStr {
    fn from(name: &'static str) -> Self {
        Self::from_static_ref(name.as_ref())
    }
}

impl From<&'_ &'static str> for OsStr {
    fn from(name: &'_ &'static str) -> Self {
        Self::from_static_ref((*name).as_ref())
    }
}

impl From<OsStr> for std::ffi::OsString {
    fn from(name: OsStr) -> Self {
        name.name.into_os_string()
    }
}

impl From<OsStr> for std::path::PathBuf {
    fn from(name: OsStr) -> Self {
        std::ffi::OsString::from(name).into()
    }
}

impl std::fmt::Debug for OsStr {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Debug::fmt(self.as_os_str(), f)
    }
}

impl std::ops::Deref for OsStr {
    type Target = std::ffi::OsStr;

    #[inline]
    fn deref(&self) -> &std::ffi::OsStr {
        self.as_os_str()
    }
}

impl AsRef<std::ffi::OsStr> for OsStr {
    #[inline]
    fn as_ref(&self) -> &std::ffi::OsStr {
        self.as_os_str()
    }
}

impl AsRef<std::path::Path> for OsStr {
    #[inline]
    fn as_ref(&self) -> &std::path::Path {
        std::path::Path::new(self)
    }
}

impl std::borrow::Borrow<std::ffi::OsStr> for OsStr {
    #[inline]
    fn borrow(&self) -> &std::ffi::OsStr {
        self.as_os_str()
    }
}

impl PartialEq<str> for OsStr {
    #[inline]
    fn eq(&self, other: &str) -> bool {
        PartialEq::eq(self.as_os_str(), other)
    }
}
impl PartialEq<OsStr> for str {
    #[inline]
    fn eq(&self, other: &OsStr) -> bool {
        PartialEq::eq(self, other.as_os_str())
    }
}

impl PartialEq<&'_ str> for OsStr {
    #[inline]
    fn eq(&self, other: &&str) -> bool {
        PartialEq::eq(self.as_os_str(), *other)
    }
}
impl PartialEq<OsStr> for &'_ str {
    #[inline]
    fn eq(&self, other: &OsStr) -> bool {
        PartialEq::eq(*self, other.as_os_str())
    }
}

impl PartialEq<&'_ std::ffi::OsStr> for OsStr {
    #[inline]
    fn eq(&self, other: &&std::ffi::OsStr) -> bool {
        PartialEq::eq(self.as_os_str(), *other)
    }
}
impl PartialEq<OsStr> for &'_ std::ffi::OsStr {
    #[inline]
    fn eq(&self, other: &OsStr) -> bool {
        PartialEq::eq(*self, other.as_os_str())
    }
}

impl PartialEq<String> for OsStr {
    #[inline]
    fn eq(&self, other: &String) -> bool {
        PartialEq::eq(self.as_os_str(), other.as_str())
    }
}
impl PartialEq<OsStr> for String {
    #[inline]
    fn eq(&self, other: &OsStr) -> bool {
        PartialEq::eq(self.as_str(), other.as_os_str())
    }
}

impl PartialEq<std::ffi::OsString> for OsStr {
    #[inline]
    fn eq(&self, other: &std::ffi::OsString) -> bool {
        PartialEq::eq(self.as_os_str(), other.as_os_str())
    }
}
impl PartialEq<OsStr> for std::ffi::OsString {
    #[inline]
    fn eq(&self, other: &OsStr) -> bool {
        PartialEq::eq(self.as_os_str(), other.as_os_str())
    }
}

#[cfg(feature = "string")]
pub(crate) mod inner {
    #[derive(Clone)]
    pub(crate) enum Inner {
        Static(&'static std::ffi::OsStr),
        Owned(Box<std::ffi::OsStr>),
    }

    impl Inner {
        pub(crate) fn from_string(name: std::ffi::OsString) -> Self {
            Self::Owned(name.into_boxed_os_str())
        }

        pub(crate) fn from_ref(name: &std::ffi::OsStr) -> Self {
            Self::Owned(Box::from(name))
        }

        pub(crate) fn from_static_ref(name: &'static std::ffi::OsStr) -> Self {
            Self::Static(name)
        }

        pub(crate) fn as_os_str(&self) -> &std::ffi::OsStr {
            match self {
                Self::Static(s) => s,
                Self::Owned(s) => s.as_ref(),
            }
        }

        pub(crate) fn into_os_string(self) -> std::ffi::OsString {
            self.as_os_str().to_owned()
        }
    }
}

#[cfg(not(feature = "string"))]
pub(crate) mod inner {
    #[derive(Clone)]
    pub(crate) struct Inner(&'static std::ffi::OsStr);

    impl Inner {
        pub(crate) fn from_static_ref(name: &'static std::ffi::OsStr) -> Self {
            Self(name)
        }

        pub(crate) fn as_os_str(&self) -> &std::ffi::OsStr {
            self.0
        }

        pub(crate) fn into_os_string(self) -> std::ffi::OsString {
            self.as_os_str().to_owned()
        }
    }
}

pub(crate) use inner::Inner;

impl Default for Inner {
    fn default() -> Self {
        Self::from_static_ref(std::ffi::OsStr::new(""))
    }
}

impl PartialEq for Inner {
    fn eq(&self, other: &Inner) -> bool {
        self.as_os_str() == other.as_os_str()
    }
}

impl PartialOrd for Inner {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Inner {
    fn cmp(&self, other: &Inner) -> std::cmp::Ordering {
        self.as_os_str().cmp(other.as_os_str())
    }
}

impl Eq for Inner {}

impl std::hash::Hash for Inner {
    #[inline]
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.as_os_str().hash(state);
    }
}

```

`clap/clap_builder/src/builder/possible_value.rs`:

```rs
use crate::builder::IntoResettable;
use crate::builder::Str;
use crate::builder::StyledStr;
use crate::util::eq_ignore_case;

/// A possible value of an argument.
///
/// This is used for specifying [possible values] of [Args].
///
/// See also [`PossibleValuesParser`][crate::builder::PossibleValuesParser]
///
/// <div class="warning">
///
/// **NOTE:** Most likely you can use strings, rather than `PossibleValue` as it is only required
/// to [hide] single values from help messages and shell completions or to attach [help] to
/// possible values.
///
/// </div>
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::{Arg, builder::PossibleValue, ArgAction};
/// let cfg = Arg::new("config")
///     .action(ArgAction::Set)
///     .value_name("FILE")
///     .value_parser([
///         PossibleValue::new("fast"),
///         PossibleValue::new("slow").help("slower than fast"),
///         PossibleValue::new("secret speed").hide(true)
///     ]);
/// ```
///
/// [Args]: crate::Arg
/// [possible values]: crate::builder::ValueParser::possible_values
/// [hide]: PossibleValue::hide()
/// [help]: PossibleValue::help()
#[derive(Debug, Default, Clone, PartialEq, Eq)]
pub struct PossibleValue {
    name: Str,
    help: Option<StyledStr>,
    aliases: Vec<Str>, // (name, visible)
    hide: bool,
}

impl PossibleValue {
    /// Create a [`PossibleValue`] with its name.
    ///
    /// The name will be used to decide whether this value was provided by the user to an argument.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** In case it is not [hidden] it will also be shown in help messages for arguments
    /// that use it as a [possible value] and have not hidden them through [`Arg::hide_possible_values(true)`].
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::builder::PossibleValue;
    /// PossibleValue::new("fast")
    /// # ;
    /// ```
    /// [hidden]: PossibleValue::hide
    /// [possible value]: crate::builder::PossibleValuesParser
    /// [`Arg::hide_possible_values(true)`]: crate::Arg::hide_possible_values()
    pub fn new(name: impl Into<Str>) -> Self {
        PossibleValue {
            name: name.into(),
            ..Default::default()
        }
    }

    /// Sets the help description of the value.
    ///
    /// This is typically displayed in completions (where supported) and should be a short, one-line
    /// description.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::builder::PossibleValue;
    /// PossibleValue::new("slow")
    ///     .help("not fast")
    /// # ;
    /// ```
    #[inline]
    #[must_use]
    pub fn help(mut self, help: impl IntoResettable<StyledStr>) -> Self {
        self.help = help.into_resettable().into_option();
        self
    }

    /// Hides this value from help and shell completions.
    ///
    /// This is an alternative to hiding through [`Arg::hide_possible_values(true)`], if you only
    /// want to hide some values.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::builder::PossibleValue;
    /// PossibleValue::new("secret")
    ///     .hide(true)
    /// # ;
    /// ```
    /// [`Arg::hide_possible_values(true)`]: crate::Arg::hide_possible_values()
    #[inline]
    #[must_use]
    pub fn hide(mut self, yes: bool) -> Self {
        self.hide = yes;
        self
    }

    /// Sets a *hidden* alias for this argument value.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::builder::PossibleValue;
    /// PossibleValue::new("slow")
    ///     .alias("not-fast")
    /// # ;
    /// ```
    #[must_use]
    pub fn alias(mut self, name: impl IntoResettable<Str>) -> Self {
        if let Some(name) = name.into_resettable().into_option() {
            self.aliases.push(name);
        } else {
            self.aliases.clear();
        }
        self
    }

    /// Sets multiple *hidden* aliases for this argument value.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::builder::PossibleValue;
    /// PossibleValue::new("slow")
    ///     .aliases(["not-fast", "snake-like"])
    /// # ;
    /// ```
    #[must_use]
    pub fn aliases(mut self, names: impl IntoIterator<Item = impl Into<Str>>) -> Self {
        self.aliases.extend(names.into_iter().map(|a| a.into()));
        self
    }
}

/// Reflection
impl PossibleValue {
    /// Get the name of the argument value
    #[inline]
    pub fn get_name(&self) -> &str {
        self.name.as_str()
    }

    /// Get the help specified for this argument, if any
    #[inline]
    pub fn get_help(&self) -> Option<&StyledStr> {
        self.help.as_ref()
    }

    /// Report if [`PossibleValue::hide`] is set
    #[inline]
    pub fn is_hide_set(&self) -> bool {
        self.hide
    }

    /// Report if `PossibleValue` is not hidden and has a help message
    pub(crate) fn should_show_help(&self) -> bool {
        !self.hide && self.help.is_some()
    }

    /// Get the name if argument value is not hidden, `None` otherwise,
    /// but wrapped in quotes if it contains whitespace
    #[cfg(feature = "help")]
    pub(crate) fn get_visible_quoted_name(&self) -> Option<std::borrow::Cow<'_, str>> {
        if !self.hide {
            Some(if self.name.contains(char::is_whitespace) {
                format!("{:?}", self.name).into()
            } else {
                self.name.as_str().into()
            })
        } else {
            None
        }
    }

    /// Returns all valid values of the argument value.
    ///
    /// Namely the name and all aliases.
    pub fn get_name_and_aliases(&self) -> impl Iterator<Item = &str> + '_ {
        std::iter::once(self.get_name()).chain(self.aliases.iter().map(|s| s.as_str()))
    }

    /// Tests if the value is valid for this argument value
    ///
    /// The value is valid if it is either the name or one of the aliases.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::builder::PossibleValue;
    /// let arg_value = PossibleValue::new("fast").alias("not-slow");
    ///
    /// assert!(arg_value.matches("fast", false));
    /// assert!(arg_value.matches("not-slow", false));
    ///
    /// assert!(arg_value.matches("FAST", true));
    /// assert!(!arg_value.matches("FAST", false));
    /// ```
    pub fn matches(&self, value: &str, ignore_case: bool) -> bool {
        if ignore_case {
            self.get_name_and_aliases()
                .any(|name| eq_ignore_case(name, value))
        } else {
            self.get_name_and_aliases().any(|name| name == value)
        }
    }
}

impl<S: Into<Str>> From<S> for PossibleValue {
    fn from(s: S) -> Self {
        Self::new(s)
    }
}

```

`clap/clap_builder/src/builder/range.rs`:

```rs
/// Values per occurrence for an argument
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct ValueRange {
    start_inclusive: usize,
    end_inclusive: usize,
}

impl ValueRange {
    /// Nor argument values, or a flag
    pub const EMPTY: Self = Self {
        start_inclusive: 0,
        end_inclusive: 0,
    };

    /// A single argument value, the most common case for options
    pub const SINGLE: Self = Self {
        start_inclusive: 1,
        end_inclusive: 1,
    };

    #[cfg(debug_assertions)]
    pub(crate) const OPTIONAL: Self = Self {
        start_inclusive: 0,
        end_inclusive: 1,
    };

    pub(crate) const FULL: Self = Self {
        start_inclusive: 0,
        end_inclusive: usize::MAX,
    };

    /// Create a range
    ///
    /// # Panics
    ///
    /// If the end is less than the start (debug builds)
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::builder::ValueRange;
    /// let range = ValueRange::new(5);
    /// let range = ValueRange::new(5..10);
    /// let range = ValueRange::new(5..=10);
    /// let range = ValueRange::new(5..);
    /// let range = ValueRange::new(..10);
    /// let range = ValueRange::new(..=10);
    /// ```
    ///
    /// While this will panic:
    /// ```should_panic
    /// # use clap_builder as clap;
    /// # use clap::builder::ValueRange;
    /// let range = ValueRange::new(10..5);  // Panics!
    /// ```
    pub fn new(range: impl Into<Self>) -> Self {
        range.into()
    }

    pub(crate) fn raw(start_inclusive: usize, end_inclusive: usize) -> Self {
        debug_assert!(start_inclusive <= end_inclusive);
        Self {
            start_inclusive,
            end_inclusive,
        }
    }

    /// Fewest number of values the argument accepts
    pub fn min_values(&self) -> usize {
        self.start_inclusive
    }

    /// Most number of values the argument accepts
    pub fn max_values(&self) -> usize {
        self.end_inclusive
    }

    /// Report whether the argument takes any values (ie is a flag)
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::builder::ValueRange;
    /// let range = ValueRange::new(5);
    /// assert!(range.takes_values());
    ///
    /// let range = ValueRange::new(0);
    /// assert!(!range.takes_values());
    /// ```
    pub fn takes_values(&self) -> bool {
        self.end_inclusive != 0
    }

    pub(crate) fn is_unbounded(&self) -> bool {
        self.end_inclusive == usize::MAX
    }

    pub(crate) fn is_fixed(&self) -> bool {
        self.start_inclusive == self.end_inclusive
    }

    pub(crate) fn is_multiple(&self) -> bool {
        self.start_inclusive != self.end_inclusive || 1 < self.start_inclusive
    }

    pub(crate) fn num_values(&self) -> Option<usize> {
        self.is_fixed().then_some(self.start_inclusive)
    }

    pub(crate) fn accepts_more(&self, current: usize) -> bool {
        current < self.end_inclusive
    }
}

impl std::ops::RangeBounds<usize> for ValueRange {
    fn start_bound(&self) -> std::ops::Bound<&usize> {
        std::ops::Bound::Included(&self.start_inclusive)
    }

    fn end_bound(&self) -> std::ops::Bound<&usize> {
        std::ops::Bound::Included(&self.end_inclusive)
    }
}

impl Default for ValueRange {
    fn default() -> Self {
        Self::SINGLE
    }
}

impl From<usize> for ValueRange {
    fn from(fixed: usize) -> Self {
        (fixed..=fixed).into()
    }
}

impl From<std::ops::Range<usize>> for ValueRange {
    fn from(range: std::ops::Range<usize>) -> Self {
        let start_inclusive = range.start;
        let end_inclusive = range.end.saturating_sub(1);
        Self::raw(start_inclusive, end_inclusive)
    }
}

impl From<std::ops::RangeFull> for ValueRange {
    fn from(_: std::ops::RangeFull) -> Self {
        Self::FULL
    }
}

impl From<std::ops::RangeFrom<usize>> for ValueRange {
    fn from(range: std::ops::RangeFrom<usize>) -> Self {
        let start_inclusive = range.start;
        let end_inclusive = usize::MAX;
        Self::raw(start_inclusive, end_inclusive)
    }
}

impl From<std::ops::RangeTo<usize>> for ValueRange {
    fn from(range: std::ops::RangeTo<usize>) -> Self {
        let start_inclusive = 0;
        let end_inclusive = range.end.saturating_sub(1);
        Self::raw(start_inclusive, end_inclusive)
    }
}

impl From<std::ops::RangeInclusive<usize>> for ValueRange {
    fn from(range: std::ops::RangeInclusive<usize>) -> Self {
        let start_inclusive = *range.start();
        let end_inclusive = *range.end();
        Self::raw(start_inclusive, end_inclusive)
    }
}

impl From<std::ops::RangeToInclusive<usize>> for ValueRange {
    fn from(range: std::ops::RangeToInclusive<usize>) -> Self {
        let start_inclusive = 0;
        let end_inclusive = range.end;
        Self::raw(start_inclusive, end_inclusive)
    }
}

impl std::fmt::Display for ValueRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ok!(self.start_inclusive.fmt(f));
        if self.is_fixed() {
        } else if self.end_inclusive == usize::MAX {
            ok!("..".fmt(f));
        } else {
            ok!("..=".fmt(f));
            ok!(self.end_inclusive.fmt(f));
        }
        Ok(())
    }
}

impl std::fmt::Debug for ValueRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self}")
    }
}

#[cfg(test)]
mod test {
    use super::*;

    use std::ops::RangeBounds;

    #[test]
    fn from_fixed() {
        let range: ValueRange = 5.into();
        assert_eq!(range.start_bound(), std::ops::Bound::Included(&5));
        assert_eq!(range.end_bound(), std::ops::Bound::Included(&5));
        assert!(range.is_fixed());
        assert!(range.is_multiple());
        assert_eq!(range.num_values(), Some(5));
        assert!(range.takes_values());
    }

    #[test]
    fn from_fixed_empty() {
        let range: ValueRange = 0.into();
        assert_eq!(range.start_bound(), std::ops::Bound::Included(&0));
        assert_eq!(range.end_bound(), std::ops::Bound::Included(&0));
        assert!(range.is_fixed());
        assert!(!range.is_multiple());
        assert_eq!(range.num_values(), Some(0));
        assert!(!range.takes_values());
    }

    #[test]
    fn from_range() {
        let range: ValueRange = (5..10).into();
        assert_eq!(range.start_bound(), std::ops::Bound::Included(&5));
        assert_eq!(range.end_bound(), std::ops::Bound::Included(&9));
        assert!(!range.is_fixed());
        assert!(range.is_multiple());
        assert_eq!(range.num_values(), None);
        assert!(range.takes_values());
    }

    #[test]
    fn from_range_inclusive() {
        let range: ValueRange = (5..=10).into();
        assert_eq!(range.start_bound(), std::ops::Bound::Included(&5));
        assert_eq!(range.end_bound(), std::ops::Bound::Included(&10));
        assert!(!range.is_fixed());
        assert!(range.is_multiple());
        assert_eq!(range.num_values(), None);
        assert!(range.takes_values());
    }

    #[test]
    fn from_range_full() {
        let range: ValueRange = (..).into();
        assert_eq!(range.start_bound(), std::ops::Bound::Included(&0));
        assert_eq!(range.end_bound(), std::ops::Bound::Included(&usize::MAX));
        assert!(!range.is_fixed());
        assert!(range.is_multiple());
        assert_eq!(range.num_values(), None);
        assert!(range.takes_values());
    }

    #[test]
    fn from_range_from() {
        let range: ValueRange = (5..).into();
        assert_eq!(range.start_bound(), std::ops::Bound::Included(&5));
        assert_eq!(range.end_bound(), std::ops::Bound::Included(&usize::MAX));
        assert!(!range.is_fixed());
        assert!(range.is_multiple());
        assert_eq!(range.num_values(), None);
        assert!(range.takes_values());
    }

    #[test]
    fn from_range_to() {
        let range: ValueRange = (..10).into();
        assert_eq!(range.start_bound(), std::ops::Bound::Included(&0));
        assert_eq!(range.end_bound(), std::ops::Bound::Included(&9));
        assert!(!range.is_fixed());
        assert!(range.is_multiple());
        assert_eq!(range.num_values(), None);
        assert!(range.takes_values());
    }

    #[test]
    fn from_range_to_inclusive() {
        let range: ValueRange = (..=10).into();
        assert_eq!(range.start_bound(), std::ops::Bound::Included(&0));
        assert_eq!(range.end_bound(), std::ops::Bound::Included(&10));
        assert!(!range.is_fixed());
        assert!(range.is_multiple());
        assert_eq!(range.num_values(), None);
        assert!(range.takes_values());
    }
}

```

`clap/clap_builder/src/builder/resettable.rs`:

```rs
// Unlike `impl Into<Option<T>>` or `Option<impl Into<T>>`, this isn't ambiguous for the `None`
// case.

use crate::builder::ArgAction;
use crate::builder::OsStr;
use crate::builder::Str;
use crate::builder::StyledStr;
use crate::builder::ValueHint;
use crate::builder::ValueParser;
use crate::builder::ValueRange;

/// Clearable builder value
///
/// This allows a builder function to both accept any value that can [`Into::into`] `T` (like
/// `&str` into `OsStr`) as well as `None` to reset it to the default.  This is needed to
/// workaround a limitation where you can't have a function argument that is `impl Into<Option<T>>`
/// where `T` is `impl Into<S>` accept `None` as its type is ambiguous.
///
/// # Example
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::Command;
/// # use clap::Arg;
/// fn common() -> Command {
///     Command::new("cli")
///         .arg(Arg::new("input").short('i').long("input"))
/// }
/// let mut command = common();
/// command.mut_arg("input", |arg| arg.short(None));
/// ```
#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Resettable<T> {
    /// Overwrite builder value
    Value(T),
    /// Reset builder value
    Reset,
}

impl<T> Resettable<T> {
    pub(crate) fn into_option(self) -> Option<T> {
        match self {
            Self::Value(t) => Some(t),
            Self::Reset => None,
        }
    }
}

impl<T> From<T> for Resettable<T> {
    fn from(other: T) -> Self {
        Self::Value(other)
    }
}

impl<T> From<Option<T>> for Resettable<T> {
    fn from(other: Option<T>) -> Self {
        match other {
            Some(inner) => Self::Value(inner),
            None => Self::Reset,
        }
    }
}

/// Convert to the intended resettable type
pub trait IntoResettable<T> {
    /// Convert to the intended resettable type
    fn into_resettable(self) -> Resettable<T>;
}

impl IntoResettable<char> for Option<char> {
    fn into_resettable(self) -> Resettable<char> {
        match self {
            Some(s) => Resettable::Value(s),
            None => Resettable::Reset,
        }
    }
}

impl IntoResettable<usize> for Option<usize> {
    fn into_resettable(self) -> Resettable<usize> {
        match self {
            Some(s) => Resettable::Value(s),
            None => Resettable::Reset,
        }
    }
}

impl IntoResettable<ArgAction> for Option<ArgAction> {
    fn into_resettable(self) -> Resettable<ArgAction> {
        match self {
            Some(s) => Resettable::Value(s),
            None => Resettable::Reset,
        }
    }
}

impl IntoResettable<ValueHint> for Option<ValueHint> {
    fn into_resettable(self) -> Resettable<ValueHint> {
        match self {
            Some(s) => Resettable::Value(s),
            None => Resettable::Reset,
        }
    }
}

impl IntoResettable<ValueParser> for Option<ValueParser> {
    fn into_resettable(self) -> Resettable<ValueParser> {
        match self {
            Some(s) => Resettable::Value(s),
            None => Resettable::Reset,
        }
    }
}

impl IntoResettable<StyledStr> for Option<&'static str> {
    fn into_resettable(self) -> Resettable<StyledStr> {
        match self {
            Some(s) => Resettable::Value(s.into()),
            None => Resettable::Reset,
        }
    }
}

impl IntoResettable<OsStr> for Option<&'static str> {
    fn into_resettable(self) -> Resettable<OsStr> {
        match self {
            Some(s) => Resettable::Value(s.into()),
            None => Resettable::Reset,
        }
    }
}

impl IntoResettable<Str> for Option<&'static str> {
    fn into_resettable(self) -> Resettable<Str> {
        match self {
            Some(s) => Resettable::Value(s.into()),
            None => Resettable::Reset,
        }
    }
}

impl<T> IntoResettable<T> for Resettable<T> {
    fn into_resettable(self) -> Resettable<T> {
        self
    }
}

impl IntoResettable<char> for char {
    fn into_resettable(self) -> Resettable<char> {
        Resettable::Value(self)
    }
}

impl IntoResettable<usize> for usize {
    fn into_resettable(self) -> Resettable<usize> {
        Resettable::Value(self)
    }
}

impl IntoResettable<ArgAction> for ArgAction {
    fn into_resettable(self) -> Resettable<ArgAction> {
        Resettable::Value(self)
    }
}

impl IntoResettable<ValueHint> for ValueHint {
    fn into_resettable(self) -> Resettable<ValueHint> {
        Resettable::Value(self)
    }
}

impl<I: Into<ValueRange>> IntoResettable<ValueRange> for I {
    fn into_resettable(self) -> Resettable<ValueRange> {
        Resettable::Value(self.into())
    }
}

impl<I: Into<ValueParser>> IntoResettable<ValueParser> for I {
    fn into_resettable(self) -> Resettable<ValueParser> {
        Resettable::Value(self.into())
    }
}

impl<I: Into<String>> IntoResettable<String> for I {
    fn into_resettable(self) -> Resettable<String> {
        Resettable::Value(self.into())
    }
}

impl<I: Into<StyledStr>> IntoResettable<StyledStr> for I {
    fn into_resettable(self) -> Resettable<StyledStr> {
        Resettable::Value(self.into())
    }
}

impl<I: Into<OsStr>> IntoResettable<OsStr> for I {
    fn into_resettable(self) -> Resettable<OsStr> {
        Resettable::Value(self.into())
    }
}

impl<I: Into<Str>> IntoResettable<Str> for I {
    fn into_resettable(self) -> Resettable<Str> {
        Resettable::Value(self.into())
    }
}

impl<I: Into<crate::Id>> IntoResettable<crate::Id> for I {
    fn into_resettable(self) -> Resettable<crate::Id> {
        Resettable::Value(self.into())
    }
}

```

`clap/clap_builder/src/builder/str.rs`:

```rs
/// A UTF-8-encoded fixed string
///
/// <div class="warning">
///
/// **NOTE:** To support dynamic values (i.e. `String`), enable the `string`
/// feature
///
/// </div>
#[derive(Default, Clone, Eq, PartialEq, PartialOrd, Ord, Hash)]
pub struct Str {
    name: Inner,
}

impl Str {
    #[cfg(feature = "string")]
    pub(crate) fn from_string(name: String) -> Self {
        Self {
            name: Inner::from_string(name),
        }
    }

    #[cfg(feature = "string")]
    pub(crate) fn from_ref(name: &str) -> Self {
        Self {
            name: Inner::from_ref(name),
        }
    }

    pub(crate) fn from_static_ref(name: &'static str) -> Self {
        Self {
            name: Inner::from_static_ref(name),
        }
    }

    pub(crate) fn into_inner(self) -> Inner {
        self.name
    }

    /// Get the raw string of the `Str`
    pub fn as_str(&self) -> &str {
        self.name.as_str()
    }
}

impl From<&'_ Str> for Str {
    fn from(id: &'_ Str) -> Self {
        id.clone()
    }
}

#[cfg(feature = "string")]
impl From<String> for Str {
    fn from(name: String) -> Self {
        Self::from_string(name)
    }
}

#[cfg(feature = "string")]
impl From<&'_ String> for Str {
    fn from(name: &'_ String) -> Self {
        Self::from_ref(name.as_str())
    }
}

impl From<&'static str> for Str {
    fn from(name: &'static str) -> Self {
        Self::from_static_ref(name)
    }
}

impl From<&'_ &'static str> for Str {
    fn from(name: &'_ &'static str) -> Self {
        Self::from_static_ref(name)
    }
}

impl From<Str> for String {
    fn from(name: Str) -> Self {
        name.name.into_string()
    }
}

impl From<Str> for Vec<u8> {
    fn from(name: Str) -> Self {
        String::from(name).into()
    }
}

impl From<Str> for std::ffi::OsString {
    fn from(name: Str) -> Self {
        String::from(name).into()
    }
}

impl From<Str> for std::path::PathBuf {
    fn from(name: Str) -> Self {
        String::from(name).into()
    }
}

impl std::fmt::Display for Str {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.as_str(), f)
    }
}

impl std::fmt::Debug for Str {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Debug::fmt(self.as_str(), f)
    }
}

impl std::ops::Deref for Str {
    type Target = str;

    #[inline]
    fn deref(&self) -> &str {
        self.as_str()
    }
}

impl AsRef<str> for Str {
    #[inline]
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl AsRef<[u8]> for Str {
    #[inline]
    fn as_ref(&self) -> &[u8] {
        self.as_bytes()
    }
}

impl AsRef<std::ffi::OsStr> for Str {
    #[inline]
    fn as_ref(&self) -> &std::ffi::OsStr {
        (**self).as_ref()
    }
}

impl AsRef<std::path::Path> for Str {
    #[inline]
    fn as_ref(&self) -> &std::path::Path {
        std::path::Path::new(self)
    }
}

impl std::borrow::Borrow<str> for Str {
    #[inline]
    fn borrow(&self) -> &str {
        self.as_str()
    }
}

impl PartialEq<str> for Str {
    #[inline]
    fn eq(&self, other: &str) -> bool {
        PartialEq::eq(self.as_str(), other)
    }
}
impl PartialEq<Str> for str {
    #[inline]
    fn eq(&self, other: &Str) -> bool {
        PartialEq::eq(self, other.as_str())
    }
}

impl PartialEq<&'_ str> for Str {
    #[inline]
    fn eq(&self, other: &&str) -> bool {
        PartialEq::eq(self.as_str(), *other)
    }
}
impl PartialEq<Str> for &'_ str {
    #[inline]
    fn eq(&self, other: &Str) -> bool {
        PartialEq::eq(*self, other.as_str())
    }
}

impl PartialEq<std::ffi::OsStr> for Str {
    #[inline]
    fn eq(&self, other: &std::ffi::OsStr) -> bool {
        PartialEq::eq(self.as_str(), other)
    }
}
impl PartialEq<Str> for std::ffi::OsStr {
    #[inline]
    fn eq(&self, other: &Str) -> bool {
        PartialEq::eq(self, other.as_str())
    }
}

impl PartialEq<&'_ std::ffi::OsStr> for Str {
    #[inline]
    fn eq(&self, other: &&std::ffi::OsStr) -> bool {
        PartialEq::eq(self.as_str(), *other)
    }
}
impl PartialEq<Str> for &'_ std::ffi::OsStr {
    #[inline]
    fn eq(&self, other: &Str) -> bool {
        PartialEq::eq(*self, other.as_str())
    }
}

impl PartialEq<String> for Str {
    #[inline]
    fn eq(&self, other: &String) -> bool {
        PartialEq::eq(self.as_str(), other.as_str())
    }
}
impl PartialEq<Str> for String {
    #[inline]
    fn eq(&self, other: &Str) -> bool {
        PartialEq::eq(self.as_str(), other.as_str())
    }
}

#[cfg(feature = "string")]
pub(crate) mod inner {
    #[derive(Clone)]
    pub(crate) enum Inner {
        Static(&'static str),
        Owned(Box<str>),
    }

    impl Inner {
        pub(crate) fn from_string(name: String) -> Self {
            Self::Owned(name.into_boxed_str())
        }

        pub(crate) fn from_ref(name: &str) -> Self {
            Self::Owned(Box::from(name))
        }

        pub(crate) fn from_static_ref(name: &'static str) -> Self {
            Self::Static(name)
        }

        pub(crate) fn as_str(&self) -> &str {
            match self {
                Self::Static(s) => s,
                Self::Owned(s) => s.as_ref(),
            }
        }

        pub(crate) fn into_string(self) -> String {
            match self {
                Self::Static(s) => s.to_owned(),
                Self::Owned(s) => s.into(),
            }
        }
    }
}

#[cfg(not(feature = "string"))]
pub(crate) mod inner {
    #[derive(Clone)]
    pub(crate) struct Inner(pub(crate) &'static str);

    impl Inner {
        pub(crate) fn from_static_ref(name: &'static str) -> Self {
            Self(name)
        }

        pub(crate) fn as_str(&self) -> &str {
            self.0
        }

        pub(crate) fn into_string(self) -> String {
            self.as_str().to_owned()
        }
    }
}

pub(crate) use inner::Inner;

impl Default for Inner {
    fn default() -> Self {
        Self::from_static_ref("")
    }
}

impl PartialEq for Inner {
    fn eq(&self, other: &Inner) -> bool {
        self.as_str() == other.as_str()
    }
}

impl PartialOrd for Inner {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Inner {
    fn cmp(&self, other: &Inner) -> std::cmp::Ordering {
        self.as_str().cmp(other.as_str())
    }
}

impl Eq for Inner {}

impl std::hash::Hash for Inner {
    #[inline]
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.as_str().hash(state);
    }
}

```

`clap/clap_builder/src/builder/styled_str.rs`:

```rs
#![cfg_attr(not(feature = "usage"), allow(dead_code))]

/// Terminal-styling container
///
/// Styling may be encoded as [ANSI Escape Code](https://en.wikipedia.org/wiki/ANSI_escape_code)
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// // `cstr!` converts tags to ANSI codes
/// let after_help: &'static str = color_print::cstr!(
/// r#"<bold><underline>Examples</underline></bold>
///
///   <dim>$</dim> <bold>mybin --input file.toml</bold>
/// "#);
///
/// let cmd = clap::Command::new("mybin")
///     .after_help(after_help)  // The `&str` gets converted into a `StyledStr`
///     // ...
/// #   ;
/// ```
#[derive(Clone, Default, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct StyledStr(String);

impl StyledStr {
    /// Create an empty buffer
    pub const fn new() -> Self {
        Self(String::new())
    }

    /// Display using [ANSI Escape Code](https://en.wikipedia.org/wiki/ANSI_escape_code) styling
    #[cfg(feature = "color")]
    pub fn ansi(&self) -> impl std::fmt::Display + '_ {
        self.0.as_str()
    }

    /// May allow the compiler to consolidate the `Drop`s for `msg`, reducing code size compared to
    /// `styled.push_str(&msg)`
    pub(crate) fn push_string(&mut self, msg: String) {
        self.0.push_str(&msg);
    }

    pub(crate) fn push_str(&mut self, msg: &str) {
        self.0.push_str(msg);
    }

    pub(crate) fn trim_start_lines(&mut self) {
        if let Some(pos) = self.0.find('\n') {
            let (leading, help) = self.0.split_at(pos + 1);
            if leading.trim().is_empty() {
                self.0 = help.to_owned();
            }
        }
    }

    pub(crate) fn trim_end(&mut self) {
        self.0 = self.0.trim_end().to_owned();
    }

    #[cfg(feature = "help")]
    pub(crate) fn replace_newline_var(&mut self) {
        self.0 = self.0.replace("{n}", "\n");
    }

    #[cfg(feature = "help")]
    pub(crate) fn indent(&mut self, initial: &str, trailing: &str) {
        self.0.insert_str(0, initial);

        let mut line_sep = "\n".to_owned();
        line_sep.push_str(trailing);
        self.0 = self.0.replace('\n', &line_sep);
    }

    #[cfg(all(not(feature = "wrap_help"), feature = "help"))]
    pub(crate) fn wrap(&mut self, _hard_width: usize) {}

    #[cfg(feature = "wrap_help")]
    pub(crate) fn wrap(&mut self, hard_width: usize) {
        let mut new = String::with_capacity(self.0.len());

        let mut last = 0;
        let mut wrapper = crate::output::textwrap::wrap_algorithms::LineWrapper::new(hard_width);
        for content in self.iter_text() {
            // Preserve styling
            let current = content.as_ptr() as usize - self.0.as_str().as_ptr() as usize;
            if last != current {
                new.push_str(&self.0.as_str()[last..current]);
            }
            last = current + content.len();

            for (i, line) in content.split_inclusive('\n').enumerate() {
                if 0 < i {
                    // reset char count on newline, skipping the start as we might have carried
                    // over from a prior block of styled text
                    wrapper.reset();
                }
                let line = crate::output::textwrap::word_separators::find_words_ascii_space(line)
                    .collect::<Vec<_>>();
                new.extend(wrapper.wrap(line));
            }
        }
        if last != self.0.len() {
            new.push_str(&self.0.as_str()[last..]);
        }
        new = new.trim_end().to_owned();

        self.0 = new;
    }

    #[inline(never)]
    #[cfg(feature = "help")]
    pub(crate) fn display_width(&self) -> usize {
        let mut width = 0;
        for c in self.iter_text() {
            width += crate::output::display_width(c);
        }
        width
    }

    #[cfg(feature = "help")]
    pub(crate) fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    #[cfg(feature = "help")]
    pub(crate) fn as_styled_str(&self) -> &str {
        &self.0
    }

    #[cfg(feature = "color")]
    pub(crate) fn iter_text(&self) -> impl Iterator<Item = &str> {
        anstream::adapter::strip_str(&self.0)
    }

    #[cfg(not(feature = "color"))]
    pub(crate) fn iter_text(&self) -> impl Iterator<Item = &str> {
        [self.0.as_str()].into_iter()
    }

    pub(crate) fn push_styled(&mut self, other: &Self) {
        self.0.push_str(&other.0);
    }

    pub(crate) fn write_to(&self, buffer: &mut dyn std::io::Write) -> std::io::Result<()> {
        ok!(buffer.write_all(self.0.as_bytes()));

        Ok(())
    }
}

impl Default for &'_ StyledStr {
    fn default() -> Self {
        static DEFAULT: StyledStr = StyledStr::new();
        &DEFAULT
    }
}

impl From<String> for StyledStr {
    fn from(name: String) -> Self {
        StyledStr(name)
    }
}

impl From<&'_ String> for StyledStr {
    fn from(name: &'_ String) -> Self {
        let mut styled = StyledStr::new();
        styled.push_str(name);
        styled
    }
}

impl From<&'static str> for StyledStr {
    fn from(name: &'static str) -> Self {
        let mut styled = StyledStr::new();
        styled.push_str(name);
        styled
    }
}

impl From<&'_ &'static str> for StyledStr {
    fn from(name: &'_ &'static str) -> Self {
        StyledStr::from(*name)
    }
}

impl std::fmt::Write for StyledStr {
    #[inline]
    fn write_str(&mut self, s: &str) -> Result<(), std::fmt::Error> {
        self.0.push_str(s);
        Ok(())
    }

    #[inline]
    fn write_char(&mut self, c: char) -> Result<(), std::fmt::Error> {
        self.0.push(c);
        Ok(())
    }
}

/// Color-unaware printing. Never uses coloring.
impl std::fmt::Display for StyledStr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for part in self.iter_text() {
            part.fmt(f)?;
        }

        Ok(())
    }
}

```

`clap/clap_builder/src/builder/styling.rs`:

```rs
//! Terminal [`Styles`] for help and error output

pub use anstyle::*;

/// Terminal styling definitions
///
/// See also [`Command::styles`][crate::Command::styles].
///
/// # Example
///
/// clap v3 styling
/// ```rust
/// # use clap_builder as clap;
/// # use clap::builder::styling::*;
/// let styles = Styles::styled()
///     .header(AnsiColor::Yellow.on_default())
///     .usage(AnsiColor::Green.on_default())
///     .literal(AnsiColor::Green.on_default())
///     .placeholder(AnsiColor::Green.on_default());
/// ```
#[derive(Clone, Debug)]
#[allow(missing_copy_implementations)] // Large enough type that I want an explicit `clone()` for now
pub struct Styles {
    header: Style,
    error: Style,
    usage: Style,
    literal: Style,
    placeholder: Style,
    valid: Style,
    invalid: Style,
}

impl Styles {
    /// No terminal styling
    pub const fn plain() -> Self {
        Self {
            header: Style::new(),
            error: Style::new(),
            usage: Style::new(),
            literal: Style::new(),
            placeholder: Style::new(),
            valid: Style::new(),
            invalid: Style::new(),
        }
    }

    /// Default terminal styling
    pub const fn styled() -> Self {
        #[cfg(feature = "color")]
        {
            Self {
                header: Style::new().bold().underline(),
                error: Style::new()
                    .fg_color(Some(Color::Ansi(AnsiColor::Red)))
                    .bold(),
                usage: Style::new().bold().underline(),
                literal: Style::new().bold(),
                placeholder: Style::new(),
                valid: Style::new().fg_color(Some(Color::Ansi(AnsiColor::Green))),
                invalid: Style::new().fg_color(Some(Color::Ansi(AnsiColor::Yellow))),
            }
        }
        #[cfg(not(feature = "color"))]
        {
            Self::plain()
        }
    }

    /// General Heading style, e.g. [`help_heading`][crate::Arg::help_heading]
    #[inline]
    pub const fn header(mut self, style: Style) -> Self {
        self.header = style;
        self
    }

    /// Error heading
    #[inline]
    pub const fn error(mut self, style: Style) -> Self {
        self.error = style;
        self
    }

    /// Usage heading
    #[inline]
    pub const fn usage(mut self, style: Style) -> Self {
        self.usage = style;
        self
    }

    /// Literal command-line syntax, e.g. `--help`
    #[inline]
    pub const fn literal(mut self, style: Style) -> Self {
        self.literal = style;
        self
    }

    /// Descriptions within command-line syntax, e.g. [`value_name`][crate::Arg::value_name]
    #[inline]
    pub const fn placeholder(mut self, style: Style) -> Self {
        self.placeholder = style;
        self
    }

    /// Highlight suggested usage
    #[inline]
    pub const fn valid(mut self, style: Style) -> Self {
        self.valid = style;
        self
    }

    /// Highlight invalid usage
    #[inline]
    pub const fn invalid(mut self, style: Style) -> Self {
        self.invalid = style;
        self
    }
}

/// Reflection
impl Styles {
    /// General Heading style, e.g. [`help_heading`][crate::Arg::help_heading]
    #[inline(always)]
    pub const fn get_header(&self) -> &Style {
        &self.header
    }

    /// Error heading
    #[inline(always)]
    pub const fn get_error(&self) -> &Style {
        &self.error
    }

    /// Usage heading
    #[inline(always)]
    pub const fn get_usage(&self) -> &Style {
        &self.usage
    }

    /// Literal command-line syntax, e.g. `--help`
    #[inline(always)]
    pub const fn get_literal(&self) -> &Style {
        &self.literal
    }

    /// Descriptions within command-line syntax, e.g. [`value_name`][crate::Arg::value_name]
    #[inline(always)]
    pub const fn get_placeholder(&self) -> &Style {
        &self.placeholder
    }

    /// Highlight suggested usage
    #[inline(always)]
    pub const fn get_valid(&self) -> &Style {
        &self.valid
    }

    /// Highlight invalid usage
    #[inline(always)]
    pub const fn get_invalid(&self) -> &Style {
        &self.invalid
    }
}

impl super::AppExt for Styles {}

impl Default for Styles {
    fn default() -> Self {
        Self::styled()
    }
}

impl Default for &'_ Styles {
    fn default() -> Self {
        const STYLES: Styles = Styles::styled();
        &STYLES
    }
}

```

`clap/clap_builder/src/builder/tests.rs`:

```rs
use crate::Arg;
use crate::Command;

#[test]
fn propagate_version() {
    let mut cmd = Command::new("test")
        .propagate_version(true)
        .version("1.1")
        .subcommand(Command::new("sub1"));
    cmd._propagate();
    assert_eq!(
        cmd.get_subcommands().next().unwrap().get_version(),
        Some("1.1")
    );
}

#[test]
fn global_setting() {
    let mut cmd = Command::new("test")
        .disable_version_flag(true)
        .subcommand(Command::new("subcmd"));
    cmd._propagate();
    assert!(cmd
        .get_subcommands()
        .find(|s| s.get_name() == "subcmd")
        .unwrap()
        .is_disable_version_flag_set());
}

// This test will *fail to compile* if Command is not Send + Sync
#[test]
fn app_send_sync() {
    fn foo<T: Send + Sync>(_: T) {}
    foo(Command::new("test"));
}

#[test]
fn issue_2090() {
    let mut cmd = Command::new("cmd")
        .disable_version_flag(true)
        .subcommand(Command::new("sub"));
    cmd._build_self(false);

    assert!(cmd
        .get_subcommands()
        .next()
        .unwrap()
        .is_disable_version_flag_set());
}

// This test will *fail to compile* if Arg is not Send + Sync
#[test]
fn arg_send_sync() {
    fn foo<T: Send + Sync>(_: T) {}
    foo(Arg::new("test"));
}

```

`clap/clap_builder/src/builder/value_hint.rs`:

```rs
use std::str::FromStr;

/// Provide shell with hint on how to complete an argument.
///
/// See [`Arg::value_hint`][crate::Arg::value_hint] to set this on an argument.
///
/// See the `clap_complete` crate for completion script generation.
///
/// Overview of which hints are supported by which shell:
///
/// | Hint                   | zsh | fish[^1] | dynamic |
/// | ---------------------- | --- | ---------|---------|
/// | `AnyPath`              | Yes | Yes      | Yes     |
/// | `FilePath`             | Yes | Yes      | Yes     |
/// | `DirPath`              | Yes | Yes      | Yes     |
/// | `ExecutablePath`       | Yes | Partial  | Yes     |
/// | `CommandName`          | Yes | Yes      | No      |
/// | `CommandString`        | Yes | Partial  | No      |
/// | `CommandWithArguments` | Yes |          | No      |
/// | `Username`             | Yes | Yes      | No      |
/// | `Hostname`             | Yes | Yes      | No      |
/// | `Url`                  | Yes |          | No      |
/// | `EmailAddress`         | Yes |          | No      |
///
/// [^1]: fish completions currently only support named arguments (e.g. -o or --opt), not
///       positional arguments.
#[derive(Debug, Default, PartialEq, Eq, Hash, Copy, Clone)]
#[non_exhaustive]
pub enum ValueHint {
    /// Default value if hint is not specified. Follows shell default behavior, which is usually
    /// auto-completing filenames.
    #[default]
    Unknown,
    /// None of the hints below apply. Disables shell completion for this argument.
    Other,
    /// Any existing path.
    AnyPath,
    /// Path to a file.
    FilePath,
    /// Path to a directory.
    DirPath,
    /// Path to an executable file.
    ExecutablePath,
    /// Name of a command, without arguments. May be relative to PATH, or full path to executable.
    CommandName,
    /// A single string containing a command and its arguments.
    CommandString,
    /// Capture the remaining arguments as a command name and arguments for that command. This is
    /// common when writing shell wrappers that execute anther command, for example `sudo` or `env`.
    ///
    /// This hint is special, the argument must be a positional argument and have
    /// [`.num_args(1..)`] and Command must use [`Command::trailing_var_arg(true)`]. The result is that the
    /// command line `my_app ls -la /` will be parsed as `["ls", "-la", "/"]` and clap won't try to
    /// parse the `-la` argument itself.
    ///
    /// [`Command::trailing_var_arg(true)`]: crate::Command::trailing_var_arg
    /// [`.num_args(1..)`]: crate::Arg::num_args()
    CommandWithArguments,
    /// Name of a local operating system user.
    Username,
    /// Host name of a computer.
    /// Shells usually parse `/etc/hosts` and `.ssh/known_hosts` to complete hostnames.
    Hostname,
    /// Complete web address.
    Url,
    /// Email address.
    EmailAddress,
}

#[cfg(feature = "unstable-ext")]
impl crate::builder::ArgExt for ValueHint {}

impl FromStr for ValueHint {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, <Self as FromStr>::Err> {
        Ok(match &*s.to_ascii_lowercase() {
            "unknown" => ValueHint::Unknown,
            "other" => ValueHint::Other,
            "anypath" => ValueHint::AnyPath,
            "filepath" => ValueHint::FilePath,
            "dirpath" => ValueHint::DirPath,
            "executablepath" => ValueHint::ExecutablePath,
            "commandname" => ValueHint::CommandName,
            "commandstring" => ValueHint::CommandString,
            "commandwitharguments" => ValueHint::CommandWithArguments,
            "username" => ValueHint::Username,
            "hostname" => ValueHint::Hostname,
            "url" => ValueHint::Url,
            "emailaddress" => ValueHint::EmailAddress,
            _ => return Err(format!("unknown ValueHint: `{s}`")),
        })
    }
}

```

`clap/clap_builder/src/builder/value_parser.rs`:

```rs
use std::convert::TryInto;
use std::ops::RangeBounds;

use crate::builder::Str;
use crate::builder::StyledStr;
use crate::parser::ValueSource;
use crate::util::AnyValue;
use crate::util::AnyValueId;

/// Parse/validate argument values
///
/// Specified with [`Arg::value_parser`][crate::Arg::value_parser].
///
/// `ValueParser` defines how to convert a raw argument value into a validated and typed value for
/// use within an application.
///
/// See
/// - [`value_parser!`][crate::value_parser] for automatically selecting an implementation for a given type
/// - [`ValueParser::new`] for additional [`TypedValueParser`] that can be used
///
/// # Example
///
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("color")
///             .long("color")
///             .value_parser(["always", "auto", "never"])
///             .default_value("auto")
///     )
///     .arg(
///         clap::Arg::new("hostname")
///             .long("hostname")
///             .value_parser(clap::builder::NonEmptyStringValueParser::new())
///             .action(clap::ArgAction::Set)
///             .required(true)
///     )
///     .arg(
///         clap::Arg::new("port")
///             .long("port")
///             .value_parser(clap::value_parser!(u16).range(3000..))
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(
///     ["cmd", "--hostname", "rust-lang.org", "--port", "3001"]
/// ).unwrap();
///
/// let color: &String = m.get_one("color")
///     .expect("default");
/// assert_eq!(color, "auto");
///
/// let hostname: &String = m.get_one("hostname")
///     .expect("required");
/// assert_eq!(hostname, "rust-lang.org");
///
/// let port: u16 = *m.get_one("port")
///     .expect("required");
/// assert_eq!(port, 3001);
/// ```
pub struct ValueParser(ValueParserInner);

enum ValueParserInner {
    // Common enough to optimize and for possible values
    Bool,
    // Common enough to optimize
    String,
    // Common enough to optimize
    OsString,
    // Common enough to optimize
    PathBuf,
    Other(Box<dyn AnyValueParser>),
}

impl ValueParser {
    /// Custom parser for argument values
    ///
    /// Pre-existing [`TypedValueParser`] implementations include:
    /// - `Fn(&str) -> Result<T, E>`
    /// - [`EnumValueParser`] and  [`PossibleValuesParser`] for static enumerated values
    /// - [`BoolishValueParser`] and [`FalseyValueParser`] for alternative `bool` implementations
    /// - [`RangedI64ValueParser`] and [`RangedU64ValueParser`]
    /// - [`NonEmptyStringValueParser`]
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// type EnvVar = (String, Option<String>);
    /// fn parse_env_var(env: &str) -> Result<EnvVar, std::io::Error> {
    ///     if let Some((var, value)) = env.split_once('=') {
    ///         Ok((var.to_owned(), Some(value.to_owned())))
    ///     } else {
    ///         Ok((env.to_owned(), None))
    ///     }
    /// }
    ///
    /// let mut cmd = clap::Command::new("raw")
    ///     .arg(
    ///         clap::Arg::new("env")
    ///             .value_parser(clap::builder::ValueParser::new(parse_env_var))
    ///             .required(true)
    ///     );
    ///
    /// let m = cmd.try_get_matches_from_mut(["cmd", "key=value"]).unwrap();
    /// let port: &EnvVar = m.get_one("env")
    ///     .expect("required");
    /// assert_eq!(*port, ("key".into(), Some("value".into())));
    /// ```
    pub fn new<P>(other: P) -> Self
    where
        P: TypedValueParser,
    {
        Self(ValueParserInner::Other(Box::new(other)))
    }

    /// [`bool`] parser for argument values
    ///
    /// See also:
    /// - [`BoolishValueParser`] for different human readable bool representations
    /// - [`FalseyValueParser`] for assuming non-false is true
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// let mut cmd = clap::Command::new("raw")
    ///     .arg(
    ///         clap::Arg::new("download")
    ///             .value_parser(clap::value_parser!(bool))
    ///             .required(true)
    ///     );
    ///
    /// let m = cmd.try_get_matches_from_mut(["cmd", "true"]).unwrap();
    /// let port: bool = *m.get_one("download")
    ///     .expect("required");
    /// assert_eq!(port, true);
    ///
    /// assert!(cmd.try_get_matches_from_mut(["cmd", "forever"]).is_err());
    /// ```
    pub const fn bool() -> Self {
        Self(ValueParserInner::Bool)
    }

    /// [`String`] parser for argument values
    ///
    /// See also:
    /// - [`NonEmptyStringValueParser`]
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// let mut cmd = clap::Command::new("raw")
    ///     .arg(
    ///         clap::Arg::new("port")
    ///             .value_parser(clap::value_parser!(String))
    ///             .required(true)
    ///     );
    ///
    /// let m = cmd.try_get_matches_from_mut(["cmd", "80"]).unwrap();
    /// let port: &String = m.get_one("port")
    ///     .expect("required");
    /// assert_eq!(port, "80");
    /// ```
    pub const fn string() -> Self {
        Self(ValueParserInner::String)
    }

    /// [`OsString`][std::ffi::OsString] parser for argument values
    ///
    /// # Example
    ///
    /// ```rust
    /// # #[cfg(unix)] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, builder::ValueParser};
    /// use std::ffi::OsString;
    /// use std::os::unix::ffi::{OsStrExt,OsStringExt};
    /// let r = Command::new("myprog")
    ///     .arg(
    ///         Arg::new("arg")
    ///         .required(true)
    ///         .value_parser(ValueParser::os_string())
    ///     )
    ///     .try_get_matches_from(vec![
    ///         OsString::from("myprog"),
    ///         OsString::from_vec(vec![0xe9])
    ///     ]);
    ///
    /// assert!(r.is_ok());
    /// let m = r.unwrap();
    /// let arg: &OsString = m.get_one("arg")
    ///     .expect("required");
    /// assert_eq!(arg.as_bytes(), &[0xe9]);
    /// # }
    /// ```
    pub const fn os_string() -> Self {
        Self(ValueParserInner::OsString)
    }

    /// [`PathBuf`][std::path::PathBuf] parser for argument values
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::path::PathBuf;
    /// # use std::path::Path;
    /// let mut cmd = clap::Command::new("raw")
    ///     .arg(
    ///         clap::Arg::new("output")
    ///             .value_parser(clap::value_parser!(PathBuf))
    ///             .required(true)
    ///     );
    ///
    /// let m = cmd.try_get_matches_from_mut(["cmd", "hello.txt"]).unwrap();
    /// let port: &PathBuf = m.get_one("output")
    ///     .expect("required");
    /// assert_eq!(port, Path::new("hello.txt"));
    ///
    /// assert!(cmd.try_get_matches_from_mut(["cmd", ""]).is_err());
    /// ```
    pub const fn path_buf() -> Self {
        Self(ValueParserInner::PathBuf)
    }
}

impl ValueParser {
    /// Parse into a `AnyValue`
    ///
    /// When `arg` is `None`, an external subcommand value is being parsed.
    pub(crate) fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
        source: ValueSource,
    ) -> Result<AnyValue, crate::Error> {
        self.any_value_parser().parse_ref_(cmd, arg, value, source)
    }

    /// Describes the content of `AnyValue`
    pub fn type_id(&self) -> AnyValueId {
        self.any_value_parser().type_id()
    }

    /// Reflect on enumerated value properties
    ///
    /// Error checking should not be done with this; it is mostly targeted at user-facing
    /// applications like errors and completion.
    pub fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        self.any_value_parser().possible_values()
    }

    fn any_value_parser(&self) -> &dyn AnyValueParser {
        match &self.0 {
            ValueParserInner::Bool => &BoolValueParser {},
            ValueParserInner::String => &StringValueParser {},
            ValueParserInner::OsString => &OsStringValueParser {},
            ValueParserInner::PathBuf => &PathBufValueParser {},
            ValueParserInner::Other(o) => o.as_ref(),
        }
    }
}

/// Convert a [`TypedValueParser`] to [`ValueParser`]
///
/// # Example
///
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("hostname")
///             .long("hostname")
///             .value_parser(clap::builder::NonEmptyStringValueParser::new())
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(
///     ["cmd", "--hostname", "rust-lang.org"]
/// ).unwrap();
///
/// let hostname: &String = m.get_one("hostname")
///     .expect("required");
/// assert_eq!(hostname, "rust-lang.org");
/// ```
impl<P> From<P> for ValueParser
where
    P: TypedValueParser + Send + Sync + 'static,
{
    fn from(p: P) -> Self {
        Self::new(p)
    }
}

impl From<_AnonymousValueParser> for ValueParser {
    fn from(p: _AnonymousValueParser) -> Self {
        p.0
    }
}

/// Create an `i64` [`ValueParser`] from a `N..M` range
///
/// See [`RangedI64ValueParser`] for more control over the output type.
///
/// See also [`RangedU64ValueParser`]
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("port")
///             .long("port")
///             .value_parser(3000..4000)
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "--port", "3001"]).unwrap();
/// let port: i64 = *m.get_one("port")
///     .expect("required");
/// assert_eq!(port, 3001);
/// ```
impl From<std::ops::Range<i64>> for ValueParser {
    fn from(value: std::ops::Range<i64>) -> Self {
        let inner = RangedI64ValueParser::<i64>::new().range(value.start..value.end);
        Self::from(inner)
    }
}

/// Create an `i64` [`ValueParser`] from a `N..=M` range
///
/// See [`RangedI64ValueParser`] for more control over the output type.
///
/// See also [`RangedU64ValueParser`]
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("port")
///             .long("port")
///             .value_parser(3000..=4000)
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "--port", "3001"]).unwrap();
/// let port: i64 = *m.get_one("port")
///     .expect("required");
/// assert_eq!(port, 3001);
/// ```
impl From<std::ops::RangeInclusive<i64>> for ValueParser {
    fn from(value: std::ops::RangeInclusive<i64>) -> Self {
        let inner = RangedI64ValueParser::<i64>::new().range(value.start()..=value.end());
        Self::from(inner)
    }
}

/// Create an `i64` [`ValueParser`] from a `N..` range
///
/// See [`RangedI64ValueParser`] for more control over the output type.
///
/// See also [`RangedU64ValueParser`]
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("port")
///             .long("port")
///             .value_parser(3000..)
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "--port", "3001"]).unwrap();
/// let port: i64 = *m.get_one("port")
///     .expect("required");
/// assert_eq!(port, 3001);
/// ```
impl From<std::ops::RangeFrom<i64>> for ValueParser {
    fn from(value: std::ops::RangeFrom<i64>) -> Self {
        let inner = RangedI64ValueParser::<i64>::new().range(value.start..);
        Self::from(inner)
    }
}

/// Create an `i64` [`ValueParser`] from a `..M` range
///
/// See [`RangedI64ValueParser`] for more control over the output type.
///
/// See also [`RangedU64ValueParser`]
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("port")
///             .long("port")
///             .value_parser(..3000)
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "--port", "80"]).unwrap();
/// let port: i64 = *m.get_one("port")
///     .expect("required");
/// assert_eq!(port, 80);
/// ```
impl From<std::ops::RangeTo<i64>> for ValueParser {
    fn from(value: std::ops::RangeTo<i64>) -> Self {
        let inner = RangedI64ValueParser::<i64>::new().range(..value.end);
        Self::from(inner)
    }
}

/// Create an `i64` [`ValueParser`] from a `..=M` range
///
/// See [`RangedI64ValueParser`] for more control over the output type.
///
/// See also [`RangedU64ValueParser`]
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("port")
///             .long("port")
///             .value_parser(..=3000)
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "--port", "80"]).unwrap();
/// let port: i64 = *m.get_one("port")
///     .expect("required");
/// assert_eq!(port, 80);
/// ```
impl From<std::ops::RangeToInclusive<i64>> for ValueParser {
    fn from(value: std::ops::RangeToInclusive<i64>) -> Self {
        let inner = RangedI64ValueParser::<i64>::new().range(..=value.end);
        Self::from(inner)
    }
}

/// Create an `i64` [`ValueParser`] from a `..` range
///
/// See [`RangedI64ValueParser`] for more control over the output type.
///
/// See also [`RangedU64ValueParser`]
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("port")
///             .long("port")
///             .value_parser(..)
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "--port", "3001"]).unwrap();
/// let port: i64 = *m.get_one("port")
///     .expect("required");
/// assert_eq!(port, 3001);
/// ```
impl From<std::ops::RangeFull> for ValueParser {
    fn from(value: std::ops::RangeFull) -> Self {
        let inner = RangedI64ValueParser::<i64>::new().range(value);
        Self::from(inner)
    }
}

/// Create a [`ValueParser`] with [`PossibleValuesParser`]
///
/// See [`PossibleValuesParser`] for more flexibility in creating the
/// [`PossibleValue`][crate::builder::PossibleValue]s.
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("color")
///             .long("color")
///             .value_parser(["always", "auto", "never"])
///             .default_value("auto")
///     );
///
/// let m = cmd.try_get_matches_from_mut(
///     ["cmd", "--color", "never"]
/// ).unwrap();
///
/// let color: &String = m.get_one("color")
///     .expect("default");
/// assert_eq!(color, "never");
/// ```
impl<P, const C: usize> From<[P; C]> for ValueParser
where
    P: Into<super::PossibleValue>,
{
    fn from(values: [P; C]) -> Self {
        let inner = PossibleValuesParser::from(values);
        Self::from(inner)
    }
}

/// Create a [`ValueParser`] with [`PossibleValuesParser`]
///
/// See [`PossibleValuesParser`] for more flexibility in creating the
/// [`PossibleValue`][crate::builder::PossibleValue]s.
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// let possible = vec!["always", "auto", "never"];
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("color")
///             .long("color")
///             .value_parser(possible)
///             .default_value("auto")
///     );
///
/// let m = cmd.try_get_matches_from_mut(
///     ["cmd", "--color", "never"]
/// ).unwrap();
///
/// let color: &String = m.get_one("color")
///     .expect("default");
/// assert_eq!(color, "never");
/// ```
impl<P> From<Vec<P>> for ValueParser
where
    P: Into<super::PossibleValue>,
{
    fn from(values: Vec<P>) -> Self {
        let inner = PossibleValuesParser::from(values);
        Self::from(inner)
    }
}

impl std::fmt::Debug for ValueParser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        match &self.0 {
            ValueParserInner::Bool => f.debug_struct("ValueParser::bool").finish(),
            ValueParserInner::String => f.debug_struct("ValueParser::string").finish(),
            ValueParserInner::OsString => f.debug_struct("ValueParser::os_string").finish(),
            ValueParserInner::PathBuf => f.debug_struct("ValueParser::path_buf").finish(),
            ValueParserInner::Other(o) => write!(f, "ValueParser::other({:?})", o.type_id()),
        }
    }
}

impl Clone for ValueParser {
    fn clone(&self) -> Self {
        Self(match &self.0 {
            ValueParserInner::Bool => ValueParserInner::Bool,
            ValueParserInner::String => ValueParserInner::String,
            ValueParserInner::OsString => ValueParserInner::OsString,
            ValueParserInner::PathBuf => ValueParserInner::PathBuf,
            ValueParserInner::Other(o) => ValueParserInner::Other(o.clone_any()),
        })
    }
}

/// A type-erased wrapper for [`TypedValueParser`].
trait AnyValueParser: Send + Sync + 'static {
    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<AnyValue, crate::Error>;

    fn parse_ref_(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
        _source: ValueSource,
    ) -> Result<AnyValue, crate::Error> {
        self.parse_ref(cmd, arg, value)
    }

    /// Describes the content of `AnyValue`
    fn type_id(&self) -> AnyValueId;

    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>>;

    fn clone_any(&self) -> Box<dyn AnyValueParser>;
}

impl<T, P> AnyValueParser for P
where
    T: std::any::Any + Clone + Send + Sync + 'static,
    P: TypedValueParser<Value = T>,
{
    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<AnyValue, crate::Error> {
        let value = ok!(TypedValueParser::parse_ref(self, cmd, arg, value));
        Ok(AnyValue::new(value))
    }

    fn parse_ref_(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
        source: ValueSource,
    ) -> Result<AnyValue, crate::Error> {
        let value = ok!(TypedValueParser::parse_ref_(self, cmd, arg, value, source));
        Ok(AnyValue::new(value))
    }

    fn type_id(&self) -> AnyValueId {
        AnyValueId::of::<T>()
    }

    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        P::possible_values(self)
    }

    fn clone_any(&self) -> Box<dyn AnyValueParser> {
        Box::new(self.clone())
    }
}

/// Parse/validate argument values
///
/// As alternatives to implementing `TypedValueParser`,
/// - Use `Fn(&str) -> Result<T, E>` which implements `TypedValueParser`
/// - [`TypedValueParser::map`] or [`TypedValueParser::try_map`] to adapt an existing `TypedValueParser`
///
/// See `ValueParserFactory` to register `TypedValueParser::Value` with
/// [`value_parser!`][crate::value_parser].
///
/// # Example
///
/// ```rust
/// # #[cfg(feature = "error-context")] {
/// # use clap_builder as clap;
/// # use clap::error::ErrorKind;
/// # use clap::error::ContextKind;
/// # use clap::error::ContextValue;
/// #[derive(Clone)]
/// struct Custom(u32);
///
/// #[derive(Clone)]
/// struct CustomValueParser;
///
/// impl clap::builder::TypedValueParser for CustomValueParser {
///     type Value = Custom;
///
///     fn parse_ref(
///         &self,
///         cmd: &clap::Command,
///         arg: Option<&clap::Arg>,
///         value: &std::ffi::OsStr,
///     ) -> Result<Self::Value, clap::Error> {
///         let inner = clap::value_parser!(u32);
///         let val = inner.parse_ref(cmd, arg, value)?;
///
///         const INVALID_VALUE: u32 = 10;
///         if val == INVALID_VALUE {
///             let mut err = clap::Error::new(ErrorKind::ValueValidation)
///                 .with_cmd(cmd);
///             if let Some(arg) = arg {
///                 err.insert(ContextKind::InvalidArg, ContextValue::String(arg.to_string()));
///             }
///             err.insert(ContextKind::InvalidValue, ContextValue::String(INVALID_VALUE.to_string()));
///             return Err(err);
///         }
///
///         Ok(Custom(val))
///     }
/// }
/// # }
/// ```
pub trait TypedValueParser: Clone + Send + Sync + 'static {
    /// Argument's value type
    type Value: Send + Sync + Clone;

    /// Parse the argument value
    ///
    /// When `arg` is `None`, an external subcommand value is being parsed.
    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error>;

    /// Parse the argument value
    ///
    /// When `arg` is `None`, an external subcommand value is being parsed.
    fn parse_ref_(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
        _source: ValueSource,
    ) -> Result<Self::Value, crate::Error> {
        self.parse_ref(cmd, arg, value)
    }

    /// Parse the argument value
    ///
    /// When `arg` is `None`, an external subcommand value is being parsed.
    fn parse(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: std::ffi::OsString,
    ) -> Result<Self::Value, crate::Error> {
        self.parse_ref(cmd, arg, &value)
    }

    /// Parse the argument value
    ///
    /// When `arg` is `None`, an external subcommand value is being parsed.
    fn parse_(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: std::ffi::OsString,
        _source: ValueSource,
    ) -> Result<Self::Value, crate::Error> {
        self.parse(cmd, arg, value)
    }

    /// Reflect on enumerated value properties
    ///
    /// Error checking should not be done with this; it is mostly targeted at user-facing
    /// applications like errors and completion.
    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        None
    }

    /// Adapt a `TypedValueParser` from one value to another
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// # use clap::builder::TypedValueParser as _;
    /// # use clap::builder::BoolishValueParser;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::SetTrue)
    ///             .value_parser(
    ///                 BoolishValueParser::new()
    ///                 .map(|b| -> usize {
    ///                     if b { 10 } else { 5 }
    ///                 })
    ///             )
    ///     );
    ///
    /// let matches = cmd.clone().try_get_matches_from(["mycmd", "--flag"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_one::<usize>("flag").copied(),
    ///     Some(10)
    /// );
    ///
    /// let matches = cmd.try_get_matches_from(["mycmd"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_one::<usize>("flag").copied(),
    ///     Some(5)
    /// );
    /// ```
    fn map<T, F>(self, func: F) -> MapValueParser<Self, F>
    where
        T: Send + Sync + Clone,
        F: Fn(Self::Value) -> T + Clone,
    {
        MapValueParser::new(self, func)
    }

    /// Adapt a `TypedValueParser` from one value to another
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::ffi::OsString;
    /// # use std::ffi::OsStr;
    /// # use std::path::PathBuf;
    /// # use std::path::Path;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// # use clap::builder::TypedValueParser as _;
    /// # use clap::builder::OsStringValueParser;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .value_parser(
    ///                 OsStringValueParser::new()
    ///                 .try_map(verify_ext)
    ///             )
    ///     );
    ///
    /// fn verify_ext(os: OsString) -> Result<PathBuf, &'static str> {
    ///     let path = PathBuf::from(os);
    ///     if path.extension() != Some(OsStr::new("rs")) {
    ///         return Err("only Rust files are supported");
    ///     }
    ///     Ok(path)
    /// }
    ///
    /// let error = cmd.clone().try_get_matches_from(["mycmd", "--flag", "foo.txt"]).unwrap_err();
    /// error.print();
    ///
    /// let matches = cmd.try_get_matches_from(["mycmd", "--flag", "foo.rs"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_one::<PathBuf>("flag").map(|s| s.as_path()),
    ///     Some(Path::new("foo.rs"))
    /// );
    /// ```
    fn try_map<T, E, F>(self, func: F) -> TryMapValueParser<Self, F>
    where
        F: Fn(Self::Value) -> Result<T, E> + Clone + Send + Sync + 'static,
        T: Send + Sync + Clone,
        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
    {
        TryMapValueParser::new(self, func)
    }
}

impl<F, T, E> TypedValueParser for F
where
    F: Fn(&str) -> Result<T, E> + Clone + Send + Sync + 'static,
    E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
    T: Send + Sync + Clone,
{
    type Value = T;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        let value = ok!(value.to_str().ok_or_else(|| {
            crate::Error::invalid_utf8(
                cmd,
                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
            )
        }));
        let value = ok!((self)(value).map_err(|e| {
            let arg = arg
                .map(|a| a.to_string())
                .unwrap_or_else(|| "...".to_owned());
            crate::Error::value_validation(arg, value.to_owned(), e.into()).with_cmd(cmd)
        }));
        Ok(value)
    }
}

/// Implementation for [`ValueParser::string`]
///
/// Useful for composing new [`TypedValueParser`]s
#[derive(Copy, Clone, Debug)]
#[non_exhaustive]
pub struct StringValueParser {}

impl StringValueParser {
    /// Implementation for [`ValueParser::string`]
    pub fn new() -> Self {
        Self {}
    }
}

impl TypedValueParser for StringValueParser {
    type Value = String;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        TypedValueParser::parse(self, cmd, arg, value.to_owned())
    }

    fn parse(
        &self,
        cmd: &crate::Command,
        _arg: Option<&crate::Arg>,
        value: std::ffi::OsString,
    ) -> Result<Self::Value, crate::Error> {
        let value = ok!(value.into_string().map_err(|_| {
            crate::Error::invalid_utf8(
                cmd,
                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
            )
        }));
        Ok(value)
    }
}

impl Default for StringValueParser {
    fn default() -> Self {
        Self::new()
    }
}

/// Implementation for [`ValueParser::os_string`]
///
/// Useful for composing new [`TypedValueParser`]s
#[derive(Copy, Clone, Debug)]
#[non_exhaustive]
pub struct OsStringValueParser {}

impl OsStringValueParser {
    /// Implementation for [`ValueParser::os_string`]
    pub fn new() -> Self {
        Self {}
    }
}

impl TypedValueParser for OsStringValueParser {
    type Value = std::ffi::OsString;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        TypedValueParser::parse(self, cmd, arg, value.to_owned())
    }

    fn parse(
        &self,
        _cmd: &crate::Command,
        _arg: Option<&crate::Arg>,
        value: std::ffi::OsString,
    ) -> Result<Self::Value, crate::Error> {
        Ok(value)
    }
}

impl Default for OsStringValueParser {
    fn default() -> Self {
        Self::new()
    }
}

/// Implementation for [`ValueParser::path_buf`]
///
/// Useful for composing new [`TypedValueParser`]s
#[derive(Copy, Clone, Debug)]
#[non_exhaustive]
pub struct PathBufValueParser {}

impl PathBufValueParser {
    /// Implementation for [`ValueParser::path_buf`]
    pub fn new() -> Self {
        Self {}
    }
}

impl TypedValueParser for PathBufValueParser {
    type Value = std::path::PathBuf;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        TypedValueParser::parse(self, cmd, arg, value.to_owned())
    }

    fn parse(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: std::ffi::OsString,
    ) -> Result<Self::Value, crate::Error> {
        if value.is_empty() {
            return Err(crate::Error::empty_value(
                cmd,
                &[],
                arg.map(ToString::to_string)
                    .unwrap_or_else(|| "...".to_owned()),
            ));
        }
        Ok(Self::Value::from(value))
    }
}

impl Default for PathBufValueParser {
    fn default() -> Self {
        Self::new()
    }
}

/// Parse an [`ValueEnum`][crate::ValueEnum] value.
///
/// See also:
/// - [`PossibleValuesParser`]
///
/// # Example
///
/// ```rust
/// # use clap_builder as clap;
/// # use std::ffi::OsStr;
/// # use clap::ColorChoice;
/// # use clap::builder::TypedValueParser;
/// # let cmd = clap::Command::new("test");
/// # let arg = None;
///
/// // Usage
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("color")
///             .value_parser(clap::builder::EnumValueParser::<ColorChoice>::new())
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "always"]).unwrap();
/// let port: ColorChoice = *m.get_one("color")
///     .expect("required");
/// assert_eq!(port, ColorChoice::Always);
///
/// // Semantics
/// let value_parser = clap::builder::EnumValueParser::<ColorChoice>::new();
/// // or
/// let value_parser = clap::value_parser!(ColorChoice);
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("random")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("")).is_err());
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("always")).unwrap(), ColorChoice::Always);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("auto")).unwrap(), ColorChoice::Auto);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("never")).unwrap(), ColorChoice::Never);
/// ```
#[derive(Clone, Debug)]
pub struct EnumValueParser<E: crate::ValueEnum + Clone + Send + Sync + 'static>(
    std::marker::PhantomData<E>,
);

impl<E: crate::ValueEnum + Clone + Send + Sync + 'static> EnumValueParser<E> {
    /// Parse an [`ValueEnum`][crate::ValueEnum]
    pub fn new() -> Self {
        let phantom: std::marker::PhantomData<E> = Default::default();
        Self(phantom)
    }
}

impl<E: crate::ValueEnum + Clone + Send + Sync + 'static> TypedValueParser for EnumValueParser<E> {
    type Value = E;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        let ignore_case = arg.map(|a| a.is_ignore_case_set()).unwrap_or(false);
        let possible_vals = || {
            E::value_variants()
                .iter()
                .filter_map(|v| v.to_possible_value())
                .filter(|v| !v.is_hide_set())
                .map(|v| v.get_name().to_owned())
                .collect::<Vec<_>>()
        };

        let value = ok!(value.to_str().ok_or_else(|| {
            crate::Error::invalid_value(
                cmd,
                value.to_string_lossy().into_owned(),
                &possible_vals(),
                arg.map(ToString::to_string)
                    .unwrap_or_else(|| "...".to_owned()),
            )
        }));
        let value = ok!(E::value_variants()
            .iter()
            .find(|v| {
                v.to_possible_value()
                    .expect("ValueEnum::value_variants contains only values with a corresponding ValueEnum::to_possible_value")
                    .matches(value, ignore_case)
            })
            .ok_or_else(|| {
            crate::Error::invalid_value(
                cmd,
                value.to_owned(),
                &possible_vals(),
                arg.map(ToString::to_string)
                    .unwrap_or_else(|| "...".to_owned()),
            )
            }))
            .clone();
        Ok(value)
    }

    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        Some(Box::new(
            E::value_variants()
                .iter()
                .filter_map(|v| v.to_possible_value()),
        ))
    }
}

impl<E: crate::ValueEnum + Clone + Send + Sync + 'static> Default for EnumValueParser<E> {
    fn default() -> Self {
        Self::new()
    }
}

/// Verify the value is from an enumerated set of [`PossibleValue`][crate::builder::PossibleValue].
///
/// See also:
/// - [`EnumValueParser`] for directly supporting [`ValueEnum`][crate::ValueEnum] types
/// - [`TypedValueParser::map`] for adapting values to a more specialized type, like an external
///   enums that can't implement [`ValueEnum`][crate::ValueEnum]
///
/// # Example
///
/// Usage:
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("color")
///             .value_parser(clap::builder::PossibleValuesParser::new(["always", "auto", "never"]))
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "always"]).unwrap();
/// let port: &String = m.get_one("color")
///     .expect("required");
/// assert_eq!(port, "always");
/// ```
///
/// Semantics:
/// ```rust
/// # use clap_builder as clap;
/// # use std::ffi::OsStr;
/// # use clap::builder::TypedValueParser;
/// # let cmd = clap::Command::new("test");
/// # let arg = None;
/// let value_parser = clap::builder::PossibleValuesParser::new(["always", "auto", "never"]);
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("random")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("")).is_err());
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("always")).unwrap(), "always");
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("auto")).unwrap(), "auto");
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("never")).unwrap(), "never");
/// ```
#[derive(Clone, Debug)]
pub struct PossibleValuesParser(Vec<super::PossibleValue>);

impl PossibleValuesParser {
    /// Verify the value is from an enumerated set of [`PossibleValue`][crate::builder::PossibleValue].
    pub fn new(values: impl Into<PossibleValuesParser>) -> Self {
        values.into()
    }
}

impl TypedValueParser for PossibleValuesParser {
    type Value = String;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        TypedValueParser::parse(self, cmd, arg, value.to_owned())
    }

    fn parse(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: std::ffi::OsString,
    ) -> Result<String, crate::Error> {
        let value = ok!(value.into_string().map_err(|_| {
            crate::Error::invalid_utf8(
                cmd,
                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
            )
        }));

        let ignore_case = arg.map(|a| a.is_ignore_case_set()).unwrap_or(false);
        if self.0.iter().any(|v| v.matches(&value, ignore_case)) {
            Ok(value)
        } else {
            let possible_vals = self
                .0
                .iter()
                .filter(|v| !v.is_hide_set())
                .map(|v| v.get_name().to_owned())
                .collect::<Vec<_>>();

            Err(crate::Error::invalid_value(
                cmd,
                value,
                &possible_vals,
                arg.map(ToString::to_string)
                    .unwrap_or_else(|| "...".to_owned()),
            ))
        }
    }

    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        Some(Box::new(self.0.iter().cloned()))
    }
}

impl<I, T> From<I> for PossibleValuesParser
where
    I: IntoIterator<Item = T>,
    T: Into<super::PossibleValue>,
{
    fn from(values: I) -> Self {
        Self(values.into_iter().map(|t| t.into()).collect())
    }
}

/// Parse number that fall within a range of values
///
/// <div class="warning">
///
/// **NOTE:** To capture negative values, you will also need to set
/// [`Arg::allow_negative_numbers`][crate::Arg::allow_negative_numbers] or
/// [`Arg::allow_hyphen_values`][crate::Arg::allow_hyphen_values].
///
/// </div>
///
/// # Example
///
/// Usage:
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("port")
///             .long("port")
///             .value_parser(clap::value_parser!(u16).range(3000..))
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "--port", "3001"]).unwrap();
/// let port: u16 = *m.get_one("port")
///     .expect("required");
/// assert_eq!(port, 3001);
/// ```
///
/// Semantics:
/// ```rust
/// # use clap_builder as clap;
/// # use std::ffi::OsStr;
/// # use clap::builder::TypedValueParser;
/// # let cmd = clap::Command::new("test");
/// # let arg = None;
/// let value_parser = clap::builder::RangedI64ValueParser::<i32>::new().range(-1..200);
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("random")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("-200")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("300")).is_err());
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("-1")).unwrap(), -1);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("0")).unwrap(), 0);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("50")).unwrap(), 50);
/// ```
#[derive(Copy, Clone, Debug)]
pub struct RangedI64ValueParser<T: TryFrom<i64> + Clone + Send + Sync = i64> {
    bounds: (std::ops::Bound<i64>, std::ops::Bound<i64>),
    target: std::marker::PhantomData<T>,
}

impl<T: TryFrom<i64> + Clone + Send + Sync> RangedI64ValueParser<T> {
    /// Select full range of `i64`
    pub fn new() -> Self {
        Self::from(..)
    }

    /// Narrow the supported range
    pub fn range<B: RangeBounds<i64>>(mut self, range: B) -> Self {
        // Consideration: when the user does `value_parser!(u8).range()`
        // - Avoid programming mistakes by accidentally expanding the range
        // - Make it convenient to limit the range like with `..10`
        let start = match range.start_bound() {
            l @ std::ops::Bound::Included(i) => {
                debug_assert!(
                    self.bounds.contains(i),
                    "{} must be in {:?}",
                    i,
                    self.bounds
                );
                l.cloned()
            }
            l @ std::ops::Bound::Excluded(i) => {
                debug_assert!(
                    self.bounds.contains(&i.saturating_add(1)),
                    "{} must be in {:?}",
                    i,
                    self.bounds
                );
                l.cloned()
            }
            std::ops::Bound::Unbounded => self.bounds.start_bound().cloned(),
        };
        let end = match range.end_bound() {
            l @ std::ops::Bound::Included(i) => {
                debug_assert!(
                    self.bounds.contains(i),
                    "{} must be in {:?}",
                    i,
                    self.bounds
                );
                l.cloned()
            }
            l @ std::ops::Bound::Excluded(i) => {
                debug_assert!(
                    self.bounds.contains(&i.saturating_sub(1)),
                    "{} must be in {:?}",
                    i,
                    self.bounds
                );
                l.cloned()
            }
            std::ops::Bound::Unbounded => self.bounds.end_bound().cloned(),
        };
        self.bounds = (start, end);
        self
    }

    fn format_bounds(&self) -> String {
        let mut result = match self.bounds.0 {
            std::ops::Bound::Included(i) => i.to_string(),
            std::ops::Bound::Excluded(i) => i.saturating_add(1).to_string(),
            std::ops::Bound::Unbounded => i64::MIN.to_string(),
        };
        result.push_str("..");
        match self.bounds.1 {
            std::ops::Bound::Included(i) => {
                result.push('=');
                result.push_str(&i.to_string());
            }
            std::ops::Bound::Excluded(i) => {
                result.push_str(&i.to_string());
            }
            std::ops::Bound::Unbounded => {
                result.push_str(&i64::MAX.to_string());
            }
        }
        result
    }
}

impl<T: TryFrom<i64> + Clone + Send + Sync + 'static> TypedValueParser for RangedI64ValueParser<T>
where
    <T as TryFrom<i64>>::Error: Send + Sync + 'static + std::error::Error + ToString,
{
    type Value = T;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        raw_value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        let value = ok!(raw_value.to_str().ok_or_else(|| {
            crate::Error::invalid_utf8(
                cmd,
                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
            )
        }));
        let value = ok!(value.parse::<i64>().map_err(|err| {
            let arg = arg
                .map(|a| a.to_string())
                .unwrap_or_else(|| "...".to_owned());
            crate::Error::value_validation(
                arg,
                raw_value.to_string_lossy().into_owned(),
                err.into(),
            )
            .with_cmd(cmd)
        }));
        if !self.bounds.contains(&value) {
            let arg = arg
                .map(|a| a.to_string())
                .unwrap_or_else(|| "...".to_owned());
            return Err(crate::Error::value_validation(
                arg,
                raw_value.to_string_lossy().into_owned(),
                format!("{} is not in {}", value, self.format_bounds()).into(),
            )
            .with_cmd(cmd));
        }

        let value: Result<Self::Value, _> = value.try_into();
        let value = ok!(value.map_err(|err| {
            let arg = arg
                .map(|a| a.to_string())
                .unwrap_or_else(|| "...".to_owned());
            crate::Error::value_validation(
                arg,
                raw_value.to_string_lossy().into_owned(),
                err.into(),
            )
            .with_cmd(cmd)
        }));

        Ok(value)
    }
}

impl<T: TryFrom<i64> + Clone + Send + Sync, B: RangeBounds<i64>> From<B>
    for RangedI64ValueParser<T>
{
    fn from(range: B) -> Self {
        Self {
            bounds: (range.start_bound().cloned(), range.end_bound().cloned()),
            target: Default::default(),
        }
    }
}

impl<T: TryFrom<i64> + Clone + Send + Sync> Default for RangedI64ValueParser<T> {
    fn default() -> Self {
        Self::new()
    }
}

/// Parse number that fall within a range of values
///
/// # Example
///
/// Usage:
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("port")
///             .long("port")
///             .value_parser(clap::value_parser!(u64).range(3000..))
///             .action(clap::ArgAction::Set)
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "--port", "3001"]).unwrap();
/// let port: u64 = *m.get_one("port")
///     .expect("required");
/// assert_eq!(port, 3001);
/// ```
///
/// Semantics:
/// ```rust
/// # use clap_builder as clap;
/// # use std::ffi::OsStr;
/// # use clap::builder::TypedValueParser;
/// # let cmd = clap::Command::new("test");
/// # let arg = None;
/// let value_parser = clap::builder::RangedU64ValueParser::<u32>::new().range(0..200);
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("random")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("-200")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("300")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("-1")).is_err());
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("0")).unwrap(), 0);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("50")).unwrap(), 50);
/// ```
#[derive(Copy, Clone, Debug)]
pub struct RangedU64ValueParser<T: TryFrom<u64> = u64> {
    bounds: (std::ops::Bound<u64>, std::ops::Bound<u64>),
    target: std::marker::PhantomData<T>,
}

impl<T: TryFrom<u64>> RangedU64ValueParser<T> {
    /// Select full range of `u64`
    pub fn new() -> Self {
        Self::from(..)
    }

    /// Narrow the supported range
    pub fn range<B: RangeBounds<u64>>(mut self, range: B) -> Self {
        // Consideration: when the user does `value_parser!(u8).range()`
        // - Avoid programming mistakes by accidentally expanding the range
        // - Make it convenient to limit the range like with `..10`
        let start = match range.start_bound() {
            l @ std::ops::Bound::Included(i) => {
                debug_assert!(
                    self.bounds.contains(i),
                    "{} must be in {:?}",
                    i,
                    self.bounds
                );
                l.cloned()
            }
            l @ std::ops::Bound::Excluded(i) => {
                debug_assert!(
                    self.bounds.contains(&i.saturating_add(1)),
                    "{} must be in {:?}",
                    i,
                    self.bounds
                );
                l.cloned()
            }
            std::ops::Bound::Unbounded => self.bounds.start_bound().cloned(),
        };
        let end = match range.end_bound() {
            l @ std::ops::Bound::Included(i) => {
                debug_assert!(
                    self.bounds.contains(i),
                    "{} must be in {:?}",
                    i,
                    self.bounds
                );
                l.cloned()
            }
            l @ std::ops::Bound::Excluded(i) => {
                debug_assert!(
                    self.bounds.contains(&i.saturating_sub(1)),
                    "{} must be in {:?}",
                    i,
                    self.bounds
                );
                l.cloned()
            }
            std::ops::Bound::Unbounded => self.bounds.end_bound().cloned(),
        };
        self.bounds = (start, end);
        self
    }

    fn format_bounds(&self) -> String {
        let mut result = match self.bounds.0 {
            std::ops::Bound::Included(i) => i.to_string(),
            std::ops::Bound::Excluded(i) => i.saturating_add(1).to_string(),
            std::ops::Bound::Unbounded => u64::MIN.to_string(),
        };
        result.push_str("..");
        match self.bounds.1 {
            std::ops::Bound::Included(i) => {
                result.push('=');
                result.push_str(&i.to_string());
            }
            std::ops::Bound::Excluded(i) => {
                result.push_str(&i.to_string());
            }
            std::ops::Bound::Unbounded => {
                result.push_str(&u64::MAX.to_string());
            }
        }
        result
    }
}

impl<T: TryFrom<u64> + Clone + Send + Sync + 'static> TypedValueParser for RangedU64ValueParser<T>
where
    <T as TryFrom<u64>>::Error: Send + Sync + 'static + std::error::Error + ToString,
{
    type Value = T;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        raw_value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        let value = ok!(raw_value.to_str().ok_or_else(|| {
            crate::Error::invalid_utf8(
                cmd,
                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
            )
        }));
        let value = ok!(value.parse::<u64>().map_err(|err| {
            let arg = arg
                .map(|a| a.to_string())
                .unwrap_or_else(|| "...".to_owned());
            crate::Error::value_validation(
                arg,
                raw_value.to_string_lossy().into_owned(),
                err.into(),
            )
            .with_cmd(cmd)
        }));
        if !self.bounds.contains(&value) {
            let arg = arg
                .map(|a| a.to_string())
                .unwrap_or_else(|| "...".to_owned());
            return Err(crate::Error::value_validation(
                arg,
                raw_value.to_string_lossy().into_owned(),
                format!("{} is not in {}", value, self.format_bounds()).into(),
            )
            .with_cmd(cmd));
        }

        let value: Result<Self::Value, _> = value.try_into();
        let value = ok!(value.map_err(|err| {
            let arg = arg
                .map(|a| a.to_string())
                .unwrap_or_else(|| "...".to_owned());
            crate::Error::value_validation(
                arg,
                raw_value.to_string_lossy().into_owned(),
                err.into(),
            )
            .with_cmd(cmd)
        }));

        Ok(value)
    }
}

impl<T: TryFrom<u64>, B: RangeBounds<u64>> From<B> for RangedU64ValueParser<T> {
    fn from(range: B) -> Self {
        Self {
            bounds: (range.start_bound().cloned(), range.end_bound().cloned()),
            target: Default::default(),
        }
    }
}

impl<T: TryFrom<u64>> Default for RangedU64ValueParser<T> {
    fn default() -> Self {
        Self::new()
    }
}

/// Implementation for [`ValueParser::bool`]
///
/// Useful for composing new [`TypedValueParser`]s
#[derive(Copy, Clone, Debug)]
#[non_exhaustive]
pub struct BoolValueParser {}

impl BoolValueParser {
    /// Implementation for [`ValueParser::bool`]
    pub fn new() -> Self {
        Self {}
    }

    fn possible_values() -> impl Iterator<Item = crate::builder::PossibleValue> {
        ["true", "false"]
            .iter()
            .copied()
            .map(crate::builder::PossibleValue::new)
    }
}

impl TypedValueParser for BoolValueParser {
    type Value = bool;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        let value = if value == std::ffi::OsStr::new("true") {
            true
        } else if value == std::ffi::OsStr::new("false") {
            false
        } else {
            // Intentionally showing hidden as we hide all of them
            let possible_vals = Self::possible_values()
                .map(|v| v.get_name().to_owned())
                .collect::<Vec<_>>();

            return Err(crate::Error::invalid_value(
                cmd,
                value.to_string_lossy().into_owned(),
                &possible_vals,
                arg.map(ToString::to_string)
                    .unwrap_or_else(|| "...".to_owned()),
            ));
        };
        Ok(value)
    }

    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        Some(Box::new(Self::possible_values()))
    }
}

impl Default for BoolValueParser {
    fn default() -> Self {
        Self::new()
    }
}

/// Parse false-like string values, everything else is `true`
///
/// See also:
/// - [`ValueParser::bool`] for assuming non-false is true
/// - [`BoolishValueParser`] for different human readable bool representations
///
/// # Example
///
/// Usage:
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("append")
///             .value_parser(clap::builder::FalseyValueParser::new())
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "true"]).unwrap();
/// let port: bool = *m.get_one("append")
///     .expect("required");
/// assert_eq!(port, true);
/// ```
///
/// Semantics:
/// ```rust
/// # use clap_builder as clap;
/// # use std::ffi::OsStr;
/// # use clap::builder::TypedValueParser;
/// # let cmd = clap::Command::new("test");
/// # let arg = None;
/// let value_parser = clap::builder::FalseyValueParser::new();
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("random")).unwrap(), true);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("100")).unwrap(), true);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("")).unwrap(), false);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("false")).unwrap(), false);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("No")).unwrap(), false);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("oFF")).unwrap(), false);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("0")).unwrap(), false);
/// ```
#[derive(Copy, Clone, Debug)]
#[non_exhaustive]
pub struct FalseyValueParser {}

impl FalseyValueParser {
    /// Parse false-like string values, everything else is `true`
    pub fn new() -> Self {
        Self {}
    }

    fn possible_values() -> impl Iterator<Item = crate::builder::PossibleValue> {
        crate::util::TRUE_LITERALS
            .iter()
            .chain(crate::util::FALSE_LITERALS.iter())
            .copied()
            .map(|l| crate::builder::PossibleValue::new(l).hide(l != "true" && l != "false"))
    }
}

impl TypedValueParser for FalseyValueParser {
    type Value = bool;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        _arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        let value = ok!(value.to_str().ok_or_else(|| {
            crate::Error::invalid_utf8(
                cmd,
                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
            )
        }));
        let value = if value.is_empty() {
            false
        } else {
            crate::util::str_to_bool(value).unwrap_or(true)
        };
        Ok(value)
    }

    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        Some(Box::new(Self::possible_values()))
    }
}

impl Default for FalseyValueParser {
    fn default() -> Self {
        Self::new()
    }
}

/// Parse bool-like string values
///
/// See also:
/// - [`ValueParser::bool`] for different human readable bool representations
/// - [`FalseyValueParser`] for assuming non-false is true
///
/// # Example
///
/// Usage:
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("append")
///             .value_parser(clap::builder::BoolishValueParser::new())
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "true"]).unwrap();
/// let port: bool = *m.get_one("append")
///     .expect("required");
/// assert_eq!(port, true);
/// ```
///
/// Semantics:
/// ```rust
/// # use clap_builder as clap;
/// # use std::ffi::OsStr;
/// # use clap::builder::TypedValueParser;
/// # let cmd = clap::Command::new("test");
/// # let arg = None;
/// let value_parser = clap::builder::BoolishValueParser::new();
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("random")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("")).is_err());
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("100")).is_err());
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("true")).unwrap(), true);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("Yes")).unwrap(), true);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("oN")).unwrap(), true);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("1")).unwrap(), true);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("false")).unwrap(), false);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("No")).unwrap(), false);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("oFF")).unwrap(), false);
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("0")).unwrap(), false);
/// ```
#[derive(Copy, Clone, Debug)]
#[non_exhaustive]
pub struct BoolishValueParser {}

impl BoolishValueParser {
    /// Parse bool-like string values
    pub fn new() -> Self {
        Self {}
    }

    fn possible_values() -> impl Iterator<Item = crate::builder::PossibleValue> {
        crate::util::TRUE_LITERALS
            .iter()
            .chain(crate::util::FALSE_LITERALS.iter())
            .copied()
            .map(|l| crate::builder::PossibleValue::new(l).hide(l != "true" && l != "false"))
    }
}

impl TypedValueParser for BoolishValueParser {
    type Value = bool;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        let value = ok!(value.to_str().ok_or_else(|| {
            crate::Error::invalid_utf8(
                cmd,
                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
            )
        }));
        let value = ok!(crate::util::str_to_bool(value).ok_or_else(|| {
            let arg = arg
                .map(|a| a.to_string())
                .unwrap_or_else(|| "...".to_owned());
            crate::Error::value_validation(arg, value.to_owned(), "value was not a boolean".into())
                .with_cmd(cmd)
        }));
        Ok(value)
    }

    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        Some(Box::new(Self::possible_values()))
    }
}

impl Default for BoolishValueParser {
    fn default() -> Self {
        Self::new()
    }
}

/// Parse non-empty string values
///
/// See also:
/// - [`ValueParser::string`]
///
/// # Example
///
/// Usage:
/// ```rust
/// # use clap_builder as clap;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("append")
///             .value_parser(clap::builder::NonEmptyStringValueParser::new())
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "true"]).unwrap();
/// let port: &String = m.get_one("append")
///     .expect("required");
/// assert_eq!(port, "true");
/// ```
///
/// Semantics:
/// ```rust
/// # use clap_builder as clap;
/// # use std::ffi::OsStr;
/// # use clap::builder::TypedValueParser;
/// # let cmd = clap::Command::new("test");
/// # let arg = None;
/// let value_parser = clap::builder::NonEmptyStringValueParser::new();
/// assert_eq!(value_parser.parse_ref(&cmd, arg, OsStr::new("random")).unwrap(), "random");
/// assert!(value_parser.parse_ref(&cmd, arg, OsStr::new("")).is_err());
/// ```
#[derive(Copy, Clone, Debug)]
#[non_exhaustive]
pub struct NonEmptyStringValueParser {}

impl NonEmptyStringValueParser {
    /// Parse non-empty string values
    pub fn new() -> Self {
        Self {}
    }
}

impl TypedValueParser for NonEmptyStringValueParser {
    type Value = String;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        if value.is_empty() {
            return Err(crate::Error::empty_value(
                cmd,
                &[],
                arg.map(ToString::to_string)
                    .unwrap_or_else(|| "...".to_owned()),
            ));
        }
        let value = ok!(value.to_str().ok_or_else(|| {
            crate::Error::invalid_utf8(
                cmd,
                crate::output::Usage::new(cmd).create_usage_with_title(&[]),
            )
        }));
        Ok(value.to_owned())
    }
}

impl Default for NonEmptyStringValueParser {
    fn default() -> Self {
        Self::new()
    }
}

/// Adapt a `TypedValueParser` from one value to another
///
/// See [`TypedValueParser::map`]
#[derive(Clone, Debug)]
pub struct MapValueParser<P, F> {
    parser: P,
    func: F,
}

impl<P, F, T> MapValueParser<P, F>
where
    P: TypedValueParser,
    P::Value: Send + Sync + Clone,
    F: Fn(P::Value) -> T + Clone,
    T: Send + Sync + Clone,
{
    fn new(parser: P, func: F) -> Self {
        Self { parser, func }
    }
}

impl<P, F, T> TypedValueParser for MapValueParser<P, F>
where
    P: TypedValueParser,
    P::Value: Send + Sync + Clone,
    F: Fn(P::Value) -> T + Clone + Send + Sync + 'static,
    T: Send + Sync + Clone,
{
    type Value = T;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        let value = ok!(self.parser.parse_ref(cmd, arg, value));
        let value = (self.func)(value);
        Ok(value)
    }

    fn parse(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: std::ffi::OsString,
    ) -> Result<Self::Value, crate::Error> {
        let value = ok!(self.parser.parse(cmd, arg, value));
        let value = (self.func)(value);
        Ok(value)
    }

    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        self.parser.possible_values()
    }
}

/// Adapt a `TypedValueParser` from one value to another
///
/// See [`TypedValueParser::try_map`]
#[derive(Clone, Debug)]
pub struct TryMapValueParser<P, F> {
    parser: P,
    func: F,
}

impl<P, F, T, E> TryMapValueParser<P, F>
where
    P: TypedValueParser,
    P::Value: Send + Sync + Clone,
    F: Fn(P::Value) -> Result<T, E> + Clone + Send + Sync + 'static,
    T: Send + Sync + Clone,
    E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
{
    fn new(parser: P, func: F) -> Self {
        Self { parser, func }
    }
}

impl<P, F, T, E> TypedValueParser for TryMapValueParser<P, F>
where
    P: TypedValueParser,
    P::Value: Send + Sync + Clone,
    F: Fn(P::Value) -> Result<T, E> + Clone + Send + Sync + 'static,
    T: Send + Sync + Clone,
    E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
{
    type Value = T;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        let mid_value = ok!(self.parser.parse_ref(cmd, arg, value));
        let value = ok!((self.func)(mid_value).map_err(|e| {
            let arg = arg
                .map(|a| a.to_string())
                .unwrap_or_else(|| "...".to_owned());
            crate::Error::value_validation(arg, value.to_string_lossy().into_owned(), e.into())
                .with_cmd(cmd)
        }));
        Ok(value)
    }

    fn possible_values(
        &self,
    ) -> Option<Box<dyn Iterator<Item = crate::builder::PossibleValue> + '_>> {
        self.parser.possible_values()
    }
}

/// When encountered, report [`ErrorKind::UnknownArgument`][crate::error::ErrorKind::UnknownArgument]
///
/// Useful to help users migrate, either from old versions or similar tools.
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::Command;
/// # use clap::Arg;
/// let cmd = Command::new("mycmd")
///     .args([
///         Arg::new("current-dir")
///             .short('C'),
///         Arg::new("current-dir-unknown")
///             .long("cwd")
///             .aliases(["current-dir", "directory", "working-directory", "root"])
///             .value_parser(clap::builder::UnknownArgumentValueParser::suggest_arg("-C"))
///             .hide(true),
///     ]);
///
/// // Use a supported version of the argument
/// let matches = cmd.clone().try_get_matches_from(["mycmd", "-C", ".."]).unwrap();
/// assert!(matches.contains_id("current-dir"));
/// assert_eq!(
///     matches.get_many::<String>("current-dir").unwrap_or_default().map(|v| v.as_str()).collect::<Vec<_>>(),
///     vec![".."]
/// );
///
/// // Use one of the invalid versions
/// let err = cmd.try_get_matches_from(["mycmd", "--cwd", ".."]).unwrap_err();
/// assert_eq!(err.kind(), clap::error::ErrorKind::UnknownArgument);
/// ```
#[derive(Clone, Debug)]
pub struct UnknownArgumentValueParser {
    arg: Option<Str>,
    suggestions: Vec<StyledStr>,
}

impl UnknownArgumentValueParser {
    /// Suggest an alternative argument
    pub fn suggest_arg(arg: impl Into<Str>) -> Self {
        Self {
            arg: Some(arg.into()),
            suggestions: Default::default(),
        }
    }

    /// Provide a general suggestion
    pub fn suggest(text: impl Into<StyledStr>) -> Self {
        Self {
            arg: Default::default(),
            suggestions: vec![text.into()],
        }
    }

    /// Extend the suggestions
    pub fn and_suggest(mut self, text: impl Into<StyledStr>) -> Self {
        self.suggestions.push(text.into());
        self
    }
}

impl TypedValueParser for UnknownArgumentValueParser {
    type Value = String;

    fn parse_ref(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        value: &std::ffi::OsStr,
    ) -> Result<Self::Value, crate::Error> {
        TypedValueParser::parse_ref_(self, cmd, arg, value, ValueSource::CommandLine)
    }

    fn parse_ref_(
        &self,
        cmd: &crate::Command,
        arg: Option<&crate::Arg>,
        _value: &std::ffi::OsStr,
        source: ValueSource,
    ) -> Result<Self::Value, crate::Error> {
        match source {
            ValueSource::DefaultValue => {
                TypedValueParser::parse_ref_(&StringValueParser::new(), cmd, arg, _value, source)
            }
            ValueSource::EnvVariable | ValueSource::CommandLine => {
                let arg = match arg {
                    Some(arg) => arg.to_string(),
                    None => "..".to_owned(),
                };
                let err = crate::Error::unknown_argument(
                    cmd,
                    arg,
                    self.arg.as_ref().map(|s| (s.as_str().to_owned(), None)),
                    false,
                    crate::output::Usage::new(cmd).create_usage_with_title(&[]),
                );
                #[cfg(feature = "error-context")]
                let err = {
                    debug_assert_eq!(
                        err.get(crate::error::ContextKind::Suggested),
                        None,
                        "Assuming `Error::unknown_argument` doesn't apply any `Suggested` so we can without caution"
                    );
                    err.insert_context_unchecked(
                        crate::error::ContextKind::Suggested,
                        crate::error::ContextValue::StyledStrs(self.suggestions.clone()),
                    )
                };
                Err(err)
            }
        }
    }
}

/// Register a type with [`value_parser!`][crate::value_parser!]
///
/// # Example
///
/// ```rust
/// # use clap_builder as clap;
/// #[derive(Copy, Clone, Debug)]
/// pub struct Custom(u32);
///
/// impl clap::builder::ValueParserFactory for Custom {
///     type Parser = CustomValueParser;
///     fn value_parser() -> Self::Parser {
///         CustomValueParser
///     }
/// }
///
/// #[derive(Clone, Debug)]
/// pub struct CustomValueParser;
/// impl clap::builder::TypedValueParser for CustomValueParser {
///     type Value = Custom;
///
///     fn parse_ref(
///         &self,
///         cmd: &clap::Command,
///         arg: Option<&clap::Arg>,
///         value: &std::ffi::OsStr,
///     ) -> Result<Self::Value, clap::Error> {
///         let inner = clap::value_parser!(u32);
///         let val = inner.parse_ref(cmd, arg, value)?;
///         Ok(Custom(val))
///     }
/// }
///
/// let parser: CustomValueParser = clap::value_parser!(Custom);
/// ```
pub trait ValueParserFactory {
    /// Generated parser, usually [`ValueParser`].
    ///
    /// It should at least be a type that supports `Into<ValueParser>`.  A non-`ValueParser` type
    /// allows the caller to do further initialization on the parser.
    type Parser;

    /// Create the specified [`Self::Parser`]
    fn value_parser() -> Self::Parser;
}
impl ValueParserFactory for String {
    type Parser = ValueParser;
    fn value_parser() -> Self::Parser {
        ValueParser::string() // Default `clap_derive` to optimized implementation
    }
}
impl ValueParserFactory for Box<str> {
    type Parser = MapValueParser<StringValueParser, fn(String) -> Box<str>>;
    fn value_parser() -> Self::Parser {
        StringValueParser::new().map(String::into_boxed_str)
    }
}
impl ValueParserFactory for std::ffi::OsString {
    type Parser = ValueParser;
    fn value_parser() -> Self::Parser {
        ValueParser::os_string() // Default `clap_derive` to optimized implementation
    }
}
impl ValueParserFactory for Box<std::ffi::OsStr> {
    type Parser =
        MapValueParser<OsStringValueParser, fn(std::ffi::OsString) -> Box<std::ffi::OsStr>>;
    fn value_parser() -> Self::Parser {
        OsStringValueParser::new().map(std::ffi::OsString::into_boxed_os_str)
    }
}
impl ValueParserFactory for std::path::PathBuf {
    type Parser = ValueParser;
    fn value_parser() -> Self::Parser {
        ValueParser::path_buf() // Default `clap_derive` to optimized implementation
    }
}
impl ValueParserFactory for Box<std::path::Path> {
    type Parser =
        MapValueParser<PathBufValueParser, fn(std::path::PathBuf) -> Box<std::path::Path>>;
    fn value_parser() -> Self::Parser {
        PathBufValueParser::new().map(std::path::PathBuf::into_boxed_path)
    }
}
impl ValueParserFactory for bool {
    type Parser = ValueParser;
    fn value_parser() -> Self::Parser {
        ValueParser::bool() // Default `clap_derive` to optimized implementation
    }
}
impl ValueParserFactory for u8 {
    type Parser = RangedI64ValueParser<u8>;
    fn value_parser() -> Self::Parser {
        let start: i64 = u8::MIN.into();
        let end: i64 = u8::MAX.into();
        RangedI64ValueParser::new().range(start..=end)
    }
}
impl ValueParserFactory for i8 {
    type Parser = RangedI64ValueParser<i8>;
    fn value_parser() -> Self::Parser {
        let start: i64 = i8::MIN.into();
        let end: i64 = i8::MAX.into();
        RangedI64ValueParser::new().range(start..=end)
    }
}
impl ValueParserFactory for u16 {
    type Parser = RangedI64ValueParser<u16>;
    fn value_parser() -> Self::Parser {
        let start: i64 = u16::MIN.into();
        let end: i64 = u16::MAX.into();
        RangedI64ValueParser::new().range(start..=end)
    }
}
impl ValueParserFactory for i16 {
    type Parser = RangedI64ValueParser<i16>;
    fn value_parser() -> Self::Parser {
        let start: i64 = i16::MIN.into();
        let end: i64 = i16::MAX.into();
        RangedI64ValueParser::new().range(start..=end)
    }
}
impl ValueParserFactory for u32 {
    type Parser = RangedI64ValueParser<u32>;
    fn value_parser() -> Self::Parser {
        let start: i64 = u32::MIN.into();
        let end: i64 = u32::MAX.into();
        RangedI64ValueParser::new().range(start..=end)
    }
}
impl ValueParserFactory for i32 {
    type Parser = RangedI64ValueParser<i32>;
    fn value_parser() -> Self::Parser {
        let start: i64 = i32::MIN.into();
        let end: i64 = i32::MAX.into();
        RangedI64ValueParser::new().range(start..=end)
    }
}
impl ValueParserFactory for u64 {
    type Parser = RangedU64ValueParser<u64>;
    fn value_parser() -> Self::Parser {
        RangedU64ValueParser::new()
    }
}
impl ValueParserFactory for i64 {
    type Parser = RangedI64ValueParser<i64>;
    fn value_parser() -> Self::Parser {
        RangedI64ValueParser::new()
    }
}
impl<T> ValueParserFactory for std::num::Saturating<T>
where
    T: ValueParserFactory,
    <T as ValueParserFactory>::Parser: TypedValueParser<Value = T>,
    T: Send + Sync + Clone,
{
    type Parser =
        MapValueParser<<T as ValueParserFactory>::Parser, fn(T) -> std::num::Saturating<T>>;
    fn value_parser() -> Self::Parser {
        T::value_parser().map(std::num::Saturating)
    }
}
impl<T> ValueParserFactory for std::num::Wrapping<T>
where
    T: ValueParserFactory,
    <T as ValueParserFactory>::Parser: TypedValueParser<Value = T>,
    T: Send + Sync + Clone,
{
    type Parser = MapValueParser<<T as ValueParserFactory>::Parser, fn(T) -> std::num::Wrapping<T>>;
    fn value_parser() -> Self::Parser {
        T::value_parser().map(std::num::Wrapping)
    }
}
impl<T> ValueParserFactory for Box<T>
where
    T: ValueParserFactory,
    <T as ValueParserFactory>::Parser: TypedValueParser<Value = T>,
    T: Send + Sync + Clone,
{
    type Parser = MapValueParser<<T as ValueParserFactory>::Parser, fn(T) -> Box<T>>;
    fn value_parser() -> Self::Parser {
        T::value_parser().map(Box::new)
    }
}
impl<T> ValueParserFactory for std::sync::Arc<T>
where
    T: ValueParserFactory,
    <T as ValueParserFactory>::Parser: TypedValueParser<Value = T>,
    T: Send + Sync + Clone,
{
    type Parser = MapValueParser<<T as ValueParserFactory>::Parser, fn(T) -> std::sync::Arc<T>>;
    fn value_parser() -> Self::Parser {
        T::value_parser().map(std::sync::Arc::new)
    }
}

#[doc(hidden)]
#[derive(Debug)]
#[allow(non_camel_case_types)]
pub struct _infer_ValueParser_for<T>(std::marker::PhantomData<T>);

impl<T> _infer_ValueParser_for<T> {
    #[doc(hidden)]
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        Self(Default::default())
    }
}

/// Unstable [`ValueParser`]
///
/// Implementation may change to more specific instance in the future
#[doc(hidden)]
#[derive(Debug)]
pub struct _AnonymousValueParser(ValueParser);

#[doc(hidden)]
pub mod impl_prelude {
    use super::*;

    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub trait _impls_ValueParserFactory: private::_impls_ValueParserFactorySealed {
        type Parser;
        fn value_parser(&self) -> Self::Parser;
    }
    impl<P: ValueParserFactory> _impls_ValueParserFactory for &&&&&&_infer_ValueParser_for<P> {
        type Parser = P::Parser;
        fn value_parser(&self) -> Self::Parser {
            P::value_parser()
        }
    }

    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub trait _impls_ValueEnum: private::_impls_ValueEnumSealed {
        type Output;

        fn value_parser(&self) -> Self::Output;
    }
    impl<E: crate::ValueEnum + Clone + Send + Sync + 'static> _impls_ValueEnum
        for &&&&&_infer_ValueParser_for<E>
    {
        type Output = EnumValueParser<E>;

        fn value_parser(&self) -> Self::Output {
            EnumValueParser::<E>::new()
        }
    }

    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub trait _impls_From_OsString: private::_impls_From_OsStringSealed {
        fn value_parser(&self) -> _AnonymousValueParser;
    }
    impl<FromOsString> _impls_From_OsString for &&&&_infer_ValueParser_for<FromOsString>
    where
        FromOsString: From<std::ffi::OsString> + std::any::Any + Clone + Send + Sync + 'static,
    {
        fn value_parser(&self) -> _AnonymousValueParser {
            _AnonymousValueParser(
                OsStringValueParser::new()
                    .map(|s| FromOsString::from(s))
                    .into(),
            )
        }
    }

    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub trait _impls_From_OsStr: private::_impls_From_OsStrSealed {
        fn value_parser(&self) -> _AnonymousValueParser;
    }
    impl<FromOsStr> _impls_From_OsStr for &&&_infer_ValueParser_for<FromOsStr>
    where
        FromOsStr:
            for<'s> From<&'s std::ffi::OsStr> + std::any::Any + Clone + Send + Sync + 'static,
    {
        fn value_parser(&self) -> _AnonymousValueParser {
            _AnonymousValueParser(
                OsStringValueParser::new()
                    .map(|s| FromOsStr::from(&s))
                    .into(),
            )
        }
    }

    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub trait _impls_From_String: private::_impls_From_StringSealed {
        fn value_parser(&self) -> _AnonymousValueParser;
    }
    impl<FromString> _impls_From_String for &&_infer_ValueParser_for<FromString>
    where
        FromString: From<String> + std::any::Any + Clone + Send + Sync + 'static,
    {
        fn value_parser(&self) -> _AnonymousValueParser {
            _AnonymousValueParser(StringValueParser::new().map(|s| FromString::from(s)).into())
        }
    }

    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub trait _impls_From_str: private::_impls_From_strSealed {
        fn value_parser(&self) -> _AnonymousValueParser;
    }
    impl<FromStr> _impls_From_str for &_infer_ValueParser_for<FromStr>
    where
        FromStr: for<'s> From<&'s str> + std::any::Any + Clone + Send + Sync + 'static,
    {
        fn value_parser(&self) -> _AnonymousValueParser {
            _AnonymousValueParser(StringValueParser::new().map(|s| FromStr::from(&s)).into())
        }
    }

    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    pub trait _impls_FromStr: private::_impls_FromStrSealed {
        fn value_parser(&self) -> _AnonymousValueParser;
    }
    impl<Parse> _impls_FromStr for _infer_ValueParser_for<Parse>
    where
        Parse: std::str::FromStr + std::any::Any + Clone + Send + Sync + 'static,
        <Parse as std::str::FromStr>::Err: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
    {
        fn value_parser(&self) -> _AnonymousValueParser {
            let func: fn(&str) -> Result<Parse, <Parse as std::str::FromStr>::Err> =
                Parse::from_str;
            _AnonymousValueParser(ValueParser::new(func))
        }
    }
}

/// Select a [`ValueParser`] implementation from the intended type
///
/// Supported types
/// - [`ValueParserFactory` types][ValueParserFactory], including
///   - [Native types][ValueParser]: `bool`, `String`, `OsString`, `PathBuf`
///   - [Ranged numeric types][RangedI64ValueParser]: `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`
/// - [`ValueEnum` types][crate::ValueEnum]
/// - [`From<OsString>` types][std::convert::From] and [`From<&OsStr>` types][std::convert::From]
/// - [`From<String>` types][std::convert::From] and [`From<&str>` types][std::convert::From]
/// - [`FromStr` types][std::str::FromStr], including usize, isize
///
/// # Example
///
/// Usage:
/// ```rust
/// # use clap_builder as clap;
/// # use std::path::PathBuf;
/// # use std::path::Path;
/// let mut cmd = clap::Command::new("raw")
///     .arg(
///         clap::Arg::new("output")
///             .value_parser(clap::value_parser!(PathBuf))
///             .required(true)
///     );
///
/// let m = cmd.try_get_matches_from_mut(["cmd", "file.txt"]).unwrap();
/// let port: &PathBuf = m.get_one("output")
///     .expect("required");
/// assert_eq!(port, Path::new("file.txt"));
/// ```
///
/// Example mappings:
/// ```rust
/// # use clap_builder as clap;
/// # use clap::ColorChoice;
/// // Built-in types
/// let parser = clap::value_parser!(String);
/// assert_eq!(format!("{parser:?}"), "ValueParser::string");
/// let parser = clap::value_parser!(std::ffi::OsString);
/// assert_eq!(format!("{parser:?}"), "ValueParser::os_string");
/// let parser = clap::value_parser!(std::path::PathBuf);
/// assert_eq!(format!("{parser:?}"), "ValueParser::path_buf");
/// clap::value_parser!(u16).range(3000..);
/// clap::value_parser!(u64).range(3000..);
///
/// // FromStr types
/// let parser = clap::value_parser!(usize);
/// assert_eq!(format!("{parser:?}"), "_AnonymousValueParser(ValueParser::other(usize))");
///
/// // ValueEnum types
/// clap::value_parser!(ColorChoice);
/// ```
#[macro_export]
macro_rules! value_parser {
    ($name:ty) => {{
        use $crate::builder::impl_prelude::*;
        let auto = $crate::builder::_infer_ValueParser_for::<$name>::new();
        (&&&&&&auto).value_parser()
    }};
}

mod private {
    use super::*;

    #[allow(non_camel_case_types)]
    pub trait _impls_ValueParserFactorySealed {}
    impl<P: ValueParserFactory> _impls_ValueParserFactorySealed for &&&&&&_infer_ValueParser_for<P> {}

    #[allow(non_camel_case_types)]
    pub trait _impls_ValueEnumSealed {}
    impl<E: crate::ValueEnum> _impls_ValueEnumSealed for &&&&&_infer_ValueParser_for<E> {}

    #[allow(non_camel_case_types)]
    pub trait _impls_From_OsStringSealed {}
    impl<FromOsString> _impls_From_OsStringSealed for &&&&_infer_ValueParser_for<FromOsString> where
        FromOsString: From<std::ffi::OsString> + std::any::Any + Send + Sync + 'static
    {
    }

    #[allow(non_camel_case_types)]
    pub trait _impls_From_OsStrSealed {}
    impl<FromOsStr> _impls_From_OsStrSealed for &&&_infer_ValueParser_for<FromOsStr> where
        FromOsStr: for<'s> From<&'s std::ffi::OsStr> + std::any::Any + Send + Sync + 'static
    {
    }

    #[allow(non_camel_case_types)]
    pub trait _impls_From_StringSealed {}
    impl<FromString> _impls_From_StringSealed for &&_infer_ValueParser_for<FromString> where
        FromString: From<String> + std::any::Any + Send + Sync + 'static
    {
    }

    #[allow(non_camel_case_types)]
    pub trait _impls_From_strSealed {}
    impl<FromStr> _impls_From_strSealed for &_infer_ValueParser_for<FromStr> where
        FromStr: for<'s> From<&'s str> + std::any::Any + Send + Sync + 'static
    {
    }

    #[allow(non_camel_case_types)]
    pub trait _impls_FromStrSealed {}
    impl<Parse> _impls_FromStrSealed for _infer_ValueParser_for<Parse>
    where
        Parse: std::str::FromStr + std::any::Any + Send + Sync + 'static,
        <Parse as std::str::FromStr>::Err: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,
    {
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn ensure_typed_applies_to_parse() {
        fn parse(_: &str) -> Result<usize, std::io::Error> {
            Ok(10)
        }
        let cmd = crate::Command::new("cmd");
        let arg = None;
        assert_eq!(
            TypedValueParser::parse_ref(&parse, &cmd, arg, std::ffi::OsStr::new("foo")).unwrap(),
            10
        );
    }
}

```

`clap/clap_builder/src/derive.rs`:

```rs
//! This module contains traits that are usable with the `#[derive(...)]`
//! macros in `clap_derive`.

use crate::builder::PossibleValue;
use crate::{ArgMatches, Command, Error};

use std::ffi::OsString;

/// Parse command-line arguments into `Self`.
///
/// The primary one-stop-shop trait used to create an instance of a `clap`
/// [`Command`], conduct the parsing, and turn the resulting [`ArgMatches`] back
/// into concrete instance of the user struct.
///
/// This trait is primarily a convenience on top of [`FromArgMatches`] +
/// [`CommandFactory`] which uses those two underlying traits to build the two
/// fundamental functions `parse` which uses the `std::env::args_os` iterator,
/// and `parse_from` which allows the consumer to supply the iterator (along
/// with fallible options for each).
///
/// See also [`Subcommand`] and [`Args`].
///
/// <div class="warning">
///
/// **NOTE:** Deriving requires the `derive` feature flag
///
/// </div>
pub trait Parser: FromArgMatches + CommandFactory + Sized {
    /// Parse from `std::env::args_os()`, [exit][Error::exit] on error.
    fn parse() -> Self {
        let mut matches = <Self as CommandFactory>::command().get_matches();
        let res = <Self as FromArgMatches>::from_arg_matches_mut(&mut matches)
            .map_err(format_error::<Self>);
        match res {
            Ok(s) => s,
            Err(e) => {
                // Since this is more of a development-time error, we aren't doing as fancy of a quit
                // as `get_matches`
                e.exit()
            }
        }
    }

    /// Parse from `std::env::args_os()`, return Err on error.
    fn try_parse() -> Result<Self, Error> {
        let mut matches = ok!(<Self as CommandFactory>::command().try_get_matches());
        <Self as FromArgMatches>::from_arg_matches_mut(&mut matches).map_err(format_error::<Self>)
    }

    /// Parse from iterator, [exit][Error::exit] on error.
    fn parse_from<I, T>(itr: I) -> Self
    where
        I: IntoIterator<Item = T>,
        T: Into<OsString> + Clone,
    {
        let mut matches = <Self as CommandFactory>::command().get_matches_from(itr);
        let res = <Self as FromArgMatches>::from_arg_matches_mut(&mut matches)
            .map_err(format_error::<Self>);
        match res {
            Ok(s) => s,
            Err(e) => {
                // Since this is more of a development-time error, we aren't doing as fancy of a quit
                // as `get_matches_from`
                e.exit()
            }
        }
    }

    /// Parse from iterator, return Err on error.
    fn try_parse_from<I, T>(itr: I) -> Result<Self, Error>
    where
        I: IntoIterator<Item = T>,
        T: Into<OsString> + Clone,
    {
        let mut matches = ok!(<Self as CommandFactory>::command().try_get_matches_from(itr));
        <Self as FromArgMatches>::from_arg_matches_mut(&mut matches).map_err(format_error::<Self>)
    }

    /// Update from iterator, [exit][Error::exit] on error.
    ///
    /// Unlike [`Parser::parse`], this works with an existing instance of `self`.
    /// The assumption is that all required fields are already provided and any [`Args`] or
    /// [`Subcommand`]s provided by the user will modify only what is specified.
    fn update_from<I, T>(&mut self, itr: I)
    where
        I: IntoIterator<Item = T>,
        T: Into<OsString> + Clone,
    {
        let mut matches = <Self as CommandFactory>::command_for_update().get_matches_from(itr);
        let res = <Self as FromArgMatches>::update_from_arg_matches_mut(self, &mut matches)
            .map_err(format_error::<Self>);
        if let Err(e) = res {
            // Since this is more of a development-time error, we aren't doing as fancy of a quit
            // as `get_matches_from`
            e.exit()
        }
    }

    /// Update from iterator, return Err on error.
    fn try_update_from<I, T>(&mut self, itr: I) -> Result<(), Error>
    where
        I: IntoIterator<Item = T>,
        T: Into<OsString> + Clone,
    {
        let mut matches =
            ok!(<Self as CommandFactory>::command_for_update().try_get_matches_from(itr));
        <Self as FromArgMatches>::update_from_arg_matches_mut(self, &mut matches)
            .map_err(format_error::<Self>)
    }
}

/// Create a [`Command`] relevant for a user-defined container.
///
/// Derived as part of [`Parser`].
pub trait CommandFactory: Sized {
    /// Build a [`Command`] that can instantiate `Self`.
    ///
    /// See [`FromArgMatches::from_arg_matches_mut`] for instantiating `Self`.
    fn command() -> Command;
    /// Build a [`Command`] that can update `self`.
    ///
    /// See [`FromArgMatches::update_from_arg_matches_mut`] for updating `self`.
    fn command_for_update() -> Command;
}

/// Converts an instance of [`ArgMatches`] to a user-defined container.
///
/// Derived as part of [`Parser`], [`Args`], and [`Subcommand`].
pub trait FromArgMatches: Sized {
    /// Instantiate `Self` from [`ArgMatches`], parsing the arguments as needed.
    ///
    /// Motivation: If our application had two CLI options, `--name
    /// <STRING>` and the flag `--debug`, we may create a struct as follows:
    ///
    /// ```rust
    /// # #[cfg(feature = "derive")] {
    /// struct Context {
    ///     name: String,
    ///     debug: bool
    /// }
    /// # }
    /// ```
    ///
    /// We then need to convert the `ArgMatches` that `clap` generated into our struct.
    /// `from_arg_matches` serves as the equivalent of:
    ///
    /// ```rust
    /// # #[cfg(feature = "derive")] {
    /// # use clap::ArgMatches;
    /// # struct Context {
    /// #   name: String,
    /// #   debug: bool
    /// # }
    /// impl From<ArgMatches> for Context {
    ///    fn from(m: ArgMatches) -> Self {
    ///        Context {
    ///            name: m.get_one::<String>("name").unwrap().clone(),
    ///            debug: m.get_flag("debug"),
    ///        }
    ///    }
    /// }
    /// # }
    /// ```
    fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error>;

    /// Instantiate `Self` from [`ArgMatches`], parsing the arguments as needed.
    ///
    /// Motivation: If our application had two CLI options, `--name
    /// <STRING>` and the flag `--debug`, we may create a struct as follows:
    ///
    /// ```rust
    /// # #[cfg(feature = "derive")] {
    /// struct Context {
    ///     name: String,
    ///     debug: bool
    /// }
    /// # }
    /// ```
    ///
    /// We then need to convert the `ArgMatches` that `clap` generated into our struct.
    /// `from_arg_matches_mut` serves as the equivalent of:
    ///
    /// ```rust
    /// # #[cfg(feature = "derive")] {
    /// # use clap::ArgMatches;
    /// # struct Context {
    /// #   name: String,
    /// #   debug: bool
    /// # }
    /// impl From<ArgMatches> for Context {
    ///    fn from(m: ArgMatches) -> Self {
    ///        Context {
    ///            name: m.get_one::<String>("name").unwrap().to_string(),
    ///            debug: m.get_flag("debug"),
    ///        }
    ///    }
    /// }
    /// # }
    /// ```
    fn from_arg_matches_mut(matches: &mut ArgMatches) -> Result<Self, Error> {
        Self::from_arg_matches(matches)
    }

    /// Assign values from `ArgMatches` to `self`.
    fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error>;

    /// Assign values from `ArgMatches` to `self`.
    fn update_from_arg_matches_mut(&mut self, matches: &mut ArgMatches) -> Result<(), Error> {
        self.update_from_arg_matches(matches)
    }
}

/// Parse a set of arguments into a user-defined container.
///
/// Implementing this trait lets a parent container delegate argument parsing behavior to `Self`.
/// with:
/// - `#[command(flatten)] args: ChildArgs`: Attribute can only be used with struct fields that impl
///   `Args`.
/// - `Variant(ChildArgs)`: No attribute is used with enum variants that impl `Args`.
///
/// <div class="warning">
///
/// **NOTE:** Deriving requires the `derive` feature flag
///
/// </div>
pub trait Args: FromArgMatches + Sized {
    /// Report the [`ArgGroup::id`][crate::ArgGroup::id] for this set of arguments
    fn group_id() -> Option<crate::Id> {
        None
    }
    /// Append to [`Command`] so it can instantiate `Self` via
    /// [`FromArgMatches::from_arg_matches_mut`]
    ///
    /// This is used to implement `#[command(flatten)]`
    ///
    /// See also [`CommandFactory::command`].
    fn augment_args(cmd: Command) -> Command;
    /// Append to [`Command`] so it can instantiate `self` via
    /// [`FromArgMatches::update_from_arg_matches_mut`]
    ///
    /// This is used to implement `#[command(flatten)]`
    ///
    /// See also [`CommandFactory::command_for_update`].
    fn augment_args_for_update(cmd: Command) -> Command;
}

/// Parse a sub-command into a user-defined enum.
///
/// Implementing this trait lets a parent container delegate subcommand behavior to `Self`.
/// with:
/// - `#[command(subcommand)] field: SubCmd`: Attribute can be used with either struct fields or enum
///   variants that impl `Subcommand`.
/// - `#[command(flatten)] Variant(SubCmd)`: Attribute can only be used with enum variants that impl
///   `Subcommand`.
///
/// <div class="warning">
///
/// **NOTE:** Deriving requires the `derive` feature flag
///
/// </div>
pub trait Subcommand: FromArgMatches + Sized {
    /// Append to [`Command`] so it can instantiate `Self` via
    /// [`FromArgMatches::from_arg_matches_mut`]
    ///
    /// This is used to implement `#[command(flatten)]`
    ///
    /// See also [`CommandFactory::command`].
    fn augment_subcommands(cmd: Command) -> Command;
    /// Append to [`Command`] so it can instantiate `self` via
    /// [`FromArgMatches::update_from_arg_matches_mut`]
    ///
    /// This is used to implement `#[command(flatten)]`
    ///
    /// See also [`CommandFactory::command_for_update`].
    fn augment_subcommands_for_update(cmd: Command) -> Command;
    /// Test whether `Self` can parse a specific subcommand
    fn has_subcommand(name: &str) -> bool;
}

/// Parse arguments into enums.
///
/// When deriving [`Parser`], a field whose type implements `ValueEnum` can have the attribute
/// `#[arg(value_enum)]` which will
/// - Call [`EnumValueParser`][crate::builder::EnumValueParser]
/// - Allowing using the `#[arg(default_value_t)]` attribute without implementing `Display`.
///
/// <div class="warning">
///
/// **NOTE:** Deriving requires the `derive` feature flag
///
/// </div>
pub trait ValueEnum: Sized + Clone {
    /// All possible argument values, in display order.
    fn value_variants<'a>() -> &'a [Self];

    /// Parse an argument into `Self`.
    fn from_str(input: &str, ignore_case: bool) -> Result<Self, String> {
        Self::value_variants()
            .iter()
            .find(|v| {
                v.to_possible_value()
                    .expect("ValueEnum::value_variants contains only values with a corresponding ValueEnum::to_possible_value")
                    .matches(input, ignore_case)
            })
            .cloned()
            .ok_or_else(|| format!("invalid variant: {input}"))
    }

    /// The canonical argument value.
    ///
    /// The value is `None` for skipped variants.
    fn to_possible_value(&self) -> Option<PossibleValue>;
}

impl<T: Parser> Parser for Box<T> {
    fn parse() -> Self {
        Box::new(<T as Parser>::parse())
    }

    fn try_parse() -> Result<Self, Error> {
        <T as Parser>::try_parse().map(Box::new)
    }

    fn parse_from<I, It>(itr: I) -> Self
    where
        I: IntoIterator<Item = It>,
        It: Into<OsString> + Clone,
    {
        Box::new(<T as Parser>::parse_from(itr))
    }

    fn try_parse_from<I, It>(itr: I) -> Result<Self, Error>
    where
        I: IntoIterator<Item = It>,
        It: Into<OsString> + Clone,
    {
        <T as Parser>::try_parse_from(itr).map(Box::new)
    }
}

impl<T: CommandFactory> CommandFactory for Box<T> {
    fn command() -> Command {
        <T as CommandFactory>::command()
    }
    fn command_for_update() -> Command {
        <T as CommandFactory>::command_for_update()
    }
}

impl<T: FromArgMatches> FromArgMatches for Box<T> {
    fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error> {
        <T as FromArgMatches>::from_arg_matches(matches).map(Box::new)
    }
    fn from_arg_matches_mut(matches: &mut ArgMatches) -> Result<Self, Error> {
        <T as FromArgMatches>::from_arg_matches_mut(matches).map(Box::new)
    }
    fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error> {
        <T as FromArgMatches>::update_from_arg_matches(self, matches)
    }
    fn update_from_arg_matches_mut(&mut self, matches: &mut ArgMatches) -> Result<(), Error> {
        <T as FromArgMatches>::update_from_arg_matches_mut(self, matches)
    }
}

impl<T: Args> Args for Box<T> {
    fn augment_args(cmd: Command) -> Command {
        <T as Args>::augment_args(cmd)
    }
    fn augment_args_for_update(cmd: Command) -> Command {
        <T as Args>::augment_args_for_update(cmd)
    }
}

impl<T: Subcommand> Subcommand for Box<T> {
    fn augment_subcommands(cmd: Command) -> Command {
        <T as Subcommand>::augment_subcommands(cmd)
    }
    fn augment_subcommands_for_update(cmd: Command) -> Command {
        <T as Subcommand>::augment_subcommands_for_update(cmd)
    }
    fn has_subcommand(name: &str) -> bool {
        <T as Subcommand>::has_subcommand(name)
    }
}

fn format_error<I: CommandFactory>(err: Error) -> Error {
    let mut cmd = I::command();
    err.format(&mut cmd)
}

```

`clap/clap_builder/src/error/context.rs`:

```rs
/// Semantics for a piece of error information
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
#[non_exhaustive]
#[cfg(feature = "error-context")]
pub enum ContextKind {
    /// The cause of the error
    InvalidSubcommand,
    /// The cause of the error
    InvalidArg,
    /// Existing arguments
    PriorArg,
    /// Accepted subcommands
    ValidSubcommand,
    /// Accepted values
    ValidValue,
    /// Rejected values
    InvalidValue,
    /// Number of values present
    ActualNumValues,
    /// Number of allowed values
    ExpectedNumValues,
    /// Minimum number of allowed values
    MinValues,
    /// Potential fix for the user
    SuggestedCommand,
    /// Potential fix for the user
    SuggestedSubcommand,
    /// Potential fix for the user
    SuggestedArg,
    /// Potential fix for the user
    SuggestedValue,
    /// Trailing argument
    TrailingArg,
    /// Potential fix for the user
    Suggested,
    /// A usage string
    Usage,
    /// An opaque message to the user
    Custom,
}

impl ContextKind {
    /// End-user description of the error case, where relevant
    pub fn as_str(self) -> Option<&'static str> {
        match self {
            Self::InvalidSubcommand => Some("Invalid Subcommand"),
            Self::InvalidArg => Some("Invalid Argument"),
            Self::PriorArg => Some("Prior Argument"),
            Self::ValidSubcommand => Some("Valid Subcommand"),
            Self::ValidValue => Some("Valid Value"),
            Self::InvalidValue => Some("Invalid Value"),
            Self::ActualNumValues => Some("Actual Number of Values"),
            Self::ExpectedNumValues => Some("Expected Number of Values"),
            Self::MinValues => Some("Minimum Number of Values"),
            Self::SuggestedCommand => Some("Suggested Command"),
            Self::SuggestedSubcommand => Some("Suggested Subcommand"),
            Self::SuggestedArg => Some("Suggested Argument"),
            Self::SuggestedValue => Some("Suggested Value"),
            Self::TrailingArg => Some("Trailing Argument"),
            Self::Suggested => Some("Suggested"),
            Self::Usage => None,
            Self::Custom => None,
        }
    }
}

impl std::fmt::Display for ContextKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.as_str().unwrap_or_default().fmt(f)
    }
}

/// A piece of error information
#[derive(Clone, Debug, PartialEq, Eq)]
#[non_exhaustive]
#[cfg(feature = "error-context")]
pub enum ContextValue {
    /// [`ContextKind`] is self-sufficient, no additional information needed
    None,
    /// A single value
    Bool(bool),
    /// A single value
    String(String),
    /// Many values
    Strings(Vec<String>),
    /// A single value
    StyledStr(crate::builder::StyledStr),
    /// many value
    StyledStrs(Vec<crate::builder::StyledStr>),
    /// A single value
    Number(isize),
}

impl std::fmt::Display for ContextValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::None => "".fmt(f),
            Self::Bool(v) => v.fmt(f),
            Self::String(v) => v.fmt(f),
            Self::Strings(v) => v.join(", ").fmt(f),
            Self::StyledStr(v) => v.fmt(f),
            Self::StyledStrs(v) => {
                for (i, v) in v.iter().enumerate() {
                    if i != 0 {
                        ", ".fmt(f)?;
                    }
                    v.fmt(f)?;
                }
                Ok(())
            }
            Self::Number(v) => v.fmt(f),
        }
    }
}

```

`clap/clap_builder/src/error/format.rs`:

```rs
#![allow(missing_copy_implementations)]
#![allow(missing_debug_implementations)]
#![cfg_attr(not(feature = "error-context"), allow(dead_code))]
#![cfg_attr(not(feature = "error-context"), allow(unused_imports))]

use std::borrow::Cow;

use crate::builder::Command;
use crate::builder::StyledStr;
use crate::builder::Styles;
#[cfg(feature = "error-context")]
use crate::error::ContextKind;
#[cfg(feature = "error-context")]
use crate::error::ContextValue;
use crate::error::ErrorKind;
use crate::output::TAB;
use crate::ArgAction;

/// Defines how to format an error for displaying to the user
pub trait ErrorFormatter: Sized {
    /// Stylize the error for the terminal
    fn format_error(error: &crate::error::Error<Self>) -> StyledStr;
}

/// Report [`ErrorKind`]
///
/// No context is included.
///
/// <div class="warning">
///
/// **NOTE:** Consider removing the `error-context` default feature if using this to remove all
/// overhead for [`RichFormatter`].
///
/// </div>
#[non_exhaustive]
pub struct KindFormatter;

impl ErrorFormatter for KindFormatter {
    fn format_error(error: &crate::error::Error<Self>) -> StyledStr {
        use std::fmt::Write as _;
        let styles = &error.inner.styles;

        let mut styled = StyledStr::new();
        start_error(&mut styled, styles);
        if let Some(msg) = error.kind().as_str() {
            styled.push_str(msg);
        } else if let Some(source) = error.inner.source.as_ref() {
            let _ = write!(styled, "{source}");
        } else {
            styled.push_str("unknown cause");
        }
        styled.push_str("\n");
        styled
    }
}

/// Richly formatted error context
///
/// This follows the [rustc diagnostic style guide](https://rustc-dev-guide.rust-lang.org/diagnostics.html#suggestion-style-guide).
#[non_exhaustive]
#[cfg(feature = "error-context")]
pub struct RichFormatter;

#[cfg(feature = "error-context")]
impl ErrorFormatter for RichFormatter {
    fn format_error(error: &crate::error::Error<Self>) -> StyledStr {
        use std::fmt::Write as _;
        let styles = &error.inner.styles;
        let valid = &styles.get_valid();

        let mut styled = StyledStr::new();
        start_error(&mut styled, styles);

        if !write_dynamic_context(error, &mut styled, styles) {
            if let Some(msg) = error.kind().as_str() {
                styled.push_str(msg);
            } else if let Some(source) = error.inner.source.as_ref() {
                let _ = write!(styled, "{source}");
            } else {
                styled.push_str("unknown cause");
            }
        }

        let mut suggested = false;
        if let Some(valid) = error.get(ContextKind::SuggestedSubcommand) {
            styled.push_str("\n");
            if !suggested {
                styled.push_str("\n");
                suggested = true;
            }
            did_you_mean(&mut styled, styles, "subcommand", valid);
        }
        if let Some(valid) = error.get(ContextKind::SuggestedArg) {
            styled.push_str("\n");
            if !suggested {
                styled.push_str("\n");
                suggested = true;
            }
            did_you_mean(&mut styled, styles, "argument", valid);
        }
        if let Some(valid) = error.get(ContextKind::SuggestedValue) {
            styled.push_str("\n");
            if !suggested {
                styled.push_str("\n");
                suggested = true;
            }
            did_you_mean(&mut styled, styles, "value", valid);
        }
        let suggestions = error.get(ContextKind::Suggested);
        if let Some(ContextValue::StyledStrs(suggestions)) = suggestions {
            if !suggested {
                styled.push_str("\n");
            }
            for suggestion in suggestions {
                let _ = write!(styled, "\n{TAB}{valid}tip:{valid:#} ",);
                styled.push_styled(suggestion);
            }
        }

        let usage = error.get(ContextKind::Usage);
        if let Some(ContextValue::StyledStr(usage)) = usage {
            put_usage(&mut styled, usage);
        }

        try_help(&mut styled, styles, error.inner.help_flag.as_deref());

        styled
    }
}

fn start_error(styled: &mut StyledStr, styles: &Styles) {
    use std::fmt::Write as _;
    let error = &styles.get_error();
    let _ = write!(styled, "{error}error:{error:#} ");
}

#[must_use]
#[cfg(feature = "error-context")]
fn write_dynamic_context(
    error: &crate::error::Error,
    styled: &mut StyledStr,
    styles: &Styles,
) -> bool {
    use std::fmt::Write as _;
    let valid = styles.get_valid();
    let invalid = styles.get_invalid();
    let literal = styles.get_literal();

    match error.kind() {
        ErrorKind::ArgumentConflict => {
            let mut prior_arg = error.get(ContextKind::PriorArg);
            if let Some(ContextValue::String(invalid_arg)) = error.get(ContextKind::InvalidArg) {
                if Some(&ContextValue::String(invalid_arg.clone())) == prior_arg {
                    prior_arg = None;
                    let _ = write!(
                        styled,
                        "the argument '{invalid}{invalid_arg}{invalid:#}' cannot be used multiple times",
                    );
                } else {
                    let _ = write!(
                        styled,
                        "the argument '{invalid}{invalid_arg}{invalid:#}' cannot be used with",
                    );
                }
            } else if let Some(ContextValue::String(invalid_arg)) =
                error.get(ContextKind::InvalidSubcommand)
            {
                let _ = write!(
                    styled,
                    "the subcommand '{invalid}{invalid_arg}{invalid:#}' cannot be used with",
                );
            } else {
                styled.push_str(error.kind().as_str().unwrap());
            }

            if let Some(prior_arg) = prior_arg {
                match prior_arg {
                    ContextValue::Strings(values) => {
                        styled.push_str(":");
                        for v in values {
                            let _ = write!(styled, "\n{TAB}{invalid}{v}{invalid:#}",);
                        }
                    }
                    ContextValue::String(value) => {
                        let _ = write!(styled, " '{invalid}{value}{invalid:#}'",);
                    }
                    _ => {
                        styled.push_str(" one or more of the other specified arguments");
                    }
                }
            }

            true
        }
        ErrorKind::NoEquals => {
            let invalid_arg = error.get(ContextKind::InvalidArg);
            if let Some(ContextValue::String(invalid_arg)) = invalid_arg {
                let _ = write!(
                    styled,
                    "equal sign is needed when assigning values to '{invalid}{invalid_arg}{invalid:#}'",
                );
                true
            } else {
                false
            }
        }
        ErrorKind::InvalidValue => {
            let invalid_arg = error.get(ContextKind::InvalidArg);
            let invalid_value = error.get(ContextKind::InvalidValue);
            if let (
                Some(ContextValue::String(invalid_arg)),
                Some(ContextValue::String(invalid_value)),
            ) = (invalid_arg, invalid_value)
            {
                if invalid_value.is_empty() {
                    let _ = write!(
                        styled,
                        "a value is required for '{invalid}{invalid_arg}{invalid:#}' but none was supplied",
                    );
                } else {
                    let _ = write!(
                        styled,
                        "invalid value '{invalid}{invalid_value}{invalid:#}' for '{literal}{invalid_arg}{literal:#}'",
                    );
                }

                let values = error.get(ContextKind::ValidValue);
                write_values_list("possible values", styled, valid, values);

                true
            } else {
                false
            }
        }
        ErrorKind::InvalidSubcommand => {
            let invalid_sub = error.get(ContextKind::InvalidSubcommand);
            if let Some(ContextValue::String(invalid_sub)) = invalid_sub {
                let _ = write!(
                    styled,
                    "unrecognized subcommand '{invalid}{invalid_sub}{invalid:#}'",
                );
                true
            } else {
                false
            }
        }
        ErrorKind::MissingRequiredArgument => {
            let invalid_arg = error.get(ContextKind::InvalidArg);
            if let Some(ContextValue::Strings(invalid_arg)) = invalid_arg {
                styled.push_str("the following required arguments were not provided:");
                for v in invalid_arg {
                    let _ = write!(styled, "\n{TAB}{valid}{v}{valid:#}",);
                }
                true
            } else {
                false
            }
        }
        ErrorKind::MissingSubcommand => {
            let invalid_sub = error.get(ContextKind::InvalidSubcommand);
            if let Some(ContextValue::String(invalid_sub)) = invalid_sub {
                let _ = write!(
                    styled,
                    "'{invalid}{invalid_sub}{invalid:#}' requires a subcommand but one was not provided",
                );
                let values = error.get(ContextKind::ValidSubcommand);
                write_values_list("subcommands", styled, valid, values);

                true
            } else {
                false
            }
        }
        ErrorKind::InvalidUtf8 => false,
        ErrorKind::TooManyValues => {
            let invalid_arg = error.get(ContextKind::InvalidArg);
            let invalid_value = error.get(ContextKind::InvalidValue);
            if let (
                Some(ContextValue::String(invalid_arg)),
                Some(ContextValue::String(invalid_value)),
            ) = (invalid_arg, invalid_value)
            {
                let _ = write!(
                    styled,
                    "unexpected value '{invalid}{invalid_value}{invalid:#}' for '{literal}{invalid_arg}{literal:#}' found; no more were expected",
                );
                true
            } else {
                false
            }
        }
        ErrorKind::TooFewValues => {
            let invalid_arg = error.get(ContextKind::InvalidArg);
            let actual_num_values = error.get(ContextKind::ActualNumValues);
            let min_values = error.get(ContextKind::MinValues);
            if let (
                Some(ContextValue::String(invalid_arg)),
                Some(ContextValue::Number(actual_num_values)),
                Some(ContextValue::Number(min_values)),
            ) = (invalid_arg, actual_num_values, min_values)
            {
                let were_provided = singular_or_plural(*actual_num_values as usize);
                let _ = write!(
                    styled,
                    "{valid}{min_values}{valid:#} values required by '{literal}{invalid_arg}{literal:#}'; only {invalid}{actual_num_values}{invalid:#}{were_provided}",
                );
                true
            } else {
                false
            }
        }
        ErrorKind::ValueValidation => {
            let invalid_arg = error.get(ContextKind::InvalidArg);
            let invalid_value = error.get(ContextKind::InvalidValue);
            if let (
                Some(ContextValue::String(invalid_arg)),
                Some(ContextValue::String(invalid_value)),
            ) = (invalid_arg, invalid_value)
            {
                let _ = write!(
                    styled,
                    "invalid value '{invalid}{invalid_value}{invalid:#}' for '{literal}{invalid_arg}{literal:#}'",
                );
                if let Some(source) = error.inner.source.as_deref() {
                    let _ = write!(styled, ": {source}");
                }
                true
            } else {
                false
            }
        }
        ErrorKind::WrongNumberOfValues => {
            let invalid_arg = error.get(ContextKind::InvalidArg);
            let actual_num_values = error.get(ContextKind::ActualNumValues);
            let num_values = error.get(ContextKind::ExpectedNumValues);
            if let (
                Some(ContextValue::String(invalid_arg)),
                Some(ContextValue::Number(actual_num_values)),
                Some(ContextValue::Number(num_values)),
            ) = (invalid_arg, actual_num_values, num_values)
            {
                let were_provided = singular_or_plural(*actual_num_values as usize);
                let _ = write!(
                    styled,
                    "{valid}{num_values}{valid:#} values required for '{literal}{invalid_arg}{literal:#}' but {invalid}{actual_num_values}{invalid:#}{were_provided}",
                );
                true
            } else {
                false
            }
        }
        ErrorKind::UnknownArgument => {
            let invalid_arg = error.get(ContextKind::InvalidArg);
            if let Some(ContextValue::String(invalid_arg)) = invalid_arg {
                let _ = write!(
                    styled,
                    "unexpected argument '{invalid}{invalid_arg}{invalid:#}' found",
                );
                true
            } else {
                false
            }
        }
        ErrorKind::DisplayHelp
        | ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand
        | ErrorKind::DisplayVersion
        | ErrorKind::Io
        | ErrorKind::Format => false,
    }
}

#[cfg(feature = "error-context")]
fn write_values_list(
    list_name: &'static str,
    styled: &mut StyledStr,
    valid: &anstyle::Style,
    possible_values: Option<&ContextValue>,
) {
    use std::fmt::Write as _;
    if let Some(ContextValue::Strings(possible_values)) = possible_values {
        if !possible_values.is_empty() {
            let _ = write!(styled, "\n{TAB}[{list_name}: ");

            for (idx, val) in possible_values.iter().enumerate() {
                if idx > 0 {
                    styled.push_str(", ");
                }
                let _ = write!(styled, "{valid}{}{valid:#}", Escape(val));
            }

            styled.push_str("]");
        }
    }
}

pub(crate) fn format_error_message(
    message: &str,
    styles: &Styles,
    cmd: Option<&Command>,
    usage: Option<&StyledStr>,
) -> StyledStr {
    let mut styled = StyledStr::new();
    start_error(&mut styled, styles);
    styled.push_str(message);
    if let Some(usage) = usage {
        put_usage(&mut styled, usage);
    }
    if let Some(cmd) = cmd {
        try_help(&mut styled, styles, get_help_flag(cmd).as_deref());
    }
    styled
}

/// Returns the singular or plural form on the verb to be based on the argument's value.
fn singular_or_plural(n: usize) -> &'static str {
    if n > 1 {
        " were provided"
    } else {
        " was provided"
    }
}

fn put_usage(styled: &mut StyledStr, usage: &StyledStr) {
    styled.push_str("\n\n");
    styled.push_styled(usage);
}

pub(crate) fn get_help_flag(cmd: &Command) -> Option<Cow<'static, str>> {
    if !cmd.is_disable_help_flag_set() {
        Some(Cow::Borrowed("--help"))
    } else if let Some(flag) = get_user_help_flag(cmd) {
        Some(Cow::Owned(flag))
    } else if cmd.has_subcommands() && !cmd.is_disable_help_subcommand_set() {
        Some(Cow::Borrowed("help"))
    } else {
        None
    }
}

fn get_user_help_flag(cmd: &Command) -> Option<String> {
    let arg = cmd.get_arguments().find(|arg| match arg.get_action() {
        ArgAction::Help | ArgAction::HelpShort | ArgAction::HelpLong => true,
        ArgAction::Append
        | ArgAction::Count
        | ArgAction::SetTrue
        | ArgAction::SetFalse
        | ArgAction::Set
        | ArgAction::Version => false,
    })?;

    arg.get_long()
        .map(|long| format!("--{long}"))
        .or_else(|| arg.get_short().map(|short| format!("-{short}")))
}

fn try_help(styled: &mut StyledStr, styles: &Styles, help: Option<&str>) {
    if let Some(help) = help {
        use std::fmt::Write as _;
        let literal = &styles.get_literal();
        let _ = write!(
            styled,
            "\n\nFor more information, try '{literal}{help}{literal:#}'.\n",
        );
    } else {
        styled.push_str("\n");
    }
}

#[cfg(feature = "error-context")]
fn did_you_mean(styled: &mut StyledStr, styles: &Styles, context: &str, possibles: &ContextValue) {
    use std::fmt::Write as _;

    let valid = &styles.get_valid();
    let _ = write!(styled, "{TAB}{valid}tip:{valid:#}",);
    if let ContextValue::String(possible) = possibles {
        let _ = write!(
            styled,
            " a similar {context} exists: '{valid}{possible}{valid:#}'",
        );
    } else if let ContextValue::Strings(possibles) = possibles {
        if possibles.len() == 1 {
            let _ = write!(styled, " a similar {context} exists: ",);
        } else {
            let _ = write!(styled, " some similar {context}s exist: ",);
        }
        for (i, possible) in possibles.iter().enumerate() {
            if i != 0 {
                styled.push_str(", ");
            }
            let _ = write!(styled, "'{valid}{possible}{valid:#}'",);
        }
    }
}

struct Escape<'s>(&'s str);

impl std::fmt::Display for Escape<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.0.contains(char::is_whitespace) {
            std::fmt::Debug::fmt(self.0, f)
        } else {
            self.0.fmt(f)
        }
    }
}

```

`clap/clap_builder/src/error/kind.rs`:

```rs
/// Command line argument parser kind of error
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[non_exhaustive]
pub enum ErrorKind {
    /// Occurs when an [`Arg`][crate::Arg] has a set of possible values,
    /// and the user provides a value which isn't in that set.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind};
    /// let result = Command::new("prog")
    ///     .arg(Arg::new("speed")
    ///         .value_parser(["fast", "slow"]))
    ///     .try_get_matches_from(vec!["prog", "other"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::InvalidValue);
    /// ```
    InvalidValue,

    /// Occurs when a user provides a flag, option, argument or subcommand which isn't defined.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg, error::ErrorKind};
    /// let result = Command::new("prog")
    ///     .arg(arg!(--flag "some flag"))
    ///     .try_get_matches_from(vec!["prog", "--other"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::UnknownArgument);
    /// ```
    UnknownArgument,

    /// Occurs when the user provides an unrecognized [`Subcommand`] which meets the threshold for
    /// being similar enough to an existing subcommand.
    /// If it doesn't meet the threshold, or the 'suggestions' feature is disabled,
    /// the more general [`UnknownArgument`] error is returned.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "suggestions")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, };
    /// let result = Command::new("prog")
    ///     .subcommand(Command::new("config")
    ///         .about("Used for configuration")
    ///         .arg(Arg::new("config_file")
    ///             .help("The configuration file to use")))
    ///     .try_get_matches_from(vec!["prog", "confi"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::InvalidSubcommand);
    /// # }
    /// ```
    ///
    /// [`Subcommand`]: crate::Subcommand
    /// [`UnknownArgument`]: ErrorKind::UnknownArgument
    InvalidSubcommand,

    /// Occurs when the user doesn't use equals for an option that requires equal
    /// sign to provide values.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let res = Command::new("prog")
    ///     .arg(Arg::new("color")
    ///          .action(ArgAction::Set)
    ///          .require_equals(true)
    ///          .long("color"))
    ///     .try_get_matches_from(vec!["prog", "--color", "red"]);
    /// assert!(res.is_err());
    /// assert_eq!(res.unwrap_err().kind(), ErrorKind::NoEquals);
    /// ```
    NoEquals,

    /// Occurs when the user provides a value for an argument with a custom validation and the
    /// value fails that validation.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, value_parser};
    /// fn is_numeric(val: &str) -> Result<(), String> {
    ///     match val.parse::<i64>() {
    ///         Ok(..) => Ok(()),
    ///         Err(..) => Err(String::from("value wasn't a number!")),
    ///     }
    /// }
    ///
    /// let result = Command::new("prog")
    ///     .arg(Arg::new("num")
    ///          .value_parser(value_parser!(u8)))
    ///     .try_get_matches_from(vec!["prog", "NotANumber"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::ValueValidation);
    /// ```
    ValueValidation,

    /// Occurs when a user provides more values for an argument than were defined by setting
    /// [`Arg::num_args`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind};
    /// let result = Command::new("prog")
    ///     .arg(Arg::new("arg")
    ///         .num_args(1..=2))
    ///     .try_get_matches_from(vec!["prog", "too", "many", "values"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::TooManyValues);
    /// ```
    /// [`Arg::num_args`]: crate::Arg::num_args()
    TooManyValues,

    /// Occurs when the user provides fewer values for an argument than were defined by setting
    /// [`Arg::num_args`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind};
    /// let result = Command::new("prog")
    ///     .arg(Arg::new("some_opt")
    ///         .long("opt")
    ///         .num_args(3..))
    ///     .try_get_matches_from(vec!["prog", "--opt", "too", "few"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::TooFewValues);
    /// ```
    /// [`Arg::num_args`]: crate::Arg::num_args()
    TooFewValues,

    /// Occurs when the user provides a different number of values for an argument than what's
    /// been defined by setting [`Arg::num_args`] or than was implicitly set by
    /// [`Arg::value_names`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let result = Command::new("prog")
    ///     .arg(Arg::new("some_opt")
    ///         .long("opt")
    ///         .action(ArgAction::Set)
    ///         .num_args(2))
    ///     .try_get_matches_from(vec!["prog", "--opt", "wrong"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::WrongNumberOfValues);
    /// ```
    ///
    /// [`Arg::num_args`]: crate::Arg::num_args()
    /// [`Arg::value_names`]: crate::Arg::value_names()
    WrongNumberOfValues,

    /// Occurs when the user provides two values which conflict with each other and can't be used
    /// together.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// let result = Command::new("prog")
    ///     .arg(Arg::new("debug")
    ///         .long("debug")
    ///         .action(ArgAction::SetTrue)
    ///         .conflicts_with("color"))
    ///     .arg(Arg::new("color")
    ///         .long("color")
    ///         .action(ArgAction::SetTrue))
    ///     .try_get_matches_from(vec!["prog", "--debug", "--color"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::ArgumentConflict);
    /// ```
    ArgumentConflict,

    /// Occurs when the user does not provide one or more required arguments.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind};
    /// let result = Command::new("prog")
    ///     .arg(Arg::new("debug")
    ///         .required(true))
    ///     .try_get_matches_from(vec!["prog"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
    /// ```
    MissingRequiredArgument,

    /// Occurs when a subcommand is required (as defined by [`Command::subcommand_required`]),
    /// but the user does not provide one.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, error::ErrorKind};
    /// let err = Command::new("prog")
    ///     .subcommand_required(true)
    ///     .subcommand(Command::new("test"))
    ///     .try_get_matches_from(vec![
    ///         "myprog",
    ///     ]);
    /// assert!(err.is_err());
    /// assert_eq!(err.unwrap_err().kind(), ErrorKind::MissingSubcommand);
    /// # ;
    /// ```
    ///
    /// [`Command::subcommand_required`]: crate::Command::subcommand_required
    MissingSubcommand,

    /// Occurs when the user provides a value containing invalid UTF-8.
    ///
    /// To allow arbitrary data
    /// - Set [`Arg::value_parser(value_parser!(OsString))`] for argument values
    /// - Set [`Command::external_subcommand_value_parser`] for external-subcommand
    ///   values
    ///
    /// # Platform Specific
    ///
    /// Non-Windows platforms only (such as Linux, Unix, OSX, etc.)
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(unix)] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, ArgAction};
    /// # use std::os::unix::ffi::OsStringExt;
    /// # use std::ffi::OsString;
    /// let result = Command::new("prog")
    ///     .arg(Arg::new("utf8")
    ///         .short('u')
    ///         .action(ArgAction::Set))
    ///     .try_get_matches_from(vec![OsString::from("myprog"),
    ///                                 OsString::from("-u"),
    ///                                 OsString::from_vec(vec![0xE9])]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::InvalidUtf8);
    /// # }
    /// ```
    ///
    /// [`Arg::allow_invalid_utf8`]: crate::Arg::allow_invalid_utf8
    /// [`Command::external_subcommand_value_parser`]: crate::Command::external_subcommand_value_parser
    InvalidUtf8,

    /// Not a true "error" as it means `--help` or similar was used.
    /// The help message will be sent to `stdout`.
    ///
    /// **Note**: If the help is displayed due to an error (such as missing subcommands) it will
    /// be sent to `stderr` instead of `stdout`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "help")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind};
    /// let result = Command::new("prog")
    ///     .try_get_matches_from(vec!["prog", "--help"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::DisplayHelp);
    /// # }
    /// ```
    DisplayHelp,

    /// Occurs when either an argument or a [`Subcommand`] is required, as defined by
    /// [`Command::arg_required_else_help`] , but the user did not provide
    /// one.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind, };
    /// let result = Command::new("prog")
    ///     .arg_required_else_help(true)
    ///     .subcommand(Command::new("config")
    ///         .about("Used for configuration")
    ///         .arg(Arg::new("config_file")
    ///             .help("The configuration file to use")))
    ///     .try_get_matches_from(vec!["prog"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand);
    /// ```
    ///
    /// [`Subcommand`]: crate::Subcommand
    /// [`Command::arg_required_else_help`]: crate::Command::arg_required_else_help
    DisplayHelpOnMissingArgumentOrSubcommand,

    /// Not a true "error" as it means `--version` or similar was used.
    /// The message will be sent to `stdout`.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, error::ErrorKind};
    /// let result = Command::new("prog")
    ///     .version("3.0")
    ///     .try_get_matches_from(vec!["prog", "--version"]);
    /// assert!(result.is_err());
    /// assert_eq!(result.unwrap_err().kind(), ErrorKind::DisplayVersion);
    /// ```
    DisplayVersion,

    /// Represents an [I/O error].
    /// Can occur when writing to `stderr` or `stdout` or reading a configuration file.
    ///
    /// [I/O error]: std::io::Error
    Io,

    /// Represents a [Format error] (which is a part of [`Display`]).
    /// Typically caused by writing to `stderr` or `stdout`.
    ///
    /// [`Display`]: std::fmt::Display
    /// [Format error]: std::fmt::Error
    Format,
}

impl ErrorKind {
    /// End-user description of the error case, where relevant
    pub fn as_str(self) -> Option<&'static str> {
        match self {
            Self::InvalidValue => Some("one of the values isn't valid for an argument"),
            Self::UnknownArgument => Some("unexpected argument found"),
            Self::InvalidSubcommand => Some("unrecognized subcommand"),
            Self::NoEquals => Some("equal is needed when assigning values to one of the arguments"),
            Self::ValueValidation => Some("invalid value for one of the arguments"),
            Self::TooManyValues => Some("unexpected value for an argument found"),
            Self::TooFewValues => Some("more values required for an argument"),
            Self::WrongNumberOfValues => Some("too many or too few values for an argument"),
            Self::ArgumentConflict => {
                Some("an argument cannot be used with one or more of the other specified arguments")
            }
            Self::MissingRequiredArgument => {
                Some("one or more required arguments were not provided")
            }
            Self::MissingSubcommand => Some("a subcommand is required but one was not provided"),
            Self::InvalidUtf8 => Some("invalid UTF-8 was detected in one or more arguments"),
            Self::DisplayHelp => None,
            Self::DisplayHelpOnMissingArgumentOrSubcommand => None,
            Self::DisplayVersion => None,
            Self::Io => None,
            Self::Format => None,
        }
    }
}

impl std::fmt::Display for ErrorKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.as_str().unwrap_or_default().fmt(f)
    }
}

```

`clap/clap_builder/src/error/mod.rs`:

```rs
//! Error reporting

#![cfg_attr(not(feature = "error-context"), allow(dead_code))]
#![cfg_attr(not(feature = "error-context"), allow(unused_imports))]
#![cfg_attr(not(feature = "error-context"), allow(unused_variables))]
#![cfg_attr(not(feature = "error-context"), allow(unused_mut))]
#![cfg_attr(not(feature = "error-context"), allow(clippy::let_and_return))]

// Std
use std::{
    borrow::Cow,
    convert::From,
    error,
    fmt::{self, Debug, Display, Formatter},
    io,
    result::Result as StdResult,
};

// Internal
use crate::builder::StyledStr;
use crate::builder::Styles;
use crate::output::fmt::Colorizer;
use crate::output::fmt::Stream;
use crate::parser::features::suggestions;
use crate::util::FlatMap;
use crate::util::{color::ColorChoice, SUCCESS_CODE, USAGE_CODE};
use crate::Command;

#[cfg(feature = "error-context")]
mod context;
mod format;
mod kind;

pub use format::ErrorFormatter;
pub use format::KindFormatter;
pub use kind::ErrorKind;

#[cfg(feature = "error-context")]
pub use context::ContextKind;
#[cfg(feature = "error-context")]
pub use context::ContextValue;
#[cfg(feature = "error-context")]
pub use format::RichFormatter;

#[cfg(not(feature = "error-context"))]
pub use KindFormatter as DefaultFormatter;
#[cfg(feature = "error-context")]
pub use RichFormatter as DefaultFormatter;

/// Short hand for [`Result`] type
///
/// [`Result`]: std::result::Result
pub type Result<T, E = Error> = StdResult<T, E>;

/// Command Line Argument Parser Error
///
/// See [`Command::error`] to create an error.
///
/// [`Command::error`]: crate::Command::error
pub struct Error<F: ErrorFormatter = DefaultFormatter> {
    inner: Box<ErrorInner>,
    phantom: std::marker::PhantomData<F>,
}

#[derive(Debug)]
struct ErrorInner {
    kind: ErrorKind,
    #[cfg(feature = "error-context")]
    context: FlatMap<ContextKind, ContextValue>,
    message: Option<Message>,
    source: Option<Box<dyn error::Error + Send + Sync>>,
    help_flag: Option<Cow<'static, str>>,
    styles: Styles,
    color_when: ColorChoice,
    color_help_when: ColorChoice,
    backtrace: Option<Backtrace>,
}

impl<F: ErrorFormatter> Error<F> {
    /// Create an unformatted error
    ///
    /// This is for you need to pass the error up to
    /// a place that has access to the `Command` at which point you can call [`Error::format`].
    ///
    /// Prefer [`Command::error`] for generating errors.
    ///
    /// [`Command::error`]: crate::Command::error
    pub fn raw(kind: ErrorKind, message: impl Display) -> Self {
        Self::new(kind).set_message(message.to_string())
    }

    /// Format the existing message with the Command's context
    #[must_use]
    pub fn format(mut self, cmd: &mut Command) -> Self {
        cmd._build_self(false);
        let usage = cmd.render_usage_();
        if let Some(message) = self.inner.message.as_mut() {
            message.format(cmd, usage);
        }
        self.with_cmd(cmd)
    }

    /// Create an error with a pre-defined message
    ///
    /// See also
    /// - [`Error::insert`]
    /// - [`Error::with_cmd`]
    ///
    /// # Example
    ///
    /// ```rust
    /// # #[cfg(feature = "error-context")] {
    /// # use clap_builder as clap;
    /// # use clap::error::ErrorKind;
    /// # use clap::error::ContextKind;
    /// # use clap::error::ContextValue;
    ///
    /// let cmd = clap::Command::new("prog");
    ///
    /// let mut err = clap::Error::new(ErrorKind::ValueValidation)
    ///     .with_cmd(&cmd);
    /// err.insert(ContextKind::InvalidArg, ContextValue::String("--foo".to_owned()));
    /// err.insert(ContextKind::InvalidValue, ContextValue::String("bar".to_owned()));
    ///
    /// err.print();
    /// # }
    /// ```
    pub fn new(kind: ErrorKind) -> Self {
        Self {
            inner: Box::new(ErrorInner {
                kind,
                #[cfg(feature = "error-context")]
                context: FlatMap::new(),
                message: None,
                source: None,
                help_flag: None,
                styles: Styles::plain(),
                color_when: ColorChoice::Never,
                color_help_when: ColorChoice::Never,
                backtrace: Backtrace::new(),
            }),
            phantom: Default::default(),
        }
    }

    /// Apply [`Command`]'s formatting to the error
    ///
    /// Generally, this is used with [`Error::new`]
    pub fn with_cmd(self, cmd: &Command) -> Self {
        self.set_styles(cmd.get_styles().clone())
            .set_color(cmd.get_color())
            .set_colored_help(cmd.color_help())
            .set_help_flag(format::get_help_flag(cmd))
    }

    /// Apply an alternative formatter to the error
    ///
    /// # Example
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// # use clap::error::KindFormatter;
    /// let cmd = Command::new("foo")
    ///     .arg(Arg::new("input").required(true));
    /// let matches = cmd
    ///     .try_get_matches_from(["foo", "input.txt"])
    ///     .map_err(|e| e.apply::<KindFormatter>())
    ///     .unwrap_or_else(|e| e.exit());
    /// ```
    pub fn apply<EF: ErrorFormatter>(self) -> Error<EF> {
        Error {
            inner: self.inner,
            phantom: Default::default(),
        }
    }

    /// Type of error for programmatic processing
    pub fn kind(&self) -> ErrorKind {
        self.inner.kind
    }

    /// Additional information to further qualify the error
    #[cfg(feature = "error-context")]
    pub fn context(&self) -> impl Iterator<Item = (ContextKind, &ContextValue)> {
        self.inner.context.iter().map(|(k, v)| (*k, v))
    }

    /// Lookup a piece of context
    #[inline(never)]
    #[cfg(feature = "error-context")]
    pub fn get(&self, kind: ContextKind) -> Option<&ContextValue> {
        self.inner.context.get(&kind)
    }

    /// Insert a piece of context
    ///
    /// If this `ContextKind` is already present, its value is replaced and the old value is returned.
    #[inline(never)]
    #[cfg(feature = "error-context")]
    pub fn insert(&mut self, kind: ContextKind, value: ContextValue) -> Option<ContextValue> {
        self.inner.context.insert(kind, value)
    }

    /// Remove a piece of context, return the old value if any
    ///
    /// The context is currently implemented in a vector, so `remove` takes
    /// linear time.
    #[inline(never)]
    #[cfg(feature = "error-context")]
    pub fn remove(&mut self, kind: ContextKind) -> Option<ContextValue> {
        self.inner.context.remove(&kind)
    }

    /// Should the message be written to `stdout` or not?
    #[inline]
    pub fn use_stderr(&self) -> bool {
        self.stream() == Stream::Stderr
    }

    pub(crate) fn stream(&self) -> Stream {
        match self.kind() {
            ErrorKind::DisplayHelp | ErrorKind::DisplayVersion => Stream::Stdout,
            _ => Stream::Stderr,
        }
    }

    /// Returns the exit code that `.exit` will exit the process with.
    ///
    /// When the error's kind would print to `stderr` this returns `2`,
    /// else it returns `0`.
    pub fn exit_code(&self) -> i32 {
        if self.use_stderr() {
            USAGE_CODE
        } else {
            SUCCESS_CODE
        }
    }

    /// Prints the error and exits.
    ///
    /// Depending on the error kind, this either prints to `stderr` and exits with a status of `2`
    /// or prints to `stdout` and exits with a status of `0`.
    pub fn exit(&self) -> ! {
        // Swallow broken pipe errors
        let _ = self.print();
        std::process::exit(self.exit_code());
    }

    /// Prints formatted and colored error to `stdout` or `stderr` according to its error kind
    ///
    /// # Example
    /// ```no_run
    /// # use clap_builder as clap;
    /// use clap::Command;
    ///
    /// match Command::new("Command").try_get_matches() {
    ///     Ok(matches) => {
    ///         // do_something
    ///     },
    ///     Err(err) => {
    ///         err.print().expect("Error writing Error");
    ///         // do_something
    ///     },
    /// };
    /// ```
    pub fn print(&self) -> io::Result<()> {
        let style = self.formatted();
        let color_when = if matches!(
            self.kind(),
            ErrorKind::DisplayHelp | ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand,
        ) {
            self.inner.color_help_when
        } else {
            self.inner.color_when
        };
        let c = Colorizer::new(self.stream(), color_when).with_content(style.into_owned());
        c.print()
    }

    /// Render the error message to a [`StyledStr`].
    ///
    /// # Example
    /// ```no_run
    /// # use clap_builder as clap;
    /// use clap::Command;
    ///
    /// match Command::new("Command").try_get_matches() {
    ///     Ok(matches) => {
    ///         // do_something
    ///     },
    ///     Err(err) => {
    ///         let err = err.render();
    ///         println!("{err}");
    ///         // do_something
    ///     },
    /// };
    /// ```
    pub fn render(&self) -> StyledStr {
        self.formatted().into_owned()
    }

    #[inline(never)]
    fn for_app(kind: ErrorKind, cmd: &Command, styled: StyledStr) -> Self {
        Self::new(kind).set_message(styled).with_cmd(cmd)
    }

    pub(crate) fn set_message(mut self, message: impl Into<Message>) -> Self {
        self.inner.message = Some(message.into());
        self
    }

    pub(crate) fn set_source(mut self, source: Box<dyn error::Error + Send + Sync>) -> Self {
        self.inner.source = Some(source);
        self
    }

    pub(crate) fn set_styles(mut self, styles: Styles) -> Self {
        self.inner.styles = styles;
        self
    }

    pub(crate) fn set_color(mut self, color_when: ColorChoice) -> Self {
        self.inner.color_when = color_when;
        self
    }

    pub(crate) fn set_colored_help(mut self, color_help_when: ColorChoice) -> Self {
        self.inner.color_help_when = color_help_when;
        self
    }

    pub(crate) fn set_help_flag(mut self, help_flag: Option<Cow<'static, str>>) -> Self {
        self.inner.help_flag = help_flag;
        self
    }

    /// Does not verify if `ContextKind` is already present
    #[inline(never)]
    #[cfg(feature = "error-context")]
    pub(crate) fn insert_context_unchecked(
        mut self,
        kind: ContextKind,
        value: ContextValue,
    ) -> Self {
        self.inner.context.insert_unchecked(kind, value);
        self
    }

    /// Does not verify if `ContextKind` is already present
    #[inline(never)]
    #[cfg(feature = "error-context")]
    pub(crate) fn extend_context_unchecked<const N: usize>(
        mut self,
        context: [(ContextKind, ContextValue); N],
    ) -> Self {
        self.inner.context.extend_unchecked(context);
        self
    }

    pub(crate) fn display_help(cmd: &Command, styled: StyledStr) -> Self {
        Self::for_app(ErrorKind::DisplayHelp, cmd, styled)
    }

    pub(crate) fn display_help_error(cmd: &Command, styled: StyledStr) -> Self {
        Self::for_app(
            ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand,
            cmd,
            styled,
        )
    }

    pub(crate) fn display_version(cmd: &Command, styled: StyledStr) -> Self {
        Self::for_app(ErrorKind::DisplayVersion, cmd, styled)
    }

    pub(crate) fn argument_conflict(
        cmd: &Command,
        arg: String,
        mut others: Vec<String>,
        usage: Option<StyledStr>,
    ) -> Self {
        let mut err = Self::new(ErrorKind::ArgumentConflict).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            let others = match others.len() {
                0 => ContextValue::None,
                1 => ContextValue::String(others.pop().unwrap()),
                _ => ContextValue::Strings(others),
            };
            err = err.extend_context_unchecked([
                (ContextKind::InvalidArg, ContextValue::String(arg)),
                (ContextKind::PriorArg, others),
            ]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn subcommand_conflict(
        cmd: &Command,
        sub: String,
        mut others: Vec<String>,
        usage: Option<StyledStr>,
    ) -> Self {
        let mut err = Self::new(ErrorKind::ArgumentConflict).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            let others = match others.len() {
                0 => ContextValue::None,
                1 => ContextValue::String(others.pop().unwrap()),
                _ => ContextValue::Strings(others),
            };
            err = err.extend_context_unchecked([
                (ContextKind::InvalidSubcommand, ContextValue::String(sub)),
                (ContextKind::PriorArg, others),
            ]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn empty_value(cmd: &Command, good_vals: &[String], arg: String) -> Self {
        Self::invalid_value(cmd, "".to_owned(), good_vals, arg)
    }

    pub(crate) fn no_equals(cmd: &Command, arg: String, usage: Option<StyledStr>) -> Self {
        let mut err = Self::new(ErrorKind::NoEquals).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            err = err
                .extend_context_unchecked([(ContextKind::InvalidArg, ContextValue::String(arg))]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn invalid_value(
        cmd: &Command,
        bad_val: String,
        good_vals: &[String],
        arg: String,
    ) -> Self {
        let suggestion = suggestions::did_you_mean(&bad_val, good_vals.iter()).pop();
        let mut err = Self::new(ErrorKind::InvalidValue).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            err = err.extend_context_unchecked([
                (ContextKind::InvalidArg, ContextValue::String(arg)),
                (ContextKind::InvalidValue, ContextValue::String(bad_val)),
                (
                    ContextKind::ValidValue,
                    ContextValue::Strings(good_vals.iter().map(|s| (*s).clone()).collect()),
                ),
            ]);
            if let Some(suggestion) = suggestion {
                err = err.insert_context_unchecked(
                    ContextKind::SuggestedValue,
                    ContextValue::String(suggestion),
                );
            }
        }

        err
    }

    pub(crate) fn invalid_subcommand(
        cmd: &Command,
        subcmd: String,
        did_you_mean: Vec<String>,
        name: String,
        suggested_trailing_arg: bool,
        usage: Option<StyledStr>,
    ) -> Self {
        use std::fmt::Write as _;
        let styles = cmd.get_styles();
        let invalid = &styles.get_invalid();
        let valid = &styles.get_valid();
        let mut err = Self::new(ErrorKind::InvalidSubcommand).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            let mut suggestions = vec![];
            if suggested_trailing_arg {
                let mut styled_suggestion = StyledStr::new();
                let _ = write!(
                    styled_suggestion,
                    "to pass '{invalid}{subcmd}{invalid:#}' as a value, use '{valid}{name} -- {subcmd}{valid:#}'",
                );
                suggestions.push(styled_suggestion);
            }

            err = err.extend_context_unchecked([
                (ContextKind::InvalidSubcommand, ContextValue::String(subcmd)),
                (
                    ContextKind::SuggestedSubcommand,
                    ContextValue::Strings(did_you_mean),
                ),
                (
                    ContextKind::Suggested,
                    ContextValue::StyledStrs(suggestions),
                ),
            ]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn unrecognized_subcommand(
        cmd: &Command,
        subcmd: String,
        usage: Option<StyledStr>,
    ) -> Self {
        let mut err = Self::new(ErrorKind::InvalidSubcommand).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            err = err.extend_context_unchecked([(
                ContextKind::InvalidSubcommand,
                ContextValue::String(subcmd),
            )]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn missing_required_argument(
        cmd: &Command,
        required: Vec<String>,
        usage: Option<StyledStr>,
    ) -> Self {
        let mut err = Self::new(ErrorKind::MissingRequiredArgument).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            err = err.extend_context_unchecked([(
                ContextKind::InvalidArg,
                ContextValue::Strings(required),
            )]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn missing_subcommand(
        cmd: &Command,
        parent: String,
        available: Vec<String>,
        usage: Option<StyledStr>,
    ) -> Self {
        let mut err = Self::new(ErrorKind::MissingSubcommand).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            err = err.extend_context_unchecked([
                (ContextKind::InvalidSubcommand, ContextValue::String(parent)),
                (
                    ContextKind::ValidSubcommand,
                    ContextValue::Strings(available),
                ),
            ]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn invalid_utf8(cmd: &Command, usage: Option<StyledStr>) -> Self {
        let mut err = Self::new(ErrorKind::InvalidUtf8).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn too_many_values(
        cmd: &Command,
        val: String,
        arg: String,
        usage: Option<StyledStr>,
    ) -> Self {
        let mut err = Self::new(ErrorKind::TooManyValues).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            err = err.extend_context_unchecked([
                (ContextKind::InvalidArg, ContextValue::String(arg)),
                (ContextKind::InvalidValue, ContextValue::String(val)),
            ]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn too_few_values(
        cmd: &Command,
        arg: String,
        min_vals: usize,
        curr_vals: usize,
        usage: Option<StyledStr>,
    ) -> Self {
        let mut err = Self::new(ErrorKind::TooFewValues).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            err = err.extend_context_unchecked([
                (ContextKind::InvalidArg, ContextValue::String(arg)),
                (
                    ContextKind::MinValues,
                    ContextValue::Number(min_vals as isize),
                ),
                (
                    ContextKind::ActualNumValues,
                    ContextValue::Number(curr_vals as isize),
                ),
            ]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn value_validation(
        arg: String,
        val: String,
        err: Box<dyn error::Error + Send + Sync>,
    ) -> Self {
        let mut err = Self::new(ErrorKind::ValueValidation).set_source(err);

        #[cfg(feature = "error-context")]
        {
            err = err.extend_context_unchecked([
                (ContextKind::InvalidArg, ContextValue::String(arg)),
                (ContextKind::InvalidValue, ContextValue::String(val)),
            ]);
        }

        err
    }

    pub(crate) fn wrong_number_of_values(
        cmd: &Command,
        arg: String,
        num_vals: usize,
        curr_vals: usize,
        usage: Option<StyledStr>,
    ) -> Self {
        let mut err = Self::new(ErrorKind::WrongNumberOfValues).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            err = err.extend_context_unchecked([
                (ContextKind::InvalidArg, ContextValue::String(arg)),
                (
                    ContextKind::ExpectedNumValues,
                    ContextValue::Number(num_vals as isize),
                ),
                (
                    ContextKind::ActualNumValues,
                    ContextValue::Number(curr_vals as isize),
                ),
            ]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    pub(crate) fn unknown_argument(
        cmd: &Command,
        arg: String,
        did_you_mean: Option<(String, Option<String>)>,
        suggested_trailing_arg: bool,
        usage: Option<StyledStr>,
    ) -> Self {
        use std::fmt::Write as _;
        let styles = cmd.get_styles();
        let invalid = &styles.get_invalid();
        let valid = &styles.get_valid();
        let mut err = Self::new(ErrorKind::UnknownArgument).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            let mut suggestions = vec![];
            if suggested_trailing_arg {
                let mut styled_suggestion = StyledStr::new();
                let _ = write!(
                    styled_suggestion,
                    "to pass '{invalid}{arg}{invalid:#}' as a value, use '{valid}-- {arg}{valid:#}'",
                );
                suggestions.push(styled_suggestion);
            }

            err = err
                .extend_context_unchecked([(ContextKind::InvalidArg, ContextValue::String(arg))]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
            match did_you_mean {
                Some((flag, Some(sub))) => {
                    let mut styled_suggestion = StyledStr::new();
                    let _ = write!(styled_suggestion, "'{valid}{sub} {flag}{valid:#}' exists",);
                    suggestions.push(styled_suggestion);
                }
                Some((flag, None)) => {
                    err = err.insert_context_unchecked(
                        ContextKind::SuggestedArg,
                        ContextValue::String(flag),
                    );
                }
                None => {}
            }
            if !suggestions.is_empty() {
                err = err.insert_context_unchecked(
                    ContextKind::Suggested,
                    ContextValue::StyledStrs(suggestions),
                );
            }
        }

        err
    }

    pub(crate) fn unnecessary_double_dash(
        cmd: &Command,
        arg: String,
        usage: Option<StyledStr>,
    ) -> Self {
        use std::fmt::Write as _;
        let styles = cmd.get_styles();
        let invalid = &styles.get_invalid();
        let valid = &styles.get_valid();
        let mut err = Self::new(ErrorKind::UnknownArgument).with_cmd(cmd);

        #[cfg(feature = "error-context")]
        {
            let mut styled_suggestion = StyledStr::new();
            let _ = write!(
                styled_suggestion,
                "subcommand '{valid}{arg}{valid:#}' exists; to use it, remove the '{invalid}--{invalid:#}' before it",
            );

            err = err.extend_context_unchecked([
                (ContextKind::InvalidArg, ContextValue::String(arg)),
                (
                    ContextKind::Suggested,
                    ContextValue::StyledStrs(vec![styled_suggestion]),
                ),
            ]);
            if let Some(usage) = usage {
                err = err
                    .insert_context_unchecked(ContextKind::Usage, ContextValue::StyledStr(usage));
            }
        }

        err
    }

    fn formatted(&self) -> Cow<'_, StyledStr> {
        if let Some(message) = self.inner.message.as_ref() {
            message.formatted(&self.inner.styles)
        } else {
            let styled = F::format_error(self);
            Cow::Owned(styled)
        }
    }
}

impl<F: ErrorFormatter> From<io::Error> for Error<F> {
    fn from(e: io::Error) -> Self {
        Error::raw(ErrorKind::Io, e)
    }
}

impl<F: ErrorFormatter> From<fmt::Error> for Error<F> {
    fn from(e: fmt::Error) -> Self {
        Error::raw(ErrorKind::Format, e)
    }
}

impl<F: ErrorFormatter> Debug for Error<F> {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), fmt::Error> {
        self.inner.fmt(f)
    }
}

impl<F: ErrorFormatter> error::Error for Error<F> {
    #[allow(trivial_casts)]
    fn source(&self) -> Option<&(dyn error::Error + 'static)> {
        self.inner.source.as_ref().map(|e| e.as_ref() as _)
    }
}

impl<F: ErrorFormatter> Display for Error<F> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        // Assuming `self.message` already has a trailing newline, from `try_help` or similar
        ok!(write!(f, "{}", self.formatted()));
        if let Some(backtrace) = self.inner.backtrace.as_ref() {
            ok!(writeln!(f));
            ok!(writeln!(f, "Backtrace:"));
            ok!(writeln!(f, "{backtrace}"));
        }
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub(crate) enum Message {
    Raw(String),
    Formatted(StyledStr),
}

impl Message {
    fn format(&mut self, cmd: &Command, usage: Option<StyledStr>) {
        match self {
            Message::Raw(s) => {
                let mut message = String::new();
                std::mem::swap(s, &mut message);

                let styled = format::format_error_message(
                    &message,
                    cmd.get_styles(),
                    Some(cmd),
                    usage.as_ref(),
                );

                *self = Self::Formatted(styled);
            }
            Message::Formatted(_) => {}
        }
    }

    fn formatted(&self, styles: &Styles) -> Cow<'_, StyledStr> {
        match self {
            Message::Raw(s) => {
                let styled = format::format_error_message(s, styles, None, None);

                Cow::Owned(styled)
            }
            Message::Formatted(s) => Cow::Borrowed(s),
        }
    }
}

impl From<String> for Message {
    fn from(inner: String) -> Self {
        Self::Raw(inner)
    }
}

impl From<StyledStr> for Message {
    fn from(inner: StyledStr) -> Self {
        Self::Formatted(inner)
    }
}

#[cfg(feature = "debug")]
#[derive(Debug)]
struct Backtrace(backtrace::Backtrace);

#[cfg(feature = "debug")]
impl Backtrace {
    fn new() -> Option<Self> {
        Some(Self(backtrace::Backtrace::new()))
    }
}

#[cfg(feature = "debug")]
impl Display for Backtrace {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        // `backtrace::Backtrace` uses `Debug` instead of `Display`
        write!(f, "{:?}", self.0)
    }
}

#[cfg(not(feature = "debug"))]
#[derive(Debug)]
struct Backtrace;

#[cfg(not(feature = "debug"))]
impl Backtrace {
    fn new() -> Option<Self> {
        None
    }
}

#[cfg(not(feature = "debug"))]
impl Display for Backtrace {
    fn fmt(&self, _: &mut Formatter<'_>) -> fmt::Result {
        Ok(())
    }
}

#[test]
fn check_auto_traits() {
    static_assertions::assert_impl_all!(Error: Send, Sync, Unpin);
}

```

`clap/clap_builder/src/lib.rs`:

```rs
// Copyright ⓒ 2015-2016 Kevin B. Knapp and [`clap-rs` contributors](https://github.com/clap-rs/clap/graphs/contributors).
// Licensed under the MIT license
// (see LICENSE or <http://opensource.org/licenses/MIT>) All files in the project carrying such
// notice may not be copied, modified, or distributed except according to those terms.

#![doc = include_str!("../README.md")]
#![doc(html_logo_url = "https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png")]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![forbid(unsafe_code)]
#![warn(missing_docs)]
#![warn(clippy::print_stderr)]
#![warn(clippy::print_stdout)]

#[cfg(not(feature = "std"))]
compile_error!("`std` feature is currently required to build `clap`");

pub use crate::builder::ArgAction;
pub use crate::builder::Command;
pub use crate::builder::ValueHint;
pub use crate::builder::{Arg, ArgGroup};
pub use crate::parser::ArgMatches;
pub use crate::util::color::ColorChoice;
pub use crate::util::Id;

/// Command Line Argument Parser Error
///
/// See [`Command::error`] to create an error.
///
/// [`Command::error`]: crate::Command::error
pub type Error = error::Error<error::DefaultFormatter>;

pub use crate::derive::{Args, CommandFactory, FromArgMatches, Parser, Subcommand, ValueEnum};

#[macro_use]
#[allow(missing_docs)]
mod macros;

mod derive;

pub mod builder;
pub mod error;
pub mod parser;

mod mkeymap;
mod output;
mod util;

const INTERNAL_ERROR_MSG: &str = "Fatal internal error. Please consider filing a bug \
                                  report at https://github.com/clap-rs/clap/issues";

```

`clap/clap_builder/src/macros.rs`:

```rs
/// Allows you to pull the version from your Cargo.toml at compile time as
/// `MAJOR.MINOR.PATCH_PKGVERSION_PRE`
///
/// # Examples
///
/// ```no_run
/// # use clap_builder as clap;
/// # use clap::crate_version;
/// # use clap::Command;
/// let m = Command::new("cmd")
///             .version(crate_version!())
///             .get_matches();
/// ```
#[cfg(feature = "cargo")]
#[macro_export]
macro_rules! crate_version {
    () => {
        env!("CARGO_PKG_VERSION")
    };
}

/// Allows you to pull the authors for the command from your Cargo.toml at
/// compile time in the form:
/// `"author1 lastname <author1@example.com>:author2 lastname <author2@example.com>"`
///
/// You can replace the colons with a custom separator by supplying a
/// replacement string, so, for example,
/// `crate_authors!(",\n")` would become
/// `"author1 lastname <author1@example.com>,\nauthor2 lastname <author2@example.com>,\nauthor3 lastname <author3@example.com>"`
///
/// # Examples
///
/// ```no_run
/// # use clap_builder as clap;
/// # use clap::crate_authors;
/// # use clap::Command;
/// let m = Command::new("cmd")
///             .author(crate_authors!("\n"))
///             .get_matches();
/// ```
#[cfg(feature = "cargo")]
#[macro_export]
macro_rules! crate_authors {
    ($sep:expr) => {{
        static AUTHORS: &str = env!("CARGO_PKG_AUTHORS");
        if AUTHORS.contains(':') {
            static CACHED: std::sync::OnceLock<String> = std::sync::OnceLock::new();
            let s = CACHED.get_or_init(|| AUTHORS.replace(':', $sep));
            let s: &'static str = &*s;
            s
        } else {
            AUTHORS
        }
    }};
    () => {
        env!("CARGO_PKG_AUTHORS")
    };
}

/// Allows you to pull the description from your Cargo.toml at compile time.
///
/// # Examples
///
/// ```no_run
/// # use clap_builder as clap;
/// # use clap::crate_description;
/// # use clap::Command;
/// let m = Command::new("cmd")
///             .about(crate_description!())
///             .get_matches();
/// ```
#[cfg(feature = "cargo")]
#[macro_export]
macro_rules! crate_description {
    () => {
        env!("CARGO_PKG_DESCRIPTION")
    };
}

/// Allows you to pull the name from your Cargo.toml at compile time.
///
/// <div class="warning">
///
/// **NOTE:** This macro extracts the name from an environment variable `CARGO_PKG_NAME`.
/// When the crate name is set to something different from the package name,
/// use environment variables `CARGO_CRATE_NAME` or `CARGO_BIN_NAME`.
/// See [the Cargo Book](https://doc.rust-lang.org/cargo/reference/environment-variables.html)
/// for more information.
///
/// </div>
///
/// # Examples
///
/// ```no_run
/// # use clap_builder as clap;
/// # use clap::crate_name;
/// # use clap::Command;
/// let m = Command::new(crate_name!())
///             .get_matches();
/// ```
#[cfg(feature = "cargo")]
#[macro_export]
macro_rules! crate_name {
    () => {
        env!("CARGO_PKG_NAME")
    };
}

/// Allows you to build the `Command` instance from your Cargo.toml at compile time.
///
/// <div class="warning">
///
/// **NOTE:** Changing the values in your `Cargo.toml` does not trigger a re-build automatically,
/// and therefore won't change the generated output until you recompile.
///
/// In some cases you can "trick" the compiler into triggering a rebuild when your
/// `Cargo.toml` is changed by including this in your `src/main.rs` file
/// `include_str!("../Cargo.toml");`
///
/// </div>
///
/// # Examples
///
/// ```no_run
/// # use clap_builder as clap;
/// # use clap::command;
/// let m = command!().get_matches();
/// ```
#[cfg(feature = "cargo")]
#[macro_export]
macro_rules! command {
    () => {{
        $crate::command!($crate::crate_name!())
    }};
    ($name:expr) => {{
        let mut cmd = $crate::Command::new($name).version($crate::crate_version!());

        let author = $crate::crate_authors!();
        if !author.is_empty() {
            cmd = cmd.author(author)
        }

        let about = $crate::crate_description!();
        if !about.is_empty() {
            cmd = cmd.about(about)
        }

        cmd
    }};
}

/// Requires `cargo` feature flag to be enabled.
#[cfg(not(feature = "cargo"))]
#[macro_export]
macro_rules! command {
    () => {{
        compile_error!("`cargo` feature flag is required");
    }};
    ($name:expr) => {{
        compile_error!("`cargo` feature flag is required");
    }};
}

#[doc(hidden)]
#[macro_export]
macro_rules! arg_impl {
    ( @string $val:ident ) => {
        stringify!($val)
    };
    ( @string $val:literal ) => {{
        let ident_or_string_literal: &str = $val;
        ident_or_string_literal
    }};
    ( @string $val:tt ) => {
        ::std::compile_error!("Only identifiers or string literals supported");
    };
    ( @string ) => {
        None
    };

    ( @char $val:ident ) => {{
        let ident_or_char_literal = stringify!($val);
        debug_assert_eq!(
            ident_or_char_literal.len(),
            1,
            "Single-letter identifier expected, got {ident_or_char_literal}",
        );
        ident_or_char_literal.chars().next().unwrap()
    }};
    ( @char $val:literal ) => {{
        let ident_or_char_literal: char = $val;
        ident_or_char_literal
    }};
    ( @char ) => {{
        None
    }};

    (
        @arg
        ($arg:expr)
        --$long:ident
        $($tail:tt)*
    ) => {{
        debug_assert_eq!($arg.get_value_names(), None, "Flags should precede values");
        debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");

        let mut arg = $arg;
        let long = $crate::arg_impl! { @string $long };
        if arg.get_id() == "" {
            arg = arg.id(long);
        }
        let action = $crate::ArgAction::SetTrue;
        let arg = arg
            .long(long)
            .action(action);
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)*
        };
        arg
    }};
    (
        @arg
        ($arg:expr)
        --$long:literal
        $($tail:tt)*
    ) => {{
        debug_assert_eq!($arg.get_value_names(), None, "Flags should precede values");
        debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");

        let mut arg = $arg;
        let long = $crate::arg_impl! { @string $long };
        if arg.get_id() == "" {
            arg = arg.id(long);
        }
        let action = $crate::ArgAction::SetTrue;
        let arg = arg
            .long(long)
            .action(action);
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)*
        };
        arg
    }};
    (
        @arg
        ($arg:expr)
        -$short:ident
        $($tail:tt)*
    ) => {{
        debug_assert_eq!($arg.get_long(), None, "Short flags should precede long flags");
        debug_assert_eq!($arg.get_value_names(), None, "Flags should precede values");
        debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");

        let action = $crate::ArgAction::SetTrue;
        let arg = $arg
            .short($crate::arg_impl! { @char $short })
            .action(action);
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)*
        };
        arg
    }};
    (
        @arg
        ($arg:expr)
        -$short:literal
        $($tail:tt)*
    ) => {{
        debug_assert_eq!($arg.get_long(), None, "Short flags should precede long flags");
        debug_assert_eq!($arg.get_value_names(), None, "Flags should precede values");
        debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");

        let action = $crate::ArgAction::SetTrue;
        let arg = $arg
            .short($crate::arg_impl! { @char $short })
            .action(action);
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)*
        };
        arg
    }};
    (
        @arg
        ($arg:expr)
        <$value_name:ident>
        $($tail:tt)*
    ) => {{
        debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");
        debug_assert_eq!($arg.get_value_names(), None, "Multiple values not yet supported");

        let mut arg = $arg;

        if arg.get_long().is_none() && arg.get_short().is_none() {
            arg = arg.required(true);
        }

        let value_name = $crate::arg_impl! { @string $value_name };
        if arg.get_id() == "" {
            arg = arg.id(value_name);
        }
        let arg = arg
            .value_name(value_name)
            .action($crate::ArgAction::Set);
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)*
        };
        arg
    }};
    (
        @arg
        ($arg:expr)
        <$value_name:literal>
        $($tail:tt)*
    ) => {{
        debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");
        debug_assert_eq!($arg.get_value_names(), None, "Multiple values not yet supported");

        let mut arg = $arg;

        if arg.get_long().is_none() && arg.get_short().is_none() {
            arg = arg.required(true);
        }

        let value_name = $crate::arg_impl! { @string $value_name };
        if arg.get_id() == "" {
            arg = arg.id(value_name);
        }
        let arg = arg
            .value_name(value_name)
            .action($crate::ArgAction::Set);
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)*
        };
        arg
    }};
    (
        @arg
        ($arg:expr)
        [$value_name:ident]
        $($tail:tt)*
    ) => {{
        debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");
        debug_assert_eq!($arg.get_value_names(), None, "Multiple values not yet supported");

        let mut arg = $arg;

        if arg.get_long().is_none() && arg.get_short().is_none() {
            arg = arg.required(false);
        } else {
            arg = arg.num_args(0..=1);
        }

        let value_name = $crate::arg_impl! { @string $value_name };
        if arg.get_id() == "" {
            arg = arg.id(value_name);
        }
        let arg = arg
            .value_name(value_name)
            .action($crate::ArgAction::Set);
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)*
        };
        arg
    }};
    (
        @arg
        ($arg:expr)
        [$value_name:literal]
        $($tail:tt)*
    ) => {{
        debug_assert!(!matches!($arg.get_action(), $crate::ArgAction::Append), "Flags should precede `...`");
        debug_assert_eq!($arg.get_value_names(), None, "Multiple values not yet supported");

        let mut arg = $arg;

        if arg.get_long().is_none() && arg.get_short().is_none() {
            arg = arg.required(false);
        } else {
            arg = arg.num_args(0..=1);
        }

        let value_name = $crate::arg_impl! { @string $value_name };
        if arg.get_id() == "" {
            arg = arg.id(value_name);
        }
        let arg = arg
            .value_name(value_name)
            .action($crate::ArgAction::Set);
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)*
        };
        arg
    }};
    (
        @arg
        ($arg:expr)
        ...
        $($tail:tt)*
    ) => {{
        let arg = match $arg.get_action() {
            $crate::ArgAction::Set => {
                if $arg.get_long().is_none() && $arg.get_short().is_none() {
                    $arg.num_args(1..)
                        // Allow collecting arguments interleaved with flags
                        .action($crate::ArgAction::Append)
                } else {
                    $arg.action($crate::ArgAction::Append)
                }
            },
            $crate::ArgAction::SetTrue | $crate::ArgAction::Help | $crate::ArgAction::Version => {
                $arg.action($crate::ArgAction::Count)
            }
            action => {
                panic!("Unexpected action {action:?}")
            }
        };
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)*
        };
        arg
    }};
    (
        @arg
        ($arg:expr)
        $help:literal
    ) => {{
        $arg.help($help)
    }};
    (
        @arg
        ($arg:expr)
    ) => {{
        $arg
    }};
}

/// Create an [`Arg`] from a usage string.
///
/// Allows creation of basic settings for the [`Arg`].
///
/// <div class="warning">
///
/// **NOTE**: Not all settings may be set using the usage string method. Some properties are
/// only available via the builder pattern.
///
/// </div>
///
/// # Syntax
///
/// Usage strings typically following the form:
///
/// ```notrust
/// [explicit name] [short] [long] [value names] [...] [help string]
/// ```
///
/// ### Explicit Name
///
/// The name may be either a bare-word or a string, followed by a `:`, like `name:` or
/// `"name":`.
///
/// *Note:* This is an optional field, if it's omitted the argument will use one of the additional
/// fields as the name using the following priority order:
///
///  1. Explicit Name
///  2. Long
///  3. Value Name
///
/// See [`Arg::id`][crate::Arg::id].
///
/// ### Short
///
/// A short flag is a `-` followed by either a bare-character or quoted character, like `-f` or
/// `-'f'`.
///
/// See [`Arg::short`][crate::Arg::short].
///
/// ### Long
///
/// A long flag is a `--` followed by either a bare-word or a string, like `--foo` or
/// `--"foo"`.
///
/// <div class="warning">
///
/// **NOTE:** Dashes in the long name (e.g. `--foo-bar`) is not supported and quoting is required
/// (e.g. `--"foo-bar"`).
///
/// </div>
///
/// See [`Arg::long`][crate::Arg::long].
///
/// ### Values (Value Notation)
///
/// This is set by placing bare-word between:
/// - `[]` like `[FOO]`
///   - Positional argument: optional
///   - Named argument: optional value
/// - `<>` like `<FOO>`: required
///
/// See [`Arg::value_name`][crate::Arg::value_name].
///
/// ### `...`
///
/// `...` (three consecutive dots/periods) specifies that this argument may occur multiple
/// times (not to be confused with multiple values per occurrence).
///
/// See [`ArgAction::Count`][crate::ArgAction::Count] and [`ArgAction::Append`][crate::ArgAction::Append].
///
/// ### Help String
///
/// The help string is denoted between a pair of double quotes `""` and may contain any
/// characters.
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::{Command, Arg, arg};
/// let cmd = Command::new("prog")
///     .args(&[
///         arg!(--config <FILE> "a required file for the configuration and no short"),
///         arg!(-d --debug ... "turns on debugging information and allows multiples"),
///         arg!([input] "an optional input file to use")
///     ]);
///
/// let m = cmd.try_get_matches_from(["prog", "--config", "file.toml"]).unwrap();
/// assert_eq!(m.get_one::<String>("config").unwrap(), "file.toml");
/// assert_eq!(*m.get_one::<u8>("debug").unwrap(), 0);
/// assert_eq!(m.get_one::<String>("input"), None);
/// ```
/// [`Arg`]: crate::Arg
#[macro_export]
macro_rules! arg {
    ( $name:ident: $($tail:tt)+ ) => {{
        let arg = $crate::Arg::new($crate::arg_impl! { @string $name });
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)+
        };
        arg
    }};
    ( $($tail:tt)+ ) => {{
        let arg = $crate::Arg::default();
        let arg = $crate::arg_impl! {
            @arg (arg) $($tail)+
        };
        debug_assert_ne!(arg.get_id(), "", "Without a value or long flag, the `name:` prefix is required");
        arg
    }};
}

#[cfg(feature = "debug")]
macro_rules! debug {
    ($($arg:tt)*) => ({
        use std::fmt::Write as _;
        let hint = anstyle::Style::new().dimmed();

        let module_path = module_path!();
        let body = format!($($arg)*);
        let mut styled = $crate::builder::StyledStr::new();
        let _ = write!(styled, "{hint}[{module_path:>28}]{body}{hint:#}\n");
        let color = $crate::output::fmt::Colorizer::new($crate::output::fmt::Stream::Stderr, $crate::ColorChoice::Auto).with_content(styled);
        let _ = color.print();
    })
}

#[cfg(not(feature = "debug"))]
macro_rules! debug {
    ($($arg:tt)*) => {};
}

macro_rules! ok {
    ($expr:expr) => {
        match $expr {
            Ok(val) => val,
            Err(err) => {
                return Err(err);
            }
        }
    };
}

macro_rules! some {
    ($expr:expr) => {
        match $expr {
            Some(val) => val,
            None => {
                return None;
            }
        }
    };
}

```

`clap/clap_builder/src/mkeymap.rs`:

```rs
use std::iter::Iterator;
use std::ops::Index;

use crate::builder::OsStr;
use crate::Arg;
use crate::INTERNAL_ERROR_MSG;

#[derive(PartialEq, Eq, Debug, Clone)]
pub(crate) struct Key {
    key: KeyType,
    index: usize,
}

#[derive(Default, PartialEq, Eq, Debug, Clone)]
pub(crate) struct MKeyMap {
    /// All of the arguments.
    args: Vec<Arg>,

    // Cache part:
    /// Will be set after `_build()`.
    keys: Vec<Key>,
}

#[derive(Debug, PartialEq, Eq, Hash, Clone)]
pub(crate) enum KeyType {
    Short(char),
    Long(OsStr),
    Position(usize),
}

impl KeyType {
    pub(crate) fn is_position(&self) -> bool {
        matches!(self, KeyType::Position(_))
    }
}

impl PartialEq<usize> for KeyType {
    fn eq(&self, rhs: &usize) -> bool {
        match self {
            KeyType::Position(x) => x == rhs,
            _ => false,
        }
    }
}

impl PartialEq<&str> for KeyType {
    fn eq(&self, rhs: &&str) -> bool {
        match self {
            KeyType::Long(l) => l == rhs,
            _ => false,
        }
    }
}

impl PartialEq<str> for KeyType {
    fn eq(&self, rhs: &str) -> bool {
        match self {
            KeyType::Long(l) => l == rhs,
            _ => false,
        }
    }
}

impl PartialEq<OsStr> for KeyType {
    fn eq(&self, rhs: &OsStr) -> bool {
        match self {
            KeyType::Long(l) => l == rhs,
            _ => false,
        }
    }
}

impl PartialEq<char> for KeyType {
    fn eq(&self, rhs: &char) -> bool {
        match self {
            KeyType::Short(c) => c == rhs,
            _ => false,
        }
    }
}

impl MKeyMap {
    /// If any arg has corresponding key in this map, we can search the key with
    /// `u64` (for positional argument), `char` (for short flag), `&str` and `OsString`
    /// (for long flag)
    pub(crate) fn contains<K>(&self, key: K) -> bool
    where
        KeyType: PartialEq<K>,
    {
        self.keys.iter().any(|x| x.key == key)
    }

    /// Push an argument in the map.
    pub(crate) fn push(&mut self, new_arg: Arg) {
        self.args.push(new_arg);
    }

    /// Find the arg have corresponding key in this map, we can search the key
    /// with `u64` (for positional argument), `char` (for short flag), `&str` and
    /// `OsString` (for long flag)
    pub(crate) fn get<K: ?Sized>(&self, key: &K) -> Option<&Arg>
    where
        KeyType: PartialEq<K>,
    {
        self.keys
            .iter()
            .find(|k| &k.key == key)
            .map(|k| &self.args[k.index])
    }

    /// Return iterators of all keys.
    pub(crate) fn keys(&self) -> impl Iterator<Item = &KeyType> {
        self.keys.iter().map(|x| &x.key)
    }

    /// Return iterators of all args.
    pub(crate) fn args(&self) -> impl Iterator<Item = &Arg> {
        self.args.iter()
    }

    /// Return mutable iterators of all args.
    pub(crate) fn args_mut(&mut self) -> impl Iterator<Item = &mut Arg> {
        self.args.iter_mut()
    }

    /// Mutate every argument.
    pub(crate) fn mut_args<F>(&mut self, f: F)
    where
        F: FnMut(Arg) -> Arg,
    {
        let mut args = std::mem::take(&mut self.args);
        self.args.extend(args.drain(..).map(f));
    }

    /// We need a lazy build here since some we may change args after creating
    /// the map, you can checkout who uses `args_mut`.
    pub(crate) fn _build(&mut self) {
        // There will be at least as many keys as args, so that is a good starting point
        self.keys.reserve(self.args.len());
        for (i, arg) in self.args.iter().enumerate() {
            append_keys(&mut self.keys, arg, i);
        }
    }

    /// Remove an arg in the graph by Id, usually used by `mut_arg`. Return
    /// `Some(arg)` if removed.
    pub(crate) fn remove_by_name(&mut self, name: &str) -> Option<Arg> {
        self.args
            .iter()
            .position(|arg| arg.id == name)
            // since it's a cold function, using this wouldn't hurt much
            .map(|i| self.args.remove(i))
    }
}

impl Index<&'_ KeyType> for MKeyMap {
    type Output = Arg;

    fn index(&self, key: &KeyType) -> &Self::Output {
        self.get(key).expect(INTERNAL_ERROR_MSG)
    }
}

/// Generate key types for an specific Arg.
fn append_keys(keys: &mut Vec<Key>, arg: &Arg, index: usize) {
    if let Some(pos_index) = arg.index {
        let key = KeyType::Position(pos_index);
        keys.push(Key { key, index });
    } else {
        if let Some(short) = arg.short {
            let key = KeyType::Short(short);
            keys.push(Key { key, index });
        }
        if let Some(long) = arg.long.clone() {
            let key = KeyType::Long(long.into());
            keys.push(Key { key, index });
        }

        for (short, _) in arg.short_aliases.iter() {
            let key = KeyType::Short(*short);
            keys.push(Key { key, index });
        }
        for (long, _) in arg.aliases.iter() {
            let key = KeyType::Long(long.into());
            keys.push(Key { key, index });
        }
    }
}

```

`clap/clap_builder/src/output/fmt.rs`:

```rs
use crate::builder::StyledStr;
use crate::util::color::ColorChoice;

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub(crate) enum Stream {
    Stdout,
    Stderr,
}

#[derive(Clone, Debug)]
pub(crate) struct Colorizer {
    stream: Stream,
    #[allow(unused)]
    color_when: ColorChoice,
    content: StyledStr,
}

impl Colorizer {
    pub(crate) fn new(stream: Stream, color_when: ColorChoice) -> Self {
        Colorizer {
            stream,
            color_when,
            content: Default::default(),
        }
    }

    pub(crate) fn with_content(mut self, content: StyledStr) -> Self {
        self.content = content;
        self
    }
}

/// Printing methods.
impl Colorizer {
    #[cfg(feature = "color")]
    pub(crate) fn print(&self) -> std::io::Result<()> {
        let color_when = match self.color_when {
            ColorChoice::Always => anstream::ColorChoice::Always,
            ColorChoice::Auto => anstream::ColorChoice::Auto,
            ColorChoice::Never => anstream::ColorChoice::Never,
        };

        let mut stdout;
        let mut stderr;
        let writer: &mut dyn std::io::Write = match self.stream {
            Stream::Stderr => {
                stderr = anstream::AutoStream::new(std::io::stderr().lock(), color_when);
                &mut stderr
            }
            Stream::Stdout => {
                stdout = anstream::AutoStream::new(std::io::stdout().lock(), color_when);
                &mut stdout
            }
        };

        self.content.write_to(writer)
    }

    #[cfg(not(feature = "color"))]
    pub(crate) fn print(&self) -> std::io::Result<()> {
        // [e]println can't be used here because it panics
        // if something went wrong. We don't want that.
        match self.stream {
            Stream::Stdout => {
                let stdout = std::io::stdout();
                let mut stdout = stdout.lock();
                self.content.write_to(&mut stdout)
            }
            Stream::Stderr => {
                let stderr = std::io::stderr();
                let mut stderr = stderr.lock();
                self.content.write_to(&mut stderr)
            }
        }
    }
}

/// Color-unaware printing. Never uses coloring.
impl std::fmt::Display for Colorizer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.content.fmt(f)
    }
}

```

`clap/clap_builder/src/output/help.rs`:

```rs
#![cfg_attr(not(feature = "help"), allow(unused_variables))]

// Internal
use crate::builder::Command;
use crate::builder::StyledStr;
use crate::output::Usage;

/// Writes the parser help to the wrapped stream.
pub(crate) fn write_help(writer: &mut StyledStr, cmd: &Command, usage: &Usage<'_>, use_long: bool) {
    debug!("write_help");

    if let Some(h) = cmd.get_override_help() {
        writer.push_styled(h);
    } else {
        #[cfg(feature = "help")]
        {
            use super::AutoHelp;
            use super::HelpTemplate;
            if let Some(tmpl) = cmd.get_help_template() {
                HelpTemplate::new(writer, cmd, usage, use_long)
                    .write_templated_help(tmpl.as_styled_str());
            } else {
                AutoHelp::new(writer, cmd, usage, use_long).write_help();
            }
        }

        #[cfg(not(feature = "help"))]
        {
            debug!("write_help: no help, `Command::override_help` and `help` is missing");
        }
    }

    // Remove any lines from unused sections
    writer.trim_start_lines();
    // Remove any whitespace caused by book keeping
    writer.trim_end();
    // Ensure there is still a trailing newline
    writer.push_str("\n");
}

```

`clap/clap_builder/src/output/help_template.rs`:

```rs
// HACK: for rust 1.64 (1.68 doesn't need this since this is in lib.rs)
//
// Wanting consistency in our calls
#![allow(clippy::write_with_newline)]

// Std
use std::borrow::Cow;
use std::cmp;
use std::collections::BTreeMap;

// Internal
use crate::builder::PossibleValue;
use crate::builder::Str;
use crate::builder::StyledStr;
use crate::builder::Styles;
use crate::builder::{Arg, Command};
use crate::output::display_width;
use crate::output::wrap;
use crate::output::Usage;
use crate::output::TAB;
use crate::output::TAB_WIDTH;
use crate::util::FlatSet;

/// `clap` auto-generated help writer
pub(crate) struct AutoHelp<'cmd, 'writer> {
    template: HelpTemplate<'cmd, 'writer>,
}

// Public Functions
impl<'cmd, 'writer> AutoHelp<'cmd, 'writer> {
    /// Create a new `HelpTemplate` instance.
    pub(crate) fn new(
        writer: &'writer mut StyledStr,
        cmd: &'cmd Command,
        usage: &'cmd Usage<'cmd>,
        use_long: bool,
    ) -> Self {
        Self {
            template: HelpTemplate::new(writer, cmd, usage, use_long),
        }
    }

    pub(crate) fn write_help(&mut self) {
        let pos = self
            .template
            .cmd
            .get_positionals()
            .any(|arg| should_show_arg(self.template.use_long, arg));
        let non_pos = self
            .template
            .cmd
            .get_non_positionals()
            .any(|arg| should_show_arg(self.template.use_long, arg));
        let subcmds = self.template.cmd.has_visible_subcommands();

        let template = if non_pos || pos || subcmds {
            DEFAULT_TEMPLATE
        } else {
            DEFAULT_NO_ARGS_TEMPLATE
        };
        self.template.write_templated_help(template);
    }
}

const DEFAULT_TEMPLATE: &str = "\
{before-help}{about-with-newline}
{usage-heading} {usage}

{all-args}{after-help}\
    ";

const DEFAULT_NO_ARGS_TEMPLATE: &str = "\
{before-help}{about-with-newline}
{usage-heading} {usage}{after-help}\
    ";

const SHORT_SIZE: usize = 4; // See `fn short` for the 4

/// Help template writer
///
/// Wraps a writer stream providing different methods to generate help for `clap` objects.
pub(crate) struct HelpTemplate<'cmd, 'writer> {
    writer: &'writer mut StyledStr,
    cmd: &'cmd Command,
    styles: &'cmd Styles,
    usage: &'cmd Usage<'cmd>,
    next_line_help: bool,
    term_w: usize,
    use_long: bool,
}

// Public Functions
impl<'cmd, 'writer> HelpTemplate<'cmd, 'writer> {
    /// Create a new `HelpTemplate` instance.
    pub(crate) fn new(
        writer: &'writer mut StyledStr,
        cmd: &'cmd Command,
        usage: &'cmd Usage<'cmd>,
        use_long: bool,
    ) -> Self {
        debug!(
            "HelpTemplate::new cmd={}, use_long={}",
            cmd.get_name(),
            use_long
        );
        let term_w = Self::term_w(cmd);
        let next_line_help = cmd.is_next_line_help_set();

        HelpTemplate {
            writer,
            cmd,
            styles: cmd.get_styles(),
            usage,
            next_line_help,
            term_w,
            use_long,
        }
    }

    #[cfg(not(feature = "unstable-v5"))]
    fn term_w(cmd: &'cmd Command) -> usize {
        match cmd.get_term_width() {
            Some(0) => usize::MAX,
            Some(w) => w,
            None => {
                let (current_width, _h) = dimensions();
                let current_width = current_width.unwrap_or(100);
                let max_width = match cmd.get_max_term_width() {
                    None | Some(0) => usize::MAX,
                    Some(mw) => mw,
                };
                cmp::min(current_width, max_width)
            }
        }
    }

    #[cfg(feature = "unstable-v5")]
    fn term_w(cmd: &'cmd Command) -> usize {
        let term_w = match cmd.get_term_width() {
            Some(0) => usize::MAX,
            Some(w) => w,
            None => {
                let (current_width, _h) = dimensions();
                current_width.unwrap_or(usize::MAX)
            }
        };

        let max_term_w = match cmd.get_max_term_width() {
            Some(0) => usize::MAX,
            Some(mw) => mw,
            None => 100,
        };

        cmp::min(term_w, max_term_w)
    }

    /// Write help to stream for the parser in the format defined by the template.
    ///
    /// For details about the template language see [`Command::help_template`].
    ///
    /// [`Command::help_template`]: Command::help_template()
    pub(crate) fn write_templated_help(&mut self, template: &str) {
        debug!("HelpTemplate::write_templated_help");
        use std::fmt::Write as _;

        let mut parts = template.split('{');
        if let Some(first) = parts.next() {
            self.writer.push_str(first);
        }
        for part in parts {
            if let Some((tag, rest)) = part.split_once('}') {
                match tag {
                    "name" => {
                        self.write_display_name();
                    }
                    #[cfg(not(feature = "unstable-v5"))]
                    "bin" => {
                        self.write_bin_name();
                    }
                    "version" => {
                        self.write_version();
                    }
                    "author" => {
                        self.write_author(false, false);
                    }
                    "author-with-newline" => {
                        self.write_author(false, true);
                    }
                    "author-section" => {
                        self.write_author(true, true);
                    }
                    "about" => {
                        self.write_about(false, false);
                    }
                    "about-with-newline" => {
                        self.write_about(false, true);
                    }
                    "about-section" => {
                        self.write_about(true, true);
                    }
                    "usage-heading" => {
                        let _ = write!(
                            self.writer,
                            "{}Usage:{}",
                            self.styles.get_usage().render(),
                            self.styles.get_usage().render_reset()
                        );
                    }
                    "usage" => {
                        self.writer.push_styled(
                            &self.usage.create_usage_no_title(&[]).unwrap_or_default(),
                        );
                    }
                    "all-args" => {
                        self.write_all_args();
                    }
                    "options" => {
                        // Include even those with a heading as we don't have a good way of
                        // handling help_heading in the template.
                        self.write_args(
                            &self.cmd.get_non_positionals().collect::<Vec<_>>(),
                            "options",
                            option_sort_key,
                        );
                    }
                    "positionals" => {
                        self.write_args(
                            &self.cmd.get_positionals().collect::<Vec<_>>(),
                            "positionals",
                            positional_sort_key,
                        );
                    }
                    "subcommands" => {
                        self.write_subcommands(self.cmd);
                    }
                    "tab" => {
                        self.writer.push_str(TAB);
                    }
                    "after-help" => {
                        self.write_after_help();
                    }
                    "before-help" => {
                        self.write_before_help();
                    }
                    _ => {
                        let _ = write!(self.writer, "{{{tag}}}");
                    }
                }
                self.writer.push_str(rest);
            }
        }
    }
}

/// Basic template methods
impl HelpTemplate<'_, '_> {
    /// Writes binary name of a Parser Object to the wrapped stream.
    fn write_display_name(&mut self) {
        debug!("HelpTemplate::write_display_name");

        let display_name = wrap(
            &self
                .cmd
                .get_display_name()
                .unwrap_or_else(|| self.cmd.get_name())
                .replace("{n}", "\n"),
            self.term_w,
        );
        self.writer.push_string(display_name);
    }

    /// Writes binary name of a Parser Object to the wrapped stream.
    #[cfg(not(feature = "unstable-v5"))]
    fn write_bin_name(&mut self) {
        debug!("HelpTemplate::write_bin_name");

        let bin_name = if let Some(bn) = self.cmd.get_bin_name() {
            if bn.contains(' ') {
                // In case we're dealing with subcommands i.e. git mv is translated to git-mv
                bn.replace(' ', "-")
            } else {
                wrap(&self.cmd.get_name().replace("{n}", "\n"), self.term_w)
            }
        } else {
            wrap(&self.cmd.get_name().replace("{n}", "\n"), self.term_w)
        };
        self.writer.push_string(bin_name);
    }

    fn write_version(&mut self) {
        let version = self
            .cmd
            .get_version()
            .or_else(|| self.cmd.get_long_version());
        if let Some(output) = version {
            self.writer.push_string(wrap(output, self.term_w));
        }
    }

    fn write_author(&mut self, before_new_line: bool, after_new_line: bool) {
        if let Some(author) = self.cmd.get_author() {
            if before_new_line {
                self.writer.push_str("\n");
            }
            self.writer.push_string(wrap(author, self.term_w));
            if after_new_line {
                self.writer.push_str("\n");
            }
        }
    }

    fn write_about(&mut self, before_new_line: bool, after_new_line: bool) {
        let about = if self.use_long {
            self.cmd.get_long_about().or_else(|| self.cmd.get_about())
        } else {
            self.cmd.get_about()
        };
        if let Some(output) = about {
            if before_new_line {
                self.writer.push_str("\n");
            }
            let mut output = output.clone();
            output.replace_newline_var();
            output.wrap(self.term_w);
            self.writer.push_styled(&output);
            if after_new_line {
                self.writer.push_str("\n");
            }
        }
    }

    fn write_before_help(&mut self) {
        debug!("HelpTemplate::write_before_help");
        let before_help = if self.use_long {
            self.cmd
                .get_before_long_help()
                .or_else(|| self.cmd.get_before_help())
        } else {
            self.cmd.get_before_help()
        };
        if let Some(output) = before_help {
            let mut output = output.clone();
            output.replace_newline_var();
            output.wrap(self.term_w);
            self.writer.push_styled(&output);
            self.writer.push_str("\n\n");
        }
    }

    fn write_after_help(&mut self) {
        debug!("HelpTemplate::write_after_help");
        let after_help = if self.use_long {
            self.cmd
                .get_after_long_help()
                .or_else(|| self.cmd.get_after_help())
        } else {
            self.cmd.get_after_help()
        };
        if let Some(output) = after_help {
            self.writer.push_str("\n\n");
            let mut output = output.clone();
            output.replace_newline_var();
            output.wrap(self.term_w);
            self.writer.push_styled(&output);
        }
    }
}

/// Arg handling
impl HelpTemplate<'_, '_> {
    /// Writes help for all arguments (options, flags, args, subcommands)
    /// including titles of a Parser Object to the wrapped stream.
    pub(crate) fn write_all_args(&mut self) {
        debug!("HelpTemplate::write_all_args");
        use std::fmt::Write as _;
        let header = &self.styles.get_header();

        let pos = self
            .cmd
            .get_positionals()
            .filter(|a| a.get_help_heading().is_none())
            .filter(|arg| should_show_arg(self.use_long, arg))
            .collect::<Vec<_>>();
        let non_pos = self
            .cmd
            .get_non_positionals()
            .filter(|a| a.get_help_heading().is_none())
            .filter(|arg| should_show_arg(self.use_long, arg))
            .collect::<Vec<_>>();
        let subcmds = self.cmd.has_visible_subcommands();

        let custom_headings = self
            .cmd
            .get_arguments()
            .filter_map(|arg| arg.get_help_heading())
            .collect::<FlatSet<_>>();

        let flatten = self.cmd.is_flatten_help_set();

        let mut first = true;

        if subcmds && !flatten {
            if !first {
                self.writer.push_str("\n\n");
            }
            first = false;
            let default_help_heading = Str::from("Commands");
            let help_heading = self
                .cmd
                .get_subcommand_help_heading()
                .unwrap_or(&default_help_heading);
            let _ = write!(self.writer, "{header}{help_heading}:{header:#}\n",);

            self.write_subcommands(self.cmd);
        }

        if !pos.is_empty() {
            if !first {
                self.writer.push_str("\n\n");
            }
            first = false;
            // Write positional args if any
            let help_heading = "Arguments";
            let _ = write!(self.writer, "{header}{help_heading}:{header:#}\n",);
            self.write_args(&pos, "Arguments", positional_sort_key);
        }

        if !non_pos.is_empty() {
            if !first {
                self.writer.push_str("\n\n");
            }
            first = false;
            let help_heading = "Options";
            let _ = write!(self.writer, "{header}{help_heading}:{header:#}\n",);
            self.write_args(&non_pos, "Options", option_sort_key);
        }
        if !custom_headings.is_empty() {
            for heading in custom_headings {
                let args = self
                    .cmd
                    .get_arguments()
                    .filter(|a| {
                        if let Some(help_heading) = a.get_help_heading() {
                            return help_heading == heading;
                        }
                        false
                    })
                    .filter(|arg| should_show_arg(self.use_long, arg))
                    .collect::<Vec<_>>();

                if !args.is_empty() {
                    if !first {
                        self.writer.push_str("\n\n");
                    }
                    first = false;
                    let _ = write!(self.writer, "{header}{heading}:{header:#}\n",);
                    self.write_args(&args, heading, option_sort_key);
                }
            }
        }
        if subcmds && flatten {
            let mut cmd = self.cmd.clone();
            cmd.build();
            self.write_flat_subcommands(&cmd, &mut first);
        }
    }

    /// Sorts arguments by length and display order and write their help to the wrapped stream.
    fn write_args(&mut self, args: &[&Arg], _category: &str, sort_key: ArgSortKey) {
        debug!("HelpTemplate::write_args {_category}");
        // The shortest an arg can legally be is 2 (i.e. '-x')
        let mut longest = 2;
        let mut ord_v = BTreeMap::new();

        // Determine the longest
        for &arg in args.iter().filter(|arg| {
            // If it's NextLineHelp we don't care to compute how long it is because it may be
            // NextLineHelp on purpose simply *because* it's so long and would throw off all other
            // args alignment
            should_show_arg(self.use_long, arg)
        }) {
            if longest_filter(arg) {
                let width = display_width(&arg.to_string());
                let actual_width = if arg.is_positional() {
                    width
                } else {
                    width + SHORT_SIZE
                };
                longest = longest.max(actual_width);
                debug!(
                    "HelpTemplate::write_args: arg={:?} longest={}",
                    arg.get_id(),
                    longest
                );
            }

            let key = (sort_key)(arg);
            ord_v.insert(key, arg);
        }

        let next_line_help = self.will_args_wrap(args, longest);

        for (i, (_, arg)) in ord_v.iter().enumerate() {
            if i != 0 {
                self.writer.push_str("\n");
                if next_line_help && self.use_long {
                    self.writer.push_str("\n");
                }
            }
            self.write_arg(arg, next_line_help, longest);
        }
    }

    /// Writes help for an argument to the wrapped stream.
    fn write_arg(&mut self, arg: &Arg, next_line_help: bool, longest: usize) {
        let spec_vals = &self.spec_vals(arg);

        self.writer.push_str(TAB);
        self.short(arg);
        self.long(arg);
        self.writer
            .push_styled(&arg.stylize_arg_suffix(self.styles, None));
        self.align_to_about(arg, next_line_help, longest);

        let about = if self.use_long {
            arg.get_long_help()
                .or_else(|| arg.get_help())
                .unwrap_or_default()
        } else {
            arg.get_help()
                .or_else(|| arg.get_long_help())
                .unwrap_or_default()
        };

        self.help(Some(arg), about, spec_vals, next_line_help, longest);
    }

    /// Writes argument's short command to the wrapped stream.
    fn short(&mut self, arg: &Arg) {
        debug!("HelpTemplate::short");
        use std::fmt::Write as _;
        let literal = &self.styles.get_literal();

        if let Some(s) = arg.get_short() {
            let _ = write!(self.writer, "{literal}-{s}{literal:#}",);
        } else if arg.get_long().is_some() {
            self.writer.push_str("    ");
        }
    }

    /// Writes argument's long command to the wrapped stream.
    fn long(&mut self, arg: &Arg) {
        debug!("HelpTemplate::long");
        use std::fmt::Write as _;
        let literal = &self.styles.get_literal();

        if let Some(long) = arg.get_long() {
            if arg.get_short().is_some() {
                self.writer.push_str(", ");
            }
            let _ = write!(self.writer, "{literal}--{long}{literal:#}",);
        }
    }

    /// Write alignment padding between arg's switches/values and its about message.
    fn align_to_about(&mut self, arg: &Arg, next_line_help: bool, longest: usize) {
        debug!(
            "HelpTemplate::align_to_about: arg={}, next_line_help={}, longest={}",
            arg.get_id(),
            next_line_help,
            longest
        );
        let padding = if self.use_long || next_line_help {
            // long help prints messages on the next line so it doesn't need to align text
            debug!("HelpTemplate::align_to_about: printing long help so skip alignment");
            0
        } else if !arg.is_positional() {
            let self_len = display_width(&arg.to_string()) + SHORT_SIZE;
            // Since we're writing spaces from the tab point we first need to know if we
            // had a long and short, or just short
            let padding = if arg.get_long().is_some() {
                // Only account 4 after the val
                TAB_WIDTH
            } else {
                // Only account for ', --' + 4 after the val
                TAB_WIDTH + 4
            };
            let spcs = longest + padding - self_len;
            debug!(
                "HelpTemplate::align_to_about: positional=false arg_len={self_len}, spaces={spcs}"
            );

            spcs
        } else {
            let self_len = display_width(&arg.to_string());
            let padding = TAB_WIDTH;
            let spcs = longest + padding - self_len;
            debug!(
                "HelpTemplate::align_to_about: positional=true arg_len={self_len}, spaces={spcs}",
            );

            spcs
        };

        self.write_padding(padding);
    }

    /// Writes argument's help to the wrapped stream.
    fn help(
        &mut self,
        arg: Option<&Arg>,
        about: &StyledStr,
        spec_vals: &str,
        next_line_help: bool,
        longest: usize,
    ) {
        debug!("HelpTemplate::help");
        use std::fmt::Write as _;
        let literal = &self.styles.get_literal();

        // Is help on next line, if so then indent
        if next_line_help {
            debug!("HelpTemplate::help: Next Line...{next_line_help:?}");
            self.writer.push_str("\n");
            self.writer.push_str(TAB);
            self.writer.push_str(NEXT_LINE_INDENT);
        }

        let spaces = if next_line_help {
            TAB.len() + NEXT_LINE_INDENT.len()
        } else {
            longest + TAB_WIDTH * 2
        };
        let trailing_indent = spaces; // Don't indent any further than the first line is indented
        let trailing_indent = self.get_spaces(trailing_indent);

        let mut help = about.clone();
        help.replace_newline_var();
        if !spec_vals.is_empty() {
            if !help.is_empty() {
                let sep = if self.use_long && arg.is_some() {
                    "\n\n"
                } else {
                    " "
                };
                help.push_str(sep);
            }
            help.push_str(spec_vals);
        }
        let avail_chars = self.term_w.saturating_sub(spaces);
        debug!(
            "HelpTemplate::help: help_width={}, spaces={}, avail={}",
            spaces,
            help.display_width(),
            avail_chars
        );
        help.wrap(avail_chars);
        help.indent("", &trailing_indent);
        let help_is_empty = help.is_empty();
        self.writer.push_styled(&help);
        if let Some(arg) = arg {
            if !arg.is_hide_possible_values_set() && self.use_long_pv(arg) {
                const DASH_SPACE: usize = "- ".len();
                let possible_vals = arg.get_possible_values();
                if !possible_vals.is_empty() {
                    debug!("HelpTemplate::help: Found possible vals...{possible_vals:?}");
                    let longest = possible_vals
                        .iter()
                        .filter(|f| !f.is_hide_set())
                        .map(|f| display_width(f.get_name()))
                        .max()
                        .expect("Only called with possible value");

                    let spaces = spaces + TAB_WIDTH - DASH_SPACE;
                    let trailing_indent = spaces + DASH_SPACE;
                    let trailing_indent = self.get_spaces(trailing_indent);

                    if !help_is_empty {
                        let _ = write!(self.writer, "\n\n{:spaces$}", "");
                    }
                    self.writer.push_str("Possible values:");
                    for pv in possible_vals.iter().filter(|pv| !pv.is_hide_set()) {
                        let name = pv.get_name();

                        let mut descr = StyledStr::new();
                        let _ = write!(&mut descr, "{literal}{name}{literal:#}",);
                        if let Some(help) = pv.get_help() {
                            debug!("HelpTemplate::help: Possible Value help");
                            // To align help messages
                            let padding = longest - display_width(name);
                            let _ = write!(&mut descr, ": {:padding$}", "");
                            descr.push_styled(help);
                        }

                        let avail_chars = if self.term_w > trailing_indent.len() {
                            self.term_w - trailing_indent.len()
                        } else {
                            usize::MAX
                        };
                        descr.replace_newline_var();
                        descr.wrap(avail_chars);
                        descr.indent("", &trailing_indent);

                        let _ = write!(self.writer, "\n{:spaces$}- ", "",);
                        self.writer.push_styled(&descr);
                    }
                }
            }
        }
    }

    /// Will use next line help on writing args.
    fn will_args_wrap(&self, args: &[&Arg], longest: usize) -> bool {
        args.iter()
            .filter(|arg| should_show_arg(self.use_long, arg))
            .any(|arg| {
                let spec_vals = &self.spec_vals(arg);
                self.arg_next_line_help(arg, spec_vals, longest)
            })
    }

    fn arg_next_line_help(&self, arg: &Arg, spec_vals: &str, longest: usize) -> bool {
        if self.next_line_help || arg.is_next_line_help_set() || self.use_long {
            // setting_next_line
            true
        } else {
            // force_next_line
            let h = arg
                .get_help()
                .or_else(|| arg.get_long_help())
                .unwrap_or_default();
            let h_w = h.display_width() + display_width(spec_vals);
            let taken = longest + TAB_WIDTH * 2;
            self.term_w >= taken
                && (taken as f32 / self.term_w as f32) > 0.40
                && h_w > (self.term_w - taken)
        }
    }

    fn spec_vals(&self, a: &Arg) -> String {
        debug!("HelpTemplate::spec_vals: a={a}");
        let mut spec_vals = Vec::new();
        #[cfg(feature = "env")]
        if let Some(ref env) = a.env {
            if !a.is_hide_env_set() {
                debug!(
                    "HelpTemplate::spec_vals: Found environment variable...[{:?}:{:?}]",
                    env.0, env.1
                );
                let env_val = if !a.is_hide_env_values_set() {
                    format!(
                        "={}",
                        env.1
                            .as_ref()
                            .map(|s| s.to_string_lossy())
                            .unwrap_or_default()
                    )
                } else {
                    Default::default()
                };
                let env_info = format!("[env: {}{}]", env.0.to_string_lossy(), env_val);
                spec_vals.push(env_info);
            }
        }
        if a.is_takes_value_set() && !a.is_hide_default_value_set() && !a.default_vals.is_empty() {
            debug!(
                "HelpTemplate::spec_vals: Found default value...[{:?}]",
                a.default_vals
            );

            let pvs = a
                .default_vals
                .iter()
                .map(|pvs| pvs.to_string_lossy())
                .map(|pvs| {
                    if pvs.contains(char::is_whitespace) {
                        Cow::from(format!("{pvs:?}"))
                    } else {
                        pvs
                    }
                })
                .collect::<Vec<_>>()
                .join(" ");

            spec_vals.push(format!("[default: {pvs}]"));
        }

        let als = a
            .aliases
            .iter()
            .filter(|&als| als.1) // visible
            .map(|als| als.0.as_str()) // name
            .collect::<Vec<_>>()
            .join(", ");
        if !als.is_empty() {
            debug!("HelpTemplate::spec_vals: Found aliases...{:?}", a.aliases);
            spec_vals.push(format!("[aliases: {als}]"));
        }

        let als = a
            .short_aliases
            .iter()
            .filter(|&als| als.1) // visible
            .map(|&als| als.0.to_string()) // name
            .collect::<Vec<_>>()
            .join(", ");
        if !als.is_empty() {
            debug!(
                "HelpTemplate::spec_vals: Found short aliases...{:?}",
                a.short_aliases
            );
            spec_vals.push(format!("[short aliases: {als}]"));
        }

        if !a.is_hide_possible_values_set() && !self.use_long_pv(a) {
            let possible_vals = a.get_possible_values();
            if !possible_vals.is_empty() {
                debug!("HelpTemplate::spec_vals: Found possible vals...{possible_vals:?}");

                let pvs = possible_vals
                    .iter()
                    .filter_map(PossibleValue::get_visible_quoted_name)
                    .collect::<Vec<_>>()
                    .join(", ");

                spec_vals.push(format!("[possible values: {pvs}]"));
            }
        }
        let connector = if self.use_long { "\n" } else { " " };
        spec_vals.join(connector)
    }

    fn get_spaces(&self, n: usize) -> String {
        " ".repeat(n)
    }

    fn write_padding(&mut self, amount: usize) {
        use std::fmt::Write as _;
        let _ = write!(self.writer, "{:amount$}", "");
    }

    fn use_long_pv(&self, arg: &Arg) -> bool {
        self.use_long
            && arg
                .get_possible_values()
                .iter()
                .any(PossibleValue::should_show_help)
    }
}

/// Subcommand handling
impl HelpTemplate<'_, '_> {
    /// Writes help for subcommands of a Parser Object to the wrapped stream.
    fn write_flat_subcommands(&mut self, cmd: &Command, first: &mut bool) {
        debug!(
            "HelpTemplate::write_flat_subcommands, cmd={}, first={}",
            cmd.get_name(),
            *first
        );
        use std::fmt::Write as _;
        let header = &self.styles.get_header();

        let mut ord_v = BTreeMap::new();
        for subcommand in cmd
            .get_subcommands()
            .filter(|subcommand| should_show_subcommand(subcommand))
        {
            ord_v.insert(
                (subcommand.get_display_order(), subcommand.get_name()),
                subcommand,
            );
        }
        for (_, subcommand) in ord_v {
            if !*first {
                self.writer.push_str("\n\n");
            }
            *first = false;

            let heading = subcommand.get_usage_name_fallback();
            let about = subcommand
                .get_about()
                .or_else(|| subcommand.get_long_about())
                .unwrap_or_default();

            let _ = write!(self.writer, "{header}{heading}:{header:#}",);
            if !about.is_empty() {
                let _ = write!(self.writer, "\n{about}",);
            }

            let args = subcommand
                .get_arguments()
                .filter(|arg| should_show_arg(self.use_long, arg) && !arg.is_global_set())
                .collect::<Vec<_>>();
            if !args.is_empty() {
                self.writer.push_str("\n");
            }

            let mut sub_help = HelpTemplate {
                writer: self.writer,
                cmd: subcommand,
                styles: self.styles,
                usage: self.usage,
                next_line_help: self.next_line_help,
                term_w: self.term_w,
                use_long: self.use_long,
            };
            sub_help.write_args(&args, heading, option_sort_key);
            if subcommand.is_flatten_help_set() {
                sub_help.write_flat_subcommands(subcommand, first);
            }
        }
    }

    /// Writes help for subcommands of a Parser Object to the wrapped stream.
    fn write_subcommands(&mut self, cmd: &Command) {
        debug!("HelpTemplate::write_subcommands");
        use std::fmt::Write as _;
        let literal = &self.styles.get_literal();

        // The shortest an arg can legally be is 2 (i.e. '-x')
        let mut longest = 2;
        let mut ord_v = BTreeMap::new();
        for subcommand in cmd
            .get_subcommands()
            .filter(|subcommand| should_show_subcommand(subcommand))
        {
            let mut styled = StyledStr::new();
            let name = subcommand.get_name();
            let _ = write!(styled, "{literal}{name}{literal:#}",);
            if let Some(short) = subcommand.get_short_flag() {
                let _ = write!(styled, ", {literal}-{short}{literal:#}",);
            }
            if let Some(long) = subcommand.get_long_flag() {
                let _ = write!(styled, ", {literal}--{long}{literal:#}",);
            }
            longest = longest.max(styled.display_width());
            ord_v.insert((subcommand.get_display_order(), styled), subcommand);
        }

        debug!("HelpTemplate::write_subcommands longest = {longest}");

        let next_line_help = self.will_subcommands_wrap(cmd.get_subcommands(), longest);

        for (i, (sc_str, sc)) in ord_v.into_iter().enumerate() {
            if 0 < i {
                self.writer.push_str("\n");
            }
            self.write_subcommand(sc_str.1, sc, next_line_help, longest);
        }
    }

    /// Will use next line help on writing subcommands.
    fn will_subcommands_wrap<'a>(
        &self,
        subcommands: impl IntoIterator<Item = &'a Command>,
        longest: usize,
    ) -> bool {
        subcommands
            .into_iter()
            .filter(|&subcommand| should_show_subcommand(subcommand))
            .any(|subcommand| {
                let spec_vals = &self.sc_spec_vals(subcommand);
                self.subcommand_next_line_help(subcommand, spec_vals, longest)
            })
    }

    fn write_subcommand(
        &mut self,
        sc_str: StyledStr,
        cmd: &Command,
        next_line_help: bool,
        longest: usize,
    ) {
        debug!("HelpTemplate::write_subcommand");

        let spec_vals = &self.sc_spec_vals(cmd);

        let about = cmd
            .get_about()
            .or_else(|| cmd.get_long_about())
            .unwrap_or_default();

        self.subcmd(sc_str, next_line_help, longest);
        self.help(None, about, spec_vals, next_line_help, longest);
    }

    fn sc_spec_vals(&self, a: &Command) -> String {
        debug!("HelpTemplate::sc_spec_vals: a={}", a.get_name());
        let mut spec_vals = vec![];

        let mut short_als = a
            .get_visible_short_flag_aliases()
            .map(|a| format!("-{a}"))
            .collect::<Vec<_>>();
        let als = a.get_visible_aliases().map(|s| s.to_string());
        short_als.extend(als);
        let all_als = short_als.join(", ");
        if !all_als.is_empty() {
            debug!(
                "HelpTemplate::spec_vals: Found aliases...{:?}",
                a.get_all_aliases().collect::<Vec<_>>()
            );
            debug!(
                "HelpTemplate::spec_vals: Found short flag aliases...{:?}",
                a.get_all_short_flag_aliases().collect::<Vec<_>>()
            );
            spec_vals.push(format!("[aliases: {all_als}]"));
        }

        spec_vals.join(" ")
    }

    fn subcommand_next_line_help(&self, cmd: &Command, spec_vals: &str, longest: usize) -> bool {
        // Ignore `self.use_long` since subcommands are only shown as short help
        if self.next_line_help {
            // setting_next_line
            true
        } else {
            // force_next_line
            let h = cmd
                .get_about()
                .or_else(|| cmd.get_long_about())
                .unwrap_or_default();
            let h_w = h.display_width() + display_width(spec_vals);
            let taken = longest + TAB_WIDTH * 2;
            self.term_w >= taken
                && (taken as f32 / self.term_w as f32) > 0.40
                && h_w > (self.term_w - taken)
        }
    }

    /// Writes subcommand to the wrapped stream.
    fn subcmd(&mut self, sc_str: StyledStr, next_line_help: bool, longest: usize) {
        self.writer.push_str(TAB);
        self.writer.push_styled(&sc_str);
        if !next_line_help {
            let width = sc_str.display_width();
            let padding = longest + TAB_WIDTH - width;
            self.write_padding(padding);
        }
    }
}

const NEXT_LINE_INDENT: &str = "        ";

type ArgSortKey = fn(arg: &Arg) -> (usize, String);

fn positional_sort_key(arg: &Arg) -> (usize, String) {
    (arg.get_index().unwrap_or(0), String::new())
}

fn option_sort_key(arg: &Arg) -> (usize, String) {
    // Formatting key like this to ensure that:
    // 1. Argument has long flags are printed just after short flags.
    // 2. For two args both have short flags like `-c` and `-C`, the
    //    `-C` arg is printed just after the `-c` arg
    // 3. For args without short or long flag, print them at last(sorted
    //    by arg name).
    // Example order: -a, -b, -B, -s, --select-file, --select-folder, -x

    let key = if let Some(x) = arg.get_short() {
        let mut s = x.to_ascii_lowercase().to_string();
        s.push(if x.is_ascii_lowercase() { '0' } else { '1' });
        s
    } else if let Some(x) = arg.get_long() {
        x.to_string()
    } else {
        let mut s = '{'.to_string();
        s.push_str(arg.get_id().as_str());
        s
    };
    (arg.get_display_order(), key)
}

pub(crate) fn dimensions() -> (Option<usize>, Option<usize>) {
    #[cfg(not(feature = "wrap_help"))]
    return (None, None);

    #[cfg(feature = "wrap_help")]
    terminal_size::terminal_size()
        .map(|(w, h)| (Some(w.0.into()), Some(h.0.into())))
        .unwrap_or_else(|| (parse_env("COLUMNS"), parse_env("LINES")))
}

#[cfg(feature = "wrap_help")]
fn parse_env(var: &str) -> Option<usize> {
    some!(some!(std::env::var_os(var)).to_str())
        .parse::<usize>()
        .ok()
}

fn should_show_arg(use_long: bool, arg: &Arg) -> bool {
    debug!(
        "should_show_arg: use_long={:?}, arg={}",
        use_long,
        arg.get_id()
    );
    if arg.is_hide_set() {
        return false;
    }
    (!arg.is_hide_long_help_set() && use_long)
        || (!arg.is_hide_short_help_set() && !use_long)
        || arg.is_next_line_help_set()
}

fn should_show_subcommand(subcommand: &Command) -> bool {
    !subcommand.is_hide_set()
}

fn longest_filter(arg: &Arg) -> bool {
    arg.is_takes_value_set() || arg.get_long().is_some() || arg.get_short().is_none()
}

#[cfg(test)]
mod test {
    #[test]
    #[cfg(feature = "wrap_help")]
    fn wrap_help_last_word() {
        use super::*;

        let help = String::from("foo bar baz");
        assert_eq!(wrap(&help, 5), "foo\nbar\nbaz");
    }

    #[test]
    #[cfg(feature = "unicode")]
    fn display_width_handles_non_ascii() {
        use super::*;

        // Popular Danish tongue-twister, the name of a fruit dessert.
        let text = "rødgrød med fløde";
        assert_eq!(display_width(text), 17);
        // Note that the string width is smaller than the string
        // length. This is due to the precomposed non-ASCII letters:
        assert_eq!(text.len(), 20);
    }

    #[test]
    #[cfg(feature = "unicode")]
    fn display_width_handles_emojis() {
        use super::*;

        let text = "😂";
        // There is a single `char`...
        assert_eq!(text.chars().count(), 1);
        // but it is double-width:
        assert_eq!(display_width(text), 2);
        // This is much less than the byte length:
        assert_eq!(text.len(), 4);
    }
}

```

`clap/clap_builder/src/output/mod.rs`:

```rs
mod help;
#[cfg(feature = "help")]
mod help_template;
mod usage;

pub(crate) mod fmt;
#[cfg(feature = "help")]
pub(crate) mod textwrap;

pub(crate) use self::help::write_help;
#[cfg(feature = "help")]
pub(crate) use self::help_template::AutoHelp;
#[cfg(feature = "help")]
pub(crate) use self::help_template::HelpTemplate;
#[cfg(feature = "help")]
pub(crate) use self::textwrap::core::display_width;
#[cfg(feature = "help")]
pub(crate) use self::textwrap::wrap;
pub(crate) use self::usage::Usage;

pub(crate) const TAB: &str = "  ";
#[cfg(feature = "help")]
pub(crate) const TAB_WIDTH: usize = TAB.len();

```

`clap/clap_builder/src/output/textwrap/core.rs`:

```rs
/// Compute the display width of `text`
///
/// # Examples
///
/// **Note:** When the `unicode` Cargo feature is disabled, all characters are presumed to take up
/// 1 width.  With the feature enabled, function will correctly deal with [combining characters] in
/// their decomposed form (see [Unicode equivalence]).
///
/// An example of a decomposed character is “é”, which can be decomposed into: “e” followed by a
/// combining acute accent: “◌́”.  Without the `unicode` Cargo feature, every `char` has a width of
/// 1. This includes the combining accent:
///
/// ## Emojis and CJK Characters
///
/// Characters such as emojis and [CJK characters] used in the
/// Chinese, Japanese, and Korean languages are seen as double-width,
/// even if the `unicode-width` feature is disabled:
///
/// # Limitations
///
/// The displayed width of a string cannot always be computed from the
/// string alone. This is because the width depends on the rendering
/// engine used. This is particularly visible with [emoji modifier
/// sequences] where a base emoji is modified with, e.g., skin tone or
/// hair color modifiers. It is up to the rendering engine to detect
/// this and to produce a suitable emoji.
///
/// A simple example is “❤️”, which consists of “❤” (U+2764: Black
/// Heart Symbol) followed by U+FE0F (Variation Selector-16). By
/// itself, “❤” is a black heart, but if you follow it with the
/// variant selector, you may get a wider red heart.
///
/// A more complex example would be “👨‍🦰” which should depict a man
/// with red hair. Here the computed width is too large — and the
/// width differs depending on the use of the `unicode-width` feature:
///
/// This happens because the grapheme consists of three code points:
/// “👨” (U+1F468: Man), Zero Width Joiner (U+200D), and “🦰”
/// (U+1F9B0: Red Hair). You can see them above in the test. With
/// `unicode-width` enabled, the ZWJ is correctly seen as having zero
/// width, without it is counted as a double-width character.
///
/// ## Terminal Support
///
/// Modern browsers typically do a great job at combining characters
/// as shown above, but terminals often struggle more. As an example,
/// Gnome Terminal version 3.38.1, shows “❤️” as a big red heart, but
/// shows "👨‍🦰" as “👨🦰”.
///
/// [combining characters]: https://en.wikipedia.org/wiki/Combining_character
/// [Unicode equivalence]: https://en.wikipedia.org/wiki/Unicode_equivalence
/// [CJK characters]: https://en.wikipedia.org/wiki/CJK_characters
/// [emoji modifier sequences]: https://unicode.org/emoji/charts/full-emoji-modifiers.html
#[inline(never)]
pub(crate) fn display_width(text: &str) -> usize {
    let mut width = 0;

    let mut control_sequence = false;
    let control_terminate: char = 'm';

    for ch in text.chars() {
        if ch.is_ascii_control() {
            control_sequence = true;
        } else if control_sequence && ch == control_terminate {
            control_sequence = false;
            continue;
        }

        if !control_sequence {
            width += ch_width(ch);
        }
    }
    width
}

#[cfg(feature = "unicode")]
fn ch_width(ch: char) -> usize {
    unicode_width::UnicodeWidthChar::width(ch).unwrap_or(0)
}

#[cfg(not(feature = "unicode"))]
fn ch_width(_: char) -> usize {
    1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[cfg(feature = "unicode")]
    use unicode_width::UnicodeWidthChar;

    #[test]
    fn emojis_have_correct_width() {
        use unic_emoji_char::is_emoji;

        // Emojis in the Basic Latin (ASCII) and Latin-1 Supplement
        // blocks all have a width of 1 column. This includes
        // characters such as '#' and '©'.
        for ch in '\u{1}'..'\u{FF}' {
            if is_emoji(ch) {
                let desc = format!("{:?} U+{:04X}", ch, ch as u32);

                #[cfg(feature = "unicode")]
                assert_eq!(ch.width().unwrap(), 1, "char: {desc}");

                #[cfg(not(feature = "unicode"))]
                assert_eq!(ch_width(ch), 1, "char: {desc}");
            }
        }

        // Emojis in the remaining blocks of the Basic Multilingual
        // Plane (BMP), in the Supplementary Multilingual Plane (SMP),
        // and in the Supplementary Ideographic Plane (SIP), are all 1
        // or 2 columns wide when unicode-width is used, and always 2
        // columns wide otherwise. This includes all of our favorite
        // emojis such as 😊.
        for ch in '\u{FF}'..'\u{2FFFF}' {
            if is_emoji(ch) {
                let desc = format!("{:?} U+{:04X}", ch, ch as u32);

                #[cfg(feature = "unicode")]
                assert!(ch.width().unwrap() <= 2, "char: {desc}");

                #[cfg(not(feature = "unicode"))]
                assert_eq!(ch_width(ch), 1, "char: {desc}");
            }
        }

        // The remaining planes contain almost no assigned code points
        // and thus also no emojis.
    }

    #[test]
    #[cfg(feature = "unicode")]
    fn display_width_works() {
        assert_eq!("Café Plain".len(), 11); // “é” is two bytes
        assert_eq!(display_width("Café Plain"), 10);
    }

    #[test]
    #[cfg(feature = "unicode")]
    fn display_width_narrow_emojis() {
        assert_eq!(display_width("⁉"), 1);
    }

    #[test]
    #[cfg(feature = "unicode")]
    fn display_width_narrow_emojis_variant_selector() {
        assert_eq!(display_width("⁉\u{fe0f}"), 1);
    }

    #[test]
    #[cfg(feature = "unicode")]
    fn display_width_emojis() {
        assert_eq!(display_width("😂😭🥺🤣✨😍🙏🥰😊🔥"), 20);
    }
}

```

`clap/clap_builder/src/output/textwrap/mod.rs`:

```rs
//! Fork of `textwrap` crate
//!
//! Benefits of forking:
//! - Pull in only what we need rather than relying on the compiler to remove what we don't need
//! - `LineWrapper` is able to incrementally wrap which will help with `StyledStr`

pub(crate) mod core;
#[cfg(feature = "wrap_help")]
pub(crate) mod word_separators;
#[cfg(feature = "wrap_help")]
pub(crate) mod wrap_algorithms;

#[cfg(feature = "wrap_help")]
pub(crate) fn wrap(content: &str, hard_width: usize) -> String {
    let mut wrapper = wrap_algorithms::LineWrapper::new(hard_width);
    let mut total = Vec::new();
    for line in content.split_inclusive('\n') {
        wrapper.reset();
        let line = word_separators::find_words_ascii_space(line).collect::<Vec<_>>();
        total.extend(wrapper.wrap(line));
    }
    total.join("")
}

#[cfg(not(feature = "wrap_help"))]
pub(crate) fn wrap(content: &str, _hard_width: usize) -> String {
    content.to_owned()
}

#[cfg(test)]
#[cfg(feature = "wrap_help")]
mod test {
    /// Compatibility shim to keep textwrap's tests
    fn wrap(content: &str, hard_width: usize) -> Vec<String> {
        super::wrap(content, hard_width)
            .trim_end()
            .split('\n')
            .map(|s| s.to_owned())
            .collect::<Vec<_>>()
    }

    #[test]
    fn no_wrap() {
        assert_eq!(wrap("foo", 10), vec!["foo"]);
    }

    #[test]
    fn wrap_simple() {
        assert_eq!(wrap("foo bar baz", 5), vec!["foo", "bar", "baz"]);
    }

    #[test]
    fn to_be_or_not() {
        assert_eq!(
            wrap("To be, or not to be, that is the question.", 10),
            vec!["To be, or", "not to be,", "that is", "the", "question."]
        );
    }

    #[test]
    fn multiple_words_on_first_line() {
        assert_eq!(wrap("foo bar baz", 10), vec!["foo bar", "baz"]);
    }

    #[test]
    fn long_word() {
        assert_eq!(wrap("foo", 0), vec!["foo"]);
    }

    #[test]
    fn long_words() {
        assert_eq!(wrap("foo bar", 0), vec!["foo", "bar"]);
    }

    #[test]
    fn max_width() {
        assert_eq!(wrap("foo bar", usize::MAX), vec!["foo bar"]);

        let text = "Hello there! This is some English text. \
                    It should not be wrapped given the extents below.";
        assert_eq!(wrap(text, usize::MAX), vec![text]);
    }

    #[test]
    fn leading_whitespace() {
        assert_eq!(wrap("  foo bar", 6), vec!["  foo", "  bar"]);
    }

    #[test]
    fn leading_whitespace_empty_first_line() {
        // If there is no space for the first word, the first line
        // will be empty. This is because the string is split into
        // words like [" ", "foobar ", "baz"], which puts "foobar " on
        // the second line. We never output trailing whitespace
        assert_eq!(wrap(" foobar baz", 6), vec!["", " foobar", " baz"]);
    }

    #[test]
    fn trailing_whitespace() {
        // Whitespace is only significant inside a line. After a line
        // gets too long and is broken, the first word starts in
        // column zero and is not indented.
        assert_eq!(wrap("foo     bar     baz  ", 5), vec!["foo", "bar", "baz"]);
    }

    #[test]
    fn issue_99() {
        // We did not reset the in_whitespace flag correctly and did
        // not handle single-character words after a line break.
        assert_eq!(
            wrap("aaabbbccc x yyyzzzwww", 9),
            vec!["aaabbbccc", "x", "yyyzzzwww"]
        );
    }

    #[test]
    fn issue_129() {
        // The dash is an em-dash which takes up four bytes. We used
        // to panic since we tried to index into the character.
        assert_eq!(wrap("x – x", 1), vec!["x", "–", "x"]);
    }
}

```

`clap/clap_builder/src/output/textwrap/word_separators.rs`:

```rs
pub(crate) fn find_words_ascii_space(line: &str) -> impl Iterator<Item = &'_ str> + '_ {
    let mut start = 0;
    let mut in_whitespace = false;
    let mut char_indices = line.char_indices();

    std::iter::from_fn(move || {
        for (idx, ch) in char_indices.by_ref() {
            let next_whitespace = ch == ' ';
            if in_whitespace && !next_whitespace {
                let word = &line[start..idx];
                start = idx;
                in_whitespace = next_whitespace;
                return Some(word);
            }

            in_whitespace = next_whitespace;
        }

        if start < line.len() {
            let word = &line[start..];
            start = line.len();
            return Some(word);
        }

        None
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    macro_rules! test_find_words {
        ($ascii_name:ident,
         $([ $line:expr, $ascii_words:expr ]),+) => {
            #[test]
            fn $ascii_name() {
                $(
                    let expected_words: Vec<&str> = $ascii_words.to_vec();
                    let actual_words = find_words_ascii_space($line)
                        .collect::<Vec<_>>();
                    assert_eq!(actual_words, expected_words, "Line: {:?}", $line);
                )+
            }
        };
    }

    test_find_words!(ascii_space_empty, ["", []]);

    test_find_words!(ascii_single_word, ["foo", ["foo"]]);

    test_find_words!(ascii_two_words, ["foo bar", ["foo ", "bar"]]);

    test_find_words!(
        ascii_multiple_words,
        ["foo bar", ["foo ", "bar"]],
        ["x y z", ["x ", "y ", "z"]]
    );

    test_find_words!(ascii_only_whitespace, [" ", [" "]], ["    ", ["    "]]);

    test_find_words!(
        ascii_inter_word_whitespace,
        ["foo   bar", ["foo   ", "bar"]]
    );

    test_find_words!(ascii_trailing_whitespace, ["foo   ", ["foo   "]]);

    test_find_words!(ascii_leading_whitespace, ["   foo", ["   ", "foo"]]);

    test_find_words!(
        ascii_multi_column_char,
        ["\u{1f920}", ["\u{1f920}"]] // cowboy emoji 🤠
    );

    test_find_words!(
        ascii_hyphens,
        ["foo-bar", ["foo-bar"]],
        ["foo- bar", ["foo- ", "bar"]],
        ["foo - bar", ["foo ", "- ", "bar"]],
        ["foo -bar", ["foo ", "-bar"]]
    );

    test_find_words!(ascii_newline, ["foo\nbar", ["foo\nbar"]]);

    test_find_words!(ascii_tab, ["foo\tbar", ["foo\tbar"]]);

    test_find_words!(
        ascii_non_breaking_space,
        ["foo\u{00A0}bar", ["foo\u{00A0}bar"]]
    );
}

```

`clap/clap_builder/src/output/textwrap/wrap_algorithms.rs`:

```rs
use super::core::display_width;

#[derive(Debug)]
pub(crate) struct LineWrapper<'w> {
    hard_width: usize,
    line_width: usize,
    carryover: Option<&'w str>,
}

impl<'w> LineWrapper<'w> {
    pub(crate) fn new(hard_width: usize) -> Self {
        Self {
            hard_width,
            line_width: 0,
            carryover: None,
        }
    }

    pub(crate) fn reset(&mut self) {
        self.line_width = 0;
        self.carryover = None;
    }

    pub(crate) fn wrap(&mut self, mut words: Vec<&'w str>) -> Vec<&'w str> {
        if self.carryover.is_none() {
            if let Some(word) = words.first() {
                if word.trim().is_empty() {
                    self.carryover = Some(*word);
                } else {
                    self.carryover = Some("");
                }
            }
        }

        let mut i = 0;
        while i < words.len() {
            let word = &words[i];
            let trimmed = word.trim_end();
            let word_width = display_width(trimmed);
            let trimmed_delta = word.len() - trimmed.len();
            if i != 0 && self.hard_width < self.line_width + word_width {
                if 0 < i {
                    let last = i - 1;
                    let trimmed = words[last].trim_end();
                    words[last] = trimmed;
                }

                self.line_width = 0;
                words.insert(i, "\n");
                i += 1;
                if let Some(carryover) = self.carryover {
                    words.insert(i, carryover);
                    self.line_width += carryover.len();
                    i += 1;
                }
            }
            self.line_width += word_width + trimmed_delta;

            i += 1;
        }
        words
    }
}

```

`clap/clap_builder/src/output/usage.rs`:

```rs
#![cfg_attr(not(feature = "usage"), allow(unused_imports))]
#![cfg_attr(not(feature = "usage"), allow(unused_variables))]
#![cfg_attr(not(feature = "usage"), allow(clippy::manual_map))]
#![cfg_attr(not(feature = "usage"), allow(dead_code))]

// Internal
use crate::builder::ArgAction;
use crate::builder::StyledStr;
use crate::builder::Styles;
use crate::builder::{ArgPredicate, Command};
use crate::parser::ArgMatcher;
use crate::util::ChildGraph;
use crate::util::FlatSet;
use crate::util::Id;

static DEFAULT_SUB_VALUE_NAME: &str = "COMMAND";
const USAGE_SEP: &str = "\n       ";

pub(crate) struct Usage<'cmd> {
    cmd: &'cmd Command,
    styles: &'cmd Styles,
    required: Option<&'cmd ChildGraph<Id>>,
}

impl<'cmd> Usage<'cmd> {
    pub(crate) fn new(cmd: &'cmd Command) -> Self {
        Usage {
            cmd,
            styles: cmd.get_styles(),
            required: None,
        }
    }

    pub(crate) fn required(mut self, required: &'cmd ChildGraph<Id>) -> Self {
        self.required = Some(required);
        self
    }

    // Creates a usage string for display. This happens just after all arguments were parsed, but before
    // any subcommands have been parsed (so as to give subcommands their own usage recursively)
    pub(crate) fn create_usage_with_title(&self, used: &[Id]) -> Option<StyledStr> {
        debug!("Usage::create_usage_with_title");
        use std::fmt::Write as _;
        let mut styled = StyledStr::new();
        let _ = write!(
            styled,
            "{}Usage:{} ",
            self.styles.get_usage().render(),
            self.styles.get_usage().render_reset()
        );
        if self.write_usage_no_title(&mut styled, used) {
            styled.trim_end();
        } else {
            return None;
        }
        debug!("Usage::create_usage_with_title: usage={styled}");
        Some(styled)
    }

    // Creates a usage string (*without title*) if one was not provided by the user manually.
    pub(crate) fn create_usage_no_title(&self, used: &[Id]) -> Option<StyledStr> {
        debug!("Usage::create_usage_no_title");

        let mut styled = StyledStr::new();
        if self.write_usage_no_title(&mut styled, used) {
            styled.trim_end();
            debug!("Usage::create_usage_no_title: usage={styled}");
            Some(styled)
        } else {
            None
        }
    }

    // Creates a usage string (*without title*) if one was not provided by the user manually.
    fn write_usage_no_title(&self, styled: &mut StyledStr, used: &[Id]) -> bool {
        debug!("Usage::create_usage_no_title");
        if let Some(u) = self.cmd.get_override_usage() {
            styled.push_styled(u);
            true
        } else {
            #[cfg(feature = "usage")]
            {
                if used.is_empty() {
                    self.write_help_usage(styled);
                } else {
                    self.write_smart_usage(styled, used);
                }
                true
            }

            #[cfg(not(feature = "usage"))]
            {
                false
            }
        }
    }
}

#[cfg(feature = "usage")]
impl Usage<'_> {
    // Creates a usage string for display in help messages (i.e. not for errors)
    fn write_help_usage(&self, styled: &mut StyledStr) {
        debug!("Usage::write_help_usage");
        use std::fmt::Write;

        if self.cmd.has_visible_subcommands() && self.cmd.is_flatten_help_set() {
            if !self.cmd.is_subcommand_required_set()
                || self.cmd.is_args_conflicts_with_subcommands_set()
            {
                self.write_arg_usage(styled, &[], true);
                styled.trim_end();
                let _ = write!(styled, "{USAGE_SEP}");
            }
            let mut cmd = self.cmd.clone();
            cmd.build();
            for (i, sub) in cmd
                .get_subcommands()
                .filter(|c| !c.is_hide_set())
                .enumerate()
            {
                if i != 0 {
                    styled.trim_end();
                    let _ = write!(styled, "{USAGE_SEP}");
                }
                Usage::new(sub).write_usage_no_title(styled, &[]);
            }
        } else {
            self.write_arg_usage(styled, &[], true);
            self.write_subcommand_usage(styled);
        }
    }

    // Creates a context aware usage string, or "smart usage" from currently used
    // args, and requirements
    fn write_smart_usage(&self, styled: &mut StyledStr, used: &[Id]) {
        debug!("Usage::create_smart_usage");
        use std::fmt::Write;
        let placeholder = &self.styles.get_placeholder();

        self.write_arg_usage(styled, used, true);

        if self.cmd.is_subcommand_required_set() {
            let value_name = self
                .cmd
                .get_subcommand_value_name()
                .unwrap_or(DEFAULT_SUB_VALUE_NAME);
            let _ = write!(styled, "{placeholder}<{value_name}>{placeholder:#}",);
        }
    }

    fn write_arg_usage(&self, styled: &mut StyledStr, used: &[Id], incl_reqs: bool) {
        debug!("Usage::write_arg_usage; incl_reqs={incl_reqs:?}");
        use std::fmt::Write as _;
        let literal = &self.styles.get_literal();
        let placeholder = &self.styles.get_placeholder();

        let bin_name = self.cmd.get_usage_name_fallback();
        if !bin_name.is_empty() {
            // the trim won't properly remove a leading space due to the formatting
            let _ = write!(styled, "{literal}{bin_name}{literal:#} ",);
        }

        if used.is_empty() && self.needs_options_tag() {
            let _ = write!(styled, "{placeholder}[OPTIONS]{placeholder:#} ",);
        }

        self.write_args(styled, used, !incl_reqs);
    }

    fn write_subcommand_usage(&self, styled: &mut StyledStr) {
        debug!("Usage::write_subcommand_usage");
        use std::fmt::Write as _;

        // incl_reqs is only false when this function is called recursively
        if self.cmd.has_visible_subcommands() || self.cmd.is_allow_external_subcommands_set() {
            let literal = &self.styles.get_literal();
            let placeholder = &self.styles.get_placeholder();
            let value_name = self
                .cmd
                .get_subcommand_value_name()
                .unwrap_or(DEFAULT_SUB_VALUE_NAME);
            if self.cmd.is_subcommand_negates_reqs_set()
                || self.cmd.is_args_conflicts_with_subcommands_set()
            {
                styled.trim_end();
                let _ = write!(styled, "{USAGE_SEP}");
                if self.cmd.is_args_conflicts_with_subcommands_set() {
                    let bin_name = self.cmd.get_usage_name_fallback();
                    // Short-circuit full usage creation since no args will be relevant
                    let _ = write!(styled, "{literal}{bin_name}{literal:#} ",);
                } else {
                    self.write_arg_usage(styled, &[], false);
                }
                let _ = write!(styled, "{placeholder}<{value_name}>{placeholder:#}",);
            } else if self.cmd.is_subcommand_required_set() {
                let _ = write!(styled, "{placeholder}<{value_name}>{placeholder:#}",);
            } else {
                let _ = write!(styled, "{placeholder}[{value_name}]{placeholder:#}",);
            }
        }
    }

    // Determines if we need the `[OPTIONS]` tag in the usage string
    fn needs_options_tag(&self) -> bool {
        debug!("Usage::needs_options_tag");
        'outer: for f in self.cmd.get_non_positionals() {
            debug!("Usage::needs_options_tag:iter: f={}", f.get_id());

            // Don't print `[OPTIONS]` just for help or version
            if f.get_long() == Some("help") || f.get_long() == Some("version") {
                debug!("Usage::needs_options_tag:iter Option is built-in");
                continue;
            }
            match f.get_action() {
                ArgAction::Set
                | ArgAction::Append
                | ArgAction::SetTrue
                | ArgAction::SetFalse
                | ArgAction::Count => {}
                ArgAction::Help
                | ArgAction::HelpShort
                | ArgAction::HelpLong
                | ArgAction::Version => {
                    debug!("Usage::needs_options_tag:iter Option is built-in");
                    continue;
                }
            }

            if f.is_hide_set() {
                debug!("Usage::needs_options_tag:iter Option is hidden");
                continue;
            }
            if f.is_required_set() {
                debug!("Usage::needs_options_tag:iter Option is required");
                continue;
            }
            for grp_s in self.cmd.groups_for_arg(f.get_id()) {
                debug!("Usage::needs_options_tag:iter:iter: grp_s={grp_s:?}");
                if self.cmd.get_groups().any(|g| g.id == grp_s && g.required) {
                    debug!("Usage::needs_options_tag:iter:iter: Group is required");
                    continue 'outer;
                }
            }

            debug!("Usage::needs_options_tag:iter: [OPTIONS] required");
            return true;
        }

        debug!("Usage::needs_options_tag: [OPTIONS] not required");
        false
    }

    // Returns the required args in usage string form by fully unrolling all groups
    pub(crate) fn write_args(&self, styled: &mut StyledStr, incls: &[Id], force_optional: bool) {
        debug!("Usage::write_args: incls={incls:?}",);
        use std::fmt::Write as _;
        let literal = &self.styles.get_literal();

        let required_owned;
        let required = if let Some(required) = self.required {
            required
        } else {
            required_owned = self.cmd.required_graph();
            &required_owned
        };

        let mut unrolled_reqs = Vec::new();
        for a in required.iter() {
            let is_relevant = |(val, req_arg): &(ArgPredicate, Id)| -> Option<Id> {
                let required = match val {
                    ArgPredicate::Equals(_) => false,
                    ArgPredicate::IsPresent => true,
                };
                required.then(|| req_arg.clone())
            };

            for aa in self.cmd.unroll_arg_requires(is_relevant, a) {
                // if we don't check for duplicates here this causes duplicate error messages
                // see https://github.com/clap-rs/clap/issues/2770
                unrolled_reqs.push(aa);
            }
            // always include the required arg itself. it will not be enumerated
            // by unroll_requirements_for_arg.
            unrolled_reqs.push(a.clone());
        }
        debug!("Usage::get_args: unrolled_reqs={unrolled_reqs:?}");

        let mut required_groups_members = FlatSet::new();
        let mut required_groups = FlatSet::new();
        for req in unrolled_reqs.iter().chain(incls.iter()) {
            if self.cmd.find_group(req).is_some() {
                let group_members = self.cmd.unroll_args_in_group(req);
                let elem = self.cmd.format_group(req);
                required_groups.insert(elem);
                required_groups_members.extend(group_members);
            } else {
                debug_assert!(self.cmd.find(req).is_some());
            }
        }

        let mut required_opts = FlatSet::new();
        let mut required_positionals = Vec::new();
        for req in unrolled_reqs.iter().chain(incls.iter()) {
            if let Some(arg) = self.cmd.find(req) {
                if required_groups_members.contains(arg.get_id()) {
                    continue;
                }

                let stylized = arg.stylized(self.styles, Some(!force_optional));
                if let Some(index) = arg.get_index() {
                    let new_len = index + 1;
                    if required_positionals.len() < new_len {
                        required_positionals.resize(new_len, None);
                    }
                    required_positionals[index] = Some(stylized);
                } else {
                    required_opts.insert(stylized);
                }
            } else {
                debug_assert!(self.cmd.find_group(req).is_some());
            }
        }

        for pos in self.cmd.get_positionals() {
            if pos.is_hide_set() {
                continue;
            }
            if required_groups_members.contains(pos.get_id()) {
                continue;
            }

            let index = pos.get_index().unwrap();
            let new_len = index + 1;
            if required_positionals.len() < new_len {
                required_positionals.resize(new_len, None);
            }
            if required_positionals[index].is_some() {
                if pos.is_last_set() {
                    let styled = required_positionals[index].take().unwrap();
                    let mut new = StyledStr::new();
                    let _ = write!(new, "{literal}--{literal:#} ");
                    new.push_styled(&styled);
                    required_positionals[index] = Some(new);
                }
            } else {
                let mut styled;
                if pos.is_last_set() {
                    styled = StyledStr::new();
                    let _ = write!(styled, "{literal}[--{literal:#} ");
                    styled.push_styled(&pos.stylized(self.styles, Some(true)));
                    let _ = write!(styled, "{literal}]{literal:#}");
                } else {
                    styled = pos.stylized(self.styles, Some(false));
                }
                required_positionals[index] = Some(styled);
            }
            if pos.is_last_set() && force_optional {
                required_positionals[index] = None;
            }
        }

        if !force_optional {
            for arg in required_opts {
                styled.push_styled(&arg);
                styled.push_str(" ");
            }
            for arg in required_groups {
                styled.push_styled(&arg);
                styled.push_str(" ");
            }
        }
        for arg in required_positionals.into_iter().flatten() {
            styled.push_styled(&arg);
            styled.push_str(" ");
        }
    }

    pub(crate) fn get_required_usage_from(
        &self,
        incls: &[Id],
        matcher: Option<&ArgMatcher>,
        incl_last: bool,
    ) -> Vec<StyledStr> {
        debug!(
            "Usage::get_required_usage_from: incls={:?}, matcher={:?}, incl_last={:?}",
            incls,
            matcher.is_some(),
            incl_last
        );

        let required_owned;
        let required = if let Some(required) = self.required {
            required
        } else {
            required_owned = self.cmd.required_graph();
            &required_owned
        };

        let mut unrolled_reqs = Vec::new();
        for a in required.iter() {
            let is_relevant = |(val, req_arg): &(ArgPredicate, Id)| -> Option<Id> {
                let required = match val {
                    ArgPredicate::Equals(_) => {
                        if let Some(matcher) = matcher {
                            matcher.check_explicit(a, val)
                        } else {
                            false
                        }
                    }
                    ArgPredicate::IsPresent => true,
                };
                required.then(|| req_arg.clone())
            };

            for aa in self.cmd.unroll_arg_requires(is_relevant, a) {
                // if we don't check for duplicates here this causes duplicate error messages
                // see https://github.com/clap-rs/clap/issues/2770
                unrolled_reqs.push(aa);
            }
            // always include the required arg itself. it will not be enumerated
            // by unroll_requirements_for_arg.
            unrolled_reqs.push(a.clone());
        }
        debug!("Usage::get_required_usage_from: unrolled_reqs={unrolled_reqs:?}");

        let mut required_groups_members = FlatSet::new();
        let mut required_groups = FlatSet::new();
        for req in unrolled_reqs.iter().chain(incls.iter()) {
            if self.cmd.find_group(req).is_some() {
                let group_members = self.cmd.unroll_args_in_group(req);
                let is_present = matcher
                    .map(|m| {
                        group_members
                            .iter()
                            .any(|arg| m.check_explicit(arg, &ArgPredicate::IsPresent))
                    })
                    .unwrap_or(false);
                debug!("Usage::get_required_usage_from:iter:{req:?} group is_present={is_present}");
                if is_present {
                    continue;
                }

                let elem = self.cmd.format_group(req);
                required_groups.insert(elem);
                required_groups_members.extend(group_members);
            } else {
                debug_assert!(self.cmd.find(req).is_some(), "`{req}` must exist");
            }
        }

        let mut required_opts = FlatSet::new();
        let mut required_positionals = Vec::new();
        for req in unrolled_reqs.iter().chain(incls.iter()) {
            if let Some(arg) = self.cmd.find(req) {
                if required_groups_members.contains(arg.get_id()) {
                    continue;
                }

                let is_present = matcher
                    .map(|m| m.check_explicit(req, &ArgPredicate::IsPresent))
                    .unwrap_or(false);
                debug!("Usage::get_required_usage_from:iter:{req:?} arg is_present={is_present}");
                if is_present {
                    continue;
                }

                let stylized = arg.stylized(self.styles, Some(true));
                if let Some(index) = arg.get_index() {
                    if !arg.is_last_set() || incl_last {
                        let new_len = index + 1;
                        if required_positionals.len() < new_len {
                            required_positionals.resize(new_len, None);
                        }
                        required_positionals[index] = Some(stylized);
                    }
                } else {
                    required_opts.insert(stylized);
                }
            } else {
                debug_assert!(self.cmd.find_group(req).is_some());
            }
        }

        let mut ret_val = Vec::new();
        ret_val.extend(required_opts);
        ret_val.extend(required_groups);
        for pos in required_positionals.into_iter().flatten() {
            ret_val.push(pos);
        }

        debug!("Usage::get_required_usage_from: ret_val={ret_val:?}");
        ret_val
    }
}

```

`clap/clap_builder/src/parser/arg_matcher.rs`:

```rs
// Std
use std::ffi::OsString;
use std::mem;
use std::ops::Deref;

// Internal
use crate::builder::{Arg, ArgPredicate, Command};
use crate::parser::Identifier;
use crate::parser::PendingArg;
use crate::parser::{ArgMatches, MatchedArg, SubCommand, ValueSource};
use crate::util::AnyValue;
use crate::util::FlatMap;
use crate::util::Id;
use crate::INTERNAL_ERROR_MSG;

#[derive(Debug, Default)]
pub(crate) struct ArgMatcher {
    matches: ArgMatches,
    pending: Option<PendingArg>,
}

impl ArgMatcher {
    pub(crate) fn new(_cmd: &Command) -> Self {
        ArgMatcher {
            matches: ArgMatches {
                #[cfg(debug_assertions)]
                valid_args: {
                    let args = _cmd.get_arguments().map(|a| a.get_id().clone());
                    let groups = _cmd.get_groups().map(|g| g.get_id().clone());
                    args.chain(groups).collect()
                },
                #[cfg(debug_assertions)]
                valid_subcommands: _cmd
                    .get_subcommands()
                    .map(|sc| sc.get_name_str().clone())
                    .collect(),
                ..Default::default()
            },
            pending: None,
        }
    }

    pub(crate) fn into_inner(self) -> ArgMatches {
        self.matches
    }

    pub(crate) fn propagate_globals(&mut self, global_arg_vec: &[Id]) {
        debug!("ArgMatcher::get_global_values: global_arg_vec={global_arg_vec:?}");
        let mut vals_map = FlatMap::new();
        self.fill_in_global_values(global_arg_vec, &mut vals_map);
    }

    fn fill_in_global_values(
        &mut self,
        global_arg_vec: &[Id],
        vals_map: &mut FlatMap<Id, MatchedArg>,
    ) {
        for global_arg in global_arg_vec {
            if let Some(ma) = self.get(global_arg) {
                // We have to check if the parent's global arg wasn't used but still exists
                // such as from a default value.
                //
                // For example, `myprog subcommand --global-arg=value` where `--global-arg` defines
                // a default value of `other` myprog would have an existing MatchedArg for
                // `--global-arg` where the value is `other`
                let to_update = if let Some(parent_ma) = vals_map.get(global_arg) {
                    if parent_ma.source() > ma.source() {
                        parent_ma
                    } else {
                        ma
                    }
                } else {
                    ma
                }
                .clone();
                vals_map.insert(global_arg.clone(), to_update);
            }
        }
        if let Some(ref mut sc) = self.matches.subcommand {
            let mut am = ArgMatcher {
                matches: mem::take(&mut sc.matches),
                pending: None,
            };
            am.fill_in_global_values(global_arg_vec, vals_map);
            mem::swap(&mut am.matches, &mut sc.matches);
        }

        for (name, matched_arg) in vals_map.iter_mut() {
            self.matches.args.insert(name.clone(), matched_arg.clone());
        }
    }

    pub(crate) fn get(&self, arg: &Id) -> Option<&MatchedArg> {
        self.matches.args.get(arg)
    }

    pub(crate) fn get_mut(&mut self, arg: &Id) -> Option<&mut MatchedArg> {
        self.matches.args.get_mut(arg)
    }

    pub(crate) fn remove(&mut self, arg: &Id) -> bool {
        self.matches.args.remove(arg).is_some()
    }

    pub(crate) fn contains(&self, arg: &Id) -> bool {
        self.matches.args.contains_key(arg)
    }

    pub(crate) fn arg_ids(&self) -> std::slice::Iter<'_, Id> {
        self.matches.args.keys()
    }

    pub(crate) fn args(&self) -> crate::util::flat_map::Iter<'_, Id, MatchedArg> {
        self.matches.args.iter()
    }

    pub(crate) fn entry(&mut self, arg: Id) -> crate::util::Entry<'_, Id, MatchedArg> {
        self.matches.args.entry(arg)
    }

    pub(crate) fn subcommand(&mut self, sc: SubCommand) {
        self.matches.subcommand = Some(Box::new(sc));
    }

    pub(crate) fn subcommand_name(&self) -> Option<&str> {
        self.matches.subcommand_name()
    }

    pub(crate) fn check_explicit(&self, arg: &Id, predicate: &ArgPredicate) -> bool {
        self.get(arg)
            .map(|a| a.check_explicit(predicate))
            .unwrap_or_default()
    }

    pub(crate) fn start_custom_arg(&mut self, arg: &Arg, source: ValueSource) {
        let id = arg.get_id().clone();
        debug!("ArgMatcher::start_custom_arg: id={id:?}, source={source:?}");
        let ma = self.entry(id).or_insert(MatchedArg::new_arg(arg));
        debug_assert_eq!(ma.type_id(), Some(arg.get_value_parser().type_id()));
        ma.set_source(source);
        ma.new_val_group();
    }

    pub(crate) fn start_custom_group(&mut self, id: Id, source: ValueSource) {
        debug!("ArgMatcher::start_custom_arg: id={id:?}, source={source:?}");
        let ma = self.entry(id).or_insert(MatchedArg::new_group());
        debug_assert_eq!(ma.type_id(), None);
        ma.set_source(source);
        ma.new_val_group();
    }

    pub(crate) fn start_occurrence_of_external(&mut self, cmd: &Command) {
        let id = Id::from_static_ref(Id::EXTERNAL);
        debug!("ArgMatcher::start_occurrence_of_external: id={id:?}");
        let ma = self.entry(id).or_insert(MatchedArg::new_external(cmd));
        debug_assert_eq!(
            ma.type_id(),
            Some(
                cmd.get_external_subcommand_value_parser()
                    .expect(INTERNAL_ERROR_MSG)
                    .type_id()
            )
        );
        ma.set_source(ValueSource::CommandLine);
        ma.new_val_group();
    }

    pub(crate) fn add_val_to(&mut self, arg: &Id, val: AnyValue, raw_val: OsString) {
        let ma = self.get_mut(arg).expect(INTERNAL_ERROR_MSG);
        ma.append_val(val, raw_val);
    }

    pub(crate) fn add_index_to(&mut self, arg: &Id, idx: usize) {
        let ma = self.get_mut(arg).expect(INTERNAL_ERROR_MSG);
        ma.push_index(idx);
    }

    pub(crate) fn needs_more_vals(&self, o: &Arg) -> bool {
        let num_pending = self
            .pending
            .as_ref()
            .and_then(|p| (p.id == *o.get_id()).then_some(p.raw_vals.len()))
            .unwrap_or(0);
        debug!(
            "ArgMatcher::needs_more_vals: o={}, pending={}",
            o.get_id(),
            num_pending
        );
        let expected = o.get_num_args().expect(INTERNAL_ERROR_MSG);
        debug!("ArgMatcher::needs_more_vals: expected={expected}, actual={num_pending}");
        expected.accepts_more(num_pending)
    }

    pub(crate) fn pending_arg_id(&self) -> Option<&Id> {
        self.pending.as_ref().map(|p| &p.id)
    }

    pub(crate) fn pending_values_mut(
        &mut self,
        id: &Id,
        ident: Option<Identifier>,
        trailing_values: bool,
    ) -> &mut Vec<OsString> {
        let pending = self.pending.get_or_insert_with(|| PendingArg {
            id: id.clone(),
            ident,
            raw_vals: Default::default(),
            trailing_idx: None,
        });
        debug_assert_eq!(pending.id, *id, "{INTERNAL_ERROR_MSG}");
        if ident.is_some() {
            debug_assert_eq!(pending.ident, ident, "{INTERNAL_ERROR_MSG}");
        }
        if trailing_values {
            pending.trailing_idx.get_or_insert(pending.raw_vals.len());
        }
        &mut pending.raw_vals
    }

    pub(crate) fn start_trailing(&mut self) {
        if let Some(pending) = &mut self.pending {
            // Allow asserting its started on subsequent calls
            pending.trailing_idx.get_or_insert(pending.raw_vals.len());
        }
    }

    pub(crate) fn take_pending(&mut self) -> Option<PendingArg> {
        self.pending.take()
    }
}

impl Deref for ArgMatcher {
    type Target = ArgMatches;

    fn deref(&self) -> &Self::Target {
        &self.matches
    }
}

```

`clap/clap_builder/src/parser/error.rs`:

```rs
use crate::util::AnyValueId;

/// Violation of [`ArgMatches`][crate::ArgMatches] assumptions
#[derive(Clone, Debug)]
#[allow(missing_copy_implementations)] // We might add non-Copy types in the future
#[non_exhaustive]
pub enum MatchesError {
    /// Failed to downcast `AnyValue` to the specified type
    #[non_exhaustive]
    Downcast {
        /// Type for value stored in [`ArgMatches`][crate::ArgMatches]
        actual: AnyValueId,
        /// The target type to downcast to
        expected: AnyValueId,
    },
    /// Argument not defined in [`Command`][crate::Command]
    #[non_exhaustive]
    UnknownArgument {
        // Missing `id` but blocked on a public id type which will hopefully come with `unstable-v4`
    },
}

impl MatchesError {
    #[cfg_attr(debug_assertions, track_caller)]
    pub(crate) fn unwrap<T>(id: &str, r: Result<T, MatchesError>) -> T {
        let err = match r {
            Ok(t) => {
                return t;
            }
            Err(err) => err,
        };
        panic!("Mismatch between definition and access of `{id}`. {err}",)
    }
}

impl std::error::Error for MatchesError {}

impl std::fmt::Display for MatchesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Downcast { actual, expected } => {
                writeln!(
                    f,
                    "Could not downcast to {expected:?}, need to downcast to {actual:?}"
                )
            }
            Self::UnknownArgument {} => {
                writeln!(f, "Unknown argument or group id.  Make sure you are using the argument id and not the short or long flags")
            }
        }
    }
}

#[test]
fn check_auto_traits() {
    static_assertions::assert_impl_all!(
        MatchesError: Send,
        Sync,
        std::panic::RefUnwindSafe,
        std::panic::UnwindSafe,
        Unpin
    );
}

```

`clap/clap_builder/src/parser/features/mod.rs`:

```rs
pub(crate) mod suggestions;

```

`clap/clap_builder/src/parser/features/suggestions.rs`:

```rs
// Internal
use crate::builder::Command;

/// Find strings from an iterable of `possible_values` similar to a given value `v`
/// Returns a Vec of all possible values that exceed a similarity threshold
/// sorted by ascending similarity, most similar comes last
#[cfg(feature = "suggestions")]
pub(crate) fn did_you_mean<T, I>(v: &str, possible_values: I) -> Vec<String>
where
    T: AsRef<str>,
    I: IntoIterator<Item = T>,
{
    use std::cmp::Ordering;

    let mut candidates: Vec<(f64, String)> = Vec::new();
    for pv in possible_values {
        // GH #4660: using `jaro` because `jaro_winkler` implementation in `strsim-rs` is wrong
        // causing strings with common prefix >=10 to be considered perfectly similar
        let confidence = strsim::jaro(v, pv.as_ref());

        if confidence > 0.7 {
            let new_elem = (confidence, pv.as_ref().to_owned());
            let pos = candidates
                .binary_search_by(|probe| {
                    if probe.0 > confidence {
                        Ordering::Greater
                    } else {
                        Ordering::Less
                    }
                })
                .unwrap_or_else(|e| e);
            candidates.insert(pos, new_elem);
        }
    }

    candidates.into_iter().map(|(_, pv)| pv).collect()
}

#[cfg(not(feature = "suggestions"))]
pub(crate) fn did_you_mean<T, I>(_: &str, _: I) -> Vec<String>
where
    T: AsRef<str>,
    I: IntoIterator<Item = T>,
{
    Vec::new()
}

/// Returns a suffix that can be empty, or is the standard 'did you mean' phrase
pub(crate) fn did_you_mean_flag<'a, 'help, I, T>(
    arg: &str,
    remaining_args: &[&std::ffi::OsStr],
    longs: I,
    subcommands: impl IntoIterator<Item = &'a mut Command>,
) -> Option<(String, Option<String>)>
where
    'help: 'a,
    T: AsRef<str>,
    I: IntoIterator<Item = T>,
{
    use crate::mkeymap::KeyType;

    match did_you_mean(arg, longs).pop() {
        Some(candidate) => Some((candidate, None)),
        None => subcommands
            .into_iter()
            .filter_map(|subcommand| {
                subcommand._build_self(false);

                let longs = subcommand.get_keymap().keys().filter_map(|a| {
                    if let KeyType::Long(v) = a {
                        Some(v.to_string_lossy().into_owned())
                    } else {
                        None
                    }
                });

                let subcommand_name = subcommand.get_name();

                let candidate = some!(did_you_mean(arg, longs).pop());
                let score = some!(remaining_args.iter().position(|x| subcommand_name == *x));
                Some((score, (candidate, Some(subcommand_name.to_string()))))
            })
            .min_by_key(|(x, _)| *x)
            .map(|(_, suggestion)| suggestion),
    }
}

#[cfg(all(test, feature = "suggestions"))]
mod test {
    use super::*;

    #[test]
    fn missing_letter() {
        let p_vals = ["test", "possible", "values"];
        assert_eq!(did_you_mean("tst", p_vals.iter()), vec!["test"]);
    }

    #[test]
    fn ambiguous() {
        let p_vals = ["test", "temp", "possible", "values"];
        assert_eq!(did_you_mean("te", p_vals.iter()), vec!["test", "temp"]);
    }

    #[test]
    fn unrelated() {
        let p_vals = ["test", "possible", "values"];
        assert_eq!(
            did_you_mean("hahaahahah", p_vals.iter()),
            Vec::<String>::new()
        );
    }

    #[test]
    fn best_fit() {
        let p_vals = [
            "test",
            "possible",
            "values",
            "alignmentStart",
            "alignmentScore",
        ];
        assert_eq!(
            did_you_mean("alignmentScorr", p_vals.iter()),
            vec!["alignmentStart", "alignmentScore"]
        );
    }

    #[test]
    fn best_fit_long_common_prefix_issue_4660() {
        let p_vals = ["alignmentScore", "alignmentStart"];
        assert_eq!(
            did_you_mean("alignmentScorr", p_vals.iter()),
            vec!["alignmentStart", "alignmentScore"]
        );
    }

    #[test]
    fn flag_missing_letter() {
        let p_vals = ["test", "possible", "values"];
        assert_eq!(
            did_you_mean_flag("tst", &[], p_vals.iter(), []),
            Some(("test".to_owned(), None))
        );
    }

    #[test]
    fn flag_ambiguous() {
        let p_vals = ["test", "temp", "possible", "values"];
        assert_eq!(
            did_you_mean_flag("te", &[], p_vals.iter(), []),
            Some(("temp".to_owned(), None))
        );
    }

    #[test]
    fn flag_unrelated() {
        let p_vals = ["test", "possible", "values"];
        assert_eq!(
            did_you_mean_flag("hahaahahah", &[], p_vals.iter(), []),
            None
        );
    }

    #[test]
    fn flag_best_fit() {
        let p_vals = [
            "test",
            "possible",
            "values",
            "alignmentStart",
            "alignmentScore",
        ];
        assert_eq!(
            did_you_mean_flag("alignmentScorr", &[], p_vals.iter(), []),
            Some(("alignmentScore".to_owned(), None))
        );
    }
}

```

`clap/clap_builder/src/parser/matches/arg_matches.rs`:

```rs
// Std
use std::any::Any;
use std::ffi::{OsStr, OsString};
use std::fmt::Debug;
use std::iter::{Cloned, Flatten, Map};
use std::slice::Iter;

// Internal
#[cfg(debug_assertions)]
use crate::builder::Str;
use crate::parser::MatchedArg;
use crate::parser::MatchesError;
use crate::parser::ValueSource;
use crate::util::AnyValue;
use crate::util::AnyValueId;
use crate::util::FlatMap;
use crate::util::Id;
use crate::INTERNAL_ERROR_MSG;

/// Container for parse results.
///
/// Used to get information about the arguments that were supplied to the program at runtime by
/// the user. New instances of this struct are obtained by using the [`Command::get_matches`] family of
/// methods.
///
/// # Examples
///
/// ```no_run
/// # use clap_builder as clap;
/// # use clap::{Command, Arg, ArgAction};
/// # use clap::parser::ValueSource;
/// let matches = Command::new("MyApp")
///     .arg(Arg::new("out")
///         .long("output")
///         .required(true)
///         .action(ArgAction::Set)
///         .default_value("-"))
///     .arg(Arg::new("cfg")
///         .short('c')
///         .action(ArgAction::Set))
///     .get_matches(); // builds the instance of ArgMatches
///
/// // to get information about the "cfg" argument we created, such as the value supplied we use
/// // various ArgMatches methods, such as [ArgMatches::get_one]
/// if let Some(c) = matches.get_one::<String>("cfg") {
///     println!("Value for -c: {c}");
/// }
///
/// // The ArgMatches::get_one method returns an Option because the user may not have supplied
/// // that argument at runtime. But if we specified that the argument was "required" as we did
/// // with the "out" argument, we can safely unwrap because `clap` verifies that was actually
/// // used at runtime.
/// println!("Value for --output: {}", matches.get_one::<String>("out").unwrap());
///
/// // You can check the presence of an argument's values
/// if matches.contains_id("out") {
///     // However, if you want to know where the value came from
///     if matches.value_source("out").expect("checked contains_id") == ValueSource::CommandLine {
///         println!("`out` set by user");
///     } else {
///         println!("`out` is defaulted");
///     }
/// }
/// ```
/// [`Command::get_matches`]: crate::Command::get_matches()
#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct ArgMatches {
    #[cfg(debug_assertions)]
    pub(crate) valid_args: Vec<Id>,
    #[cfg(debug_assertions)]
    pub(crate) valid_subcommands: Vec<Str>,
    pub(crate) args: FlatMap<Id, MatchedArg>,
    pub(crate) subcommand: Option<Box<SubCommand>>,
}

/// # Arguments
impl ArgMatches {
    /// Gets the value of a specific option or positional argument.
    ///
    /// i.e. an argument that [takes an additional value][crate::Arg::num_args] at runtime.
    ///
    /// Returns an error if the wrong type was used.
    ///
    /// Returns `None` if the option wasn't present.
    ///
    /// <div class="warning">
    ///
    /// *NOTE:* This will always return `Some(value)` if [`default_value`] has been set.
    /// [`ArgMatches::value_source`] can be used to check if a value is present at runtime.
    ///
    /// </div>
    ///
    /// # Panic
    ///
    /// If the argument definition and access mismatch.  To handle this case programmatically, see
    /// [`ArgMatches::try_get_one`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, value_parser, ArgAction};
    /// let m = Command::new("myapp")
    ///     .arg(Arg::new("port")
    ///         .value_parser(value_parser!(usize))
    ///         .action(ArgAction::Set)
    ///         .required(true))
    ///     .get_matches_from(vec!["myapp", "2020"]);
    ///
    /// let port: usize = *m
    ///     .get_one("port")
    ///     .expect("`port`is required");
    /// assert_eq!(port, 2020);
    /// ```
    /// [positional]: crate::Arg::index()
    /// [`default_value`]: crate::Arg::default_value()
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn get_one<T: Any + Clone + Send + Sync + 'static>(&self, id: &str) -> Option<&T> {
        MatchesError::unwrap(id, self.try_get_one(id))
    }

    /// Gets the value of a specific [`ArgAction::Count`][crate::ArgAction::Count] flag
    ///
    /// # Panic
    ///
    /// If the argument's action is not [`ArgAction::Count`][crate::ArgAction::Count]
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::Count)
    ///     );
    ///
    /// let matches = cmd.clone().try_get_matches_from(["mycmd", "--flag", "--flag"]).unwrap();
    /// assert_eq!(
    ///     matches.get_count("flag"),
    ///     2
    /// );
    /// ```
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn get_count(&self, id: &str) -> u8 {
        *self.get_one::<u8>(id).unwrap_or_else(|| {
            panic!("arg `{id}`'s `ArgAction` should be `Count` which should provide a default")
        })
    }

    /// Gets the value of a specific [`ArgAction::SetTrue`][crate::ArgAction::SetTrue] or [`ArgAction::SetFalse`][crate::ArgAction::SetFalse] flag
    ///
    /// # Panic
    ///
    /// If the argument's action is not [`ArgAction::SetTrue`][crate::ArgAction::SetTrue] or [`ArgAction::SetFalse`][crate::ArgAction::SetFalse]
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::Command;
    /// # use clap::Arg;
    /// let cmd = Command::new("mycmd")
    ///     .arg(
    ///         Arg::new("flag")
    ///             .long("flag")
    ///             .action(clap::ArgAction::SetTrue)
    ///     );
    ///
    /// let matches = cmd.clone().try_get_matches_from(["mycmd", "--flag"]).unwrap();
    /// assert!(matches.contains_id("flag"));
    /// assert_eq!(
    ///     matches.get_flag("flag"),
    ///     true
    /// );
    /// ```
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn get_flag(&self, id: &str) -> bool {
        *self
            .get_one::<bool>(id)
            .unwrap_or_else(|| {
                panic!(
                    "arg `{id}`'s `ArgAction` should be one of `SetTrue`, `SetFalse` which should provide a default"
                )
            })
    }

    /// Iterate over values of a specific option or positional argument.
    ///
    /// i.e. an argument that takes multiple values at runtime.
    ///
    /// Returns an error if the wrong type was used.
    ///
    /// Returns `None` if the option wasn't present.
    ///
    /// # Panic
    ///
    /// If the argument definition and access mismatch.  To handle this case programmatically, see
    /// [`ArgMatches::try_get_many`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, value_parser, ArgAction};
    /// let m = Command::new("myprog")
    ///     .arg(Arg::new("ports")
    ///         .action(ArgAction::Append)
    ///         .value_parser(value_parser!(usize))
    ///         .short('p')
    ///         .required(true))
    ///     .get_matches_from(vec![
    ///         "myprog", "-p", "22", "-p", "80", "-p", "2020"
    ///     ]);
    /// let vals: Vec<usize> = m.get_many("ports")
    ///     .expect("`port`is required")
    ///     .copied()
    ///     .collect();
    /// assert_eq!(vals, [22, 80, 2020]);
    /// ```
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn get_many<T: Any + Clone + Send + Sync + 'static>(
        &self,
        id: &str,
    ) -> Option<ValuesRef<'_, T>> {
        MatchesError::unwrap(id, self.try_get_many(id))
    }

    /// Iterate over the values passed to each occurrence of an option.
    ///
    /// Each item is itself an iterator containing the arguments passed to a single occurrence
    /// of the option.
    ///
    /// If the option doesn't support multiple occurrences, or there was only a single occurrence,
    /// the iterator will only contain a single item.
    ///
    /// Returns `None` if the option wasn't present.
    ///
    /// # Panics
    ///
    /// If the argument definition and access mismatch (debug builds). To handle this case programmatically, see
    /// [`ArgMatches::try_get_occurrences`].
    ///
    /// # Examples
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command,Arg, ArgAction, value_parser};
    /// let m = Command::new("myprog")
    ///     .arg(Arg::new("x")
    ///         .short('x')
    ///         .num_args(2)
    ///         .action(ArgAction::Append)
    ///         .value_parser(value_parser!(String)))
    ///     .get_matches_from(vec![
    ///         "myprog", "-x", "a", "b", "-x", "c", "d"]);
    /// let vals: Vec<Vec<&String>> = m.get_occurrences("x").unwrap().map(Iterator::collect).collect();
    /// assert_eq!(vals, [["a", "b"], ["c", "d"]]);
    /// ```
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn get_occurrences<T: Any + Clone + Send + Sync + 'static>(
        &self,
        id: &str,
    ) -> Option<OccurrencesRef<'_, T>> {
        MatchesError::unwrap(id, self.try_get_occurrences(id))
    }

    /// Iterate over the original argument values.
    ///
    /// An `OsStr` on Unix-like systems is any series of bytes, regardless of whether or not they
    /// contain valid UTF-8. Since [`String`]s in Rust are guaranteed to be valid UTF-8, a valid
    /// filename on a Unix system as an argument value may contain invalid UTF-8.
    ///
    /// Returns `None` if the option wasn't present.
    ///
    /// # Panic
    ///
    /// If the argument definition and access mismatch.  To handle this case programmatically, see
    /// [`ArgMatches::try_get_raw`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(unix)] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg, value_parser};
    /// # use std::ffi::{OsStr,OsString};
    /// # use std::os::unix::ffi::{OsStrExt,OsStringExt};
    /// use std::path::PathBuf;
    ///
    /// let m = Command::new("utf8")
    ///     .arg(arg!(<arg> ... "some arg").value_parser(value_parser!(PathBuf)))
    ///     .get_matches_from(vec![OsString::from("myprog"),
    ///                                 // "Hi"
    ///                                 OsString::from_vec(vec![b'H', b'i']),
    ///                                 // "{0xe9}!"
    ///                                 OsString::from_vec(vec![0xe9, b'!'])]);
    ///
    /// let mut itr = m.get_raw("arg")
    ///     .expect("`port`is required")
    ///     .into_iter();
    /// assert_eq!(itr.next(), Some(OsStr::new("Hi")));
    /// assert_eq!(itr.next(), Some(OsStr::from_bytes(&[0xe9, b'!'])));
    /// assert_eq!(itr.next(), None);
    /// # }
    /// ```
    /// [`Iterator`]: std::iter::Iterator
    /// [`OsSt`]: std::ffi::OsStr
    /// [values]: OsValues
    /// [`String`]: std::string::String
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn get_raw(&self, id: &str) -> Option<RawValues<'_>> {
        MatchesError::unwrap(id, self.try_get_raw(id))
    }

    /// Iterate over the original values for each occurrence of an option.
    ///
    /// Similar to [`ArgMatches::get_occurrences`] but returns raw values.
    ///
    /// An `OsStr` on Unix-like systems is any series of bytes, regardless of whether or not they
    /// contain valid UTF-8. Since [`String`]s in Rust are guaranteed to be valid UTF-8, a valid
    /// filename on a Unix system as an argument value may contain invalid UTF-8.
    ///
    /// Returns `None` if the option wasn't present.
    ///
    /// # Panic
    ///
    /// If the argument definition and access mismatch.  To handle this case programmatically, see
    /// [`ArgMatches::try_get_raw_occurrences`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(unix)] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg, value_parser, ArgAction, Arg};
    /// # use std::ffi::{OsStr,OsString};
    /// # use std::os::unix::ffi::{OsStrExt,OsStringExt};
    /// use std::path::PathBuf;
    ///
    /// let m = Command::new("myprog")
    ///     .arg(Arg::new("x")
    ///         .short('x')
    ///         .num_args(2)
    ///         .action(ArgAction::Append)
    ///         .value_parser(value_parser!(PathBuf)))
    ///     .get_matches_from(vec![OsString::from("myprog"),
    ///                             OsString::from("-x"),
    ///                             OsString::from("a"), OsString::from("b"),
    ///                             OsString::from("-x"),
    ///                             OsString::from("c"),
    ///                             // "{0xe9}!"
    ///                             OsString::from_vec(vec![0xe9, b'!'])]);
    /// let mut itr = m.get_raw_occurrences("x")
    ///     .expect("`-x`is required")
    ///     .map(Iterator::collect::<Vec<_>>);
    /// assert_eq!(itr.next(), Some(vec![OsStr::new("a"), OsStr::new("b")]));
    /// assert_eq!(itr.next(), Some(vec![OsStr::new("c"), OsStr::from_bytes(&[0xe9, b'!'])]));
    /// assert_eq!(itr.next(), None);
    /// # }
    /// ```
    /// [`Iterator`]: std::iter::Iterator
    /// [`OsStr`]: std::ffi::OsStr
    /// [values]: OsValues
    /// [`String`]: std::string::String
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn get_raw_occurrences(&self, id: &str) -> Option<RawOccurrences<'_>> {
        MatchesError::unwrap(id, self.try_get_raw_occurrences(id))
    }

    /// Returns the value of a specific option or positional argument.
    ///
    /// i.e. an argument that [takes an additional value][crate::Arg::num_args] at runtime.
    ///
    /// Returns an error if the wrong type was used.  No item will have been removed.
    ///
    /// Returns `None` if the option wasn't present.
    ///
    /// <div class="warning">
    ///
    /// *NOTE:* This will always return `Some(value)` if [`default_value`] has been set.
    /// [`ArgMatches::value_source`] can be used to check if a value is present at runtime.
    ///
    /// </div>
    ///
    /// # Panic
    ///
    /// If the argument definition and access mismatch.  To handle this case programmatically, see
    /// [`ArgMatches::try_remove_one`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, value_parser, ArgAction};
    /// let mut m = Command::new("myprog")
    ///     .arg(Arg::new("file")
    ///         .required(true)
    ///         .action(ArgAction::Set))
    ///     .get_matches_from(vec![
    ///         "myprog", "file.txt",
    ///     ]);
    /// let vals: String = m.remove_one("file")
    ///     .expect("`file`is required");
    /// assert_eq!(vals, "file.txt");
    /// ```
    /// [positional]: crate::Arg::index()
    /// [`default_value`]: crate::Arg::default_value()
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn remove_one<T: Any + Clone + Send + Sync + 'static>(&mut self, id: &str) -> Option<T> {
        MatchesError::unwrap(id, self.try_remove_one(id))
    }

    /// Return values of a specific option or positional argument.
    ///
    /// i.e. an argument that takes multiple values at runtime.
    ///
    /// Returns an error if the wrong type was used.  No item will have been removed.
    ///
    /// Returns `None` if the option wasn't present.
    ///
    /// # Panic
    ///
    /// If the argument definition and access mismatch.  To handle this case programmatically, see
    /// [`ArgMatches::try_remove_many`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, value_parser, ArgAction};
    /// let mut m = Command::new("myprog")
    ///     .arg(Arg::new("file")
    ///         .action(ArgAction::Append)
    ///         .num_args(1..)
    ///         .required(true))
    ///     .get_matches_from(vec![
    ///         "myprog", "file1.txt", "file2.txt", "file3.txt", "file4.txt",
    ///     ]);
    /// let vals: Vec<String> = m.remove_many("file")
    ///     .expect("`file`is required")
    ///     .collect();
    /// assert_eq!(vals, ["file1.txt", "file2.txt", "file3.txt", "file4.txt"]);
    /// ```
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn remove_many<T: Any + Clone + Send + Sync + 'static>(
        &mut self,
        id: &str,
    ) -> Option<Values<T>> {
        MatchesError::unwrap(id, self.try_remove_many(id))
    }

    /// Return values for each occurrence of an option.
    ///
    /// Each item is itself an iterator containing the arguments passed to a single occurrence of
    /// the option.
    ///
    /// If the option doesn't support multiple occurrences, or there was only a single occurrence,
    /// the iterator will only contain a single item.
    ///
    /// Returns `None` if the option wasn't present.
    ///
    /// # Panic
    ///
    /// If the argument definition and access mismatch.  To handle this case programmatically, see
    /// [`ArgMatches::try_remove_occurrences`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, value_parser, ArgAction};
    /// let mut m = Command::new("myprog")
    ///     .arg(Arg::new("x")
    ///         .short('x')
    ///         .num_args(2)
    ///         .action(ArgAction::Append)
    ///         .value_parser(value_parser!(String)))
    ///     .get_matches_from(vec![
    ///         "myprog", "-x", "a", "b", "-x", "c", "d"]);
    /// let vals: Vec<Vec<String>> = m.remove_occurrences("x").unwrap().map(Iterator::collect).collect();
    /// assert_eq!(vals, [["a", "b"], ["c", "d"]]);
    /// ```
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn remove_occurrences<T: Any + Clone + Send + Sync + 'static>(
        &mut self,
        id: &str,
    ) -> Option<Occurrences<T>> {
        MatchesError::unwrap(id, self.try_remove_occurrences(id))
    }

    /// Check if values are present for the argument or group id
    ///
    /// <div class="warning">
    ///
    /// *NOTE:* This will always return `true` if [`default_value`] has been set.
    /// [`ArgMatches::value_source`] can be used to check if a value is present at runtime.
    ///
    /// </div>
    ///
    /// # Panics
    ///
    /// If `id` is not a valid argument or group name (debug builds).  To handle this case programmatically, see
    /// [`ArgMatches::try_contains_id`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("myprog")
    ///     .arg(Arg::new("debug")
    ///         .short('d')
    ///         .action(ArgAction::SetTrue))
    ///     .get_matches_from(vec![
    ///         "myprog", "-d"
    ///     ]);
    ///
    /// assert!(m.contains_id("debug"));
    /// ```
    ///
    /// [`default_value`]: crate::Arg::default_value()
    pub fn contains_id(&self, id: &str) -> bool {
        MatchesError::unwrap(id, self.try_contains_id(id))
    }

    /// Iterate over [`Arg`][crate::Arg] and [`ArgGroup`][crate::ArgGroup] [`Id`]s via [`ArgMatches::ids`].
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, arg, value_parser};
    ///
    /// let m = Command::new("myprog")
    ///     .arg(arg!(--color <when>)
    ///         .value_parser(["auto", "always", "never"]))
    ///     .arg(arg!(--config <path>)
    ///         .value_parser(value_parser!(std::path::PathBuf)))
    ///     .get_matches_from(["myprog", "--config=config.toml", "--color=auto"]);
    /// assert_eq!(m.ids().len(), 2);
    /// assert_eq!(
    ///     m.ids()
    ///         .map(|id| id.as_str())
    ///         .collect::<Vec<_>>(),
    ///     ["config", "color"]
    /// );
    /// ```
    pub fn ids(&self) -> IdsRef<'_> {
        IdsRef {
            iter: self.args.keys(),
        }
    }

    /// Check if any [`Arg`][crate::Arg]s were present on the command line
    ///
    /// See [`ArgMatches::subcommand_name()`] or [`ArgMatches::subcommand()`] to check if a
    /// subcommand was present on the command line.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let mut cmd = Command::new("myapp")
    ///     .arg(Arg::new("output")
    ///         .action(ArgAction::Set));
    ///
    /// let m = cmd
    ///     .try_get_matches_from_mut(vec!["myapp", "something"])
    ///     .unwrap();
    /// assert!(m.args_present());
    ///
    /// let m = cmd
    ///     .try_get_matches_from_mut(vec!["myapp"])
    ///     .unwrap();
    /// assert!(! m.args_present());
    pub fn args_present(&self) -> bool {
        self.args
            .values()
            .any(|v| v.source().map(|s| s.is_explicit()).unwrap_or(false))
    }

    /// Report where argument value came from
    ///
    /// # Panics
    ///
    /// If `id` is not a valid argument or group id (debug builds).
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// # use clap::parser::ValueSource;
    /// let m = Command::new("myprog")
    ///     .arg(Arg::new("debug")
    ///         .short('d')
    ///         .action(ArgAction::SetTrue))
    ///     .get_matches_from(vec![
    ///         "myprog", "-d"
    ///     ]);
    ///
    /// assert_eq!(m.value_source("debug"), Some(ValueSource::CommandLine));
    /// ```
    ///
    /// [`default_value`]: crate::Arg::default_value()
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn value_source(&self, id: &str) -> Option<ValueSource> {
        let value = self.get_arg(id);

        value.and_then(MatchedArg::source)
    }

    /// The first index of that an argument showed up.
    ///
    /// Indices are similar to argv indices, but are not exactly 1:1.
    ///
    /// For flags (i.e. those arguments which don't have an associated value), indices refer
    /// to occurrence of the switch, such as `-f`, or `--flag`. However, for options the indices
    /// refer to the *values* `-o val` would therefore not represent two distinct indices, only the
    /// index for `val` would be recorded. This is by design.
    ///
    /// Besides the flag/option discrepancy, the primary difference between an argv index and clap
    /// index, is that clap continues counting once all arguments have properly separated, whereas
    /// an argv index does not.
    ///
    /// The examples should clear this up.
    ///
    /// <div class="warning">
    ///
    /// *NOTE:* If an argument is allowed multiple times, this method will only give the *first*
    /// index.  See [`ArgMatches::indices_of`].
    ///
    /// </div>
    ///
    /// # Panics
    ///
    /// If `id` is not a valid argument or group id (debug builds).
    ///
    /// # Examples
    ///
    /// The argv indices are listed in the comments below. See how they correspond to the clap
    /// indices. Note that if it's not listed in a clap index, this is because it's not saved in
    /// in an `ArgMatches` struct for querying.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("myapp")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("option")
    ///         .short('o')
    ///         .action(ArgAction::Set))
    ///     .get_matches_from(vec!["myapp", "-f", "-o", "val"]);
    ///            // ARGV indices: ^0       ^1    ^2    ^3
    ///            // clap indices:          ^1          ^3
    ///
    /// assert_eq!(m.index_of("flag"), Some(1));
    /// assert_eq!(m.index_of("option"), Some(3));
    /// ```
    ///
    /// Now notice, if we use one of the other styles of options:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("myapp")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("option")
    ///         .short('o')
    ///         .action(ArgAction::Set))
    ///     .get_matches_from(vec!["myapp", "-f", "-o=val"]);
    ///            // ARGV indices: ^0       ^1    ^2
    ///            // clap indices:          ^1       ^3
    ///
    /// assert_eq!(m.index_of("flag"), Some(1));
    /// assert_eq!(m.index_of("option"), Some(3));
    /// ```
    ///
    /// Things become much more complicated, or clear if we look at a more complex combination of
    /// flags. Let's also throw in the final option style for good measure.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("myapp")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("flag2")
    ///         .short('F')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("flag3")
    ///         .short('z')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("option")
    ///         .short('o')
    ///         .action(ArgAction::Set))
    ///     .get_matches_from(vec!["myapp", "-fzF", "-oval"]);
    ///            // ARGV indices: ^0      ^1       ^2
    ///            // clap indices:         ^1,2,3    ^5
    ///            //
    ///            // clap sees the above as 'myapp -f -z -F -o val'
    ///            //                         ^0    ^1 ^2 ^3 ^4 ^5
    /// assert_eq!(m.index_of("flag"), Some(1));
    /// assert_eq!(m.index_of("flag2"), Some(3));
    /// assert_eq!(m.index_of("flag3"), Some(2));
    /// assert_eq!(m.index_of("option"), Some(5));
    /// ```
    ///
    /// One final combination of flags/options to see how they combine:
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("myapp")
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("flag2")
    ///         .short('F')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("flag3")
    ///         .short('z')
    ///         .action(ArgAction::SetTrue))
    ///     .arg(Arg::new("option")
    ///         .short('o')
    ///         .action(ArgAction::Set))
    ///     .get_matches_from(vec!["myapp", "-fzFoval"]);
    ///            // ARGV indices: ^0       ^1
    ///            // clap indices:          ^1,2,3^5
    ///            //
    ///            // clap sees the above as 'myapp -f -z -F -o val'
    ///            //                         ^0    ^1 ^2 ^3 ^4 ^5
    /// assert_eq!(m.index_of("flag"), Some(1));
    /// assert_eq!(m.index_of("flag2"), Some(3));
    /// assert_eq!(m.index_of("flag3"), Some(2));
    /// assert_eq!(m.index_of("option"), Some(5));
    /// ```
    ///
    /// The last part to mention is when values are sent in multiple groups with a [delimiter].
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("myapp")
    ///     .arg(Arg::new("option")
    ///         .short('o')
    ///         .value_delimiter(',')
    ///         .num_args(1..))
    ///     .get_matches_from(vec!["myapp", "-o=val1,val2,val3"]);
    ///            // ARGV indices: ^0       ^1
    ///            // clap indices:             ^2   ^3   ^4
    ///            //
    ///            // clap sees the above as 'myapp -o val1 val2 val3'
    ///            //                         ^0    ^1 ^2   ^3   ^4
    /// assert_eq!(m.index_of("option"), Some(2));
    /// assert_eq!(m.indices_of("option").unwrap().collect::<Vec<_>>(), &[2, 3, 4]);
    /// ```
    /// [delimiter]: crate::Arg::value_delimiter()
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn index_of(&self, id: &str) -> Option<usize> {
        let arg = some!(self.get_arg(id));
        let i = some!(arg.get_index(0));
        Some(i)
    }

    /// All indices an argument appeared at when parsing.
    ///
    /// Indices are similar to argv indices, but are not exactly 1:1.
    ///
    /// For flags (i.e. those arguments which don't have an associated value), indices refer
    /// to occurrence of the switch, such as `-f`, or `--flag`. However, for options the indices
    /// refer to the *values* `-o val` would therefore not represent two distinct indices, only the
    /// index for `val` would be recorded. This is by design.
    ///
    /// <div class="warning">
    ///
    /// *NOTE:* For more information about how clap indices compared to argv indices, see
    /// [`ArgMatches::index_of`]
    ///
    /// </div>
    ///
    /// # Panics
    ///
    /// If `id` is not a valid argument or group id (debug builds).
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg};
    /// let m = Command::new("myapp")
    ///     .arg(Arg::new("option")
    ///         .short('o')
    ///         .value_delimiter(','))
    ///     .get_matches_from(vec!["myapp", "-o=val1,val2,val3"]);
    ///            // ARGV indices: ^0       ^1
    ///            // clap indices:             ^2   ^3   ^4
    ///            //
    ///            // clap sees the above as 'myapp -o val1 val2 val3'
    ///            //                         ^0    ^1 ^2   ^3   ^4
    /// assert_eq!(m.indices_of("option").unwrap().collect::<Vec<_>>(), &[2, 3, 4]);
    /// ```
    ///
    /// Another quick example is when flags and options are used together
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("myapp")
    ///     .arg(Arg::new("option")
    ///         .short('o')
    ///         .action(ArgAction::Set)
    ///         .action(ArgAction::Append))
    ///     .arg(Arg::new("flag")
    ///         .short('f')
    ///         .action(ArgAction::Count))
    ///     .get_matches_from(vec!["myapp", "-o", "val1", "-f", "-o", "val2", "-f"]);
    ///            // ARGV indices: ^0       ^1    ^2      ^3    ^4    ^5      ^6
    ///            // clap indices:                ^2      ^3          ^5      ^6
    ///
    /// assert_eq!(m.indices_of("option").unwrap().collect::<Vec<_>>(), &[2, 5]);
    /// assert_eq!(m.indices_of("flag").unwrap().collect::<Vec<_>>(), &[6]);
    /// ```
    ///
    /// One final example, which is an odd case; if we *don't* use  value delimiter as we did with
    /// the first example above instead of `val1`, `val2` and `val3` all being distinc values, they
    /// would all be a single value of `val1,val2,val3`, in which case they'd only receive a single
    /// index.
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let m = Command::new("myapp")
    ///     .arg(Arg::new("option")
    ///         .short('o')
    ///         .action(ArgAction::Set)
    ///         .num_args(1..))
    ///     .get_matches_from(vec!["myapp", "-o=val1,val2,val3"]);
    ///            // ARGV indices: ^0       ^1
    ///            // clap indices:             ^2
    ///            //
    ///            // clap sees the above as 'myapp -o "val1,val2,val3"'
    ///            //                         ^0    ^1  ^2
    /// assert_eq!(m.indices_of("option").unwrap().collect::<Vec<_>>(), &[2]);
    /// ```
    /// [`ArgMatches::index_of`]: ArgMatches::index_of()
    /// [delimiter]: Arg::value_delimiter()
    #[cfg_attr(debug_assertions, track_caller)]
    pub fn indices_of(&self, id: &str) -> Option<Indices<'_>> {
        let arg = some!(self.get_arg(id));
        let i = Indices {
            iter: arg.indices(),
            len: arg.num_vals(),
        };
        Some(i)
    }
}

/// # Subcommands
impl ArgMatches {
    /// The name and `ArgMatches` of the current [subcommand].
    ///
    /// Subcommand values are put in a child [`ArgMatches`]
    ///
    /// Returns `None` if the subcommand wasn't present at runtime,
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    ///  let app_m = Command::new("git")
    ///      .subcommand(Command::new("clone"))
    ///      .subcommand(Command::new("push"))
    ///      .subcommand(Command::new("commit"))
    ///      .get_matches();
    ///
    /// match app_m.subcommand() {
    ///     Some(("clone",  sub_m)) => {}, // clone was used
    ///     Some(("push",   sub_m)) => {}, // push was used
    ///     Some(("commit", sub_m)) => {}, // commit was used
    ///     _                       => {}, // Either no subcommand or one not tested for...
    /// }
    /// ```
    ///
    /// Another useful scenario is when you want to support third party, or external, subcommands.
    /// In these cases you can't know the subcommand name ahead of time, so use a variable instead
    /// with pattern matching!
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::ffi::OsString;
    /// # use std::ffi::OsStr;
    /// # use clap::Command;
    /// // Assume there is an external subcommand named "subcmd"
    /// let app_m = Command::new("myprog")
    ///     .allow_external_subcommands(true)
    ///     .get_matches_from(vec![
    ///         "myprog", "subcmd", "--option", "value", "-fff", "--flag"
    ///     ]);
    ///
    /// // All trailing arguments will be stored under the subcommand's sub-matches using an empty
    /// // string argument name
    /// match app_m.subcommand() {
    ///     Some((external, sub_m)) => {
    ///          let ext_args: Vec<&OsStr> = sub_m.get_many::<OsString>("")
    ///             .unwrap().map(|s| s.as_os_str()).collect();
    ///          assert_eq!(external, "subcmd");
    ///          assert_eq!(ext_args, ["--option", "value", "-fff", "--flag"]);
    ///     },
    ///     _ => {},
    /// }
    /// ```
    /// [subcommand]: crate::Command::subcommand
    #[inline]
    pub fn subcommand(&self) -> Option<(&str, &ArgMatches)> {
        self.subcommand.as_ref().map(|sc| (&*sc.name, &sc.matches))
    }

    /// Return the name and `ArgMatches` of the current [subcommand].
    ///
    /// Subcommand values are put in a child [`ArgMatches`]
    ///
    /// Returns `None` if the subcommand wasn't present at runtime,
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    ///  let mut app_m = Command::new("git")
    ///      .subcommand(Command::new("clone"))
    ///      .subcommand(Command::new("push"))
    ///      .subcommand(Command::new("commit"))
    ///      .subcommand_required(true)
    ///      .get_matches();
    ///
    /// let (name, sub_m) = app_m.remove_subcommand().expect("required");
    /// match (name.as_str(), sub_m) {
    ///     ("clone",  sub_m) => {}, // clone was used
    ///     ("push",   sub_m) => {}, // push was used
    ///     ("commit", sub_m) => {}, // commit was used
    ///     (name, _)         => unimplemented!("{name}"),
    /// }
    /// ```
    ///
    /// Another useful scenario is when you want to support third party, or external, subcommands.
    /// In these cases you can't know the subcommand name ahead of time, so use a variable instead
    /// with pattern matching!
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use std::ffi::OsString;
    /// # use clap::Command;
    /// // Assume there is an external subcommand named "subcmd"
    /// let mut app_m = Command::new("myprog")
    ///     .allow_external_subcommands(true)
    ///     .get_matches_from(vec![
    ///         "myprog", "subcmd", "--option", "value", "-fff", "--flag"
    ///     ]);
    ///
    /// // All trailing arguments will be stored under the subcommand's sub-matches using an empty
    /// // string argument name
    /// match app_m.remove_subcommand() {
    ///     Some((external, mut sub_m)) => {
    ///          let ext_args: Vec<OsString> = sub_m.remove_many("")
    ///             .expect("`file`is required")
    ///             .collect();
    ///          assert_eq!(external, "subcmd");
    ///          assert_eq!(ext_args, ["--option", "value", "-fff", "--flag"]);
    ///     },
    ///     _ => {},
    /// }
    /// ```
    /// [subcommand]: crate::Command::subcommand
    pub fn remove_subcommand(&mut self) -> Option<(String, ArgMatches)> {
        self.subcommand.take().map(|sc| (sc.name, sc.matches))
    }

    /// The `ArgMatches` for the current [subcommand].
    ///
    /// Subcommand values are put in a child [`ArgMatches`]
    ///
    /// Returns `None` if the subcommand wasn't present at runtime,
    ///
    /// # Panics
    ///
    /// If `id` is not a valid subcommand (debug builds).
    ///
    /// # Examples
    ///
    /// ```rust
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, ArgAction};
    /// let app_m = Command::new("myprog")
    ///     .arg(Arg::new("debug")
    ///         .short('d')
    ///         .action(ArgAction::SetTrue)
    ///     )
    ///     .subcommand(Command::new("test")
    ///         .arg(Arg::new("opt")
    ///             .long("option")
    ///             .action(ArgAction::Set)))
    ///     .get_matches_from(vec![
    ///         "myprog", "-d", "test", "--option", "val"
    ///     ]);
    ///
    /// // Both parent commands, and child subcommands can have arguments present at the same times
    /// assert!(app_m.get_flag("debug"));
    ///
    /// // Get the subcommand's ArgMatches instance
    /// if let Some(sub_m) = app_m.subcommand_matches("test") {
    ///     // Use the struct like normal
    ///     assert_eq!(sub_m.get_one::<String>("opt").map(|s| s.as_str()), Some("val"));
    /// }
    /// ```
    ///
    /// [subcommand]: crate::Command::subcommand
    /// [`Command`]: crate::Command
    pub fn subcommand_matches(&self, name: &str) -> Option<&ArgMatches> {
        self.get_subcommand(name).map(|sc| &sc.matches)
    }

    /// The name of the current [subcommand].
    ///
    /// Returns `None` if the subcommand wasn't present at runtime,
    ///
    /// # Examples
    ///
    /// ```no_run
    /// # use clap_builder as clap;
    /// # use clap::{Command, Arg, };
    ///  let app_m = Command::new("git")
    ///      .subcommand(Command::new("clone"))
    ///      .subcommand(Command::new("push"))
    ///      .subcommand(Command::new("commit"))
    ///      .get_matches();
    ///
    /// match app_m.subcommand_name() {
    ///     Some("clone")  => {}, // clone was used
    ///     Some("push")   => {}, // push was used
    ///     Some("commit") => {}, // commit was used
    ///     _              => {}, // Either no subcommand or one not tested for...
    /// }
    /// ```
    /// [subcommand]: crate::Command::subcommand
    /// [`Command`]: crate::Command
    #[inline]
    pub fn subcommand_name(&self) -> Option<&str> {
        self.subcommand.as_ref().map(|sc| &*sc.name)
    }

    /// Check if a subcommand can be queried
    ///
    /// By default, `ArgMatches` functions assert on undefined `Id`s to help catch programmer
    /// mistakes.  In some context, this doesn't work, so users can use this function to check
    /// before they do a query on `ArgMatches`.
    #[inline]
    #[doc(hidden)]
    pub fn is_valid_subcommand(&self, _name: &str) -> bool {
        #[cfg(debug_assertions)]
        {
            _name.is_empty() || self.valid_subcommands.iter().any(|s| *s == _name)
        }
        #[cfg(not(debug_assertions))]
        {
            true
        }
    }
}

/// # Advanced
impl ArgMatches {
    /// Non-panicking version of [`ArgMatches::get_one`]
    pub fn try_get_one<T: Any + Clone + Send + Sync + 'static>(
        &self,
        id: &str,
    ) -> Result<Option<&T>, MatchesError> {
        let arg = ok!(self.try_get_arg_t::<T>(id));
        let value = match arg.and_then(|a| a.first()) {
            Some(value) => value,
            None => {
                return Ok(None);
            }
        };
        Ok(value
            .downcast_ref::<T>()
            .map(Some)
            .expect(INTERNAL_ERROR_MSG)) // enforced by `try_get_arg_t`
    }

    /// Non-panicking version of [`ArgMatches::get_many`]
    pub fn try_get_many<T: Any + Clone + Send + Sync + 'static>(
        &self,
        id: &str,
    ) -> Result<Option<ValuesRef<'_, T>>, MatchesError> {
        let arg = match ok!(self.try_get_arg_t::<T>(id)) {
            Some(arg) => arg,
            None => return Ok(None),
        };
        let len = arg.num_vals();
        let values = arg.vals_flatten();
        let values = ValuesRef {
            // enforced by `try_get_arg_t`
            iter: values.map(unwrap_downcast_ref),
            len,
        };
        Ok(Some(values))
    }

    /// Non-panicking version of [`ArgMatches::get_occurrences`]
    pub fn try_get_occurrences<T: Any + Clone + Send + Sync + 'static>(
        &self,
        id: &str,
    ) -> Result<Option<OccurrencesRef<'_, T>>, MatchesError> {
        let arg = match ok!(self.try_get_arg_t::<T>(id)) {
            Some(arg) => arg,
            None => return Ok(None),
        };
        let values = arg.vals();
        Ok(Some(OccurrencesRef {
            iter: values.map(|g| OccurrenceValuesRef {
                iter: g.iter().map(unwrap_downcast_ref),
            }),
        }))
    }

    /// Non-panicking version of [`ArgMatches::get_raw`]
    pub fn try_get_raw(&self, id: &str) -> Result<Option<RawValues<'_>>, MatchesError> {
        let arg = match ok!(self.try_get_arg(id)) {
            Some(arg) => arg,
            None => return Ok(None),
        };
        let len = arg.num_vals();
        let values = arg.raw_vals_flatten();
        let values = RawValues {
            iter: values.map(OsString::as_os_str),
            len,
        };
        Ok(Some(values))
    }

    /// Non-panicking version of [`ArgMatches::get_raw_occurrences`]
    pub fn try_get_raw_occurrences(
        &self,
        id: &str,
    ) -> Result<Option<RawOccurrences<'_>>, MatchesError> {
        let arg = match ok!(self.try_get_arg(id)) {
            Some(arg) => arg,
            None => return Ok(None),
        };
        let values = arg.raw_vals();
        let occurrences = RawOccurrences {
            iter: values.map(|g| RawOccurrenceValues {
                iter: g.iter().map(OsString::as_os_str),
            }),
        };
        Ok(Some(occurrences))
    }

    /// Non-panicking version of [`ArgMatches::remove_one`]
    pub fn try_remove_one<T: Any + Clone + Send + Sync + 'static>(
        &mut self,
        id: &str,
    ) -> Result<Option<T>, MatchesError> {
        match ok!(self.try_remove_arg_t::<T>(id)) {
            Some(values) => Ok(values
                .into_vals_flatten()
                // enforced by `try_get_arg_t`
                .map(unwrap_downcast_into)
                .next()),
            None => Ok(None),
        }
    }

    /// Non-panicking version of [`ArgMatches::remove_many`]
    pub fn try_remove_many<T: Any + Clone + Send + Sync + 'static>(
        &mut self,
        id: &str,
    ) -> Result<Option<Values<T>>, MatchesError> {
        let arg = match ok!(self.try_remove_arg_t::<T>(id)) {
            Some(arg) => arg,
            None => return Ok(None),
        };
        let len = arg.num_vals();
        let values = arg.into_vals_flatten();
        let values = Values {
            // enforced by `try_get_arg_t`
            iter: values.map(unwrap_downcast_into),
            len,
        };
        Ok(Some(values))
    }

    /// Non-panicking version of [`ArgMatches::remove_occurrences`]
    pub fn try_remove_occurrences<T: Any + Clone + Send + Sync + 'static>(
        &mut self,
        id: &str,
    ) -> Result<Option<Occurrences<T>>, MatchesError> {
        let arg = match ok!(self.try_remove_arg_t::<T>(id)) {
            Some(arg) => arg,
            None => return Ok(None),
        };
        let values = arg.into_vals();
        let occurrences = Occurrences {
            iter: values.into_iter().map(|g| OccurrenceValues {
                iter: g.into_iter().map(unwrap_downcast_into),
            }),
        };
        Ok(Some(occurrences))
    }

    /// Non-panicking version of [`ArgMatches::contains_id`]
    pub fn try_contains_id(&self, id: &str) -> Result<bool, MatchesError> {
        ok!(self.verify_arg(id));

        let presence = self.args.contains_key(id);
        Ok(presence)
    }
}

// Private methods
impl ArgMatches {
    #[inline]
    fn try_get_arg(&self, arg: &str) -> Result<Option<&MatchedArg>, MatchesError> {
        ok!(self.verify_arg(arg));
        Ok(self.args.get(arg))
    }

    #[inline]
    fn try_get_arg_t<T: Any + Send + Sync + 'static>(
        &self,
        arg: &str,
    ) -> Result<Option<&MatchedArg>, MatchesError> {
        let arg = match ok!(self.try_get_arg(arg)) {
            Some(arg) => arg,
            None => {
                return Ok(None);
            }
        };
        ok!(self.verify_arg_t::<T>(arg));
        Ok(Some(arg))
    }

    #[inline]
    fn try_remove_arg_t<T: Any + Send + Sync + 'static>(
        &mut self,
        arg: &str,
    ) -> Result<Option<MatchedArg>, MatchesError> {
        ok!(self.verify_arg(arg));
        let (id, matched) = match self.args.remove_entry(arg) {
            Some((id, matched)) => (id, matched),
            None => {
                return Ok(None);
            }
        };

        let expected = AnyValueId::of::<T>();
        let actual = matched.infer_type_id(expected);
        if actual == expected {
            Ok(Some(matched))
        } else {
            self.args.insert(id, matched);
            Err(MatchesError::Downcast { actual, expected })
        }
    }

    fn verify_arg_t<T: Any + Send + Sync + 'static>(
        &self,
        arg: &MatchedArg,
    ) -> Result<(), MatchesError> {
        let expected = AnyValueId::of::<T>();
        let actual = arg.infer_type_id(expected);
        if expected == actual {
            Ok(())
        } else {
            Err(MatchesError::Downcast { actual, expected })
        }
    }

    #[inline]
    fn verify_arg(&self, _arg: &str) -> Result<(), MatchesError> {
        #[cfg(debug_assertions)]
        {
            if _arg == Id::EXTERNAL || self.valid_args.iter().any(|s| *s == _arg) {
            } else {
                debug!(
                    "`{:?}` is not an id of an argument or a group.\n\
                     Make sure you're using the name of the argument itself \
                     and not the name of short or long flags.",
                    _arg
                );
                return Err(MatchesError::UnknownArgument {});
            }
        }
        Ok(())
    }

    #[inline]
    #[cfg_attr(debug_assertions, track_caller)]
    fn get_arg<'s>(&'s self, arg: &str) -> Option<&'s MatchedArg> {
        #[cfg(debug_assertions)]
        {
            if arg == Id::EXTERNAL || self.valid_args.iter().any(|s| *s == arg) {
            } else {
                panic!(
                    "`{arg:?}` is not an id of an argument or a group.\n\
                     Make sure you're using the name of the argument itself \
                     and not the name of short or long flags."
                );
            }
        }

        self.args.get(arg)
    }

    #[inline]
    #[cfg_attr(debug_assertions, track_caller)]
    fn get_subcommand(&self, name: &str) -> Option<&SubCommand> {
        #[cfg(debug_assertions)]
        {
            if name.is_empty() || self.valid_subcommands.iter().any(|s| *s == name) {
            } else {
                panic!("`{name}` is not a name of a subcommand.");
            }
        }

        if let Some(ref sc) = self.subcommand {
            if sc.name == name {
                return Some(sc);
            }
        }

        None
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct SubCommand {
    pub(crate) name: String,
    pub(crate) matches: ArgMatches,
}

/// Iterate over [`Arg`][crate::Arg] and [`ArgGroup`][crate::ArgGroup] [`Id`]s via [`ArgMatches::ids`].
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::{Command, arg, value_parser};
///
/// let m = Command::new("myprog")
///     .arg(arg!(--color <when>)
///         .value_parser(["auto", "always", "never"]))
///     .arg(arg!(--config <path>)
///         .value_parser(value_parser!(std::path::PathBuf)))
///     .get_matches_from(["myprog", "--config=config.toml", "--color=auto"]);
/// assert_eq!(
///     m.ids()
///         .map(|id| id.as_str())
///         .collect::<Vec<_>>(),
///     ["config", "color"]
/// );
/// ```
#[derive(Clone, Debug)]
pub struct IdsRef<'a> {
    iter: Iter<'a, Id>,
}

impl<'a> Iterator for IdsRef<'a> {
    type Item = &'a Id;

    fn next(&mut self) -> Option<&'a Id> {
        self.iter.next()
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl<'a> DoubleEndedIterator for IdsRef<'a> {
    fn next_back(&mut self) -> Option<&'a Id> {
        self.iter.next_back()
    }
}

impl ExactSizeIterator for IdsRef<'_> {}

/// Iterate over multiple values for an argument via [`ArgMatches::remove_many`].
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::{Command, Arg, ArgAction};
/// let mut m = Command::new("myapp")
///     .arg(Arg::new("output")
///         .short('o')
///         .action(ArgAction::Append))
///     .get_matches_from(vec!["myapp", "-o", "val1", "-o", "val2"]);
///
/// let mut values = m.remove_many::<String>("output")
///     .unwrap();
///
/// assert_eq!(values.next(), Some(String::from("val1")));
/// assert_eq!(values.next(), Some(String::from("val2")));
/// assert_eq!(values.next(), None);
/// ```
#[derive(Clone, Debug)]
pub struct Values<T> {
    #[allow(clippy::type_complexity)]
    iter: Map<Flatten<std::vec::IntoIter<Vec<AnyValue>>>, fn(AnyValue) -> T>,
    len: usize,
}

impl<T> Iterator for Values<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(next) = self.iter.next() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<T> DoubleEndedIterator for Values<T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if let Some(next) = self.iter.next_back() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
}

impl<T> ExactSizeIterator for Values<T> {}

/// Creates an empty iterator.
impl<T> Default for Values<T> {
    fn default() -> Self {
        let empty: Vec<Vec<AnyValue>> = Default::default();
        Values {
            iter: empty.into_iter().flatten().map(|_| unreachable!()),
            len: 0,
        }
    }
}

/// Iterate over multiple values for an argument via [`ArgMatches::get_many`].
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::{Command, Arg, ArgAction};
/// let m = Command::new("myapp")
///     .arg(Arg::new("output")
///         .short('o')
///         .action(ArgAction::Append))
///     .get_matches_from(vec!["myapp", "-o", "val1", "-o", "val2"]);
///
/// let mut values = m.get_many::<String>("output")
///     .unwrap()
///     .map(|s| s.as_str());
///
/// assert_eq!(values.next(), Some("val1"));
/// assert_eq!(values.next(), Some("val2"));
/// assert_eq!(values.next(), None);
/// ```
#[derive(Clone, Debug)]
pub struct ValuesRef<'a, T> {
    #[allow(clippy::type_complexity)]
    iter: Map<Flatten<Iter<'a, Vec<AnyValue>>>, fn(&AnyValue) -> &T>,
    len: usize,
}

impl<'a, T: 'a> Iterator for ValuesRef<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(next) = self.iter.next() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a, T: 'a> DoubleEndedIterator for ValuesRef<'a, T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if let Some(next) = self.iter.next_back() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
}

impl<'a, T: 'a> ExactSizeIterator for ValuesRef<'a, T> {}

/// Creates an empty iterator.
impl<'a, T: 'a> Default for ValuesRef<'a, T> {
    fn default() -> Self {
        static EMPTY: [Vec<AnyValue>; 0] = [];
        ValuesRef {
            iter: EMPTY[..].iter().flatten().map(|_| unreachable!()),
            len: 0,
        }
    }
}

/// Iterate over raw argument values via [`ArgMatches::get_raw`].
///
/// # Examples
///
/// ```rust
/// # #[cfg(unix)] {
/// # use clap_builder as clap;
/// # use clap::{Command, arg, value_parser};
/// use std::ffi::OsString;
/// use std::os::unix::ffi::{OsStrExt,OsStringExt};
///
/// let m = Command::new("utf8")
///     .arg(arg!(<arg> "some arg")
///         .value_parser(value_parser!(OsString)))
///     .get_matches_from(vec![OsString::from("myprog"),
///                             // "Hi {0xe9}!"
///                             OsString::from_vec(vec![b'H', b'i', b' ', 0xe9, b'!'])]);
/// assert_eq!(
///     &*m.get_raw("arg")
///         .unwrap()
///         .next().unwrap()
///         .as_bytes(),
///     [b'H', b'i', b' ', 0xe9, b'!']
/// );
/// # }
/// ```
#[derive(Clone, Debug)]
pub struct RawValues<'a> {
    #[allow(clippy::type_complexity)]
    iter: Map<Flatten<Iter<'a, Vec<OsString>>>, fn(&OsString) -> &OsStr>,
    len: usize,
}

impl<'a> Iterator for RawValues<'a> {
    type Item = &'a OsStr;

    fn next(&mut self) -> Option<&'a OsStr> {
        if let Some(next) = self.iter.next() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl<'a> DoubleEndedIterator for RawValues<'a> {
    fn next_back(&mut self) -> Option<&'a OsStr> {
        if let Some(next) = self.iter.next_back() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
}

impl ExactSizeIterator for RawValues<'_> {}

/// Creates an empty iterator.
impl Default for RawValues<'_> {
    fn default() -> Self {
        static EMPTY: [Vec<OsString>; 0] = [];
        RawValues {
            iter: EMPTY[..].iter().flatten().map(|_| unreachable!()),
            len: 0,
        }
    }
}

// The following were taken and adapted from vec_map source
// repo: https://github.com/contain-rs/vec-map
// commit: be5e1fa3c26e351761b33010ddbdaf5f05dbcc33
// license: MIT - Copyright (c) 2015 The Rust Project Developers

#[derive(Clone, Debug)]
#[deprecated(since = "4.1.0", note = "Use Occurrences instead")]
pub(crate) struct GroupedValues<'a> {
    #[allow(clippy::type_complexity)]
    iter: Map<Iter<'a, Vec<AnyValue>>, fn(&Vec<AnyValue>) -> Vec<&str>>,
    len: usize,
}

#[allow(deprecated)]
impl<'a> Iterator for GroupedValues<'a> {
    type Item = Vec<&'a str>;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(next) = self.iter.next() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

#[allow(deprecated)]
impl DoubleEndedIterator for GroupedValues<'_> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if let Some(next) = self.iter.next_back() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
}

#[allow(deprecated)]
impl ExactSizeIterator for GroupedValues<'_> {}

/// Creates an empty iterator. Used for `unwrap_or_default()`.
#[allow(deprecated)]
impl Default for GroupedValues<'_> {
    fn default() -> Self {
        static EMPTY: [Vec<AnyValue>; 0] = [];
        GroupedValues {
            iter: EMPTY[..].iter().map(|_| unreachable!()),
            len: 0,
        }
    }
}

#[derive(Clone, Debug)]
pub struct Occurrences<T> {
    #[allow(clippy::type_complexity)]
    iter: Map<std::vec::IntoIter<Vec<AnyValue>>, fn(Vec<AnyValue>) -> OccurrenceValues<T>>,
}

impl<T> Iterator for Occurrences<T> {
    type Item = OccurrenceValues<T>;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl<T> DoubleEndedIterator for Occurrences<T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }
}

impl<T> ExactSizeIterator for Occurrences<T> {}

impl<T> Default for Occurrences<T> {
    fn default() -> Self {
        let empty: Vec<Vec<AnyValue>> = Default::default();
        Occurrences {
            iter: empty.into_iter().map(|_| unreachable!()),
        }
    }
}

#[derive(Clone, Debug)]
pub struct OccurrenceValues<T> {
    #[allow(clippy::type_complexity)]
    iter: Map<std::vec::IntoIter<AnyValue>, fn(AnyValue) -> T>,
}

impl<T> Iterator for OccurrenceValues<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl<T> DoubleEndedIterator for OccurrenceValues<T> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }
}

impl<T> ExactSizeIterator for OccurrenceValues<T> {}

#[derive(Clone, Debug)]
pub struct OccurrencesRef<'a, T> {
    #[allow(clippy::type_complexity)]
    iter: Map<Iter<'a, Vec<AnyValue>>, fn(&Vec<AnyValue>) -> OccurrenceValuesRef<'_, T>>,
}

impl<'a, T> Iterator for OccurrencesRef<'a, T>
where
    Self: 'a,
{
    type Item = OccurrenceValuesRef<'a, T>;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl<'a, T> DoubleEndedIterator for OccurrencesRef<'a, T>
where
    Self: 'a,
{
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }
}

impl<'a, T> ExactSizeIterator for OccurrencesRef<'a, T> where Self: 'a {}
impl<T> Default for OccurrencesRef<'_, T> {
    fn default() -> Self {
        static EMPTY: [Vec<AnyValue>; 0] = [];
        OccurrencesRef {
            iter: EMPTY[..].iter().map(|_| unreachable!()),
        }
    }
}

#[derive(Clone, Debug)]
pub struct OccurrenceValuesRef<'a, T> {
    #[allow(clippy::type_complexity)]
    iter: Map<Iter<'a, AnyValue>, fn(&AnyValue) -> &T>,
}

impl<'a, T> Iterator for OccurrenceValuesRef<'a, T>
where
    Self: 'a,
{
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl<'a, T> DoubleEndedIterator for OccurrenceValuesRef<'a, T>
where
    Self: 'a,
{
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }
}

impl<'a, T> ExactSizeIterator for OccurrenceValuesRef<'a, T> where Self: 'a {}

#[derive(Clone, Debug)]
pub struct RawOccurrences<'a> {
    #[allow(clippy::type_complexity)]
    iter: Map<Iter<'a, Vec<OsString>>, fn(&Vec<OsString>) -> RawOccurrenceValues<'_>>,
}

impl<'a> Iterator for RawOccurrences<'a> {
    type Item = RawOccurrenceValues<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl DoubleEndedIterator for RawOccurrences<'_> {
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }
}

impl ExactSizeIterator for RawOccurrences<'_> {}

impl Default for RawOccurrences<'_> {
    fn default() -> Self {
        static EMPTY: [Vec<OsString>; 0] = [];
        RawOccurrences {
            iter: EMPTY[..].iter().map(|_| unreachable!()),
        }
    }
}

#[derive(Clone, Debug)]
pub struct RawOccurrenceValues<'a> {
    #[allow(clippy::type_complexity)]
    iter: Map<Iter<'a, OsString>, fn(&OsString) -> &OsStr>,
}

impl<'a> Iterator for RawOccurrenceValues<'a>
where
    Self: 'a,
{
    type Item = &'a OsStr;

    fn next(&mut self) -> Option<Self::Item> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

impl<'a> DoubleEndedIterator for RawOccurrenceValues<'a>
where
    Self: 'a,
{
    fn next_back(&mut self) -> Option<Self::Item> {
        self.iter.next_back()
    }
}

impl ExactSizeIterator for RawOccurrenceValues<'_> {}

/// Iterate over indices for where an argument appeared when parsing, via [`ArgMatches::indices_of`]
///
/// # Examples
///
/// ```rust
/// # use clap_builder as clap;
/// # use clap::{Command, Arg, ArgAction};
/// let m = Command::new("myapp")
///     .arg(Arg::new("output")
///         .short('o')
///         .num_args(1..)
///         .action(ArgAction::Set))
///     .get_matches_from(vec!["myapp", "-o", "val1", "val2"]);
///
/// let mut indices = m.indices_of("output").unwrap();
///
/// assert_eq!(indices.next(), Some(2));
/// assert_eq!(indices.next(), Some(3));
/// assert_eq!(indices.next(), None);
/// ```
/// [`ArgMatches::indices_of`]: ArgMatches::indices_of()
#[derive(Clone, Debug)]
pub struct Indices<'a> {
    iter: Cloned<Iter<'a, usize>>,
    len: usize,
}

impl Iterator for Indices<'_> {
    type Item = usize;

    fn next(&mut self) -> Option<usize> {
        if let Some(next) = self.iter.next() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        (self.len, Some(self.len))
    }
}

impl DoubleEndedIterator for Indices<'_> {
    fn next_back(&mut self) -> Option<usize> {
        if let Some(next) = self.iter.next_back() {
            self.len -= 1;
            Some(next)
        } else {
            None
        }
    }
}

impl ExactSizeIterator for Indices<'_> {}

/// Creates an empty iterator.
impl Default for Indices<'_> {
    fn default() -> Self {
        static EMPTY: [usize; 0] = [];
        // This is never called because the iterator is empty:
        Indices {
            iter: EMPTY[..].iter().cloned(),
            len: 0,
        }
    }
}

#[track_caller]
fn unwrap_downcast_ref<T: Any + Clone + Send + Sync + 'static>(value: &AnyValue) -> &T {
    value.downcast_ref().expect(INTERNAL_ERROR_MSG)
}

#[track_caller]
fn unwrap_downcast_into<T: Any + Clone + Send + Sync + 'static>(value: AnyValue) -> T {
    value.downcast_into().expect(INTERNAL_ERROR_MSG)
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::ArgAction;

    #[test]
    fn check_auto_traits() {
        static_assertions::assert_impl_all!(ArgMatches: Send, Sync, Unpin);
    }

    #[test]
    fn test_default_raw_values() {
        let mut values: RawValues<'_> = Default::default();
        assert_eq!(values.next(), None);
    }

    #[test]
    fn test_default_indices() {
        let mut indices: Indices<'_> = Indices::default();
        assert_eq!(indices.next(), None);
    }

    #[test]
    fn test_default_indices_with_shorter_lifetime() {
        let matches = ArgMatches::default();
        let mut indices = matches.indices_of("").unwrap_or_default();
        assert_eq!(indices.next(), None);
    }

    #[test]
    fn values_exact_size() {
        let l = crate::Command::new("test")
            .arg(
                crate::Arg::new("POTATO")
                    .action(ArgAction::Set)
                    .num_args(1..)
                    .required(true),
            )
            .try_get_matches_from(["test", "one"])
            .unwrap()
            .get_many::<String>("POTATO")
            .expect("present")
            .count();
        assert_eq!(l, 1);
    }

    #[test]
    fn os_values_exact_size() {
        let l = crate::Command::new("test")
            .arg(
                crate::Arg::new("POTATO")
                    .action(ArgAction::Set)
                    .num_args(1..)
                    .value_parser(crate::builder::ValueParser::os_string())
                    .required(true),
            )
            .try_get_matches_from(["test", "one"])
            .unwrap()
            .get_many::<OsString>("POTATO")
            .expect("present")
            .count();
        assert_eq!(l, 1);
    }

    #[test]
    fn indices_exact_size() {
        let l = crate::Command::new("test")
            .arg(
                crate::Arg::new("POTATO")
                    .action(ArgAction::Set)
                    .num_args(1..)
                    .required(true),
            )
            .try_get_matches_from(["test", "one"])
            .unwrap()
            .indices_of("POTATO")
            .expect("present")
            .len();
        assert_eq!(l, 1);
    }

    #[test]
    fn rev_iter() {
        let mut matches = crate::Command::new("myprog")
            .arg(crate::Arg::new("a").short('a').action(ArgAction::Append))
            .arg(crate::Arg::new("b").short('b').action(ArgAction::Append))
            .try_get_matches_from(vec!["myprog", "-a1", "-b1", "-b3"])
            .unwrap();

        let a_index = matches
            .indices_of("a")
            .expect("missing aopt indices")
            .collect::<Vec<_>>();
        dbg!(&a_index);
        let a_value = matches
            .remove_many::<String>("a")
            .expect("missing aopt values");
        dbg!(&a_value);
        let a = a_index.into_iter().zip(a_value).rev().collect::<Vec<_>>();
        dbg!(a);

        let b_index = matches
            .indices_of("b")
            .expect("missing aopt indices")
            .collect::<Vec<_>>();
        dbg!(&b_index);
        let b_value = matches
            .remove_many::<String>("b")
            .expect("missing aopt values");
        dbg!(&b_value);
        let b = b_index.into_iter().zip(b_value).rev().collect::<Vec<_>>();
        dbg!(b);
    }
}

```

`clap/clap_builder/src/parser/matches/matched_arg.rs`:

```rs
// Std
use std::{
    ffi::{OsStr, OsString},
    iter::{Cloned, Flatten},
    slice::Iter,
};

use crate::builder::ArgPredicate;
use crate::parser::ValueSource;
use crate::util::eq_ignore_case;
use crate::util::AnyValue;
use crate::util::AnyValueId;
use crate::INTERNAL_ERROR_MSG;

#[derive(Debug, Clone)]
pub(crate) struct MatchedArg {
    source: Option<ValueSource>,
    indices: Vec<usize>,
    type_id: Option<AnyValueId>,
    vals: Vec<Vec<AnyValue>>,
    raw_vals: Vec<Vec<OsString>>,
    ignore_case: bool,
}

impl MatchedArg {
    pub(crate) fn new_arg(arg: &crate::Arg) -> Self {
        let ignore_case = arg.is_ignore_case_set();
        Self {
            source: None,
            indices: Vec::new(),
            type_id: Some(arg.get_value_parser().type_id()),
            vals: Vec::new(),
            raw_vals: Vec::new(),
            ignore_case,
        }
    }

    pub(crate) fn new_group() -> Self {
        let ignore_case = false;
        Self {
            source: None,
            indices: Vec::new(),
            type_id: None,
            vals: Vec::new(),
            raw_vals: Vec::new(),
            ignore_case,
        }
    }

    pub(crate) fn new_external(cmd: &crate::Command) -> Self {
        let ignore_case = false;
        Self {
            source: None,
            indices: Vec::new(),
            type_id: Some(
                cmd.get_external_subcommand_value_parser()
                    .expect(INTERNAL_ERROR_MSG)
                    .type_id(),
            ),
            vals: Vec::new(),
            raw_vals: Vec::new(),
            ignore_case,
        }
    }

    pub(crate) fn indices(&self) -> Cloned<Iter<'_, usize>> {
        self.indices.iter().cloned()
    }

    pub(crate) fn get_index(&self, index: usize) -> Option<usize> {
        self.indices.get(index).cloned()
    }

    pub(crate) fn push_index(&mut self, index: usize) {
        self.indices.push(index);
    }

    pub(crate) fn vals(&self) -> Iter<'_, Vec<AnyValue>> {
        self.vals.iter()
    }

    pub(crate) fn into_vals(self) -> Vec<Vec<AnyValue>> {
        self.vals
    }

    pub(crate) fn vals_flatten(&self) -> Flatten<Iter<'_, Vec<AnyValue>>> {
        self.vals.iter().flatten()
    }

    pub(crate) fn into_vals_flatten(self) -> Flatten<std::vec::IntoIter<Vec<AnyValue>>> {
        self.vals.into_iter().flatten()
    }

    pub(crate) fn raw_vals(&self) -> Iter<'_, Vec<OsString>> {
        self.raw_vals.iter()
    }

    pub(crate) fn raw_vals_flatten(&self) -> Flatten<Iter<'_, Vec<OsString>>> {
        self.raw_vals.iter().flatten()
    }

    pub(crate) fn first(&self) -> Option<&AnyValue> {
        self.vals_flatten().next()
    }

    #[cfg(test)]
    pub(crate) fn first_raw(&self) -> Option<&OsString> {
        self.raw_vals_flatten().next()
    }

    pub(crate) fn new_val_group(&mut self) {
        self.vals.push(vec![]);
        self.raw_vals.push(vec![]);
    }

    pub(crate) fn append_val(&mut self, val: AnyValue, raw_val: OsString) {
        // We assume there is always a group created before.
        self.vals.last_mut().expect(INTERNAL_ERROR_MSG).push(val);
        self.raw_vals
            .last_mut()
            .expect(INTERNAL_ERROR_MSG)
            .push(raw_val);
    }

    pub(crate) fn num_vals(&self) -> usize {
        self.vals.iter().map(|v| v.len()).sum()
    }

    // Will be used later
    #[allow(dead_code)]
    pub(crate) fn num_vals_last_group(&self) -> usize {
        self.vals.last().map(|x| x.len()).unwrap_or(0)
    }

    pub(crate) fn check_explicit(&self, predicate: &ArgPredicate) -> bool {
        if self.source.map(|s| !s.is_explicit()).unwrap_or(false) {
            return false;
        }

        match predicate {
            ArgPredicate::Equals(val) => self.raw_vals_flatten().any(|v| {
                if self.ignore_case {
                    // If `v` isn't utf8, it can't match `val`, so `OsStr::to_str` should be fine
                    eq_ignore_case(&v.to_string_lossy(), &val.to_string_lossy())
                } else {
                    OsString::as_os_str(v) == OsStr::new(val)
                }
            }),
            ArgPredicate::IsPresent => true,
        }
    }

    pub(crate) fn source(&self) -> Option<ValueSource> {
        self.source
    }

    pub(crate) fn set_source(&mut self, source: ValueSource) {
        if let Some(existing) = self.source {
            self.source = Some(existing.max(source));
        } else {
            self.source = Some(source);
        }
    }

    pub(crate) fn type_id(&self) -> Option<AnyValueId> {
        self.type_id
    }

    pub(crate) fn infer_type_id(&self, expected: AnyValueId) -> AnyValueId {
        self.type_id()
            .or_else(|| {
                self.vals_flatten()
                    .map(|v| v.type_id())
                    .find(|actual| *actual != expected)
            })
            .unwrap_or(expected)
    }
}

impl PartialEq for MatchedArg {
    fn eq(&self, other: &MatchedArg) -> bool {
        let MatchedArg {
            source: self_source,
            indices: self_indices,
            type_id: self_type_id,
            vals: _,
            raw_vals: self_raw_vals,
            ignore_case: self_ignore_case,
        } = self;
        let MatchedArg {
            source: other_source,
            indices: other_indices,
            type_id: other_type_id,
            vals: _,
            raw_vals: other_raw_vals,
            ignore_case: other_ignore_case,
        } = other;
        self_source == other_source
            && self_indices == other_indices
            && self_type_id == other_type_id
            && self_raw_vals == other_raw_vals
            && self_ignore_case == other_ignore_case
    }
}

impl Eq for MatchedArg {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_grouped_vals_first() {
        let mut m = MatchedArg::new_group();
        m.new_val_group();
        m.new_val_group();
        m.append_val(AnyValue::new(String::from("bbb")), "bbb".into());
        m.append_val(AnyValue::new(String::from("ccc")), "ccc".into());
        assert_eq!(m.first_raw(), Some(&OsString::from("bbb")));
    }
}

```

`clap/clap_builder/src/parser/matches/mod.rs`:

```rs
mod arg_matches;
mod matched_arg;
mod value_source;

pub use arg_matches::IdsRef;
pub use arg_matches::RawValues;
pub use arg_matches::Values;
pub use arg_matches::ValuesRef;
pub use arg_matches::{ArgMatches, Indices};
pub use value_source::ValueSource;

pub(crate) use arg_matches::SubCommand;
pub(crate) use matched_arg::MatchedArg;

```

`clap/clap_builder/src/parser/matches/value_source.rs`:

```rs
/// Origin of the argument's value
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[non_exhaustive]
pub enum ValueSource {
    /// Value came [`Arg::default_value`][crate::Arg::default_value]
    DefaultValue,
    /// Value came [`Arg::env`][crate::Arg::env]
    EnvVariable,
    /// Value was passed in on the command-line
    CommandLine,
}

impl ValueSource {
    pub(crate) fn is_explicit(self) -> bool {
        self != Self::DefaultValue
    }
}

```

`clap/clap_builder/src/parser/mod.rs`:

```rs
//! [`Command`][crate::Command] line argument parser

mod arg_matcher;
mod error;
mod matches;
#[allow(clippy::module_inception)]
mod parser;
mod validator;

pub(crate) mod features;

pub(crate) use self::arg_matcher::ArgMatcher;
pub(crate) use self::matches::{MatchedArg, SubCommand};
pub(crate) use self::parser::Identifier;
pub(crate) use self::parser::Parser;
pub(crate) use self::parser::PendingArg;
pub(crate) use self::validator::get_possible_values_cli;
pub(crate) use self::validator::Validator;

pub use self::matches::IdsRef;
pub use self::matches::RawValues;
pub use self::matches::Values;
pub use self::matches::ValuesRef;
pub use self::matches::{ArgMatches, Indices, ValueSource};
pub use error::MatchesError;

```

`clap/clap_builder/src/parser/parser.rs`:

```rs
// Std
use std::{
    cell::Cell,
    ffi::{OsStr, OsString},
};

use clap_lex::OsStrExt as _;

// Internal
use crate::builder::{Arg, Command};
use crate::error::Error as ClapError;
use crate::error::Result as ClapResult;
use crate::mkeymap::KeyType;
use crate::output::Usage;
use crate::parser::features::suggestions;
use crate::parser::{ArgMatcher, SubCommand};
use crate::parser::{Validator, ValueSource};
use crate::util::AnyValue;
use crate::util::Id;
use crate::ArgAction;
use crate::INTERNAL_ERROR_MSG;

pub(crate) struct Parser<'cmd> {
    cmd: &'cmd mut Command,
    cur_idx: Cell<usize>,
    /// Index of the previous flag subcommand in a group of flags.
    flag_subcmd_at: Option<usize>,
    /// Counter indicating the number of items to skip
    /// when revisiting the group of flags which includes the flag subcommand.
    flag_subcmd_skip: usize,
}

// Initializing Methods
impl<'cmd> Parser<'cmd> {
    pub(crate) fn new(cmd: &'cmd mut Command) -> Self {
        Parser {
            cmd,
            cur_idx: Cell::new(0),
            flag_subcmd_at: None,
            flag_subcmd_skip: 0,
        }
    }
}

// Parsing Methods
impl<'cmd> Parser<'cmd> {
    // The actual parsing function
    #[allow(clippy::cognitive_complexity)]
    pub(crate) fn get_matches_with(
        &mut self,
        matcher: &mut ArgMatcher,
        raw_args: &mut clap_lex::RawArgs,
        args_cursor: clap_lex::ArgCursor,
    ) -> ClapResult<()> {
        debug!("Parser::get_matches_with");

        ok!(self.parse(matcher, raw_args, args_cursor).map_err(|err| {
            if self.cmd.is_ignore_errors_set() {
                #[cfg(feature = "env")]
                let _ = self.add_env(matcher);
                let _ = self.add_defaults(matcher);
            }
            err
        }));
        ok!(self.resolve_pending(matcher));

        #[cfg(feature = "env")]
        ok!(self.add_env(matcher));
        ok!(self.add_defaults(matcher));

        Validator::new(self.cmd).validate(matcher)
    }

    // The actual parsing function
    #[allow(clippy::cognitive_complexity)]
    pub(crate) fn parse(
        &mut self,
        matcher: &mut ArgMatcher,
        raw_args: &mut clap_lex::RawArgs,
        mut args_cursor: clap_lex::ArgCursor,
    ) -> ClapResult<()> {
        debug!("Parser::parse");
        // Verify all positional assertions pass

        let mut subcmd_name: Option<String> = None;
        let mut keep_state = false;
        let mut parse_state = ParseState::ValuesDone;
        let mut pos_counter = 1;

        // Already met any valid arg(then we shouldn't expect subcommands after it).
        let mut valid_arg_found = false;
        // If the user already passed '--'. Meaning only positional args follow.
        let mut trailing_values = false;

        // Count of positional args
        let positional_count = self
            .cmd
            .get_keymap()
            .keys()
            .filter(|x| x.is_position())
            .count();
        // If any arg sets .last(true)
        let contains_last = self.cmd.get_arguments().any(|x| x.is_last_set());

        while let Some(arg_os) = raw_args.next(&mut args_cursor) {
            debug!(
                "Parser::get_matches_with: Begin parsing '{:?}'",
                arg_os.to_value_os(),
            );

            // Has the user already passed '--'? Meaning only positional args follow
            if !trailing_values {
                if self.cmd.is_subcommand_precedence_over_arg_set()
                    || !matches!(parse_state, ParseState::Opt(_) | ParseState::Pos(_))
                {
                    // Does the arg match a subcommand name, or any of its aliases (if defined)
                    let sc_name = self.possible_subcommand(arg_os.to_value(), valid_arg_found);
                    debug!("Parser::get_matches_with: sc={sc_name:?}");
                    if let Some(sc_name) = sc_name {
                        if sc_name == "help" && !self.cmd.is_disable_help_subcommand_set() {
                            ok!(self.parse_help_subcommand(raw_args.remaining(&mut args_cursor)));
                            unreachable!("`parse_help_subcommand` always errors");
                        } else {
                            subcmd_name = Some(sc_name.to_owned());
                        }
                        break;
                    }
                }

                if arg_os.is_escape() {
                    if matches!(&parse_state, ParseState::Opt(opt) | ParseState::Pos(opt) if
                        self.cmd[opt].is_allow_hyphen_values_set())
                    {
                        // ParseResult::MaybeHyphenValue, do nothing
                    } else {
                        debug!("Parser::get_matches_with: setting TrailingVals=true");
                        trailing_values = true;
                        matcher.start_trailing();
                        continue;
                    }
                } else if let Some((long_arg, long_value)) = arg_os.to_long() {
                    let parse_result = ok!(self.parse_long_arg(
                        matcher,
                        long_arg,
                        long_value,
                        &parse_state,
                        pos_counter,
                        &mut valid_arg_found,
                    ));
                    debug!("Parser::get_matches_with: After parse_long_arg {parse_result:?}");
                    match parse_result {
                        ParseResult::NoArg => {
                            unreachable!("`to_long` always has the flag specified")
                        }
                        ParseResult::ValuesDone => {
                            parse_state = ParseState::ValuesDone;
                            continue;
                        }
                        ParseResult::Opt(id) => {
                            parse_state = ParseState::Opt(id);
                            continue;
                        }
                        ParseResult::FlagSubCommand(name) => {
                            debug!(
                                "Parser::get_matches_with: FlagSubCommand found in long arg {:?}",
                                &name
                            );
                            subcmd_name = Some(name);
                            break;
                        }
                        ParseResult::EqualsNotProvided { arg } => {
                            let _ = self.resolve_pending(matcher);
                            return Err(ClapError::no_equals(
                                self.cmd,
                                arg,
                                Usage::new(self.cmd).create_usage_with_title(&[]),
                            ));
                        }
                        ParseResult::NoMatchingArg { arg } => {
                            let _ = self.resolve_pending(matcher);
                            let remaining_args: Vec<_> =
                                raw_args.remaining(&mut args_cursor).collect();
                            return Err(self.did_you_mean_error(
                                &arg,
                                matcher,
                                &remaining_args,
                                trailing_values,
                            ));
                        }
                        ParseResult::UnneededAttachedValue { rest, used, arg } => {
                            let _ = self.resolve_pending(matcher);
                            return Err(ClapError::too_many_values(
                                self.cmd,
                                rest,
                                arg,
                                Usage::new(self.cmd).create_usage_with_title(&used),
                            ));
                        }
                        ParseResult::MaybeHyphenValue => {
                            // Maybe a hyphen value, do nothing.
                        }
                        ParseResult::AttachedValueNotConsumed => {
                            unreachable!()
                        }
                    }
                } else if let Some(short_arg) = arg_os.to_short() {
                    // Arg looks like a short flag, and not a possible number

                    // Try to parse short args like normal, if allow_hyphen_values or
                    // AllowNegativeNumbers is set, parse_short_arg will *not* throw
                    // an error, and instead return Ok(None)
                    let parse_result = ok!(self.parse_short_arg(
                        matcher,
                        short_arg,
                        &parse_state,
                        pos_counter,
                        &mut valid_arg_found,
                    ));
                    // If it's None, we then check if one of those two AppSettings was set
                    debug!("Parser::get_matches_with: After parse_short_arg {parse_result:?}");
                    match parse_result {
                        ParseResult::NoArg => {
                            // Is a single dash `-`, try positional.
                        }
                        ParseResult::ValuesDone => {
                            parse_state = ParseState::ValuesDone;
                            continue;
                        }
                        ParseResult::Opt(id) => {
                            parse_state = ParseState::Opt(id);
                            continue;
                        }
                        ParseResult::FlagSubCommand(name) => {
                            // If there are more short flags to be processed, we should keep the state, and later
                            // revisit the current group of short flags skipping the subcommand.
                            keep_state = self
                                .flag_subcmd_at
                                .map(|at| {
                                    raw_args
                                        .seek(&mut args_cursor, clap_lex::SeekFrom::Current(-1));
                                    // Since we are now saving the current state, the number of flags to skip during state recovery should
                                    // be the current index (`cur_idx`) minus ONE UNIT TO THE LEFT of the starting position.
                                    self.flag_subcmd_skip = self.cur_idx.get() - at + 1;
                                })
                                .is_some();

                            debug!(
                                "Parser::get_matches_with:FlagSubCommandShort: subcmd_name={}, keep_state={}, flag_subcmd_skip={}",
                                name,
                                keep_state,
                                self.flag_subcmd_skip
                            );

                            subcmd_name = Some(name);
                            break;
                        }
                        ParseResult::EqualsNotProvided { arg } => {
                            let _ = self.resolve_pending(matcher);
                            return Err(ClapError::no_equals(
                                self.cmd,
                                arg,
                                Usage::new(self.cmd).create_usage_with_title(&[]),
                            ));
                        }
                        ParseResult::NoMatchingArg { arg } => {
                            let _ = self.resolve_pending(matcher);
                            // We already know it looks like a flag
                            let suggested_trailing_arg =
                                !trailing_values && self.cmd.has_positionals();
                            return Err(ClapError::unknown_argument(
                                self.cmd,
                                arg,
                                None,
                                suggested_trailing_arg,
                                Usage::new(self.cmd).create_usage_with_title(&[]),
                            ));
                        }
                        ParseResult::MaybeHyphenValue => {
                            // Maybe a hyphen value, do nothing.
                        }
                        ParseResult::UnneededAttachedValue { .. }
                        | ParseResult::AttachedValueNotConsumed => unreachable!(),
                    }
                }

                if let ParseState::Opt(id) = &parse_state {
                    // Assume this is a value of a previous arg.

                    // get the option so we can check the settings
                    let arg = &self.cmd[id];
                    let parse_result = if let Some(parse_result) =
                        self.check_terminator(arg, arg_os.to_value_os())
                    {
                        parse_result
                    } else {
                        let trailing_values = false;
                        let arg_values = matcher.pending_values_mut(id, None, trailing_values);
                        arg_values.push(arg_os.to_value_os().to_owned());
                        if matcher.needs_more_vals(arg) {
                            ParseResult::Opt(arg.get_id().clone())
                        } else {
                            ParseResult::ValuesDone
                        }
                    };
                    parse_state = match parse_result {
                        ParseResult::Opt(id) => ParseState::Opt(id),
                        ParseResult::ValuesDone => ParseState::ValuesDone,
                        _ => unreachable!(),
                    };
                    // get the next value from the iterator
                    continue;
                }
            }

            // Correct pos_counter.
            pos_counter = {
                let is_second_to_last = pos_counter + 1 == positional_count;

                // The last positional argument, or second to last positional
                // argument may be set to .multiple_values(true) or `.multiple_occurrences(true)`
                let low_index_mults = is_second_to_last
                    && self.cmd.get_positionals().any(|a| {
                        a.is_multiple() && (positional_count != a.get_index().unwrap_or(0))
                    })
                    && self
                        .cmd
                        .get_positionals()
                        .last()
                        .map(|p_name| !p_name.is_last_set())
                        .unwrap_or_default();

                let is_terminated = self
                    .cmd
                    .get_keymap()
                    .get(&pos_counter)
                    .map(|a| a.get_value_terminator().is_some())
                    .unwrap_or_default();

                let missing_pos = self.cmd.is_allow_missing_positional_set()
                    && is_second_to_last
                    && !trailing_values;

                debug!("Parser::get_matches_with: Positional counter...{pos_counter}");
                debug!("Parser::get_matches_with: Low index multiples...{low_index_mults:?}");

                if (low_index_mults || missing_pos) && !is_terminated {
                    let skip_current = if let Some(n) = raw_args.peek(&args_cursor) {
                        if let Some(arg) = self
                            .cmd
                            .get_positionals()
                            .find(|a| a.get_index() == Some(pos_counter))
                        {
                            // If next value looks like a new_arg or it's a
                            // subcommand, skip positional argument under current
                            // pos_counter(which means current value cannot be a
                            // positional argument with a value next to it), assume
                            // current value matches the next arg.
                            self.is_new_arg(&n, arg)
                                || self
                                    .possible_subcommand(n.to_value(), valid_arg_found)
                                    .is_some()
                        } else {
                            true
                        }
                    } else {
                        true
                    };

                    if skip_current {
                        debug!("Parser::get_matches_with: Bumping the positional counter...");
                        pos_counter + 1
                    } else {
                        pos_counter
                    }
                } else if trailing_values
                    && (self.cmd.is_allow_missing_positional_set() || contains_last)
                {
                    // Came to -- and one positional has .last(true) set, so we go immediately
                    // to the last (highest index) positional
                    debug!("Parser::get_matches_with: .last(true) and --, setting last pos");
                    positional_count
                } else {
                    pos_counter
                }
            };

            if let Some(arg) = self.cmd.get_keymap().get(&pos_counter) {
                if arg.is_last_set() && !trailing_values {
                    let _ = self.resolve_pending(matcher);
                    // Its already considered a positional, we don't need to suggest turning it
                    // into one
                    let suggested_trailing_arg = false;
                    return Err(ClapError::unknown_argument(
                        self.cmd,
                        arg_os.display().to_string(),
                        None,
                        suggested_trailing_arg,
                        Usage::new(self.cmd).create_usage_with_title(&[]),
                    ));
                }

                if arg.is_trailing_var_arg_set() {
                    trailing_values = true;
                }

                if matcher.pending_arg_id() != Some(arg.get_id()) || !arg.is_multiple_values_set() {
                    ok!(self.resolve_pending(matcher));
                }
                parse_state =
                    if let Some(parse_result) = self.check_terminator(arg, arg_os.to_value_os()) {
                        debug_assert_eq!(parse_result, ParseResult::ValuesDone);
                        pos_counter += 1;
                        ParseState::ValuesDone
                    } else {
                        let arg_values = matcher.pending_values_mut(
                            arg.get_id(),
                            Some(Identifier::Index),
                            trailing_values,
                        );
                        arg_values.push(arg_os.to_value_os().to_owned());

                        // Only increment the positional counter if it doesn't allow multiples
                        if !arg.is_multiple() {
                            pos_counter += 1;
                            ParseState::ValuesDone
                        } else {
                            ParseState::Pos(arg.get_id().clone())
                        }
                    };
                valid_arg_found = true;
            } else if let Some(external_parser) =
                self.cmd.get_external_subcommand_value_parser().cloned()
            {
                // Get external subcommand name
                let sc_name = match arg_os.to_value() {
                    Ok(s) => s.to_owned(),
                    Err(_) => {
                        let _ = self.resolve_pending(matcher);
                        return Err(ClapError::invalid_utf8(
                            self.cmd,
                            Usage::new(self.cmd).create_usage_with_title(&[]),
                        ));
                    }
                };

                // Collect the external subcommand args
                let mut sc_m = ArgMatcher::new(self.cmd);
                sc_m.start_occurrence_of_external(self.cmd);

                for raw_val in raw_args.remaining(&mut args_cursor) {
                    let val = ok!(external_parser.parse_ref(
                        self.cmd,
                        None,
                        raw_val,
                        ValueSource::CommandLine
                    ));
                    let external_id = Id::from_static_ref(Id::EXTERNAL);
                    sc_m.add_val_to(&external_id, val, raw_val.to_os_string());
                }

                matcher.subcommand(SubCommand {
                    name: sc_name,
                    matches: sc_m.into_inner(),
                });

                return Ok(());
            } else {
                // Start error processing
                let _ = self.resolve_pending(matcher);
                return Err(self.match_arg_error(
                    &arg_os,
                    valid_arg_found,
                    trailing_values,
                    matcher,
                ));
            }
        }

        if let Some(ref pos_sc_name) = subcmd_name {
            if self.cmd.is_args_conflicts_with_subcommands_set() && valid_arg_found {
                return Err(ClapError::subcommand_conflict(
                    self.cmd,
                    pos_sc_name.clone(),
                    matcher
                        .arg_ids()
                        .map(|id| self.cmd.find(id).unwrap().to_string())
                        .collect(),
                    Usage::new(self.cmd).create_usage_with_title(&[]),
                ));
            }
            let sc_name = self
                .cmd
                .find_subcommand(pos_sc_name)
                .expect(INTERNAL_ERROR_MSG)
                .get_name()
                .to_owned();
            ok!(self.parse_subcommand(&sc_name, matcher, raw_args, args_cursor, keep_state));
        }

        Ok(())
    }

    fn match_arg_error(
        &self,
        arg_os: &clap_lex::ParsedArg<'_>,
        valid_arg_found: bool,
        trailing_values: bool,
        matcher: &ArgMatcher,
    ) -> ClapError {
        // If argument follows a `--`
        if trailing_values {
            // If the arg matches a subcommand name, or any of its aliases (if defined)
            if self
                .possible_subcommand(arg_os.to_value(), valid_arg_found)
                .is_some()
            {
                return ClapError::unnecessary_double_dash(
                    self.cmd,
                    arg_os.display().to_string(),
                    Usage::new(self.cmd).create_usage_with_title(&[]),
                );
            }
        }

        let suggested_trailing_arg = !trailing_values
            && self.cmd.has_positionals()
            && (arg_os.is_long() || arg_os.is_short());

        if self.cmd.has_subcommands() {
            if self.cmd.is_args_conflicts_with_subcommands_set() && valid_arg_found {
                return ClapError::subcommand_conflict(
                    self.cmd,
                    arg_os.display().to_string(),
                    matcher
                        .arg_ids()
                        .filter_map(|id| self.cmd.find(id).map(|a| a.to_string()))
                        .collect(),
                    Usage::new(self.cmd).create_usage_with_title(&[]),
                );
            }

            let candidates = suggestions::did_you_mean(
                &arg_os.display().to_string(),
                self.cmd.all_subcommand_names(),
            );
            // If the argument looks like a subcommand.
            if !candidates.is_empty() {
                return ClapError::invalid_subcommand(
                    self.cmd,
                    arg_os.display().to_string(),
                    candidates,
                    self.cmd.get_bin_name_fallback().to_owned(),
                    suggested_trailing_arg,
                    Usage::new(self.cmd).create_usage_with_title(&[]),
                );
            }

            // If the argument must be a subcommand.
            if !self.cmd.has_positionals() || self.cmd.is_infer_subcommands_set() {
                return ClapError::unrecognized_subcommand(
                    self.cmd,
                    arg_os.display().to_string(),
                    Usage::new(self.cmd).create_usage_with_title(&[]),
                );
            }
        }

        ClapError::unknown_argument(
            self.cmd,
            arg_os.display().to_string(),
            None,
            suggested_trailing_arg,
            Usage::new(self.cmd).create_usage_with_title(&[]),
        )
    }

    // Checks if the arg matches a subcommand name, or any of its aliases (if defined)
    fn possible_subcommand(
        &self,
        arg: Result<&str, &OsStr>,
        valid_arg_found: bool,
    ) -> Option<&str> {
        debug!("Parser::possible_subcommand: arg={arg:?}");
        let arg = some!(arg.ok());

        if !(self.cmd.is_args_conflicts_with_subcommands_set() && valid_arg_found) {
            if self.cmd.is_infer_subcommands_set() {
                // For subcommand `test`, we accepts it's prefix: `t`, `te`,
                // `tes` and `test`.
                let mut iter = self.cmd.get_subcommands().filter_map(|s| {
                    if s.get_name().starts_with(arg) {
                        return Some(s.get_name());
                    }

                    // Use find here instead of chaining the iterator because we want to accept
                    // conflicts in aliases.
                    s.get_all_aliases().find(|s| s.starts_with(arg))
                });

                if let name @ Some(_) = iter.next() {
                    if iter.next().is_none() {
                        return name;
                    }
                }
            }
            // Don't use an else here because we want inference to support exact matching even if
            // there are conflicts.
            if let Some(sc) = self.cmd.find_subcommand(arg) {
                return Some(sc.get_name());
            }
        }
        None
    }

    // Checks if the arg matches a long flag subcommand name, or any of its aliases (if defined)
    fn possible_long_flag_subcommand(&self, arg: &str) -> Option<&str> {
        debug!("Parser::possible_long_flag_subcommand: arg={arg:?}");
        if self.cmd.is_infer_subcommands_set() {
            let mut iter = self.cmd.get_subcommands().filter_map(|sc| {
                sc.get_long_flag().and_then(|long| {
                    if long.starts_with(arg) {
                        Some(sc.get_name())
                    } else {
                        sc.get_all_long_flag_aliases().find_map(|alias| {
                            if alias.starts_with(arg) {
                                Some(sc.get_name())
                            } else {
                                None
                            }
                        })
                    }
                })
            });

            if let name @ Some(_) = iter.next() {
                if iter.next().is_none() {
                    return name;
                }
            }
        }
        if let Some(sc_name) = self.cmd.find_long_subcmd(arg) {
            return Some(sc_name);
        }
        None
    }

    fn parse_help_subcommand(
        &self,
        cmds: impl Iterator<Item = &'cmd OsStr>,
    ) -> ClapResult<std::convert::Infallible> {
        debug!("Parser::parse_help_subcommand");

        let mut cmd = self.cmd.clone();
        let sc = {
            let mut sc = &mut cmd;

            for cmd in cmds {
                sc = if let Some(sc_name) =
                    sc.find_subcommand(cmd).map(|sc| sc.get_name().to_owned())
                {
                    sc._build_subcommand(&sc_name).unwrap()
                } else {
                    return Err(ClapError::unrecognized_subcommand(
                        sc,
                        cmd.to_string_lossy().into_owned(),
                        Usage::new(sc).create_usage_with_title(&[]),
                    ));
                };
            }

            sc
        };
        let parser = Parser::new(sc);

        Err(parser.help_err(true))
    }

    fn is_new_arg(&self, next: &clap_lex::ParsedArg<'_>, current_positional: &Arg) -> bool {
        #![allow(clippy::needless_bool)] // Prefer consistent if/else-if ladder

        debug!(
            "Parser::is_new_arg: {:?}:{}",
            next.to_value_os(),
            current_positional.get_id()
        );

        if self.cmd[current_positional.get_id()].is_allow_hyphen_values_set()
            || (self.cmd[current_positional.get_id()].is_allow_negative_numbers_set()
                && next.is_negative_number())
        {
            // If allow hyphen, this isn't a new arg.
            debug!("Parser::is_new_arg: Allow hyphen");
            false
        } else if next.is_long() {
            // If this is a long flag, this is a new arg.
            debug!("Parser::is_new_arg: --<something> found");
            true
        } else if next.is_short() {
            // If this is a short flag, this is a new arg. But a single '-' by
            // itself is a value and typically means "stdin" on unix systems.
            debug!("Parser::is_new_arg: -<something> found");
            true
        } else {
            // Nothing special, this is a value.
            debug!("Parser::is_new_arg: value");
            false
        }
    }

    fn parse_subcommand(
        &mut self,
        sc_name: &str,
        matcher: &mut ArgMatcher,
        raw_args: &mut clap_lex::RawArgs,
        args_cursor: clap_lex::ArgCursor,
        keep_state: bool,
    ) -> ClapResult<()> {
        debug!("Parser::parse_subcommand");

        let partial_parsing_enabled = self.cmd.is_ignore_errors_set();

        if let Some(sc) = self.cmd._build_subcommand(sc_name) {
            let mut sc_matcher = ArgMatcher::new(sc);

            debug!(
                "Parser::parse_subcommand: About to parse sc={}",
                sc.get_name()
            );

            {
                let mut p = Parser::new(sc);
                // HACK: maintain indexes between parsers
                // FlagSubCommand short arg needs to revisit the current short args, but skip the subcommand itself
                if keep_state {
                    p.cur_idx.set(self.cur_idx.get());
                    p.flag_subcmd_at = self.flag_subcmd_at;
                    p.flag_subcmd_skip = self.flag_subcmd_skip;
                }
                if let Err(error) = p.get_matches_with(&mut sc_matcher, raw_args, args_cursor) {
                    if partial_parsing_enabled {
                        debug!("Parser::parse_subcommand: ignored error in subcommand {sc_name}: {error:?}");
                    } else {
                        return Err(error);
                    }
                }
            }
            matcher.subcommand(SubCommand {
                name: sc.get_name().to_owned(),
                matches: sc_matcher.into_inner(),
            });
        }
        Ok(())
    }

    fn parse_long_arg(
        &mut self,
        matcher: &mut ArgMatcher,
        long_arg: Result<&str, &OsStr>,
        long_value: Option<&OsStr>,
        parse_state: &ParseState,
        pos_counter: usize,
        valid_arg_found: &mut bool,
    ) -> ClapResult<ParseResult> {
        // maybe here lifetime should be 'a
        debug!("Parser::parse_long_arg");

        #[allow(clippy::blocks_in_conditions)]
        if matches!(parse_state, ParseState::Opt(opt) | ParseState::Pos(opt) if
            self.cmd[opt].is_allow_hyphen_values_set())
        {
            debug!("Parser::parse_long_arg: prior arg accepts hyphenated values",);
            return Ok(ParseResult::MaybeHyphenValue);
        }

        debug!("Parser::parse_long_arg: Does it contain '='...");
        let long_arg = match long_arg {
            Ok(long_arg) => long_arg,
            Err(long_arg_os) => {
                return Ok(ParseResult::NoMatchingArg {
                    arg: long_arg_os.to_string_lossy().into_owned(),
                })
            }
        };
        if long_arg.is_empty() {
            debug_assert!(
                long_value.is_some(),
                "`--` should be filtered out before this point"
            );
        }

        let arg = if let Some(arg) = self.cmd.get_keymap().get(long_arg) {
            debug!("Parser::parse_long_arg: Found valid arg or flag '{arg}'");
            Some((long_arg, arg))
        } else if self.cmd.is_infer_long_args_set() {
            let mut iter = self.cmd.get_arguments().filter_map(|a| {
                if let Some(long) = a.get_long() {
                    if long.starts_with(long_arg) {
                        return Some((long, a));
                    }
                }
                a.aliases
                    .iter()
                    .find_map(|(alias, _)| alias.starts_with(long_arg).then(|| (alias.as_str(), a)))
            });

            iter.next().filter(|_| iter.next().is_none())
        } else {
            None
        };

        if let Some((_long_arg, arg)) = arg {
            let ident = Identifier::Long;
            *valid_arg_found = true;
            if arg.is_takes_value_set() {
                debug!(
                    "Parser::parse_long_arg({:?}): Found an arg with value '{:?}'",
                    long_arg, &long_value
                );
                let has_eq = long_value.is_some();
                self.parse_opt_value(ident, long_value, arg, matcher, has_eq)
            } else if let Some(rest) = long_value {
                let required = self.cmd.required_graph();
                debug!("Parser::parse_long_arg({long_arg:?}): Got invalid literal `{rest:?}`");
                let mut used: Vec<Id> = matcher
                    .arg_ids()
                    .filter(|arg_id| {
                        matcher.check_explicit(arg_id, &crate::builder::ArgPredicate::IsPresent)
                    })
                    .filter(|&n| {
                        self.cmd
                            .find(n)
                            .map(|a| !(a.is_hide_set() || required.contains(a.get_id())))
                            .unwrap_or(true)
                    })
                    .cloned()
                    .collect();
                used.push(arg.get_id().clone());

                Ok(ParseResult::UnneededAttachedValue {
                    rest: rest.to_string_lossy().into_owned(),
                    used,
                    arg: arg.to_string(),
                })
            } else {
                debug!("Parser::parse_long_arg({long_arg:?}): Presence validated");
                let trailing_idx = None;
                self.react(
                    Some(ident),
                    ValueSource::CommandLine,
                    arg,
                    vec![],
                    trailing_idx,
                    matcher,
                )
            }
        } else if let Some(sc_name) = self.possible_long_flag_subcommand(long_arg) {
            Ok(ParseResult::FlagSubCommand(sc_name.to_string()))
        } else if self
            .cmd
            .get_keymap()
            .get(&pos_counter)
            .map(|arg| arg.is_allow_hyphen_values_set() && !arg.is_last_set())
            .unwrap_or_default()
        {
            debug!("Parser::parse_long_args: positional at {pos_counter} allows hyphens");
            Ok(ParseResult::MaybeHyphenValue)
        } else {
            Ok(ParseResult::NoMatchingArg {
                arg: long_arg.to_owned(),
            })
        }
    }

    fn parse_short_arg(
        &mut self,
        matcher: &mut ArgMatcher,
        mut short_arg: clap_lex::ShortFlags<'_>,
        parse_state: &ParseState,
        // change this to possible pos_arg when removing the usage of &mut Parser.
        pos_counter: usize,
        valid_arg_found: &mut bool,
    ) -> ClapResult<ParseResult> {
        debug!("Parser::parse_short_arg: short_arg={short_arg:?}");

        #[allow(clippy::blocks_in_conditions)]
        if matches!(parse_state, ParseState::Opt(opt) | ParseState::Pos(opt)
                if self.cmd[opt].is_allow_hyphen_values_set() || (self.cmd[opt].is_allow_negative_numbers_set() && short_arg.is_negative_number()))
        {
            debug!("Parser::parse_short_args: prior arg accepts hyphenated values",);
            return Ok(ParseResult::MaybeHyphenValue);
        } else if self
            .cmd
            .get_keymap()
            .get(&pos_counter)
            .map(|arg| arg.is_allow_negative_numbers_set())
            .unwrap_or_default()
            && short_arg.is_negative_number()
        {
            debug!("Parser::parse_short_arg: negative number");
            return Ok(ParseResult::MaybeHyphenValue);
        } else if self
            .cmd
            .get_keymap()
            .get(&pos_counter)
            .map(|arg| arg.is_allow_hyphen_values_set() && !arg.is_last_set())
            .unwrap_or_default()
            && short_arg
                .clone()
                .any(|c| !c.map(|c| self.cmd.contains_short(c)).unwrap_or_default())
        {
            debug!("Parser::parse_short_args: positional at {pos_counter} allows hyphens");
            return Ok(ParseResult::MaybeHyphenValue);
        }

        let mut ret = ParseResult::NoArg;

        let skip = self.flag_subcmd_skip;
        self.flag_subcmd_skip = 0;
        let res = short_arg.advance_by(skip);
        debug_assert_eq!(
            res,
            Ok(()),
            "tracking of `flag_subcmd_skip` is off for `{short_arg:?}`"
        );
        while let Some(c) = short_arg.next_flag() {
            let c = match c {
                Ok(c) => c,
                Err(rest) => {
                    return Ok(ParseResult::NoMatchingArg {
                        arg: format!("-{}", rest.to_string_lossy()),
                    });
                }
            };
            debug!("Parser::parse_short_arg:iter:{c}");

            // Check for matching short options, and return the name if there is no trailing
            // concatenated value: -oval
            // Option: -o
            // Value: val
            if let Some(arg) = self.cmd.get_keymap().get(&c) {
                let ident = Identifier::Short;
                debug!("Parser::parse_short_arg:iter:{c}: Found valid opt or flag");
                *valid_arg_found = true;
                if !arg.is_takes_value_set() {
                    let arg_values = Vec::new();
                    let trailing_idx = None;
                    ret = ok!(self.react(
                        Some(ident),
                        ValueSource::CommandLine,
                        arg,
                        arg_values,
                        trailing_idx,
                        matcher,
                    ));
                    continue;
                }

                // Check for trailing concatenated value
                //
                // Cloning the iterator, so we rollback if it isn't there.
                let val = short_arg.clone().next_value_os().unwrap_or_default();
                debug!("Parser::parse_short_arg:iter:{c}: val={val:?}, short_arg={short_arg:?}");
                let val = Some(val).filter(|v| !v.is_empty());

                // Default to "we're expecting a value later".
                //
                // If attached value is not consumed, we may have more short
                // flags to parse, continue.
                //
                // e.g. `-xvf`, when require_equals && x.min_vals == 0, we don't
                // consume the `vf`, even if it's provided as value.
                let (val, has_eq) = if let Some(val) = val.and_then(|v| v.strip_prefix("=")) {
                    (Some(val), true)
                } else {
                    (val, false)
                };
                match ok!(self.parse_opt_value(ident, val, arg, matcher, has_eq)) {
                    ParseResult::AttachedValueNotConsumed => continue,
                    x => return Ok(x),
                }
            }

            return if let Some(sc_name) = self.cmd.find_short_subcmd(c) {
                debug!("Parser::parse_short_arg:iter:{c}: subcommand={sc_name}");
                // Make sure indices get updated before reading `self.cur_idx`
                ok!(self.resolve_pending(matcher));
                self.cur_idx.set(self.cur_idx.get() + 1);
                debug!("Parser::parse_short_arg: cur_idx:={}", self.cur_idx.get());

                let name = sc_name.to_string();
                // Get the index of the previously saved flag subcommand in the group of flags (if exists).
                // If it is a new flag subcommand, then the formentioned index should be the current one
                // (ie. `cur_idx`), and should be registered.
                let cur_idx = self.cur_idx.get();
                self.flag_subcmd_at.get_or_insert(cur_idx);
                let done_short_args = short_arg.is_empty();
                if done_short_args {
                    self.flag_subcmd_at = None;
                }
                Ok(ParseResult::FlagSubCommand(name))
            } else {
                Ok(ParseResult::NoMatchingArg {
                    arg: format!("-{c}"),
                })
            };
        }
        Ok(ret)
    }

    fn parse_opt_value(
        &self,
        ident: Identifier,
        attached_value: Option<&OsStr>,
        arg: &Arg,
        matcher: &mut ArgMatcher,
        has_eq: bool,
    ) -> ClapResult<ParseResult> {
        debug!(
            "Parser::parse_opt_value; arg={}, val={:?}, has_eq={:?}",
            arg.get_id(),
            attached_value,
            has_eq
        );
        debug!("Parser::parse_opt_value; arg.settings={:?}", arg.settings);

        debug!("Parser::parse_opt_value; Checking for val...");
        // require_equals is set, but no '=' is provided, try throwing error.
        if arg.is_require_equals_set() && !has_eq {
            if arg.get_min_vals() == 0 {
                debug!("Requires equals, but min_vals == 0");
                let arg_values = Vec::new();
                let trailing_idx = None;
                let react_result = ok!(self.react(
                    Some(ident),
                    ValueSource::CommandLine,
                    arg,
                    arg_values,
                    trailing_idx,
                    matcher,
                ));
                debug_assert_eq!(react_result, ParseResult::ValuesDone);
                if attached_value.is_some() {
                    Ok(ParseResult::AttachedValueNotConsumed)
                } else {
                    Ok(ParseResult::ValuesDone)
                }
            } else {
                debug!("Requires equals but not provided. Error.");
                Ok(ParseResult::EqualsNotProvided {
                    arg: arg.to_string(),
                })
            }
        } else if let Some(v) = attached_value {
            let arg_values = vec![v.to_owned()];
            let trailing_idx = None;
            let react_result = ok!(self.react(
                Some(ident),
                ValueSource::CommandLine,
                arg,
                arg_values,
                trailing_idx,
                matcher,
            ));
            debug_assert_eq!(react_result, ParseResult::ValuesDone);
            // Attached are always done
            Ok(ParseResult::ValuesDone)
        } else {
            debug!("Parser::parse_opt_value: More arg vals required...");
            ok!(self.resolve_pending(matcher));
            let trailing_values = false;
            matcher.pending_values_mut(arg.get_id(), Some(ident), trailing_values);
            Ok(ParseResult::Opt(arg.get_id().clone()))
        }
    }

    fn check_terminator(&self, arg: &Arg, val: &OsStr) -> Option<ParseResult> {
        if Some(val) == arg.terminator.as_ref().map(|s| OsStr::new(s.as_str())) {
            debug!("Parser::check_terminator: terminator={:?}", arg.terminator);
            Some(ParseResult::ValuesDone)
        } else {
            None
        }
    }

    fn push_arg_values(
        &self,
        arg: &Arg,
        raw_vals: Vec<OsString>,
        source: ValueSource,
        matcher: &mut ArgMatcher,
    ) -> ClapResult<()> {
        debug!("Parser::push_arg_values: {raw_vals:?}");

        for raw_val in raw_vals {
            // update the current index because each value is a distinct index to clap
            self.cur_idx.set(self.cur_idx.get() + 1);
            debug!(
                "Parser::add_single_val_to_arg: cur_idx:={}",
                self.cur_idx.get()
            );
            let value_parser = arg.get_value_parser();
            let val = ok!(value_parser.parse_ref(self.cmd, Some(arg), &raw_val, source));

            matcher.add_val_to(arg.get_id(), val, raw_val);
            matcher.add_index_to(arg.get_id(), self.cur_idx.get());
        }

        Ok(())
    }

    fn resolve_pending(&self, matcher: &mut ArgMatcher) -> ClapResult<()> {
        let pending = match matcher.take_pending() {
            Some(pending) => pending,
            None => {
                return Ok(());
            }
        };

        debug!("Parser::resolve_pending: id={:?}", pending.id);
        let arg = self.cmd.find(&pending.id).expect(INTERNAL_ERROR_MSG);
        let _ = ok!(self.react(
            pending.ident,
            ValueSource::CommandLine,
            arg,
            pending.raw_vals,
            pending.trailing_idx,
            matcher,
        ));

        Ok(())
    }

    fn react(
        &self,
        ident: Option<Identifier>,
        source: ValueSource,
        arg: &Arg,
        mut raw_vals: Vec<OsString>,
        mut trailing_idx: Option<usize>,
        matcher: &mut ArgMatcher,
    ) -> ClapResult<ParseResult> {
        ok!(self.resolve_pending(matcher));

        debug!(
            "Parser::react action={:?}, identifier={:?}, source={:?}",
            arg.get_action(),
            ident,
            source
        );

        // Process before `default_missing_values` to avoid it counting as values from the command
        // line
        if source == ValueSource::CommandLine {
            ok!(self.verify_num_args(arg, &raw_vals));
        }

        if raw_vals.is_empty() {
            // We assume this case is valid: require equals, but min_vals == 0.
            if !arg.default_missing_vals.is_empty() {
                debug!("Parser::react: has default_missing_vals");
                trailing_idx = None;
                raw_vals.extend(
                    arg.default_missing_vals
                        .iter()
                        .map(|s| s.as_os_str().to_owned()),
                );
            }
        }

        if let Some(val_delim) = arg.get_value_delimiter() {
            if self.cmd.is_dont_delimit_trailing_values_set() && trailing_idx == Some(0) {
                // Nothing to do
            } else {
                let mut val_delim_buffer = [0; 4];
                let val_delim = val_delim.encode_utf8(&mut val_delim_buffer);
                let mut split_raw_vals = Vec::with_capacity(raw_vals.len());
                for (i, raw_val) in raw_vals.into_iter().enumerate() {
                    if !raw_val.contains(val_delim)
                        || (self.cmd.is_dont_delimit_trailing_values_set()
                            && trailing_idx == Some(i))
                    {
                        split_raw_vals.push(raw_val);
                    } else {
                        split_raw_vals.extend(raw_val.split(val_delim).map(|x| x.to_owned()));
                    }
                }
                raw_vals = split_raw_vals;
            }
        }

        match arg.get_action() {
            ArgAction::Set => {
                if source == ValueSource::CommandLine
                    && matches!(ident, Some(Identifier::Short) | Some(Identifier::Long))
                {
                    // Record flag's index
                    self.cur_idx.set(self.cur_idx.get() + 1);
                    debug!("Parser::react: cur_idx:={}", self.cur_idx.get());
                }
                if matcher.remove(arg.get_id())
                    && !(self.cmd.is_args_override_self() || arg.overrides.contains(arg.get_id()))
                {
                    return Err(ClapError::argument_conflict(
                        self.cmd,
                        arg.to_string(),
                        vec![arg.to_string()],
                        Usage::new(self.cmd).create_usage_with_title(&[]),
                    ));
                }
                self.start_custom_arg(matcher, arg, source);
                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                if cfg!(debug_assertions) && matcher.needs_more_vals(arg) {
                    debug!(
                        "Parser::react not enough values passed in, leaving it to the validator to complain",
                    );
                }
                Ok(ParseResult::ValuesDone)
            }
            ArgAction::Append => {
                if source == ValueSource::CommandLine
                    && matches!(ident, Some(Identifier::Short) | Some(Identifier::Long))
                {
                    // Record flag's index
                    self.cur_idx.set(self.cur_idx.get() + 1);
                    debug!("Parser::react: cur_idx:={}", self.cur_idx.get());
                }
                self.start_custom_arg(matcher, arg, source);
                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                if cfg!(debug_assertions) && matcher.needs_more_vals(arg) {
                    debug!(
                        "Parser::react not enough values passed in, leaving it to the validator to complain",
                    );
                }
                Ok(ParseResult::ValuesDone)
            }
            ArgAction::SetTrue => {
                let raw_vals = if raw_vals.is_empty() {
                    vec![OsString::from("true")]
                } else {
                    raw_vals
                };

                if matcher.remove(arg.get_id())
                    && !(self.cmd.is_args_override_self() || arg.overrides.contains(arg.get_id()))
                {
                    return Err(ClapError::argument_conflict(
                        self.cmd,
                        arg.to_string(),
                        vec![arg.to_string()],
                        Usage::new(self.cmd).create_usage_with_title(&[]),
                    ));
                }
                self.start_custom_arg(matcher, arg, source);
                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                Ok(ParseResult::ValuesDone)
            }
            ArgAction::SetFalse => {
                let raw_vals = if raw_vals.is_empty() {
                    vec![OsString::from("false")]
                } else {
                    raw_vals
                };

                if matcher.remove(arg.get_id())
                    && !(self.cmd.is_args_override_self() || arg.overrides.contains(arg.get_id()))
                {
                    return Err(ClapError::argument_conflict(
                        self.cmd,
                        arg.to_string(),
                        vec![arg.to_string()],
                        Usage::new(self.cmd).create_usage_with_title(&[]),
                    ));
                }
                self.start_custom_arg(matcher, arg, source);
                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                Ok(ParseResult::ValuesDone)
            }
            ArgAction::Count => {
                let raw_vals = if raw_vals.is_empty() {
                    let existing_value = *matcher
                        .get_one::<crate::builder::CountType>(arg.get_id().as_str())
                        .unwrap_or(&0);
                    let next_value = existing_value.saturating_add(1);
                    vec![OsString::from(next_value.to_string())]
                } else {
                    raw_vals
                };

                matcher.remove(arg.get_id());
                self.start_custom_arg(matcher, arg, source);
                ok!(self.push_arg_values(arg, raw_vals, source, matcher));
                Ok(ParseResult::ValuesDone)
            }
            ArgAction::Help => {
                let use_long = match ident {
                    Some(Identifier::Long) => true,
                    Some(Identifier::Short) => false,
                    Some(Identifier::Index) => true,
                    None => true,
                };
                debug!("Help: use_long={use_long}");
                Err(self.help_err(use_long))
            }
            ArgAction::HelpShort => {
                let use_long = false;
                debug!("Help: use_long={use_long}");
                Err(self.help_err(use_long))
            }
            ArgAction::HelpLong => {
                let use_long = true;
                debug!("Help: use_long={use_long}");
                Err(self.help_err(use_long))
            }
            ArgAction::Version => {
                let use_long = match ident {
                    Some(Identifier::Long) => true,
                    Some(Identifier::Short) => false,
                    Some(Identifier::Index) => true,
                    None => true,
                };
                debug!("Version: use_long={use_long}");
                Err(self.version_err(use_long))
            }
        }
    }

    fn verify_num_args(&self, arg: &Arg, raw_vals: &[OsString]) -> ClapResult<()> {
        if self.cmd.is_ignore_errors_set() {
            return Ok(());
        }

        let actual = raw_vals.len();
        let expected = arg.get_num_args().expect(INTERNAL_ERROR_MSG);

        if 0 < expected.min_values() && actual == 0 {
            // Issue 665 (https://github.com/clap-rs/clap/issues/665)
            // Issue 1105 (https://github.com/clap-rs/clap/issues/1105)
            return Err(ClapError::empty_value(
                self.cmd,
                &super::get_possible_values_cli(arg)
                    .iter()
                    .filter(|pv| !pv.is_hide_set())
                    .map(|n| n.get_name().to_owned())
                    .collect::<Vec<_>>(),
                arg.to_string(),
            ));
        } else if let Some(expected) = expected.num_values() {
            if expected != actual {
                debug!("Validator::validate_arg_num_vals: Sending error WrongNumberOfValues");
                return Err(ClapError::wrong_number_of_values(
                    self.cmd,
                    arg.to_string(),
                    expected,
                    actual,
                    Usage::new(self.cmd).create_usage_with_title(&[]),
                ));
            }
        } else if actual < expected.min_values() {
            return Err(ClapError::too_few_values(
                self.cmd,
                arg.to_string(),
                expected.min_values(),
                actual,
                Usage::new(self.cmd).create_usage_with_title(&[]),
            ));
        } else if expected.max_values() < actual {
            debug!("Validator::validate_arg_num_vals: Sending error TooManyValues");
            return Err(ClapError::too_many_values(
                self.cmd,
                raw_vals
                    .last()
                    .expect(INTERNAL_ERROR_MSG)
                    .to_string_lossy()
                    .into_owned(),
                arg.to_string(),
                Usage::new(self.cmd).create_usage_with_title(&[]),
            ));
        }

        Ok(())
    }

    fn remove_overrides(&self, arg: &Arg, matcher: &mut ArgMatcher) {
        debug!("Parser::remove_overrides: id={:?}", arg.id);
        for override_id in &arg.overrides {
            debug!("Parser::remove_overrides:iter:{override_id:?}: removing");
            matcher.remove(override_id);
        }

        // Override anything that can override us
        let mut transitive = Vec::new();
        for arg_id in matcher.arg_ids() {
            if let Some(overrider) = self.cmd.find(arg_id) {
                if overrider.overrides.contains(arg.get_id()) {
                    transitive.push(overrider.get_id());
                }
            }
        }
        for overrider_id in transitive {
            debug!("Parser::remove_overrides:iter:{overrider_id:?}: removing");
            matcher.remove(overrider_id);
        }
    }

    #[cfg(feature = "env")]
    fn add_env(&mut self, matcher: &mut ArgMatcher) -> ClapResult<()> {
        debug!("Parser::add_env");

        for arg in self.cmd.get_arguments() {
            // Use env only if the arg was absent among command line args,
            // early return if this is not the case.
            if matcher.contains(&arg.id) {
                debug!("Parser::add_env: Skipping existing arg `{arg}`");
                continue;
            }

            debug!("Parser::add_env: Checking arg `{arg}`");
            if let Some((_, Some(ref val))) = arg.env {
                debug!("Parser::add_env: Found an opt with value={val:?}");
                let arg_values = vec![val.to_owned()];
                let trailing_idx = None;
                let _ = ok!(self.react(
                    None,
                    ValueSource::EnvVariable,
                    arg,
                    arg_values,
                    trailing_idx,
                    matcher,
                ));
            }
        }

        Ok(())
    }

    fn add_defaults(&self, matcher: &mut ArgMatcher) -> ClapResult<()> {
        debug!("Parser::add_defaults");

        for arg in self.cmd.get_arguments() {
            debug!("Parser::add_defaults:iter:{}:", arg.get_id());
            ok!(self.add_default_value(arg, matcher));
        }

        Ok(())
    }

    fn add_default_value(&self, arg: &Arg, matcher: &mut ArgMatcher) -> ClapResult<()> {
        if !arg.default_vals_ifs.is_empty() {
            debug!("Parser::add_default_value: has conditional defaults");
            if !matcher.contains(arg.get_id()) {
                for (id, val, default) in arg.default_vals_ifs.iter() {
                    let add = if let Some(a) = matcher.get(id) {
                        match val {
                            crate::builder::ArgPredicate::Equals(v) => {
                                a.raw_vals_flatten().any(|value| v == value)
                            }
                            crate::builder::ArgPredicate::IsPresent => true,
                        }
                    } else {
                        false
                    };

                    if add {
                        if let Some(default) = default {
                            let arg_values = vec![default.to_os_string()];
                            let trailing_idx = None;
                            let _ = ok!(self.react(
                                None,
                                ValueSource::DefaultValue,
                                arg,
                                arg_values,
                                trailing_idx,
                                matcher,
                            ));
                        }
                        return Ok(());
                    }
                }
            }
        } else {
            debug!("Parser::add_default_value: doesn't have conditional defaults");
        }

        if !arg.default_vals.is_empty() {
            debug!(
                "Parser::add_default_value:iter:{}: has default vals",
                arg.get_id()
            );
            if matcher.contains(arg.get_id()) {
                debug!("Parser::add_default_value:iter:{}: was used", arg.get_id());
            // do nothing
            } else {
                debug!(
                    "Parser::add_default_value:iter:{}: wasn't used",
                    arg.get_id()
                );
                let arg_values: Vec<_> = arg
                    .default_vals
                    .iter()
                    .map(crate::builder::OsStr::to_os_string)
                    .collect();
                let trailing_idx = None;
                let _ = ok!(self.react(
                    None,
                    ValueSource::DefaultValue,
                    arg,
                    arg_values,
                    trailing_idx,
                    matcher,
                ));
            }
        } else {
            debug!(
                "Parser::add_default_value:iter:{}: doesn't have default vals",
                arg.get_id()
            );

            // do nothing
        }

        Ok(())
    }

    fn start_custom_arg(&self, matcher: &mut ArgMatcher, arg: &Arg, source: ValueSource) {
        if source == ValueSource::CommandLine {
            // With each new occurrence, remove overrides from prior occurrences
            self.remove_overrides(arg, matcher);
        }
        matcher.start_custom_arg(arg, source);
        if source.is_explicit() {
            for group in self.cmd.groups_for_arg(arg.get_id()) {
                matcher.start_custom_group(group.clone(), source);
                matcher.add_val_to(
                    &group,
                    AnyValue::new(arg.get_id().clone()),
                    OsString::from(arg.get_id().as_str()),
                );
            }
        }
    }
}

// Error, Help, and Version Methods
impl Parser<'_> {
    /// Is only used for the long flag(which is the only one needs fuzzy searching)
    fn did_you_mean_error(
        &mut self,
        arg: &str,
        matcher: &mut ArgMatcher,
        remaining_args: &[&OsStr],
        trailing_values: bool,
    ) -> ClapError {
        debug!("Parser::did_you_mean_error: arg={arg}");
        // Didn't match a flag or option
        let longs = self
            .cmd
            .get_keymap()
            .keys()
            .filter_map(|x| match x {
                KeyType::Long(l) => Some(l.to_string_lossy().into_owned()),
                _ => None,
            })
            .collect::<Vec<_>>();
        debug!("Parser::did_you_mean_error: longs={longs:?}");

        let did_you_mean = suggestions::did_you_mean_flag(
            arg,
            remaining_args,
            longs.iter().map(|x| &x[..]),
            self.cmd.get_subcommands_mut(),
        );

        // Add the arg to the matches to build a proper usage string
        if !self.cmd.is_ignore_errors_set() {
            if let Some((name, _)) = did_you_mean.as_ref() {
                if let Some(arg) = self.cmd.get_keymap().get(&name.as_ref()) {
                    self.start_custom_arg(matcher, arg, ValueSource::CommandLine);
                }
            }
        }
        let did_you_mean = did_you_mean.map(|(arg, cmd)| (format!("--{arg}"), cmd));

        let required = self.cmd.required_graph();
        let used: Vec<Id> = matcher
            .arg_ids()
            .filter(|arg_id| {
                matcher.check_explicit(arg_id, &crate::builder::ArgPredicate::IsPresent)
            })
            .filter(|n| self.cmd.find(n).map(|a| !a.is_hide_set()).unwrap_or(false))
            .cloned()
            .collect();

        // `did_you_mean` is a lot more likely and should cause us to skip the `--` suggestion
        // with the one exception being that the CLI is trying to capture arguments
        //
        // In theory, this is only called for `--long`s, so we don't need to check
        let suggested_trailing_arg = (did_you_mean.is_none()
            || self
                .cmd
                .get_positionals()
                .any(|arg| arg.is_last_set() || arg.is_trailing_var_arg_set()))
            && !trailing_values
            && self.cmd.has_positionals();
        ClapError::unknown_argument(
            self.cmd,
            format!("--{arg}"),
            did_you_mean,
            suggested_trailing_arg,
            Usage::new(self.cmd)
                .required(&required)
                .create_usage_with_title(&used),
        )
    }

    fn help_err(&self, use_long: bool) -> ClapError {
        let styled = self.cmd.write_help_err(use_long);
        ClapError::display_help(self.cmd, styled)
    }

    fn version_err(&self, use_long: bool) -> ClapError {
        let styled = self.cmd.write_version_err(use_long);
        ClapError::display_version(self.cmd, styled)
    }
}

#[derive(Debug, PartialEq, Eq)]
pub(crate) enum ParseState {
    ValuesDone,
    Opt(Id),
    Pos(Id),
}

/// Recoverable Parsing results.
#[derive(Debug, PartialEq, Clone)]
#[must_use]
enum ParseResult {
    FlagSubCommand(String),
    Opt(Id),
    ValuesDone,
    /// Value attached to the short flag is not consumed(e.g. 'u' for `-cu` is
    /// not consumed).
    AttachedValueNotConsumed,
    /// This long flag doesn't need a value but is provided one.
    UnneededAttachedValue {
        rest: String,
        used: Vec<Id>,
        arg: String,
    },
    /// This flag might be an hyphen Value.
    MaybeHyphenValue,
    /// Equals required but not provided.
    EqualsNotProvided {
        arg: String,
    },
    /// Failed to match a Arg.
    NoMatchingArg {
        arg: String,
    },
    /// No argument found e.g. parser is given `-` when parsing a flag.
    NoArg,
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub(crate) struct PendingArg {
    pub(crate) id: Id,
    pub(crate) ident: Option<Identifier>,
    pub(crate) raw_vals: Vec<OsString>,
    pub(crate) trailing_idx: Option<usize>,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub(crate) enum Identifier {
    Short,
    Long,
    Index,
}

```

`clap/clap_builder/src/parser/validator.rs`:

```rs
// Internal
use crate::builder::StyledStr;
use crate::builder::{Arg, ArgGroup, ArgPredicate, Command, PossibleValue};
use crate::error::{Error, Result as ClapResult};
use crate::output::Usage;
use crate::parser::ArgMatcher;
use crate::util::ChildGraph;
use crate::util::FlatMap;
use crate::util::FlatSet;
use crate::util::Id;
use crate::INTERNAL_ERROR_MSG;

pub(crate) struct Validator<'cmd> {
    cmd: &'cmd Command,
    required: ChildGraph<Id>,
}

impl<'cmd> Validator<'cmd> {
    pub(crate) fn new(cmd: &'cmd Command) -> Self {
        let required = cmd.required_graph();
        Validator { cmd, required }
    }

    pub(crate) fn validate(&mut self, matcher: &mut ArgMatcher) -> ClapResult<()> {
        debug!("Validator::validate");
        let conflicts = Conflicts::with_args(self.cmd, matcher);
        let has_subcmd = matcher.subcommand_name().is_some();

        if !has_subcmd && self.cmd.is_arg_required_else_help_set() {
            let num_user_values = matcher
                .args()
                .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                .count();
            if num_user_values == 0 {
                let message = self.cmd.write_help_err(false);
                return Err(Error::display_help_error(self.cmd, message));
            }
        }
        if !has_subcmd && self.cmd.is_subcommand_required_set() {
            let bn = self.cmd.get_bin_name_fallback();
            return Err(Error::missing_subcommand(
                self.cmd,
                bn.to_string(),
                self.cmd
                    .all_subcommand_names()
                    .map(|s| s.to_owned())
                    .collect::<Vec<_>>(),
                Usage::new(self.cmd)
                    .required(&self.required)
                    .create_usage_with_title(&[]),
            ));
        }

        ok!(self.validate_conflicts(matcher, &conflicts));
        if !(self.cmd.is_subcommand_negates_reqs_set() && has_subcmd) {
            ok!(self.validate_required(matcher, &conflicts));
        }

        Ok(())
    }

    fn validate_conflicts(
        &mut self,
        matcher: &ArgMatcher,
        conflicts: &Conflicts,
    ) -> ClapResult<()> {
        debug!("Validator::validate_conflicts");

        ok!(self.validate_exclusive(matcher));

        for (arg_id, _) in matcher
            .args()
            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
            .filter(|(arg_id, _)| self.cmd.find(arg_id).is_some())
        {
            debug!("Validator::validate_conflicts::iter: id={arg_id:?}");
            let conflicts = conflicts.gather_conflicts(self.cmd, arg_id);
            ok!(self.build_conflict_err(arg_id, &conflicts, matcher));
        }

        Ok(())
    }

    fn validate_exclusive(&self, matcher: &ArgMatcher) -> ClapResult<()> {
        debug!("Validator::validate_exclusive");
        let args_count = matcher
            .args()
            .filter(|(arg_id, matched)| {
                matched.check_explicit(&ArgPredicate::IsPresent)
                    // Avoid including our own groups by checking none of them.  If a group is present, the
                    // args for the group will be.
                    && self.cmd.find(arg_id).is_some()
            })
            .count();
        if args_count <= 1 {
            // Nothing present to conflict with
            return Ok(());
        }

        matcher
            .args()
            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
            .find_map(|(id, _)| {
                debug!("Validator::validate_exclusive:iter:{id:?}");
                self.cmd
                    .find(id)
                    // Find `arg`s which are exclusive but also appear with other args.
                    .filter(|&arg| arg.is_exclusive_set() && args_count > 1)
            })
            .map(|arg| {
                // Throw an error for the first conflict found.
                Err(Error::argument_conflict(
                    self.cmd,
                    arg.to_string(),
                    Vec::new(),
                    Usage::new(self.cmd)
                        .required(&self.required)
                        .create_usage_with_title(&[]),
                ))
            })
            .unwrap_or(Ok(()))
    }

    fn build_conflict_err(
        &self,
        name: &Id,
        conflict_ids: &[Id],
        matcher: &ArgMatcher,
    ) -> ClapResult<()> {
        if conflict_ids.is_empty() {
            return Ok(());
        }

        debug!("Validator::build_conflict_err: name={name:?}");
        let mut seen = FlatSet::new();
        let conflicts = conflict_ids
            .iter()
            .flat_map(|c_id| {
                if self.cmd.find_group(c_id).is_some() {
                    self.cmd.unroll_args_in_group(c_id)
                } else {
                    vec![c_id.clone()]
                }
            })
            .filter_map(|c_id| {
                seen.insert(c_id.clone()).then(|| {
                    let c_arg = self.cmd.find(&c_id).expect(INTERNAL_ERROR_MSG);
                    c_arg.to_string()
                })
            })
            .collect();

        let former_arg = self.cmd.find(name).expect(INTERNAL_ERROR_MSG);
        let usg = self.build_conflict_err_usage(matcher, conflict_ids);
        Err(Error::argument_conflict(
            self.cmd,
            former_arg.to_string(),
            conflicts,
            usg,
        ))
    }

    fn build_conflict_err_usage(
        &self,
        matcher: &ArgMatcher,
        conflicting_keys: &[Id],
    ) -> Option<StyledStr> {
        let used_filtered: Vec<Id> = matcher
            .args()
            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
            .map(|(n, _)| n)
            .filter(|n| {
                // Filter out the args we don't want to specify.
                self.cmd
                    .find(n)
                    .map(|a| !a.is_hide_set())
                    .unwrap_or_default()
            })
            .filter(|key| !conflicting_keys.contains(key))
            .cloned()
            .collect();
        let required: Vec<Id> = used_filtered
            .iter()
            .filter_map(|key| self.cmd.find(key))
            .flat_map(|arg| arg.requires.iter().map(|item| &item.1))
            .filter(|key| !used_filtered.contains(key) && !conflicting_keys.contains(key))
            .chain(used_filtered.iter())
            .cloned()
            .collect();
        Usage::new(self.cmd)
            .required(&self.required)
            .create_usage_with_title(&required)
    }

    fn gather_requires(&mut self, matcher: &ArgMatcher) {
        debug!("Validator::gather_requires");
        for (name, matched) in matcher
            .args()
            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
        {
            debug!("Validator::gather_requires:iter:{name:?}");
            if let Some(arg) = self.cmd.find(name) {
                let is_relevant = |(val, req_arg): &(ArgPredicate, Id)| -> Option<Id> {
                    let required = matched.check_explicit(val);
                    required.then(|| req_arg.clone())
                };

                for req in self.cmd.unroll_arg_requires(is_relevant, arg.get_id()) {
                    self.required.insert(req);
                }
            } else if let Some(g) = self.cmd.find_group(name) {
                debug!("Validator::gather_requires:iter:{name:?}:group");
                for r in &g.requires {
                    self.required.insert(r.clone());
                }
            }
        }
    }

    fn validate_required(&mut self, matcher: &ArgMatcher, conflicts: &Conflicts) -> ClapResult<()> {
        debug!("Validator::validate_required: required={:?}", self.required);
        self.gather_requires(matcher);

        let mut missing_required = Vec::new();
        let mut highest_index = 0;

        let is_exclusive_present = matcher
            .args()
            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
            .any(|(id, _)| {
                self.cmd
                    .find(id)
                    .map(|arg| arg.is_exclusive_set())
                    .unwrap_or_default()
            });
        debug!("Validator::validate_required: is_exclusive_present={is_exclusive_present}");

        for arg_or_group in self
            .required
            .iter()
            .filter(|r| !matcher.check_explicit(r, &ArgPredicate::IsPresent))
        {
            debug!("Validator::validate_required:iter:aog={arg_or_group:?}");
            if let Some(arg) = self.cmd.find(arg_or_group) {
                debug!("Validator::validate_required:iter: This is an arg");
                if !is_exclusive_present && !self.is_missing_required_ok(arg, conflicts) {
                    debug!(
                        "Validator::validate_required:iter: Missing {:?}",
                        arg.get_id()
                    );
                    missing_required.push(arg.get_id().clone());
                    if !arg.is_last_set() {
                        highest_index = highest_index.max(arg.get_index().unwrap_or(0));
                    }
                }
            } else if let Some(group) = self.cmd.find_group(arg_or_group) {
                debug!("Validator::validate_required:iter: This is a group");
                if !self
                    .cmd
                    .unroll_args_in_group(&group.id)
                    .iter()
                    .any(|a| matcher.check_explicit(a, &ArgPredicate::IsPresent))
                {
                    debug!(
                        "Validator::validate_required:iter: Missing {:?}",
                        group.get_id()
                    );
                    missing_required.push(group.get_id().clone());
                }
            }
        }

        // Validate the conditionally required args
        for a in self
            .cmd
            .get_arguments()
            .filter(|a| !matcher.check_explicit(a.get_id(), &ArgPredicate::IsPresent))
        {
            let mut required = false;

            for (other, val) in &a.r_ifs {
                if matcher.check_explicit(other, &ArgPredicate::Equals(val.into())) {
                    debug!(
                        "Validator::validate_required:iter: Missing {:?}",
                        a.get_id()
                    );
                    required = true;
                }
            }

            let match_all = a.r_ifs_all.iter().all(|(other, val)| {
                matcher.check_explicit(other, &ArgPredicate::Equals(val.into()))
            });
            if match_all && !a.r_ifs_all.is_empty() {
                debug!(
                    "Validator::validate_required:iter: Missing {:?}",
                    a.get_id()
                );
                required = true;
            }

            if (!a.r_unless.is_empty() || !a.r_unless_all.is_empty())
                && self.fails_arg_required_unless(a, matcher)
            {
                debug!(
                    "Validator::validate_required:iter: Missing {:?}",
                    a.get_id()
                );
                required = true;
            }

            if !is_exclusive_present && required {
                missing_required.push(a.get_id().clone());
                if !a.is_last_set() {
                    highest_index = highest_index.max(a.get_index().unwrap_or(0));
                }
            }
        }

        // For display purposes, include all of the preceding positional arguments
        if !self.cmd.is_allow_missing_positional_set() {
            for pos in self
                .cmd
                .get_positionals()
                .filter(|a| !matcher.check_explicit(a.get_id(), &ArgPredicate::IsPresent))
            {
                if pos.get_index() < Some(highest_index) {
                    debug!(
                        "Validator::validate_required:iter: Missing {:?}",
                        pos.get_id()
                    );
                    missing_required.push(pos.get_id().clone());
                }
            }
        }

        if !missing_required.is_empty() {
            ok!(self.missing_required_error(matcher, missing_required));
        }

        Ok(())
    }

    fn is_missing_required_ok(&self, a: &Arg, conflicts: &Conflicts) -> bool {
        debug!("Validator::is_missing_required_ok: {}", a.get_id());
        if !conflicts.gather_conflicts(self.cmd, a.get_id()).is_empty() {
            debug!("Validator::is_missing_required_ok: true (self)");
            return true;
        }
        for group_id in self.cmd.groups_for_arg(a.get_id()) {
            if !conflicts.gather_conflicts(self.cmd, &group_id).is_empty() {
                debug!("Validator::is_missing_required_ok: true ({group_id})");
                return true;
            }
        }
        false
    }

    // Failing a required unless means, the arg's "unless" wasn't present, and neither were they
    fn fails_arg_required_unless(&self, a: &Arg, matcher: &ArgMatcher) -> bool {
        debug!("Validator::fails_arg_required_unless: a={:?}", a.get_id());
        let exists = |id| matcher.check_explicit(id, &ArgPredicate::IsPresent);

        (a.r_unless_all.is_empty() || !a.r_unless_all.iter().all(exists))
            && !a.r_unless.iter().any(exists)
    }

    // `req_args`: an arg to include in the error even if not used
    fn missing_required_error(
        &self,
        matcher: &ArgMatcher,
        raw_req_args: Vec<Id>,
    ) -> ClapResult<()> {
        debug!("Validator::missing_required_error; incl={raw_req_args:?}");
        debug!(
            "Validator::missing_required_error: reqs={:?}",
            self.required
        );

        let usg = Usage::new(self.cmd).required(&self.required);

        let req_args = {
            #[cfg(feature = "usage")]
            {
                usg.get_required_usage_from(&raw_req_args, Some(matcher), true)
                    .into_iter()
                    .map(|s| s.to_string())
                    .collect::<Vec<_>>()
            }

            #[cfg(not(feature = "usage"))]
            {
                raw_req_args
                    .iter()
                    .map(|id| {
                        if let Some(arg) = self.cmd.find(id) {
                            arg.to_string()
                        } else if let Some(_group) = self.cmd.find_group(id) {
                            self.cmd.format_group(id).to_string()
                        } else {
                            debug_assert!(false, "id={id:?} is unknown");
                            "".to_owned()
                        }
                    })
                    .collect::<FlatSet<_>>()
                    .into_iter()
                    .collect::<Vec<_>>()
            }
        };

        debug!("Validator::missing_required_error: req_args={req_args:#?}");

        let used: Vec<Id> = matcher
            .args()
            .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
            .map(|(n, _)| n)
            .filter(|n| {
                // Filter out the args we don't want to specify.
                self.cmd
                    .find(n)
                    .map(|a| !a.is_hide_set())
                    .unwrap_or_default()
            })
            .cloned()
            .chain(raw_req_args)
            .collect();

        Err(Error::missing_required_argument(
            self.cmd,
            req_args,
            usg.create_usage_with_title(&used),
        ))
    }
}

#[derive(Default, Clone, Debug)]
struct Conflicts {
    potential: FlatMap<Id, Vec<Id>>,
}

impl Conflicts {
    fn with_args(cmd: &Command, matcher: &ArgMatcher) -> Self {
        let mut potential = FlatMap::new();
        potential.extend_unchecked(
            matcher
                .args()
                .filter(|(_, matched)| matched.check_explicit(&ArgPredicate::IsPresent))
                .map(|(id, _)| {
                    let conf = gather_direct_conflicts(cmd, id);
                    (id.clone(), conf)
                }),
        );
        Self { potential }
    }

    fn gather_conflicts(&self, cmd: &Command, arg_id: &Id) -> Vec<Id> {
        debug!("Conflicts::gather_conflicts: arg={arg_id:?}");
        let mut conflicts = Vec::new();

        let arg_id_conflicts_storage;
        let arg_id_conflicts = if let Some(arg_id_conflicts) = self.get_direct_conflicts(arg_id) {
            arg_id_conflicts
        } else {
            // `is_missing_required_ok` is a case where we check not-present args for conflicts
            arg_id_conflicts_storage = gather_direct_conflicts(cmd, arg_id);
            &arg_id_conflicts_storage
        };
        for (other_arg_id, other_arg_id_conflicts) in self.potential.iter() {
            if arg_id == other_arg_id {
                continue;
            }

            if arg_id_conflicts.contains(other_arg_id) {
                conflicts.push(other_arg_id.clone());
            }
            if other_arg_id_conflicts.contains(arg_id) {
                conflicts.push(other_arg_id.clone());
            }
        }

        debug!("Conflicts::gather_conflicts: conflicts={conflicts:?}");
        conflicts
    }

    fn get_direct_conflicts(&self, arg_id: &Id) -> Option<&[Id]> {
        self.potential.get(arg_id).map(Vec::as_slice)
    }
}

fn gather_direct_conflicts(cmd: &Command, id: &Id) -> Vec<Id> {
    let conf = if let Some(arg) = cmd.find(id) {
        gather_arg_direct_conflicts(cmd, arg)
    } else if let Some(group) = cmd.find_group(id) {
        gather_group_direct_conflicts(group)
    } else {
        debug_assert!(false, "id={id:?} is unknown");
        Vec::new()
    };
    debug!("Conflicts::gather_direct_conflicts id={id:?}, conflicts={conf:?}",);
    conf
}

fn gather_arg_direct_conflicts(cmd: &Command, arg: &Arg) -> Vec<Id> {
    let mut conf = arg.blacklist.clone();
    for group_id in cmd.groups_for_arg(arg.get_id()) {
        let group = cmd.find_group(&group_id).expect(INTERNAL_ERROR_MSG);
        conf.extend(group.conflicts.iter().cloned());
        if !group.multiple {
            for member_id in &group.args {
                if member_id != arg.get_id() {
                    conf.push(member_id.clone());
                }
            }
        }
    }

    // Overrides are implicitly conflicts
    conf.extend(arg.overrides.iter().cloned());

    conf
}

fn gather_group_direct_conflicts(group: &ArgGroup) -> Vec<Id> {
    group.conflicts.clone()
}

pub(crate) fn get_possible_values_cli(a: &Arg) -> Vec<PossibleValue> {
    if !a.is_takes_value_set() {
        vec![]
    } else {
        a.get_value_parser()
            .possible_values()
            .map(|pvs| pvs.collect())
            .unwrap_or_default()
    }
}

```

`clap/clap_builder/src/util/any_value.rs`:

```rs
#[derive(Clone)]
pub(crate) struct AnyValue {
    inner: std::sync::Arc<dyn std::any::Any + Send + Sync + 'static>,
    // While we can extract `TypeId` from `inner`, the debug repr is of a number, so let's track
    // the type_name in debug builds.
    id: AnyValueId,
}

impl AnyValue {
    pub(crate) fn new<V: std::any::Any + Clone + Send + Sync + 'static>(inner: V) -> Self {
        let id = AnyValueId::of::<V>();
        let inner = std::sync::Arc::new(inner);
        Self { inner, id }
    }

    pub(crate) fn downcast_ref<T: std::any::Any + Clone + Send + Sync + 'static>(
        &self,
    ) -> Option<&T> {
        self.inner.downcast_ref::<T>()
    }

    pub(crate) fn downcast_into<T: std::any::Any + Clone + Send + Sync>(self) -> Result<T, Self> {
        let id = self.id;
        let value =
            ok!(std::sync::Arc::downcast::<T>(self.inner).map_err(|inner| Self { inner, id }));
        let value = std::sync::Arc::try_unwrap(value).unwrap_or_else(|arc| (*arc).clone());
        Ok(value)
    }

    pub(crate) fn type_id(&self) -> AnyValueId {
        self.id
    }
}

impl std::fmt::Debug for AnyValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        f.debug_struct("AnyValue").field("inner", &self.id).finish()
    }
}

#[derive(Copy, Clone)]
pub struct AnyValueId {
    type_id: std::any::TypeId,
    #[cfg(debug_assertions)]
    type_name: &'static str,
}

impl AnyValueId {
    pub(crate) fn of<A: ?Sized + 'static>() -> Self {
        Self {
            type_id: std::any::TypeId::of::<A>(),
            #[cfg(debug_assertions)]
            type_name: std::any::type_name::<A>(),
        }
    }
}

impl PartialEq for AnyValueId {
    fn eq(&self, other: &Self) -> bool {
        self.type_id == other.type_id
    }
}

impl Eq for AnyValueId {}

impl PartialOrd for AnyValueId {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq<std::any::TypeId> for AnyValueId {
    fn eq(&self, other: &std::any::TypeId) -> bool {
        self.type_id == *other
    }
}

impl Ord for AnyValueId {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.type_id.cmp(&other.type_id)
    }
}

impl std::hash::Hash for AnyValueId {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.type_id.hash(state);
    }
}

impl std::fmt::Debug for AnyValueId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        #[cfg(not(debug_assertions))]
        {
            self.type_id.fmt(f)
        }
        #[cfg(debug_assertions)]
        {
            f.debug_struct(self.type_name).finish()
        }
    }
}

impl<'a, A: ?Sized + 'static> From<&'a A> for AnyValueId {
    fn from(_: &'a A) -> Self {
        Self::of::<A>()
    }
}

#[cfg(test)]
mod test {
    #[test]
    #[cfg(debug_assertions)]
    fn debug_impl() {
        use super::*;

        assert_eq!(format!("{:?}", AnyValue::new(5)), "AnyValue { inner: i32 }");
    }

    #[test]
    fn eq_to_type_id() {
        use super::*;

        let any_value_id = AnyValueId::of::<i32>();
        let type_id = std::any::TypeId::of::<i32>();
        assert_eq!(any_value_id, type_id);
    }
}

```

`clap/clap_builder/src/util/color.rs`:

```rs
use crate::builder::PossibleValue;
use crate::derive::ValueEnum;

/// Represents the color preferences for program output
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ColorChoice {
    /// Enables colored output only when the output is going to a terminal or TTY.
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** This is the default behavior of `clap`.
    ///
    /// </div>
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "color")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, ColorChoice};
    /// Command::new("myprog")
    ///     .color(ColorChoice::Auto)
    ///     .get_matches();
    /// # }
    /// ```
    Auto,

    /// Enables colored output regardless of whether or not the output is going to a terminal/TTY.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "color")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, ColorChoice};
    /// Command::new("myprog")
    ///     .color(ColorChoice::Always)
    ///     .get_matches();
    /// # }
    /// ```
    Always,

    /// Disables colored output no matter if the output is going to a terminal/TTY, or not.
    ///
    /// # Examples
    ///
    /// ```rust
    /// # #[cfg(feature = "color")] {
    /// # use clap_builder as clap;
    /// # use clap::{Command, ColorChoice};
    /// Command::new("myprog")
    ///     .color(ColorChoice::Never)
    ///     .get_matches();
    /// # }
    /// ```
    Never,
}

impl ColorChoice {
    /// Report all `possible_values`
    pub fn possible_values() -> impl Iterator<Item = PossibleValue> {
        Self::value_variants()
            .iter()
            .filter_map(ValueEnum::to_possible_value)
    }
}

impl Default for ColorChoice {
    fn default() -> Self {
        Self::Auto
    }
}

impl std::fmt::Display for ColorChoice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.to_possible_value()
            .expect("no values are skipped")
            .get_name()
            .fmt(f)
    }
}

impl std::str::FromStr for ColorChoice {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        for variant in Self::value_variants() {
            if variant.to_possible_value().unwrap().matches(s, false) {
                return Ok(*variant);
            }
        }
        Err(format!("invalid variant: {s}"))
    }
}

impl ValueEnum for ColorChoice {
    fn value_variants<'a>() -> &'a [Self] {
        &[Self::Auto, Self::Always, Self::Never]
    }

    fn to_possible_value(&self) -> Option<PossibleValue> {
        Some(match self {
            Self::Auto => PossibleValue::new("auto"),
            Self::Always => PossibleValue::new("always"),
            Self::Never => PossibleValue::new("never"),
        })
    }
}

```

`clap/clap_builder/src/util/flat_map.rs`:

```rs
#![allow(dead_code)]

use std::borrow::Borrow;

/// Flat (Vec) backed map
///
/// This preserves insertion order
#[derive(Clone, Debug, PartialEq, Eq)]
pub(crate) struct FlatMap<K, V> {
    keys: Vec<K>,
    values: Vec<V>,
}

impl<K: PartialEq + Eq, V> FlatMap<K, V> {
    pub(crate) fn new() -> Self {
        Default::default()
    }

    pub(crate) fn insert(&mut self, key: K, mut value: V) -> Option<V> {
        for (index, existing) in self.keys.iter().enumerate() {
            if *existing == key {
                std::mem::swap(&mut self.values[index], &mut value);
                return Some(value);
            }
        }

        self.insert_unchecked(key, value);
        None
    }

    pub(crate) fn insert_unchecked(&mut self, key: K, value: V) {
        self.keys.push(key);
        self.values.push(value);
    }

    pub(crate) fn extend_unchecked(&mut self, iter: impl IntoIterator<Item = (K, V)>) {
        for (key, value) in iter {
            self.insert_unchecked(key, value);
        }
    }

    pub(crate) fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool
    where
        K: Borrow<Q>,
        Q: Eq,
    {
        for existing in &self.keys {
            if existing.borrow() == key {
                return true;
            }
        }
        false
    }

    pub(crate) fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>
    where
        K: Borrow<Q>,
        Q: std::hash::Hash + Eq,
    {
        self.remove_entry(key).map(|(_, v)| v)
    }

    pub(crate) fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>
    where
        K: Borrow<Q>,
        Q: std::hash::Hash + Eq,
    {
        let index = some!(self
            .keys
            .iter()
            .enumerate()
            .find_map(|(i, k)| (k.borrow() == key).then_some(i)));
        let key = self.keys.remove(index);
        let value = self.values.remove(index);
        Some((key, value))
    }

    pub(crate) fn is_empty(&self) -> bool {
        self.keys.is_empty()
    }

    pub(crate) fn entry(&mut self, key: K) -> Entry<'_, K, V> {
        for (index, existing) in self.keys.iter().enumerate() {
            if *existing == key {
                return Entry::Occupied(OccupiedEntry { v: self, index });
            }
        }
        Entry::Vacant(VacantEntry { v: self, key })
    }

    pub(crate) fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
    where
        K: Borrow<Q>,
        Q: Eq,
    {
        for (index, existing) in self.keys.iter().enumerate() {
            if existing.borrow() == k {
                return Some(&self.values[index]);
            }
        }
        None
    }

    pub(crate) fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>
    where
        K: Borrow<Q>,
        Q: Eq,
    {
        for (index, existing) in self.keys.iter().enumerate() {
            if existing.borrow() == k {
                return Some(&mut self.values[index]);
            }
        }
        None
    }

    pub(crate) fn keys(&self) -> std::slice::Iter<'_, K> {
        self.keys.iter()
    }

    pub(crate) fn values(&self) -> std::slice::Iter<'_, V> {
        self.values.iter()
    }

    pub(crate) fn iter(&self) -> Iter<'_, K, V> {
        Iter {
            keys: self.keys.iter(),
            values: self.values.iter(),
        }
    }

    pub(crate) fn iter_mut(&mut self) -> IterMut<'_, K, V> {
        IterMut {
            keys: self.keys.iter_mut(),
            values: self.values.iter_mut(),
        }
    }
}

impl<K: PartialEq + Eq, V> Default for FlatMap<K, V> {
    fn default() -> Self {
        Self {
            keys: Default::default(),
            values: Default::default(),
        }
    }
}

pub(crate) enum Entry<'a, K, V> {
    Vacant(VacantEntry<'a, K, V>),
    Occupied(OccupiedEntry<'a, K, V>),
}

impl<'a, K: 'a, V: 'a> Entry<'a, K, V> {
    pub(crate) fn or_insert(self, default: V) -> &'a mut V {
        match self {
            Entry::Occupied(entry) => &mut entry.v.values[entry.index],
            Entry::Vacant(entry) => {
                entry.v.keys.push(entry.key);
                entry.v.values.push(default);
                entry.v.values.last_mut().unwrap()
            }
        }
    }

    pub(crate) fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
        match self {
            Entry::Occupied(entry) => &mut entry.v.values[entry.index],
            Entry::Vacant(entry) => {
                entry.v.keys.push(entry.key);
                entry.v.values.push(default());
                entry.v.values.last_mut().unwrap()
            }
        }
    }
}

pub(crate) struct VacantEntry<'a, K, V> {
    v: &'a mut FlatMap<K, V>,
    key: K,
}

pub(crate) struct OccupiedEntry<'a, K, V> {
    v: &'a mut FlatMap<K, V>,
    index: usize,
}

pub(crate) struct Iter<'a, K, V> {
    keys: std::slice::Iter<'a, K>,
    values: std::slice::Iter<'a, V>,
}

impl<'a, K, V> Iterator for Iter<'a, K, V> {
    type Item = (&'a K, &'a V);

    fn next(&mut self) -> Option<(&'a K, &'a V)> {
        match self.keys.next() {
            Some(k) => {
                let v = self.values.next().unwrap();
                Some((k, v))
            }
            None => None,
        }
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.keys.size_hint()
    }
}

impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {
    fn next_back(&mut self) -> Option<(&'a K, &'a V)> {
        match self.keys.next_back() {
            Some(k) => {
                let v = self.values.next_back().unwrap();
                Some((k, v))
            }
            None => None,
        }
    }
}

impl<K, V> ExactSizeIterator for Iter<'_, K, V> {}

pub(crate) struct IterMut<'a, K, V> {
    keys: std::slice::IterMut<'a, K>,
    values: std::slice::IterMut<'a, V>,
}

impl<'a, K, V> Iterator for IterMut<'a, K, V> {
    type Item = (&'a K, &'a mut V);

    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {
        match self.keys.next() {
            Some(k) => {
                let v = self.values.next().unwrap();
                Some((k, v))
            }
            None => None,
        }
    }
    fn size_hint(&self) -> (usize, Option<usize>) {
        self.keys.size_hint()
    }
}

impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {
    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {
        match self.keys.next_back() {
            Some(k) => {
                let v = self.values.next_back().unwrap();
                Some((k, v))
            }
            None => None,
        }
    }
}

impl<K, V> ExactSizeIterator for IterMut<'_, K, V> {}

```

`clap/clap_builder/src/util/flat_set.rs`:

```rs
#![allow(dead_code)]

use std::borrow::Borrow;

/// Flat (Vec) backed set
///
/// This preserves insertion order
#[derive(Clone, Debug, PartialEq, Eq)]
pub(crate) struct FlatSet<T> {
    inner: Vec<T>,
}

impl<T: PartialEq + Eq> FlatSet<T> {
    pub(crate) fn new() -> Self {
        Default::default()
    }

    pub(crate) fn insert(&mut self, value: T) -> bool {
        for existing in &self.inner {
            if *existing == value {
                return false;
            }
        }
        self.inner.push(value);
        true
    }

    pub(crate) fn contains<Q: ?Sized>(&self, value: &Q) -> bool
    where
        T: Borrow<Q>,
        Q: Eq,
    {
        for existing in &self.inner {
            if existing.borrow() == value {
                return true;
            }
        }
        false
    }

    pub(crate) fn retain<F>(&mut self, f: F)
    where
        F: FnMut(&T) -> bool,
    {
        self.inner.retain(f);
    }

    pub(crate) fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }

    pub(crate) fn iter(&self) -> std::slice::Iter<'_, T> {
        self.inner.iter()
    }

    pub(crate) fn sort_by_key<K, F>(&mut self, f: F)
    where
        F: FnMut(&T) -> K,
        K: Ord,
    {
        self.inner.sort_by_key(f);
    }
}

impl<T: PartialEq + Eq> Default for FlatSet<T> {
    fn default() -> Self {
        Self {
            inner: Default::default(),
        }
    }
}

impl<T: PartialEq + Eq> IntoIterator for FlatSet<T> {
    type Item = T;
    type IntoIter = std::vec::IntoIter<T>;

    fn into_iter(self) -> Self::IntoIter {
        self.inner.into_iter()
    }
}

impl<'s, T: PartialEq + Eq> IntoIterator for &'s FlatSet<T> {
    type Item = &'s T;
    type IntoIter = std::slice::Iter<'s, T>;

    fn into_iter(self) -> Self::IntoIter {
        self.inner.iter()
    }
}

impl<T: PartialEq + Eq> Extend<T> for FlatSet<T> {
    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
        for value in iter {
            self.insert(value);
        }
    }
}

impl<T: PartialEq + Eq> FromIterator<T> for FlatSet<T> {
    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
        let mut set = Self::new();
        for value in iter {
            set.insert(value);
        }
        set
    }
}

```

`clap/clap_builder/src/util/graph.rs`:

```rs
#[derive(Debug)]
struct Child<T> {
    id: T,
    children: Vec<usize>,
}

impl<T> Child<T> {
    fn new(id: T) -> Self {
        Child {
            id,
            children: vec![],
        }
    }
}

#[derive(Debug)]
pub(crate) struct ChildGraph<T>(Vec<Child<T>>);

impl<T> ChildGraph<T>
where
    T: Sized + PartialEq + Clone,
{
    pub(crate) fn with_capacity(s: usize) -> Self {
        ChildGraph(Vec::with_capacity(s))
    }

    pub(crate) fn insert(&mut self, req: T) -> usize {
        self.0.iter().position(|e| e.id == req).unwrap_or_else(|| {
            let idx = self.0.len();
            self.0.push(Child::new(req));
            idx
        })
    }

    pub(crate) fn insert_child(&mut self, parent: usize, child: T) -> usize {
        let c_idx = self.0.len();
        self.0.push(Child::new(child));
        self.0[parent].children.push(c_idx);
        c_idx
    }

    pub(crate) fn iter(&self) -> impl Iterator<Item = &T> {
        self.0.iter().map(|r| &r.id)
    }

    pub(crate) fn contains(&self, req: &T) -> bool {
        self.0.iter().any(|r| r.id == *req)
    }
}

```

`clap/clap_builder/src/util/id.rs`:

```rs
use crate::builder::Str;

/// [`Arg`][crate::Arg] or [`ArgGroup`][crate::ArgGroup] identifier
///
/// This is used for accessing the value in [`ArgMatches`][crate::ArgMatches] or defining
/// relationships between `Arg`s and `ArgGroup`s with functions like
/// [`Arg::conflicts_with`][crate::Arg::conflicts_with].
#[derive(Default, Clone, Eq, PartialEq, PartialOrd, Ord, Hash)]
pub struct Id(Str);

impl Id {
    pub(crate) const HELP: &'static str = "help";
    pub(crate) const VERSION: &'static str = "version";
    pub(crate) const EXTERNAL: &'static str = "";

    pub(crate) fn from_static_ref(name: &'static str) -> Self {
        Self(Str::from_static_ref(name))
    }

    /// Get the raw string of the `Id`
    pub fn as_str(&self) -> &str {
        self.0.as_str()
    }

    pub(crate) fn as_internal_str(&self) -> &Str {
        &self.0
    }
}

impl From<&'_ Id> for Id {
    fn from(id: &'_ Id) -> Self {
        id.clone()
    }
}

impl From<Str> for Id {
    fn from(name: Str) -> Self {
        Self(name)
    }
}

impl From<&'_ Str> for Id {
    fn from(name: &'_ Str) -> Self {
        Self(name.into())
    }
}

#[cfg(feature = "string")]
impl From<String> for Id {
    fn from(name: String) -> Self {
        Self(name.into())
    }
}

#[cfg(feature = "string")]
impl From<&'_ String> for Id {
    fn from(name: &'_ String) -> Self {
        Self(name.into())
    }
}

impl From<&'static str> for Id {
    fn from(name: &'static str) -> Self {
        Self(name.into())
    }
}

impl From<&'_ &'static str> for Id {
    fn from(name: &'_ &'static str) -> Self {
        Self(name.into())
    }
}

impl From<Id> for Str {
    fn from(name: Id) -> Self {
        name.0
    }
}

impl From<Id> for String {
    fn from(name: Id) -> Self {
        Str::from(name).into()
    }
}

impl std::fmt::Display for Id {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.as_str(), f)
    }
}

impl std::fmt::Debug for Id {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Debug::fmt(self.as_str(), f)
    }
}

impl AsRef<str> for Id {
    #[inline]
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

impl std::borrow::Borrow<str> for Id {
    #[inline]
    fn borrow(&self) -> &str {
        self.as_str()
    }
}

impl PartialEq<str> for Id {
    #[inline]
    fn eq(&self, other: &str) -> bool {
        PartialEq::eq(self.as_str(), other)
    }
}
impl PartialEq<Id> for str {
    #[inline]
    fn eq(&self, other: &Id) -> bool {
        PartialEq::eq(self, other.as_str())
    }
}

impl PartialEq<&'_ str> for Id {
    #[inline]
    fn eq(&self, other: &&str) -> bool {
        PartialEq::eq(self.as_str(), *other)
    }
}
impl PartialEq<Id> for &'_ str {
    #[inline]
    fn eq(&self, other: &Id) -> bool {
        PartialEq::eq(*self, other.as_str())
    }
}

impl PartialEq<Str> for Id {
    #[inline]
    fn eq(&self, other: &Str) -> bool {
        PartialEq::eq(self.as_str(), other.as_str())
    }
}
impl PartialEq<Id> for Str {
    #[inline]
    fn eq(&self, other: &Id) -> bool {
        PartialEq::eq(self.as_str(), other.as_str())
    }
}

impl PartialEq<String> for Id {
    #[inline]
    fn eq(&self, other: &String) -> bool {
        PartialEq::eq(self.as_str(), other.as_str())
    }
}
impl PartialEq<Id> for String {
    #[inline]
    fn eq(&self, other: &Id) -> bool {
        PartialEq::eq(other, self)
    }
}

```

`clap/clap_builder/src/util/mod.rs`:

```rs
#![allow(clippy::single_component_path_imports)]

mod any_value;
pub(crate) mod flat_map;
pub(crate) mod flat_set;
mod graph;
mod id;
mod str_to_bool;

pub use self::id::Id;

pub(crate) use self::any_value::AnyValue;
pub(crate) use self::any_value::AnyValueId;
pub(crate) use self::flat_map::Entry;
pub(crate) use self::flat_map::FlatMap;
pub(crate) use self::flat_set::FlatSet;
pub(crate) use self::graph::ChildGraph;
pub(crate) use self::str_to_bool::str_to_bool;
pub(crate) use self::str_to_bool::FALSE_LITERALS;
pub(crate) use self::str_to_bool::TRUE_LITERALS;

pub(crate) mod color;

pub(crate) const SUCCESS_CODE: i32 = 0;
// While sysexists.h defines EX_USAGE as 64, this doesn't seem to be used much in practice but
// instead 2 seems to be frequently used.
// Examples
// - GNU `ls` returns 2
// - Python's `argparse` returns 2
pub(crate) const USAGE_CODE: i32 = 2;

#[cfg(not(feature = "unicode"))]
pub(crate) fn eq_ignore_case(left: &str, right: &str) -> bool {
    left.eq_ignore_ascii_case(right)
}

#[cfg(feature = "unicode")]
pub(crate) use unicase::eq as eq_ignore_case;

```

`clap/clap_builder/src/util/str_to_bool.rs`:

```rs
/// True values are `y`, `yes`, `t`, `true`, `on`, and `1`.
pub(crate) const TRUE_LITERALS: [&str; 6] = ["y", "yes", "t", "true", "on", "1"];

/// False values are `n`, `no`, `f`, `false`, `off`, and `0`.
pub(crate) const FALSE_LITERALS: [&str; 6] = ["n", "no", "f", "false", "off", "0"];

/// Converts a string literal representation of truth to true or false.
///
/// `false` values are `n`, `no`, `f`, `false`, `off`, and `0` (case insensitive).
///
/// Any other value will be considered as `true`.
pub(crate) fn str_to_bool(val: impl AsRef<str>) -> Option<bool> {
    let pat: &str = &val.as_ref().to_lowercase();
    if TRUE_LITERALS.contains(&pat) {
        Some(true)
    } else if FALSE_LITERALS.contains(&pat) {
        Some(false)
    } else {
        None
    }
}

```

`clap/clap_complete/CHANGELOG.md`:

```md
# Change Log
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/)
and this project adheres to [Semantic Versioning](http://semver.org/).

<!-- next-header -->
## [Unreleased] - ReleaseDate

## [4.5.47] - 2025-03-19

### Features

- *(dynamic)* Complete flags with variable-number of `num_args`

## [4.5.46] - 2025-02-24

## [4.5.45] - 2025-02-17

### Fixes

- *(dynamic)* Correctly complete option values based on `num_args`

## [4.5.44] - 2025-01-29

### Features

- *(dynamic)* Allow disabling completions through `COMPLETE=` and `COMPLETE=0`

## [4.5.43] - 2025-01-27

### Fixes

- *(powershell)* Correctly escape backtick
- *(powershell)* Improve handling of empty help

## [4.5.42] - 2025-01-09

### Fixes

- *(fish)* Corectly generate `aot` completions for single-value `ValueEnum`s

## [4.5.41] - 2025-01-07

### Fixes

- *(elvish)* Avoid leaking env variables in dynamic completions

## [4.5.40] - 2024-12-17

### Fixes

- *(powershell)* Fix syntax in dynamic registration script

## [4.5.39] - 2024-12-16

### Fixes

- *(bash)* For AOT completions, de-duplicate when subcommand aliases are used

## [4.5.38] - 2024-11-13

## [4.5.37] - 2024-11-04

### Fixes

- *(dynamic)* Be compatible with package's MSRV

## [4.5.36] - 2024-10-29

### Fixes

- *(zsh)* Change `ValueHint::Unknown` to `_default` in static completions

## [4.5.35] - 2024-10-24

## [4.5.34] - 2024-10-24

### Features

- *(dynamic)* Show description in zsh

## [4.5.33] - 2024-10-08

### Features

- *(dynamic)* `SubcommandCandidates` support

## [4.5.32] - 2024-10-02

## [4.5.31] - 2024-10-02

### Compatibility

- *(dynamic)* `CompleteEnv::with_factory` now takes in a `Fn` instead of a `FnOnce`

## [4.5.30] - 2024-10-02

### Fixes

- *(dynamic)* Don't default to `ValueHint::AnyPath` but "no completion"

## [4.5.29] - 2024-09-20

### Features

- *(dynamic)* Change completion order to subcommands, positional values, flags
- *(dynamic)* When completing `-[TAB]`, prioritize shorts over longs
- *(dynamic)* De-duplicate completions that have the same result (longs, shorts, aliases)
- *(dynamic)* Group candidates from the same `CompletionCandidate::tag`
- *(dynamic)* Sort candidates within a `CompletionCandidate::tag` by their `display_order`

## [4.5.28] - 2024-09-17

### Compatibility

- *(dynamic)* The binary called when completing is now `std::env::args_os()[0]`, rather than `Command::name`

### Features

- *(dynamic)* Allow overriding the binary being completed and the binary being called for completions

### Fixes

- *(dynamic)* By default, remove wrappers around a binary when calling for completions

## [4.5.27] - 2024-09-17

### Fixes

- *(dynamic)* Fix completions for bash for at least some users

## [4.5.26] - 2024-09-05

### Features

- *(dynamic)* `allow_hyphen_values` support

## [4.5.25] - 2024-09-04

### Compatibility

- *(dynamic)* Removed `CompleteCommand`

### Fixes

- *(dynamic)* Take over ordering of Fish completions

## [4.5.24] - 2024-08-27

### Fixes

- *(dynamic)* Ensure a new enough `shlex` is required

## [4.5.23] - 2024-08-22

### Compatibility

- *(dynamic)* Rename `CompletionCandidate::get_content` to `CompletionCandidate::get_value`

## [4.5.22] - 2024-08-21

### Fixes

- *(dynamic)* Dir completions now include `.`

## [4.5.21] - 2024-08-21

### Features

- *(dynamic)* Add `ArgValueCompleter`, a more flexible `ArgValueCandidates`
- *(dynamic)* Add `PathCompleter`, a more flexible `ValueHint::*Path`

### Fixes

- *(dynamic)* Sort `ValueHint::*Path` results
- *(dynamic)* Preserve the users path for `ValueHint::*Path` results

## [4.5.20] - 2024-08-20

### Compatibility

- *(dynamic)* Renamed `CustomCompleter` to `ValueCandidates`
- *(dynamic)* Renamed `ArgValueCompleter` to `ArgValueCandidates`

## [4.5.19] - 2024-08-19

### Compatibility

- *(dynamic)* Renamed `dynamic` to `engine`

### Fixes

- *(dynamic)* *(bash)* Don't cause a completion to make the program un-runnabe
- *(dynamic)* *(zsh)* Don't cause a completion to make the program un-runnabe

## [4.5.18] - 2024-08-16

### Features

- *(dynamic)* Complete the last value in a delimited list

## [4.5.17] - 2024-08-16

### Compatibility

- *(dynamic)* Move `command` and `env` out of `dynamic`

### Fixes

- *(dynamic)* Increase `ArgValueCompleter` precedence over `ValueEnum`
- *(dynamic)* Move `command` and `env` out of `dynamic`
- Move pre-generated completions to `aot` module

## [4.5.16] - 2024-08-12

## [4.5.15] - 2024-08-12

### Compatibility

- *(dynamic)* Moved `dynamic::shells` to `dynamic::command`
- *(dynamic)* Guarded `dynamic::command` with `unstable-command` feature

### Features

- *(dynamic)* Added `env::CompleteEnv` application integration

## [4.5.14] - 2024-08-10

### Compatibility

- *(dynamic)* Renamed `CustomCompleter::completions` to `CustomCompleter::candidates`
- *(dynamic)* Renamed `Completer` to `shells::ShellCompleter`

### Features

- *(dynamic)* Add `shells::CompleteArgs::complete`
- *(dynamic)* Make `--register` optional
- *(dynamic)* Make `--shell` optional
- *(dynamic)* Add powershell support

### Fixes

- *(powershell)* Add missing option hyphens
- *(dynamic)* Expose `shells::CompleteArgs` and `shells::CompleteCommand` at top-level
- *(dynamic)* Improve help output

## [4.5.13] - 2024-08-08

### Features

- *(dynamic)* Added `ArgValueCompleter` for custom completions

### Compatibility

- *(dynamic)* `CompletionCandidate::visible` was renamed to `CompletionCandidate::hide`

## [4.5.12] - 2024-07-31

#### Features

- *(dynamic)* Support completing with `num_args`

## [4.5.11] - 2024-07-25

#### Features

- *(dynamic)* Add support for `-fbar` and `-f=bar` completions

## [4.5.10] - 2024-07-25

## [4.5.9] - 2024-07-23

### Features

- *(dynamic)* Support for zsh, elvis, powershell
- *(dynamic)* Complete `--option val[TAB]`
- *(dynamic)* Complete subcommand aliases
- *(dynamic)* Hide hidden flags, subcommands, values, and aliases, only completeing them if no visible variant is available

## [4.5.8] - 2024-07-11

### Fixes

- *(fish)* Nested subcommand completions

## [4.5.7] - 2024-06-28

### Fixes

- *(fish)* Allow completing positionals when subcommands are present

## [4.5.6] - 2024-06-19

## [4.5.5] - 2024-06-07

### Fixes

- *(zsh)* Don't fail or ignore options consumed by `_arguments`

## [4.5.4] - 2024-06-06

## [4.5.3] - 2024-06-06

## [4.5.2] - 2024-04-09

### Fixes

- *(bash)* Improve compatibility with older bash versions

## [4.5.1] - 2024-02-16

### Fixes

- Correctly handle completion descriptions with newlines

## [4.5.0] - 2024-02-08

### Compatibility

- Update MSRV to 1.74

## [4.4.10] - 2024-02-02

### Fixes

- *(bash)* Allow completing filenames with spaces

## [4.4.9] - 2024-01-22

### Features

- *(bash)* Add support file `ValueHint::FilePath`
- *(bash)* Add support file `ValueHint::DirPath`
- *(bash)* Don't add space for `ValueHint::Other`

## [4.4.8] - 2024-01-19

### Fixes

- *(bash)* be consistent in identifiers when custom bin names are used

## [4.4.7] - 2024-01-15

### Fixes

- *(unstable)* Don't have dynamic completions pollute the parent command's help output

## [4.4.6] - 2024-01-02

### Fixes

- Work with older Bash versions, particularly for MacOS

## [4.4.5] - 2023-12-27

### Documentation

- *(unstable)* Include / expand `dynamic` on docs.rs

## [4.4.4] - 2023-10-24

## [4.4.3] - 2023-09-28

## [4.4.2] - 2023-09-25

### Fixes

- *(unstable)* Complete positionals in subcommands

## [4.4.1] - 2023-09-07

### Fixes

- *(fish)* Properly escape `()` in descriptions

## [4.4.0] - 2023-08-24

### Compatibility

- Update MSRV to 1.70.0

### Features

- *(unstable)* Fish dynamic completion support

### Fixes

- *(unstable)* Manual control over sort order
- *(unstable)* Don't recursively report subcommands
- *(unstable)* Get bash support working again
- *(unstable)* Ensure shorts keep their leading `-`

## [4.3.2] - 2023-07-05

### Fixes

- *(powershell)* Attempt to allow completing `-s` separately from `-S`

## [4.3.1] - 2023-06-02

## [4.3.0] - 2023-05-19

## [4.2.3] - 2023-05-12

### Fixes

- *(zsh)* Avoid error when mixing multiple values with subcommands

## [4.2.2] - 2023-05-09

- *(bash)* Respect `ValueHint::Other`

## [4.2.1] - 2023-04-21

- *(zsh)* Improved escaping

## [4.2.0] - 2023-03-28

## [4.1.6] - 2023-03-28

## [4.1.5] - 2023-03-16

## [4.1.4] - 2023-02-27

### Features

- *(zsh)* Allow sourcing completion

## [4.1.3] - 2023-02-23

### Fixes

- *(zsh)* Improve handling of multi-valued arguments

## [4.1.2] - 2023-02-15

## [4.1.1] - 2023-01-23

### Fixes

- *(bash)* Mark `cmd` variable as local

## [4.1.0] - 2023-01-13

### Compatibility

MSRV changed to 1.64.0

## [4.0.7] - 2022-12-22

## [4.0.6] - 2022-11-24

## [4.0.5] - 2022-11-07

### Features

- Added `Shell::from_env`

## [4.0.4] - 2022-11-07

## [4.0.3] - 2022-10-18

## [4.0.2] - 2022-09-29

### Fixes

- *(bash)* Fix `git diff git <TAB>` completions
- *(bash)* Fix `git diff log <TAB>` completions
- *(bash)* Fix command alias

## [4.0.1] - 2022-09-28

### Fixes

- *(zsh)* Fix multiple-items regression introduced in v4

## [4.0.0] - 2022-09-28

## [3.2.3] - 2022-06-28

## [3.2.2] - 2022-06-21

## [3.2.1] - 2022-06-13

## [3.2.0] - 2022-06-13

## [3.1.4] - 2022-05-06

### Fixes

- *(bash)* Complete visible `PossibleValue`s, rather than hidden

## [3.1.3] - 2022-04-30

### Fixes

- Minimal rust-implemented clap completion engine, behind `unstable-dynamic` feature flag

## [3.1.2] - 2022-04-19

## [3.1.1] - 2022-03-02

## [3.1.0] - 2022-02-16

### Fixes

- Fish: escape possible values (#3467)

## [3.0.6] - 2022-02-05

### Fixes

- Powershell: Allow completion of partial commands

## [3.0.5] - 2022-01-24

### Fixes

- Clarified panics

## [3.0.4] - 2022-01-15

### Fixes

- Unescaped chars in zsh completions

## [3.0.3] - 2022-01-12

### Fixes

- Use new Elvish 0.17 syntax
- Add newline at end of zsh output

## [3.0.2] - 2022-01-04

## [3.0.1] - 2022-01-03

<!-- next-url -->
[Unreleased]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.47...HEAD
[4.5.47]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.46...clap_complete-v4.5.47
[4.5.46]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.45...clap_complete-v4.5.46
[4.5.45]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.44...clap_complete-v4.5.45
[4.5.44]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.43...clap_complete-v4.5.44
[4.5.43]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.42...clap_complete-v4.5.43
[4.5.42]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.41...clap_complete-v4.5.42
[4.5.41]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.40...clap_complete-v4.5.41
[4.5.40]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.39...clap_complete-v4.5.40
[4.5.39]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.38...clap_complete-v4.5.39
[4.5.38]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.37...clap_complete-v4.5.38
[4.5.37]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.36...clap_complete-v4.5.37
[4.5.36]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.35...clap_complete-v4.5.36
[4.5.35]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.34...clap_complete-v4.5.35
[4.5.34]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.33...clap_complete-v4.5.34
[4.5.33]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.32...clap_complete-v4.5.33
[4.5.32]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.31...clap_complete-v4.5.32
[4.5.31]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.30...clap_complete-v4.5.31
[4.5.30]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.29...clap_complete-v4.5.30
[4.5.29]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.28...clap_complete-v4.5.29
[4.5.28]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.27...clap_complete-v4.5.28
[4.5.27]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.26...clap_complete-v4.5.27
[4.5.26]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.25...clap_complete-v4.5.26
[4.5.25]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.24...clap_complete-v4.5.25
[4.5.24]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.23...clap_complete-v4.5.24
[4.5.23]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.22...clap_complete-v4.5.23
[4.5.22]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.21...clap_complete-v4.5.22
[4.5.21]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.20...clap_complete-v4.5.21
[4.5.20]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.19...clap_complete-v4.5.20
[4.5.19]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.18...clap_complete-v4.5.19
[4.5.18]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.17...clap_complete-v4.5.18
[4.5.17]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.16...clap_complete-v4.5.17
[4.5.16]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.15...clap_complete-v4.5.16
[4.5.15]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.14...clap_complete-v4.5.15
[4.5.14]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.13...clap_complete-v4.5.14
[4.5.13]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.12...clap_complete-v4.5.13
[4.5.12]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.11...clap_complete-v4.5.12
[4.5.11]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.10...clap_complete-v4.5.11
[4.5.10]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.9...clap_complete-v4.5.10
[4.5.9]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.8...clap_complete-v4.5.9
[4.5.8]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.7...clap_complete-v4.5.8
[4.5.7]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.6...clap_complete-v4.5.7
[4.5.6]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.5...clap_complete-v4.5.6
[4.5.5]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.4...clap_complete-v4.5.5
[4.5.4]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.3...clap_complete-v4.5.4
[4.5.3]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.2...clap_complete-v4.5.3
[4.5.2]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.1...clap_complete-v4.5.2
[4.5.1]: https://github.com/clap-rs/clap/compare/clap_complete-v4.5.0...clap_complete-v4.5.1
[4.5.0]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.10...clap_complete-v4.5.0
[4.4.10]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.9...clap_complete-v4.4.10
[4.4.9]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.8...clap_complete-v4.4.9
[4.4.8]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.7...clap_complete-v4.4.8
[4.4.7]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.6...clap_complete-v4.4.7
[4.4.6]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.5...clap_complete-v4.4.6
[4.4.5]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.4...clap_complete-v4.4.5
[4.4.4]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.3...clap_complete-v4.4.4
[4.4.3]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.2...clap_complete-v4.4.3
[4.4.2]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.1...clap_complete-v4.4.2
[4.4.1]: https://github.com/clap-rs/clap/compare/clap_complete-v4.4.0...clap_complete-v4.4.1
[4.4.0]: https://github.com/clap-rs/clap/compare/clap_complete-v4.3.2...clap_complete-v4.4.0
[4.3.2]: https://github.com/clap-rs/clap/compare/clap_complete-v4.3.1...clap_complete-v4.3.2
[4.3.1]: https://github.com/clap-rs/clap/compare/clap_complete-v4.3.0...clap_complete-v4.3.1
[4.3.0]: https://github.com/clap-rs/clap/compare/clap_complete-v4.2.3...clap_complete-v4.3.0
[4.2.3]: https://github.com/clap-rs/clap/compare/clap_complete-v4.2.2...clap_complete-v4.2.3
[4.2.2]: https://github.com/clap-rs/clap/compare/clap_complete-v4.2.1...clap_complete-v4.2.2
[4.2.1]: https://github.com/clap-rs/clap/compare/clap_complete-v4.2.0...clap_complete-v4.2.1
[4.2.0]: https://github.com/clap-rs/clap/compare/clap_complete-v4.1.6...clap_complete-v4.2.0
[4.1.6]: https://github.com/clap-rs/clap/compare/clap_complete-v4.1.5...clap_complete-v4.1.6
[4.1.5]: https://github.com/clap-rs/clap/compare/clap_complete-v4.1.4...clap_complete-v4.1.5
[4.1.4]: https://github.com/clap-rs/clap/compare/clap_complete-v4.1.3...clap_complete-v4.1.4
[4.1.3]: https://github.com/clap-rs/clap/compare/clap_complete-v4.1.2...clap_complete-v4.1.3
[4.1.2]: https://github.com/clap-rs/clap/compare/clap_complete-v4.1.1...clap_complete-v4.1.2
[4.1.1]: https://github.com/clap-rs/clap/compare/clap_complete-v4.1.0...clap_complete-v4.1.1
[4.1.0]: https://github.com/clap-rs/clap/compare/clap_complete-v4.0.7...clap_complete-v4.1.0
[4.0.7]: https://github.com/clap-rs/clap/compare/clap_complete-v4.0.6...clap_complete-v4.0.7
[4.0.6]: https://github.com/clap-rs/clap/compare/clap_complete-v4.0.5...clap_complete-v4.0.6
[4.0.5]: https://github.com/clap-rs/clap/compare/clap_complete-v4.0.4...clap_complete-v4.0.5
[4.0.4]: https://github.com/clap-rs/clap/compare/clap_complete-v4.0.3...clap_complete-v4.0.4
[4.0.3]: https://github.com/clap-rs/clap/compare/clap_complete-v4.0.2...clap_complete-v4.0.3
[4.0.2]: https://github.com/clap-rs/clap/compare/clap_complete-v4.0.1...clap_complete-v4.0.2
[4.0.1]: https://github.com/clap-rs/clap/compare/clap_complete-v4.0.0...clap_complete-v4.0.1
[4.0.0]: https://github.com/clap-rs/clap/compare/clap_complete-v3.2.3...clap_complete-v4.0.0
[3.2.3]: https://github.com/clap-rs/clap/compare/clap_complete-v3.2.2...clap_complete-v3.2.3
[3.2.2]: https://github.com/clap-rs/clap/compare/clap_complete-v3.2.1...clap_complete-v3.2.2
[3.2.1]: https://github.com/clap-rs/clap/compare/clap_complete-v3.2.0...clap_complete-v3.2.1
[3.2.0]: https://github.com/clap-rs/clap/compare/clap_complete-v3.1.4...clap_complete-v3.2.0
[3.1.4]: https://github.com/clap-rs/clap/compare/clap_complete-v3.1.3...clap_complete-v3.1.4
[3.1.3]: https://github.com/clap-rs/clap/compare/clap_complete-v3.1.2...clap_complete-v3.1.3
[3.1.2]: https://github.com/clap-rs/clap/compare/clap_complete-v3.1.1...clap_complete-v3.1.2
[3.1.1]: https://github.com/clap-rs/clap/compare/clap_complete-v3.1.0...clap_complete-v3.1.1
[3.1.0]: https://github.com/clap-rs/clap/compare/clap_complete-v3.0.6...clap_complete-v3.1.0
[3.0.6]: https://github.com/clap-rs/clap/compare/clap_complete-v3.0.5...clap_complete-v3.0.6
[3.0.5]: https://github.com/clap-rs/clap/compare/clap_complete-v3.0.4...clap_complete-v3.0.5
[3.0.4]: https://github.com/clap-rs/clap/compare/clap_complete-v3.0.3...clap_complete-v3.0.4
[3.0.3]: https://github.com/clap-rs/clap/compare/v3.0.2...clap_complete-v3.0.3
[3.0.2]: https://github.com/clap-rs/clap/compare/v3.0.1...v3.0.2
[3.0.1]: https://github.com/clap-rs/clap/compare/v3.0.0...v3.0.1

```

`clap/clap_complete/CONTRIBUTING.md`:

```md
# How to Contribute

See the [clap-wide CONTRIBUTING.md](../CONTRIBUTING.md).  This will contain `clap_complete` specific notes.

### Scope

`clap_complete` contains the core completion generators, meaning ones
maintained by the clap maintainers that get priority for features and fixes.
Additional, including contributor-maintained generators can also be contributed
to the clap repo and sit alongside `clap_complete` in a `clap_complete_<name>`
crate.

```

`clap/clap_complete/Cargo.toml`:

```toml
[package]
name = "clap_complete"
version = "4.5.47"
description = "Generate shell completion scripts for your clap::Command"
categories = ["command-line-interface"]
keywords = [
  "clap",
  "cli",
  "completion",
  "bash",
]
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
include.workspace = true

[package.metadata.docs.rs]
features = ["unstable-doc"]
rustdoc-args = ["--cfg", "docsrs", "--generate-link-to-definition"]
cargo-args = ["-Zunstable-options", "-Zrustdoc-scrape-examples"]

[package.metadata.release]
pre-release-replacements = [
  {file="CHANGELOG.md", search="Unreleased", replace="{{version}}", min=1},
  {file="CHANGELOG.md", search="\\.\\.\\.HEAD", replace="...{{tag_name}}", exactly=1},
  {file="CHANGELOG.md", search="ReleaseDate", replace="{{date}}", min=1},
  {file="CHANGELOG.md", search="<!-- next-header -->", replace="<!-- next-header -->\n## [Unreleased] - ReleaseDate\n", exactly=1},
  {file="CHANGELOG.md", search="<!-- next-url -->", replace="<!-- next-url -->\n[Unreleased]: https://github.com/clap-rs/clap/compare/{{tag_name}}...HEAD", exactly=1},
  {file="README.md", search="github.com/clap-rs/clap/blob/[^/]+/", replace="github.com/clap-rs/clap/blob/{{tag_name}}/", exactly=4, prerelease = true},
]

[lib]
bench = false

[dependencies]
clap = { path = "../", version = "4.5.20", default-features = false, features = ["std"] }
clap_lex = { path = "../clap_lex", version = "0.7.0", optional = true }
is_executable = { version = "1.0.1", optional = true }
shlex = { version = "1.3.0", optional = true }
completest = { version = "0.4.2", optional = true }
completest-pty = { version = "0.5.5", optional = true }

[dev-dependencies]
snapbox = { version = "0.6.0", features = ["diff", "dir", "examples"] }
# Cutting out `filesystem` feature
trycmd = { version = "0.15.1", default-features = false, features = ["color-auto", "diff", "examples"] }
clap = { path = "../", version = "4.5.20", default-features = false, features = ["std", "derive", "help"] }
automod = "1.0.14"

[[example]]
name = "dynamic"
required-features = ["unstable-dynamic"]

[features]
default = []
unstable-doc = ["unstable-dynamic"] # for docs.rs
unstable-dynamic = ["dep:clap_lex", "dep:shlex", "dep:is_executable", "clap/unstable-ext"]
unstable-shell-tests = ["dep:completest", "dep:completest-pty"]
debug = ["clap/debug"]

[lints]
workspace = true

```

`clap/clap_complete/LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`clap/clap_complete/LICENSE-MIT`:

```
The MIT License (MIT)

Copyright (c) 2015-2022 Kevin B. Knapp and Clap Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`clap/clap_complete/README.md`:

```md
<!-- omit in TOC -->
# clap_complete

> **Shell completion generation for `clap`**

[![Crates.io](https://img.shields.io/crates/v/clap_complete?style=flat-square)](https://crates.io/crates/clap_complete)
[![Crates.io](https://img.shields.io/crates/d/clap_complete?style=flat-square)](https://crates.io/crates/clap_complete)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue?style=flat-square)](https://github.com/clap-rs/clap/blob/clap_complete-v4.5.47/LICENSE-APACHE)
[![License](https://img.shields.io/badge/license-MIT-blue?style=flat-square)](https://github.com/clap-rs/clap/blob/clap_complete-v4.5.47/LICENSE-MIT)

Dual-licensed under [Apache 2.0](LICENSE-APACHE) or [MIT](LICENSE-MIT).

1. [About](#about)
2. [API Reference](https://docs.rs/clap_complete)
3. [Questions & Discussions](https://github.com/clap-rs/clap/discussions)
4. [CONTRIBUTING](https://github.com/clap-rs/clap/blob/clap_complete-v4.5.47/clap_complete/CONTRIBUTING.md)
5. [Sponsors](https://github.com/clap-rs/clap/blob/clap_complete-v4.5.47/README.md#sponsors)

## About

### Related Projects

- [clap_complete_nushell](https://crates.io/crates/clap_complete_nushell) for [nushell](https://www.nushell.sh/) shell completion support

```

`clap/clap_complete/examples/completion-derive.rs`:

```rs
//! How to use value hints and generate shell completions.
//!
//! Usage with zsh:
//! ```console
//! $ cargo run --example completion-derive -- --generate=zsh > /usr/local/share/zsh/site-functions/_completion_derive
//! $ compinit
//! $ ./target/debug/examples/completion_derive --<TAB>
//! ```
//! fish:
//! ```console
//! $ cargo run --example completion-derive -- --generate=fish > completion_derive.fish
//! $ . ./completion_derive.fish
//! $ ./target/debug/examples/completion_derive --<TAB>
//! ```
use clap::{Args, Command, CommandFactory, Parser, Subcommand, ValueHint};
use clap_complete::{generate, Generator, Shell};
use std::ffi::OsString;
use std::io;
use std::path::PathBuf;

#[derive(Parser, Debug, PartialEq)]
#[command(name = "completion-derive")]
struct Opt {
    // If provided, outputs the completion file for given shell
    #[arg(long = "generate", value_enum)]
    generator: Option<Shell>,
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand, Debug, PartialEq)]
enum Commands {
    #[command(visible_alias = "hint")]
    ValueHint(ValueHintOpt),
}

#[derive(Args, Debug, PartialEq)]
struct ValueHintOpt {
    // Showcasing all possible ValueHints:
    #[arg(long, value_hint = ValueHint::Unknown)]
    unknown: Option<String>,
    #[arg(long, value_hint = ValueHint::Other)]
    other: Option<String>,
    #[arg(short, long, value_hint = ValueHint::AnyPath)]
    path: Option<PathBuf>,
    #[arg(short, long, value_hint = ValueHint::FilePath)]
    file: Option<PathBuf>,
    #[arg(short, long, value_hint = ValueHint::DirPath)]
    dir: Option<PathBuf>,
    #[arg(short, long, value_hint = ValueHint::ExecutablePath)]
    exe: Option<PathBuf>,
    #[arg(long, value_hint = ValueHint::CommandName)]
    cmd_name: Option<OsString>,
    #[arg(short, long, value_hint = ValueHint::CommandString)]
    cmd: Option<String>,
    // Command::trailing_var_ar is required to use ValueHint::CommandWithArguments
    #[arg(trailing_var_arg = true, value_hint = ValueHint::CommandWithArguments)]
    command_with_args: Vec<String>,
    #[arg(short, long, value_hint = ValueHint::Username)]
    user: Option<String>,
    #[arg(long, value_hint = ValueHint::Hostname)]
    host: Option<String>,
    #[arg(long, value_hint = ValueHint::Url)]
    url: Option<String>,
    #[arg(long, value_hint = ValueHint::EmailAddress)]
    email: Option<String>,
}

fn print_completions<G: Generator>(generator: G, cmd: &mut Command) {
    generate(
        generator,
        cmd,
        cmd.get_name().to_string(),
        &mut io::stdout(),
    );
}

fn main() {
    let opt = Opt::parse();

    if let Some(generator) = opt.generator {
        let mut cmd = Opt::command();
        eprintln!("Generating completion file for {generator:?}...");
        print_completions(generator, &mut cmd);
    } else {
        println!("{opt:#?}");
    }
}

```

`clap/clap_complete/examples/completion.rs`:

```rs
//! Example to test arguments with different `ValueHint` values.
//!
//! Usage with zsh:
//! ```console
//! $ cargo run --example completion -- --generate=zsh > /usr/local/share/zsh/site-functions/_completion$
//! $ compinit
//! $ ./target/debug/examples/completion --<TAB>
//! ```
//! fish:
//! ```console
//! $ cargo run --example completion -- --generate=fish > completion.fish
//! $ . ./completion.fish
//! $ ./target/debug/examples/completion --<TAB>
//! ```
use clap::{value_parser, Arg, Command, ValueHint};
use clap_complete::{generate, Generator, Shell};
use std::io;

fn build_cli() -> Command {
    let value_hint_command = Command::new("value-hint")
        .visible_alias("hint")
        .arg(
            Arg::new("unknown")
                .long("unknown")
                .value_hint(ValueHint::Unknown),
        )
        .arg(Arg::new("other").long("other").value_hint(ValueHint::Other))
        .arg(
            Arg::new("path")
                .long("path")
                .short('p')
                .value_hint(ValueHint::AnyPath),
        )
        .arg(
            Arg::new("file")
                .long("file")
                .short('f')
                .value_hint(ValueHint::FilePath),
        )
        .arg(
            Arg::new("dir")
                .long("dir")
                .short('d')
                .value_hint(ValueHint::DirPath),
        )
        .arg(
            Arg::new("exe")
                .long("exe")
                .short('e')
                .value_hint(ValueHint::ExecutablePath),
        )
        .arg(
            Arg::new("cmd_name")
                .long("cmd-name")
                .value_hint(ValueHint::CommandName),
        )
        .arg(
            Arg::new("cmd")
                .long("cmd")
                .short('c')
                .value_hint(ValueHint::CommandString),
        )
        .arg(
            Arg::new("command_with_args")
                .num_args(1..)
                // AppSettings::TrailingVarArg is required to use ValueHint::CommandWithArguments
                .trailing_var_arg(true)
                .value_hint(ValueHint::CommandWithArguments),
        )
        .arg(
            Arg::new("user")
                .short('u')
                .long("user")
                .value_hint(ValueHint::Username),
        )
        .arg(
            Arg::new("host")
                .long("host")
                .value_hint(ValueHint::Hostname),
        )
        .arg(Arg::new("url").long("url").value_hint(ValueHint::Url))
        .arg(
            Arg::new("email")
                .long("email")
                .value_hint(ValueHint::EmailAddress),
        );

    Command::new("completion")
        .arg(
            Arg::new("generator")
                .long("generate")
                .value_parser(value_parser!(Shell)),
        )
        .subcommand(value_hint_command)
}

fn print_completions<G: Generator>(generator: G, cmd: &mut Command) {
    generate(
        generator,
        cmd,
        cmd.get_name().to_string(),
        &mut io::stdout(),
    );
}

fn main() {
    let matches = build_cli().get_matches();

    if let Some(generator) = matches.get_one::<Shell>("generator") {
        let mut cmd = build_cli();
        eprintln!("Generating completion file for {generator}...");
        print_completions(*generator, &mut cmd);
    }
}

```

`clap/clap_complete/examples/dynamic.rs`:

```rs
fn command() -> clap::Command {
    clap::Command::new("dynamic")
        .arg(
            clap::Arg::new("input")
                .long("input")
                .short('i')
                .value_hint(clap::ValueHint::FilePath),
        )
        .arg(
            clap::Arg::new("format")
                .long("format")
                .short('F')
                .value_parser(["json", "yaml", "toml"]),
        )
        .args_conflicts_with_subcommands(true)
}

fn main() {
    clap_complete::CompleteEnv::with_factory(command).complete();

    let cmd = command();
    let matches = cmd.get_matches();
    println!("{matches:#?}");
}

#[test]
fn verify_cli() {
    command().debug_assert();
}

```

`clap/clap_complete/examples/exhaustive.rs`:

```rs
use clap::builder::PossibleValue;
use clap_complete::{generate, Generator, Shell};

fn main() {
    #[cfg(feature = "unstable-dynamic")]
    clap_complete::CompleteEnv::with_factory(cli)
        // Avoid tests snapshotting a path into `target/`
        .completer("exhaustive")
        .complete();

    let matches = cli().get_matches();
    if let Some(generator) = matches.get_one::<Shell>("generate") {
        let mut cmd = cli();
        eprintln!("Generating completion file for {generator}...");
        print_completions(*generator, &mut cmd);
        return;
    }

    println!("{matches:?}");
}

fn print_completions<G: Generator>(generator: G, cmd: &mut clap::Command) {
    generate(
        generator,
        cmd,
        cmd.get_name().to_string(),
        &mut std::io::stdout(),
    );
}

const EMPTY: [&str; 0] = [];

#[allow(clippy::let_and_return)]
fn cli() -> clap::Command {
    clap::Command::new("exhaustive")
        .args([
            clap::Arg::new("generate")
                .long("generate")
                .value_name("SHELL")
                .value_parser(clap::value_parser!(Shell))
                .help("generate"),
            clap::Arg::new("empty-choice")
                .long("empty-choice")
                .value_parser(EMPTY),
        ])
        .subcommands([
            clap::Command::new("empty")
                .disable_help_subcommand(true)
                .disable_help_flag(true),
            clap::Command::new("global")
                .version("3.0")
                .propagate_version(true)
                .args([clap::Arg::new("global")
                    .long("global")
                    .global(true)
                    .action(clap::ArgAction::SetTrue)
                    .help("everywhere")])
                .subcommands([
                    clap::Command::new("one").subcommand(clap::Command::new("one-one")),
                    clap::Command::new("two"),
                ]),
            clap::Command::new("action").args([
                clap::Arg::new("set-true")
                    .long("set-true")
                    .action(clap::ArgAction::SetTrue)
                    .help("bool"),
                clap::Arg::new("set")
                    .long("set")
                    .action(clap::ArgAction::Set)
                    .help("value"),
                clap::Arg::new("count")
                    .long("count")
                    .action(clap::ArgAction::Count)
                    .help("number"),
                clap::Arg::new("choice")
                    .long("choice")
                    .value_parser(["first", "second"])
                    .help("enum"),
            ]),
            clap::Command::new("quote")
                .args([
                    clap::Arg::new("single-quotes")
                        .long("single-quotes")
                        .action(clap::ArgAction::SetTrue)
                        .help("Can be 'always', 'auto', or 'never'"),
                    clap::Arg::new("double-quotes")
                        .long("double-quotes")
                        .action(clap::ArgAction::SetTrue)
                        .help("Can be \"always\", \"auto\", or \"never\""),
                    clap::Arg::new("backticks")
                        .long("backticks")
                        .action(clap::ArgAction::SetTrue)
                        .help("For more information see `echo test`"),
                    clap::Arg::new("backslash")
                        .long("backslash")
                        .action(clap::ArgAction::SetTrue)
                        .help("Avoid '\\n'"),
                    clap::Arg::new("brackets")
                        .long("brackets")
                        .action(clap::ArgAction::SetTrue)
                        .help("List packages [filter]"),
                    clap::Arg::new("expansions")
                        .long("expansions")
                        .action(clap::ArgAction::SetTrue)
                        .help("Execute the shell command with $SHELL"),
                    clap::Arg::new("choice")
                        .long("choice")
                        .action(clap::ArgAction::Set)
                        .value_parser(clap::builder::PossibleValuesParser::new([
                            PossibleValue::new("another shell").help("something with a space"),
                            PossibleValue::new("bash").help("bash (shell)"),
                            PossibleValue::new("fish").help("fish shell"),
                            PossibleValue::new("zsh").help("zsh shell"),
                        ])),
                ])
                .subcommands([
                    clap::Command::new("cmd-single-quotes")
                        .about("Can be 'always', 'auto', or 'never'"),
                    clap::Command::new("cmd-double-quotes")
                        .about("Can be \"always\", \"auto\", or \"never\""),
                    clap::Command::new("cmd-backticks")
                        .about("For more information see `echo test`"),
                    clap::Command::new("cmd-backslash").about("Avoid '\\n'"),
                    clap::Command::new("cmd-brackets").about("List packages [filter]"),
                    clap::Command::new("cmd-expansions")
                        .about("Execute the shell command with $SHELL"),
                    clap::Command::new("escape-help").about("\\tab\t\"'\nNew Line"),
                ]),
            clap::Command::new("value").args([
                clap::Arg::new("delim").long("delim").value_delimiter(','),
                clap::Arg::new("tuple").long("tuple").num_args(2),
                clap::Arg::new("require-eq")
                    .long("require-eq")
                    .require_equals(true),
                clap::Arg::new("term").num_args(1..).value_terminator(";"),
            ]),
            clap::Command::new("pacman").subcommands([
                clap::Command::new("one").long_flag("one").short_flag('o'),
                clap::Command::new("two").long_flag("two").short_flag('t'),
            ]),
            clap::Command::new("last")
                .args([clap::Arg::new("first"), clap::Arg::new("free").last(true)]),
            clap::Command::new("alias").args([
                clap::Arg::new("flag")
                    .short('f')
                    .visible_short_alias('F')
                    .long("flag")
                    .action(clap::ArgAction::SetTrue)
                    .visible_alias("flg")
                    .help("cmd flag"),
                clap::Arg::new("option")
                    .short('o')
                    .visible_short_alias('O')
                    .long("option")
                    .visible_alias("opt")
                    .help("cmd option")
                    .action(clap::ArgAction::Set),
                clap::Arg::new("positional"),
            ]),
            clap::Command::new("hint").args([
                clap::Arg::new("choice")
                    .long("choice")
                    .action(clap::ArgAction::Set)
                    .value_parser(["bash", "fish", "zsh"]),
                clap::Arg::new("unknown")
                    .long("unknown")
                    .value_hint(clap::ValueHint::Unknown),
                clap::Arg::new("other")
                    .long("other")
                    .value_hint(clap::ValueHint::Other),
                clap::Arg::new("path")
                    .long("path")
                    .short('p')
                    .value_hint(clap::ValueHint::AnyPath),
                clap::Arg::new("file")
                    .long("file")
                    .short('f')
                    .value_hint(clap::ValueHint::FilePath),
                clap::Arg::new("dir")
                    .long("dir")
                    .short('d')
                    .value_hint(clap::ValueHint::DirPath),
                clap::Arg::new("exe")
                    .long("exe")
                    .short('e')
                    .value_hint(clap::ValueHint::ExecutablePath),
                clap::Arg::new("cmd_name")
                    .long("cmd-name")
                    .value_hint(clap::ValueHint::CommandName),
                clap::Arg::new("cmd")
                    .long("cmd")
                    .short('c')
                    .value_hint(clap::ValueHint::CommandString),
                clap::Arg::new("command_with_args")
                    .action(clap::ArgAction::Set)
                    .num_args(1..)
                    .trailing_var_arg(true)
                    .value_hint(clap::ValueHint::CommandWithArguments),
                clap::Arg::new("user")
                    .short('u')
                    .long("user")
                    .value_hint(clap::ValueHint::Username),
                clap::Arg::new("host")
                    .short('H')
                    .long("host")
                    .value_hint(clap::ValueHint::Hostname),
                clap::Arg::new("url")
                    .long("url")
                    .value_hint(clap::ValueHint::Url),
                clap::Arg::new("email")
                    .long("email")
                    .value_hint(clap::ValueHint::EmailAddress),
            ]),
        ])
}

```

`clap/clap_complete/src/aot/generator/mod.rs`:

```rs
//! Shell completion machinery

pub mod utils;

use std::ffi::OsString;
use std::fs::File;
use std::io::Error;
use std::io::Write;
use std::path::PathBuf;

use clap::Command;

/// Generator trait which can be used to write generators
pub trait Generator {
    /// Returns the file name that is created when this generator is called during compile time.
    ///
    /// # Panics
    ///
    /// May panic when called outside of the context of [`generate`] or [`generate_to`]
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::io::Write;
    /// # use clap::Command;
    /// use clap_complete::Generator;
    ///
    /// pub struct Fish;
    ///
    /// impl Generator for Fish {
    ///     fn file_name(&self, name: &str) -> String {
    ///         format!("{name}.fish")
    ///     }
    /// #   fn generate(&self, cmd: &Command, buf: &mut dyn Write) {}
    /// }
    /// ```
    fn file_name(&self, name: &str) -> String;

    /// Generates output out of [`clap::Command`].
    ///
    /// # Panics
    ///
    /// May panic when called outside of the context of [`generate`] or [`generate_to`]
    ///
    /// # Examples
    ///
    /// The following example generator displays the [`clap::Command`]
    /// as if it is printed using [`std::println`].
    ///
    /// ```
    /// use std::{io::Write, fmt::write};
    /// use clap::Command;
    /// use clap_complete::Generator;
    ///
    /// pub struct ClapDebug;
    ///
    /// impl Generator for ClapDebug {
    /// #   fn file_name(&self, name: &str) -> String {
    /// #       name.into()
    /// #   }
    ///     fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
    ///         write!(buf, "{cmd}").unwrap();
    ///     }
    /// }
    /// ```
    fn generate(&self, cmd: &Command, buf: &mut dyn Write);
}

/// Generate a completions file for a specified shell at compile-time.
///
/// <div class="warning">
///
/// **NOTE:** to generate the file at compile time you must use a `build.rs` "Build Script" or a
/// [`cargo-xtask`](https://github.com/matklad/cargo-xtask)
///
/// </div>
///
/// # Examples
///
/// The following example generates a bash completion script via a `build.rs` script. In this
/// simple example, we'll demo a very small application with only a single subcommand and two
/// args. Real applications could be many multiple levels deep in subcommands, and have tens or
/// potentially hundreds of arguments.
///
/// First, it helps if we separate out our `Command` definition into a separate file. Whether you
/// do this as a function, or bare Command definition is a matter of personal preference.
///
/// ```
/// // src/cli.rs
/// # use clap::{Command, Arg, ArgAction};
/// pub fn build_cli() -> Command {
///     Command::new("compl")
///         .about("Tests completions")
///         .arg(Arg::new("file")
///             .help("some input file"))
///         .subcommand(Command::new("test")
///             .about("tests things")
///             .arg(Arg::new("case")
///                 .long("case")
///                 .action(ArgAction::Set)
///                 .help("the case to test")))
/// }
/// ```
///
/// In our regular code, we can simply call this `build_cli()` function, then call
/// `get_matches()`, or any of the other normal methods directly after. For example:
///
/// ```ignore
/// // src/main.rs
///
/// mod cli;
///
/// fn main() {
///     let _m = cli::build_cli().get_matches();
///
///     // normal logic continues...
/// }
/// ```
///
/// Next, we set up our `Cargo.toml` to use a `build.rs` build script.
///
/// ```toml
/// # Cargo.toml
/// build = "build.rs"
///
/// [dependencies]
/// clap = "*"
///
/// [build-dependencies]
/// clap = "*"
/// clap_complete = "*"
/// ```
///
/// Next, we place a `build.rs` in our project root.
///
/// ```ignore
/// use clap_complete::{generate_to, shells::Bash};
/// use std::env;
/// use std::io::Error;
///
/// include!("src/cli.rs");
///
/// fn main() -> Result<(), Error> {
///     let outdir = match env::var_os("OUT_DIR") {
///         None => return Ok(()),
///         Some(outdir) => outdir,
///     };
///
///     let mut cmd = build_cli();
///     let path = generate_to(
///         Bash,
///         &mut cmd, // We need to specify what generator to use
///         "myapp",  // We need to specify the bin name manually
///         outdir,   // We need to specify where to write to
///     )?;
///
///     println!("cargo:warning=completion file is generated: {path:?}");
///
///     Ok(())
/// }
/// ```
///
/// Now, once we compile there will be a `{bin_name}.bash` file in the directory.
/// Assuming we compiled with debug mode, it would be somewhere similar to
/// `<project>/target/debug/build/myapp-<hash>/out/myapp.bash`.
///
/// <div class="warning">
///
/// **NOTE:** Please look at the individual [shells][crate::shells]
/// to see the name of the files generated.
///
/// </div>
///
/// Using [`ValueEnum::value_variants()`][clap::ValueEnum::value_variants] you can easily loop over
/// all the supported shell variants to generate all the completions at once too.
///
/// ```ignore
/// use clap::ValueEnum;
/// use clap_complete::{generate_to, Shell};
/// use std::env;
/// use std::io::Error;
///
/// include!("src/cli.rs");
///
/// fn main() -> Result<(), Error> {
///     let outdir = match env::var_os("OUT_DIR") {
///         None => return Ok(()),
///         Some(outdir) => outdir,
///     };
///
///     let mut cmd = build_cli();
///     for &shell in Shell::value_variants() {
///         generate_to(shell, &mut cmd, "myapp", outdir)?;
///     }
///
///     Ok(())
/// }
/// ```
pub fn generate_to<G, S, T>(
    generator: G,
    cmd: &mut Command,
    bin_name: S,
    out_dir: T,
) -> Result<PathBuf, Error>
where
    G: Generator,
    S: Into<String>,
    T: Into<OsString>,
{
    cmd.set_bin_name(bin_name);

    let out_dir = PathBuf::from(out_dir.into());
    let file_name = generator.file_name(cmd.get_bin_name().unwrap());

    let path = out_dir.join(file_name);
    let mut file = File::create(&path)?;

    _generate::<G>(generator, cmd, &mut file);
    Ok(path)
}

/// Generate a completions file for a specified shell at runtime.
///
/// Until `cargo install` can install extra files like a completion script, this may be
/// used e.g. in a command that outputs the contents of the completion script, to be
/// redirected into a file by the user.
///
/// # Examples
///
/// Assuming a separate `cli.rs` like the [`generate_to` example](generate_to()),
/// we can let users generate a completion script using a command:
///
/// ```ignore
/// // src/main.rs
///
/// mod cli;
/// use std::io;
/// use clap_complete::{generate, shells::Bash};
///
/// fn main() {
///     let matches = cli::build_cli().get_matches();
///
///     if matches.is_present("generate-bash-completions") {
///         generate(Bash, &mut cli::build_cli(), "myapp", &mut io::stdout());
///     }
///
///     // normal logic continues...
/// }
///
/// ```
///
/// Usage:
///
/// ```console
/// $ myapp generate-bash-completions > /usr/share/bash-completion/completions/myapp.bash
/// ```
pub fn generate<G, S>(generator: G, cmd: &mut Command, bin_name: S, buf: &mut dyn Write)
where
    G: Generator,
    S: Into<String>,
{
    cmd.set_bin_name(bin_name);
    _generate::<G>(generator, cmd, buf);
}

fn _generate<G: Generator>(generator: G, cmd: &mut Command, buf: &mut dyn Write) {
    cmd.build();
    generator.generate(cmd, buf);
}

```

`clap/clap_complete/src/aot/generator/utils.rs`:

```rs
//! Helpers for writing generators

use clap::{Arg, Command};

/// Gets all subcommands including child subcommands in the form of `("name", "bin_name")`.
///
/// Subcommand `rustup toolchain install` would be converted to
/// `("install", "rustup toolchain install")`.
pub fn all_subcommands(cmd: &Command) -> Vec<(String, String)> {
    let mut subcmds: Vec<_> = subcommands(cmd);

    for sc_v in cmd.get_subcommands().map(all_subcommands) {
        subcmds.extend(sc_v);
    }

    subcmds
}

/// Finds the subcommand [`clap::Command`] from the given [`clap::Command`] with the given path.
///
/// <div class="warning">
///
/// **NOTE:** `path` should not contain the root `bin_name`.
///
/// </div>
pub fn find_subcommand_with_path<'cmd>(p: &'cmd Command, path: Vec<&str>) -> &'cmd Command {
    let mut cmd = p;

    for sc in path {
        cmd = cmd.find_subcommand(sc).unwrap();
    }

    cmd
}

/// Gets subcommands of [`clap::Command`] in the form of `("name", "bin_name")`.
///
/// Subcommand `rustup toolchain install` would be converted to
/// `("install", "rustup toolchain install")`.
pub fn subcommands(p: &Command) -> Vec<(String, String)> {
    debug!("subcommands: name={}", p.get_name());
    debug!("subcommands: Has subcommands...{:?}", p.has_subcommands());

    let mut subcmds = vec![];

    for sc in p.get_subcommands() {
        let sc_bin_name = sc.get_bin_name().unwrap();

        debug!(
            "subcommands:iter: name={}, bin_name={}",
            sc.get_name(),
            sc_bin_name
        );
        subcmds.push((sc.get_name().to_string(), sc_bin_name.to_string()));

        for alias in sc.get_visible_aliases() {
            debug!(
                "subcommands:iter: alias={}, bin_name={}",
                alias, sc_bin_name
            );
            subcmds.push((alias.to_string(), sc_bin_name.to_string()));
        }
    }

    subcmds
}

/// Gets all the short options, their visible aliases and flags of a [`clap::Command`].
/// Includes `h` and `V` depending on the [`clap::Command`] settings.
pub fn shorts_and_visible_aliases(p: &Command) -> Vec<char> {
    debug!("shorts: name={}", p.get_name());

    p.get_arguments()
        .filter_map(|a| {
            if !a.is_positional() {
                if a.get_visible_short_aliases().is_some() && a.get_short().is_some() {
                    let mut shorts_and_visible_aliases = a.get_visible_short_aliases().unwrap();
                    shorts_and_visible_aliases.push(a.get_short().unwrap());
                    Some(shorts_and_visible_aliases)
                } else if a.get_visible_short_aliases().is_none() && a.get_short().is_some() {
                    Some(vec![a.get_short().unwrap()])
                } else {
                    None
                }
            } else {
                None
            }
        })
        .flatten()
        .collect()
}

/// Gets all the long options, their visible aliases and flags of a [`clap::Command`].
/// Includes `help` and `version` depending on the [`clap::Command`] settings.
pub fn longs_and_visible_aliases(p: &Command) -> Vec<String> {
    debug!("longs: name={}", p.get_name());

    p.get_arguments()
        .filter_map(|a| {
            if !a.is_positional() {
                if a.get_visible_aliases().is_some() && a.get_long().is_some() {
                    let mut visible_aliases: Vec<_> = a
                        .get_visible_aliases()
                        .unwrap()
                        .into_iter()
                        .map(|s| s.to_string())
                        .collect();
                    visible_aliases.push(a.get_long().unwrap().to_string());
                    Some(visible_aliases)
                } else if a.get_visible_aliases().is_none() && a.get_long().is_some() {
                    Some(vec![a.get_long().unwrap().to_string()])
                } else {
                    None
                }
            } else {
                None
            }
        })
        .flatten()
        .collect()
}

/// Gets all the flags of a [`clap::Command`].
/// Includes `help` and `version` depending on the [`clap::Command`] settings.
pub fn flags(p: &Command) -> Vec<Arg> {
    debug!("flags: name={}", p.get_name());
    p.get_arguments()
        .filter(|a| !a.get_num_args().expect("built").takes_values() && !a.is_positional())
        .cloned()
        .collect()
}

/// Get the possible values for completion
pub fn possible_values(a: &Arg) -> Option<Vec<clap::builder::PossibleValue>> {
    if !a.get_num_args().expect("built").takes_values() {
        None
    } else {
        a.get_value_parser()
            .possible_values()
            .map(|pvs| pvs.collect())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use clap::Arg;
    use clap::ArgAction;

    fn common_app() -> Command {
        Command::new("myapp")
            .subcommand(
                Command::new("test").subcommand(Command::new("config")).arg(
                    Arg::new("file")
                        .short('f')
                        .short_alias('c')
                        .visible_short_alias('p')
                        .long("file")
                        .action(ArgAction::SetTrue)
                        .visible_alias("path"),
                ),
            )
            .subcommand(Command::new("hello"))
            .bin_name("my-cmd")
    }

    fn built() -> Command {
        let mut cmd = common_app();

        cmd.build();
        cmd
    }

    fn built_with_version() -> Command {
        let mut cmd = common_app().version("3.0");

        cmd.build();
        cmd
    }

    #[test]
    fn test_subcommands() {
        let cmd = built_with_version();

        assert_eq!(
            subcommands(&cmd),
            vec![
                ("test".to_string(), "my-cmd test".to_string()),
                ("hello".to_string(), "my-cmd hello".to_string()),
                ("help".to_string(), "my-cmd help".to_string()),
            ]
        );
    }

    #[test]
    fn test_all_subcommands() {
        let cmd = built_with_version();

        assert_eq!(
            all_subcommands(&cmd),
            vec![
                ("test".to_string(), "my-cmd test".to_string()),
                ("hello".to_string(), "my-cmd hello".to_string()),
                ("help".to_string(), "my-cmd help".to_string()),
                ("config".to_string(), "my-cmd test config".to_string()),
                ("help".to_string(), "my-cmd test help".to_string()),
                ("config".to_string(), "my-cmd test help config".to_string()),
                ("help".to_string(), "my-cmd test help help".to_string()),
                ("test".to_string(), "my-cmd help test".to_string()),
                ("hello".to_string(), "my-cmd help hello".to_string()),
                ("help".to_string(), "my-cmd help help".to_string()),
                ("config".to_string(), "my-cmd help test config".to_string()),
            ]
        );
    }

    #[test]
    fn test_find_subcommand_with_path() {
        let cmd = built_with_version();
        let sc_app = find_subcommand_with_path(&cmd, "test config".split(' ').collect());

        assert_eq!(sc_app.get_name(), "config");
    }

    #[test]
    fn test_flags() {
        let cmd = built_with_version();
        let actual_flags = flags(&cmd);

        assert_eq!(actual_flags.len(), 2);
        assert_eq!(actual_flags[0].get_long(), Some("help"));
        assert_eq!(actual_flags[1].get_long(), Some("version"));

        let sc_flags = flags(find_subcommand_with_path(&cmd, vec!["test"]));

        assert_eq!(sc_flags.len(), 2);
        assert_eq!(sc_flags[0].get_long(), Some("file"));
        assert_eq!(sc_flags[1].get_long(), Some("help"));
    }

    #[test]
    fn test_flag_subcommand() {
        let cmd = built();
        let actual_flags = flags(&cmd);

        assert_eq!(actual_flags.len(), 1);
        assert_eq!(actual_flags[0].get_long(), Some("help"));

        let sc_flags = flags(find_subcommand_with_path(&cmd, vec!["test"]));

        assert_eq!(sc_flags.len(), 2);
        assert_eq!(sc_flags[0].get_long(), Some("file"));
        assert_eq!(sc_flags[1].get_long(), Some("help"));
    }

    #[test]
    fn test_shorts() {
        let cmd = built_with_version();
        let shorts = shorts_and_visible_aliases(&cmd);

        assert_eq!(shorts.len(), 2);
        assert_eq!(shorts[0], 'h');
        assert_eq!(shorts[1], 'V');

        let sc_shorts = shorts_and_visible_aliases(find_subcommand_with_path(&cmd, vec!["test"]));

        assert_eq!(sc_shorts.len(), 3);
        assert_eq!(sc_shorts[0], 'p');
        assert_eq!(sc_shorts[1], 'f');
        assert_eq!(sc_shorts[2], 'h');
    }

    #[test]
    fn test_longs() {
        let cmd = built_with_version();
        let longs = longs_and_visible_aliases(&cmd);

        assert_eq!(longs.len(), 2);
        assert_eq!(longs[0], "help");
        assert_eq!(longs[1], "version");

        let sc_longs = longs_and_visible_aliases(find_subcommand_with_path(&cmd, vec!["test"]));

        assert_eq!(sc_longs.len(), 3);
        assert_eq!(sc_longs[0], "path");
        assert_eq!(sc_longs[1], "file");
        assert_eq!(sc_longs[2], "help");
    }
}

```

`clap/clap_complete/src/aot/mod.rs`:

```rs
//! Prebuilt completions
//!
//! ## Quick Start
//!
//! - For generating at compile-time, see [`generate_to`]
//! - For generating at runtime, see [`generate`]
//!
//! [`Shell`] is a convenience `enum` for an argument value type that implements `Generator`
//! for each natively-supported shell type.
//!
//! To customize completions, see
//! - [`ValueHint`]
//! - [`ValueEnum`][clap::ValueEnum]
//!
//! ## Example
//!
//! ```rust,no_run
//! use clap::{Command, Arg, ValueHint, value_parser, ArgAction};
//! use clap_complete::{generate, Generator, Shell};
//! use std::io;
//!
//! fn build_cli() -> Command {
//!     Command::new("example")
//!          .arg(Arg::new("file")
//!              .help("some input file")
//!                 .value_hint(ValueHint::AnyPath),
//!         )
//!        .arg(
//!            Arg::new("generator")
//!                .long("generate")
//!                .action(ArgAction::Set)
//!                .value_parser(value_parser!(Shell)),
//!        )
//! }
//!
//! fn print_completions<G: Generator>(generator: G, cmd: &mut Command) {
//!     generate(generator, cmd, cmd.get_name().to_string(), &mut io::stdout());
//! }
//!
//! fn main() {
//!     let matches = build_cli().get_matches();
//!
//!     if let Some(generator) = matches.get_one::<Shell>("generator").copied() {
//!         let mut cmd = build_cli();
//!         eprintln!("Generating completion file for {generator}...");
//!         print_completions(generator, &mut cmd);
//!     }
//! }
//! ```

mod generator;
mod shells;

pub use clap::ValueHint;
pub use generator::*;
pub use shells::*;

```

`clap/clap_complete/src/aot/shells/bash.rs`:

```rs
use std::{fmt::Write as _, io::Write};

use clap::{Arg, Command, ValueHint};

use crate::generator::{utils, Generator};

/// Generate bash completion file
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Bash;

impl Generator for Bash {
    fn file_name(&self, name: &str) -> String {
        format!("{name}.bash")
    }

    fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
        let bin_name = cmd
            .get_bin_name()
            .expect("crate::generate should have set the bin_name");

        let fn_name = bin_name.replace('-', "__");

        write!(
            buf,
            "_{name}() {{
    local i cur prev opts cmd
    COMPREPLY=()
    cur=\"${{COMP_WORDS[COMP_CWORD]}}\"
    prev=\"${{COMP_WORDS[COMP_CWORD-1]}}\"
    cmd=\"\"
    opts=\"\"

    for i in ${{COMP_WORDS[@]}}
    do
        case \"${{cmd}},${{i}}\" in
            \",$1\")
                cmd=\"{cmd}\"
                ;;{subcmds}
            *)
                ;;
        esac
    done

    case \"${{cmd}}\" in
        {cmd})
            opts=\"{name_opts}\"
            if [[ ${{cur}} == -* || ${{COMP_CWORD}} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )
                return 0
            fi
            case \"${{prev}}\" in{name_opts_details}
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )
            return 0
            ;;{subcmd_details}
    esac
}}

if [[ \"${{BASH_VERSINFO[0]}}\" -eq 4 && \"${{BASH_VERSINFO[1]}}\" -ge 4 || \"${{BASH_VERSINFO[0]}}\" -gt 4 ]]; then
    complete -F _{name} -o nosort -o bashdefault -o default {name}
else
    complete -F _{name} -o bashdefault -o default {name}
fi
",
            name = bin_name,
            cmd = fn_name,
            name_opts = all_options_for_path(cmd, bin_name),
            name_opts_details = option_details_for_path(cmd, bin_name),
            subcmds = all_subcommands(cmd, &fn_name),
            subcmd_details = subcommand_details(cmd)
        ).expect("failed to write completion file");
    }
}

fn all_subcommands(cmd: &Command, parent_fn_name: &str) -> String {
    debug!("all_subcommands");

    fn add_command(
        parent_fn_name: &str,
        cmd: &Command,
        subcmds: &mut Vec<(String, String, String)>,
    ) {
        let fn_name = format!(
            "{parent_fn_name}__{cmd_name}",
            parent_fn_name = parent_fn_name,
            cmd_name = cmd.get_name().to_string().replace('-', "__")
        );
        subcmds.push((
            parent_fn_name.to_string(),
            cmd.get_name().to_string(),
            fn_name.clone(),
        ));
        for alias in cmd.get_visible_aliases() {
            subcmds.push((
                parent_fn_name.to_string(),
                alias.to_string(),
                fn_name.clone(),
            ));
        }
        for subcmd in cmd.get_subcommands() {
            add_command(&fn_name, subcmd, subcmds);
        }
    }
    let mut subcmds = vec![];
    for subcmd in cmd.get_subcommands() {
        add_command(parent_fn_name, subcmd, &mut subcmds);
    }
    subcmds.sort();

    let mut cases = vec![String::new()];
    for (parent_fn_name, name, fn_name) in subcmds {
        cases.push(format!(
            "{parent_fn_name},{name})
                cmd=\"{fn_name}\"
                ;;",
        ));
    }

    cases.join("\n            ")
}

fn subcommand_details(cmd: &Command) -> String {
    debug!("subcommand_details");

    let mut subcmd_dets = vec![String::new()];
    let mut scs = utils::all_subcommands(cmd)
        .iter()
        .map(|x| x.1.replace(' ', "__"))
        .collect::<Vec<_>>();

    scs.sort();
    scs.dedup();

    subcmd_dets.extend(scs.iter().map(|sc| {
        format!(
            "{subcmd})
            opts=\"{sc_opts}\"
            if [[ ${{cur}} == -* || ${{COMP_CWORD}} -eq {level} ]] ; then
                COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )
                return 0
            fi
            case \"${{prev}}\" in{opts_details}
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W \"${{opts}}\" -- \"${{cur}}\") )
            return 0
            ;;",
            subcmd = sc.replace('-', "__"),
            sc_opts = all_options_for_path(cmd, sc),
            level = sc.split("__").map(|_| 1).sum::<u64>(),
            opts_details = option_details_for_path(cmd, sc)
        )
    }));

    subcmd_dets.join("\n        ")
}

fn option_details_for_path(cmd: &Command, path: &str) -> String {
    debug!("option_details_for_path: path={path}");

    let p = utils::find_subcommand_with_path(cmd, path.split("__").skip(1).collect());
    let mut opts = vec![String::new()];

    for o in p.get_opts() {
        let compopt = match o.get_value_hint() {
            ValueHint::FilePath => Some("compopt -o filenames"),
            ValueHint::DirPath => Some("compopt -o plusdirs"),
            ValueHint::Other => Some("compopt -o nospace"),
            _ => None,
        };

        if let Some(longs) = o.get_long_and_visible_aliases() {
            opts.extend(longs.iter().map(|long| {
                let mut v = vec![format!("--{})", long)];

                if o.get_value_hint() == ValueHint::FilePath {
                    v.extend([
                        "local oldifs".to_string(),
                        r#"if [ -n "${IFS+x}" ]; then"#.to_string(),
                        r#"    oldifs="$IFS""#.to_string(),
                        "fi".to_string(),
                        r#"IFS=$'\n'"#.to_string(),
                        format!("COMPREPLY=({})", vals_for(o)),
                        r#"if [ -n "${oldifs+x}" ]; then"#.to_string(),
                        r#"    IFS="$oldifs""#.to_string(),
                        "fi".to_string(),
                    ]);
                } else {
                    v.push(format!("COMPREPLY=({})", vals_for(o)));
                }

                if let Some(copt) = compopt {
                    v.extend([
                        r#"if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then"#.to_string(),
                        format!("    {copt}"),
                        "fi".to_string(),
                    ]);
                }

                v.extend(["return 0", ";;"].iter().map(|s| (*s).to_string()));
                v.join("\n                    ")
            }));
        }

        if let Some(shorts) = o.get_short_and_visible_aliases() {
            opts.extend(shorts.iter().map(|short| {
                let mut v = vec![format!("-{})", short)];

                if o.get_value_hint() == ValueHint::FilePath {
                    v.extend([
                        "local oldifs".to_string(),
                        r#"if [ -n "${IFS+x}" ]; then"#.to_string(),
                        r#"    oldifs="$IFS""#.to_string(),
                        "fi".to_string(),
                        r#"IFS=$'\n'"#.to_string(),
                        format!("COMPREPLY=({})", vals_for(o)),
                        r#"if [ -n "${oldifs+x}" ]; then"#.to_string(),
                        r#"    IFS="$oldifs""#.to_string(),
                        "fi".to_string(),
                    ]);
                } else {
                    v.push(format!("COMPREPLY=({})", vals_for(o)));
                }

                if let Some(copt) = compopt {
                    v.extend([
                        r#"if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then"#.to_string(),
                        format!("    {copt}"),
                        "fi".to_string(),
                    ]);
                }

                v.extend(["return 0", ";;"].iter().map(|s| (*s).to_string()));
                v.join("\n                    ")
            }));
        }
    }

    opts.join("\n                ")
}

fn vals_for(o: &Arg) -> String {
    debug!("vals_for: o={}", o.get_id());

    if let Some(vals) = utils::possible_values(o) {
        format!(
            "$(compgen -W \"{}\" -- \"${{cur}}\")",
            vals.iter()
                .filter(|pv| !pv.is_hide_set())
                .map(|n| n.get_name())
                .collect::<Vec<_>>()
                .join(" ")
        )
    } else if o.get_value_hint() == ValueHint::DirPath {
        String::from("") // should be empty to avoid duplicate candidates
    } else if o.get_value_hint() == ValueHint::Other {
        String::from("\"${cur}\"")
    } else {
        String::from("$(compgen -f \"${cur}\")")
    }
}

fn all_options_for_path(cmd: &Command, path: &str) -> String {
    debug!("all_options_for_path: path={path}");

    let p = utils::find_subcommand_with_path(cmd, path.split("__").skip(1).collect());

    let mut opts = String::new();
    for short in utils::shorts_and_visible_aliases(p) {
        write!(&mut opts, "-{short} ").expect("writing to String is infallible");
    }
    for long in utils::longs_and_visible_aliases(p) {
        write!(&mut opts, "--{long} ").expect("writing to String is infallible");
    }
    for pos in p.get_positionals() {
        if let Some(vals) = utils::possible_values(pos) {
            for value in vals {
                write!(&mut opts, "{} ", value.get_name())
                    .expect("writing to String is infallible");
            }
        } else {
            write!(&mut opts, "{pos} ").expect("writing to String is infallible");
        }
    }
    for (sc, _) in utils::subcommands(p) {
        write!(&mut opts, "{sc} ").expect("writing to String is infallible");
    }
    opts.pop();

    opts
}

```

`clap/clap_complete/src/aot/shells/elvish.rs`:

```rs
use std::io::Write;

use clap::builder::StyledStr;
use clap::Command;

use crate::generator::{utils, Generator};
use crate::INTERNAL_ERROR_MSG;

/// Generate elvish completion file
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Elvish;

impl Generator for Elvish {
    fn file_name(&self, name: &str) -> String {
        format!("{name}.elv")
    }

    fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
        let bin_name = cmd
            .get_bin_name()
            .expect("crate::generate should have set the bin_name");

        let subcommands_cases = generate_inner(cmd, "");

        write!(
            buf,
            r#"
use builtin;
use str;

set edit:completion:arg-completer[{bin_name}] = {{|@words|
    fn spaces {{|n|
        builtin:repeat $n ' ' | str:join ''
    }}
    fn cand {{|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }}
    var command = '{bin_name}'
    for word $words[1..-1] {{
        if (str:has-prefix $word '-') {{
            break
        }}
        set command = $command';'$word
    }}
    var completions = [{subcommands_cases}
    ]
    $completions[$command]
}}
"#,
        )
        .expect("failed to write completion file");
    }
}

// Escape string inside single quotes
fn escape_string(string: &str) -> String {
    string.replace('\'', "''")
}

fn escape_help<T: ToString>(help: Option<&StyledStr>, data: T) -> String {
    match help {
        Some(help) => escape_string(&help.to_string().replace('\n', " ")),
        _ => data.to_string(),
    }
}

fn generate_inner(p: &Command, previous_command_name: &str) -> String {
    debug!("generate_inner");

    let command_names = if previous_command_name.is_empty() {
        vec![p.get_bin_name().expect(INTERNAL_ERROR_MSG).to_string()]
    } else {
        p.get_name_and_visible_aliases()
            .into_iter()
            .map(|name| format!("{previous_command_name};{name}"))
            .collect()
    };

    let mut completions = String::new();
    let preamble = String::from("\n            cand ");

    for option in p.get_opts() {
        if let Some(shorts) = option.get_short_and_visible_aliases() {
            let tooltip = escape_help(option.get_help(), shorts[0]);
            for short in shorts {
                completions.push_str(&preamble);
                completions.push_str(format!("-{short} '{tooltip}'").as_str());
            }
        }

        if let Some(longs) = option.get_long_and_visible_aliases() {
            let tooltip = escape_help(option.get_help(), longs[0]);
            for long in longs {
                completions.push_str(&preamble);
                completions.push_str(format!("--{long} '{tooltip}'").as_str());
            }
        }
    }

    for flag in utils::flags(p) {
        if let Some(shorts) = flag.get_short_and_visible_aliases() {
            let tooltip = escape_help(flag.get_help(), shorts[0]);
            for short in shorts {
                completions.push_str(&preamble);
                completions.push_str(format!("-{short} '{tooltip}'").as_str());
            }
        }

        if let Some(longs) = flag.get_long_and_visible_aliases() {
            let tooltip = escape_help(flag.get_help(), longs[0]);
            for long in longs {
                completions.push_str(&preamble);
                completions.push_str(format!("--{long} '{tooltip}'").as_str());
            }
        }
    }

    for subcommand in p.get_subcommands() {
        for name in subcommand.get_name_and_visible_aliases() {
            let tooltip = escape_help(subcommand.get_about(), name);

            completions.push_str(&preamble);
            completions.push_str(format!("{name} '{tooltip}'").as_str());
        }
    }

    let mut subcommands_cases = String::new();
    for command_name in &command_names {
        subcommands_cases.push_str(&format!(
            r"
        &'{}'= {{{}
        }}",
            &command_name, completions
        ));
    }

    for subcommand in p.get_subcommands() {
        for command_name in &command_names {
            let subcommand_subcommands_cases = generate_inner(subcommand, command_name);
            subcommands_cases.push_str(&subcommand_subcommands_cases);
        }
    }

    subcommands_cases
}

```

`clap/clap_complete/src/aot/shells/fish.rs`:

```rs
use std::io::Write;

use clap::{builder, Arg, Command, ValueHint};

use crate::generator::{utils, Generator};

/// Generate fish completion file
///
/// Note: The fish generator currently only supports named options (-o/--option), not positional arguments.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Fish;

impl Generator for Fish {
    fn file_name(&self, name: &str) -> String {
        format!("{name}.fish")
    }

    fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
        let bin_name = cmd
            .get_bin_name()
            .expect("crate::generate should have set the bin_name");

        let name = escape_name(bin_name);
        let mut needs_fn_name = &format!("__fish_{name}_needs_command")[..];
        let mut using_fn_name = &format!("__fish_{name}_using_subcommand")[..];
        // Given `git --git-dir somedir status`, using `__fish_seen_subcommand_from` won't help us
        // find out `status` is the real subcommand, and not `somedir`. However, when there are no subcommands,
        // there is no need to use our custom stubs.
        if cmd.has_subcommands() {
            gen_subcommand_helpers(&name, cmd, buf, needs_fn_name, using_fn_name);
        } else {
            needs_fn_name = "__fish_use_subcommand";
            using_fn_name = "__fish_seen_subcommand_from";
        }

        let mut buffer = String::new();
        gen_fish_inner(
            bin_name,
            &[],
            cmd,
            &mut buffer,
            needs_fn_name,
            using_fn_name,
        );
        write!(buf, "{buffer}").expect("failed to write completion file");
    }
}

// Escape string inside single quotes
fn escape_string(string: &str, escape_comma: bool) -> String {
    let string = string.replace('\\', "\\\\").replace('\'', "\\'");
    if escape_comma {
        string.replace(',', "\\,")
    } else {
        string
    }
}

fn escape_help(help: &builder::StyledStr) -> String {
    escape_string(&help.to_string().replace('\n', " "), false)
}

fn escape_name(name: &str) -> String {
    name.replace('-', "_")
}

fn gen_fish_inner(
    root_command: &str,
    parent_commands: &[&str],
    cmd: &Command,
    buffer: &mut String,
    needs_fn_name: &str,
    using_fn_name: &str,
) {
    debug!("gen_fish_inner");
    // example :
    //
    // complete
    //      -c {command}
    //      -d "{description}"
    //      -s {short}
    //      -l {long}
    //      -a "{possible_arguments}"
    //      -r # if require parameter
    //      -f # don't use file completion
    //      -n "{needs_fn_name}"            # complete for command "myprog"
    //      -n "{using_fn_name} subcmd1"    # complete for command "myprog subcmd1"

    let mut basic_template = format!("complete -c {root_command}");

    if parent_commands.is_empty() {
        if cmd.has_subcommands() {
            basic_template.push_str(&format!(" -n \"{needs_fn_name}\""));
        }
    } else {
        let mut out = String::from(using_fn_name);
        match parent_commands {
            [] => unreachable!(),
            [command] => {
                out.push_str(&format!(" {command}"));
                if cmd.has_subcommands() {
                    out.push_str("; and not __fish_seen_subcommand_from");
                }
                let subcommands = cmd
                    .get_subcommands()
                    .flat_map(Command::get_name_and_visible_aliases);
                for name in subcommands {
                    out.push_str(&format!(" {name}"));
                }
            }
            [command, subcommand] => out.push_str(&format!(
                " {command}; and __fish_seen_subcommand_from {subcommand}"
            )),
            // HACK: Assuming subcommands are only nested less than 3 levels as more than that is
            // unwieldy and takes more effort to support.
            // For example, `rustup toolchain help install` is the longest valid command line of `rustup`
            // that uses nested subcommands, and it cannot receive any flags to it.
            _ => return,
        }
        basic_template.push_str(format!(" -n \"{out}\"").as_str());
    }

    debug!("gen_fish_inner: parent_commands={parent_commands:?}");

    for option in cmd.get_opts() {
        let mut template = basic_template.clone();

        if let Some(shorts) = option.get_short_and_visible_aliases() {
            for short in shorts {
                template.push_str(format!(" -s {short}").as_str());
            }
        }

        if let Some(longs) = option.get_long_and_visible_aliases() {
            for long in longs {
                template.push_str(format!(" -l {}", escape_string(long, false)).as_str());
            }
        }

        if let Some(data) = option.get_help() {
            template.push_str(&format!(" -d '{}'", escape_help(data)));
        }

        template.push_str(value_completion(option).as_str());

        buffer.push_str(template.as_str());
        buffer.push('\n');
    }

    for flag in utils::flags(cmd) {
        let mut template = basic_template.clone();

        if let Some(shorts) = flag.get_short_and_visible_aliases() {
            for short in shorts {
                template.push_str(format!(" -s {short}").as_str());
            }
        }

        if let Some(longs) = flag.get_long_and_visible_aliases() {
            for long in longs {
                template.push_str(format!(" -l {}", escape_string(long, false)).as_str());
            }
        }

        if let Some(data) = flag.get_help() {
            template.push_str(&format!(" -d '{}'", escape_help(data)));
        }

        buffer.push_str(template.as_str());
        buffer.push('\n');
    }

    let has_positionals = cmd.get_positionals().next().is_some();
    if !has_positionals {
        basic_template.push_str(" -f");
    }
    for subcommand in cmd.get_subcommands() {
        for subcommand_name in subcommand.get_name_and_visible_aliases() {
            let mut template = basic_template.clone();

            template.push_str(format!(" -a \"{subcommand_name}\"").as_str());

            if let Some(data) = subcommand.get_about() {
                template.push_str(format!(" -d '{}'", escape_help(data)).as_str());
            }

            buffer.push_str(template.as_str());
            buffer.push('\n');
        }
    }

    // generate options of subcommands
    for subcommand in cmd.get_subcommands() {
        for subcommand_name in subcommand.get_name_and_visible_aliases() {
            let mut parent_commands: Vec<_> = parent_commands.into();
            parent_commands.push(subcommand_name);
            gen_fish_inner(
                root_command,
                &parent_commands,
                subcommand,
                buffer,
                needs_fn_name,
                using_fn_name,
            );
        }
    }
}

/// Print fish's helpers for easy handling subcommands.
fn gen_subcommand_helpers(
    bin_name: &str,
    cmd: &Command,
    buf: &mut dyn Write,
    needs_fn_name: &str,
    using_fn_name: &str,
) {
    let mut optspecs = String::new();
    let cmd_opts = cmd.get_arguments().filter(|a| !a.is_positional());
    for option in cmd_opts {
        optspecs.push(' ');
        let mut has_short = false;
        if let Some(short) = option.get_short() {
            has_short = true;
            optspecs.push(short);
        }

        if let Some(long) = option.get_long() {
            if has_short {
                optspecs.push('/');
            }
            optspecs.push_str(&escape_string(long, false));
        }

        let is_an_option = option
            .get_num_args()
            .map(|r| r.takes_values())
            .unwrap_or(true);
        if is_an_option {
            optspecs.push('=');
        }
    }
    let optspecs_fn_name = format!("__fish_{bin_name}_global_optspecs");
    write!(
        buf,
        "\
        # Print an optspec for argparse to handle cmd's options that are independent of any subcommand.\n\
        function {optspecs_fn_name}\n\
        \tstring join \\n{optspecs}\n\
        end\n\n\
        function {needs_fn_name}\n\
        \t# Figure out if the current invocation already has a command.\n\
        \tset -l cmd (commandline -opc)\n\
        \tset -e cmd[1]\n\
        \targparse -s ({optspecs_fn_name}) -- $cmd 2>/dev/null\n\
        \tor return\n\
        \tif set -q argv[1]\n\
        \t\t# Also print the command, so this can be used to figure out what it is.\n\
        \t\techo $argv[1]\n\
        \t\treturn 1\n\
        \tend\n\
        \treturn 0\n\
        end\n\n\
        function {using_fn_name}\n\
        \tset -l cmd ({needs_fn_name})\n\
        \ttest -z \"$cmd\"\n\
        \tand return 1\n\
        \tcontains -- $cmd[1] $argv\n\
        end\n\n\
    ").expect("failed to write completion file");
}

fn value_completion(option: &Arg) -> String {
    if !option.get_num_args().expect("built").takes_values() {
        return "".to_string();
    }

    if let Some(data) = utils::possible_values(option) {
        // We return the possible values with their own empty description e.g. "a\t''\nb\t''"
        // this makes sure that a and b don't get the description of the option or argument
        format!(
            " -r -f -a \"{}\"",
            data.iter()
                .filter_map(|value| if value.is_hide_set() {
                    None
                } else {
                    // The help text after \t is wrapped in '' to make sure that the it is taken literally
                    // and there is no command substitution or variable expansion resulting in unexpected errors
                    Some(format!(
                        "{}\\t'{}'",
                        escape_string(value.get_name(), true).as_str(),
                        escape_help(value.get_help().unwrap_or_default())
                    ))
                })
                .collect::<Vec<_>>()
                .join("\n")
        )
    } else {
        // NB! If you change this, please also update the table in `ValueHint` documentation.
        match option.get_value_hint() {
            ValueHint::Unknown => " -r",
            // fish has no built-in support to distinguish these
            ValueHint::AnyPath | ValueHint::FilePath | ValueHint::ExecutablePath => " -r -F",
            ValueHint::DirPath => " -r -f -a \"(__fish_complete_directories)\"",
            // It seems fish has no built-in support for completing command + arguments as
            // single string (CommandString). Complete just the command name.
            ValueHint::CommandString | ValueHint::CommandName => {
                " -r -f -a \"(__fish_complete_command)\""
            }
            ValueHint::Username => " -r -f -a \"(__fish_complete_users)\"",
            ValueHint::Hostname => " -r -f -a \"(__fish_print_hostnames)\"",
            // Disable completion for others
            _ => " -r -f",
        }
        .to_string()
    }
}

```

`clap/clap_complete/src/aot/shells/mod.rs`:

```rs
//! Shell-specific generators

mod bash;
mod elvish;
mod fish;
mod powershell;
mod shell;
mod zsh;

pub use bash::Bash;
pub use elvish::Elvish;
pub use fish::Fish;
pub use powershell::PowerShell;
pub use shell::Shell;
pub use zsh::Zsh;

```

`clap/clap_complete/src/aot/shells/powershell.rs`:

```rs
use std::io::Write;

use clap::builder::StyledStr;
use clap::{Arg, Command};

use crate::generator::{utils, Generator};
use crate::INTERNAL_ERROR_MSG;

/// Generate powershell completion file
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct PowerShell;

impl Generator for PowerShell {
    fn file_name(&self, name: &str) -> String {
        format!("_{name}.ps1")
    }

    fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
        let bin_name = cmd
            .get_bin_name()
            .expect("crate::generate should have set the bin_name");

        let subcommands_cases = generate_inner(cmd, "");

        write!(
            buf,
            r#"
using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName '{bin_name}' -ScriptBlock {{
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        '{bin_name}'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {{
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {{
                break
        }}
        $element.Value
    }}) -join ';'

    $completions = @(switch ($command) {{{subcommands_cases}
    }})

    $completions.Where{{ $_.CompletionText -like "$wordToComplete*" }} |
        Sort-Object -Property ListItemText
}}
"#
        )
        .expect("failed to write completion file");
    }
}

// Escape string inside single quotes
fn escape_string(string: &str) -> String {
    string.replace('\'', "''").replace('’', "'’")
}

fn escape_help<T: ToString>(help: Option<&StyledStr>, data: T) -> String {
    if let Some(help) = help {
        let help_str = help.to_string();
        if !help_str.is_empty() {
            return escape_string(&help_str.replace('\n', " "));
        }
    }
    data.to_string()
}

fn generate_inner(p: &Command, previous_command_name: &str) -> String {
    debug!("generate_inner");

    let command_names = if previous_command_name.is_empty() {
        vec![p.get_bin_name().expect(INTERNAL_ERROR_MSG).to_string()]
    } else {
        p.get_name_and_visible_aliases()
            .into_iter()
            .map(|name| format!("{previous_command_name};{name}"))
            .collect()
    };

    let mut completions = String::new();
    let preamble = String::from("\n            [CompletionResult]::new(");

    for option in p.get_opts() {
        generate_aliases(&mut completions, &preamble, option);
    }

    for flag in utils::flags(p) {
        generate_aliases(&mut completions, &preamble, &flag);
    }

    for subcommand in p.get_subcommands() {
        for name in subcommand.get_name_and_visible_aliases() {
            let tooltip = escape_help(subcommand.get_about(), name);
            completions.push_str(&preamble);
            completions.push_str(&format!(
                "'{name}', '{name}', [CompletionResultType]::ParameterValue, '{tooltip}')"
            ));
        }
    }

    let mut subcommands_cases = String::new();
    for command_name in &command_names {
        subcommands_cases.push_str(&format!(
            r"
        '{command_name}' {{{completions}
            break
        }}"
        ));
    }

    for subcommand in p.get_subcommands() {
        for command_name in &command_names {
            let subcommand_subcommands_cases = generate_inner(subcommand, command_name);
            subcommands_cases.push_str(&subcommand_subcommands_cases);
        }
    }

    subcommands_cases
}

fn generate_aliases(completions: &mut String, preamble: &String, arg: &Arg) {
    use std::fmt::Write as _;

    if let Some(aliases) = arg.get_short_and_visible_aliases() {
        let tooltip = escape_help(arg.get_help(), aliases[0]);
        for alias in aliases {
            let _ = write!(
                completions,
                "{preamble}'-{alias}', '-{alias}{}', [CompletionResultType]::ParameterName, '{tooltip}')",
                // make PowerShell realize there is a difference between `-s` and `-S`
                if alias.is_uppercase() { " " } else { "" },
            );
        }
    }
    if let Some(aliases) = arg.get_long_and_visible_aliases() {
        let tooltip = escape_help(arg.get_help(), aliases[0]);
        for alias in aliases {
            let _ = write!(
                completions,
                "{preamble}'--{alias}', '--{alias}', [CompletionResultType]::ParameterName, '{tooltip}')"
            );
        }
    }
}

```

`clap/clap_complete/src/aot/shells/shell.rs`:

```rs
use std::fmt::Display;
use std::path::Path;
use std::str::FromStr;

use clap::builder::PossibleValue;
use clap::ValueEnum;

use crate::shells;
use crate::Generator;

/// Shell with auto-generated completion script available.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
#[non_exhaustive]
pub enum Shell {
    /// Bourne Again `SHell` (bash)
    Bash,
    /// Elvish shell
    Elvish,
    /// Friendly Interactive `SHell` (fish)
    Fish,
    /// `PowerShell`
    PowerShell,
    /// Z `SHell` (zsh)
    Zsh,
}

impl Display for Shell {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.to_possible_value()
            .expect("no values are skipped")
            .get_name()
            .fmt(f)
    }
}

impl FromStr for Shell {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        for variant in Self::value_variants() {
            if variant.to_possible_value().unwrap().matches(s, false) {
                return Ok(*variant);
            }
        }
        Err(format!("invalid variant: {s}"))
    }
}

// Hand-rolled so it can work even when `derive` feature is disabled
impl ValueEnum for Shell {
    fn value_variants<'a>() -> &'a [Self] {
        &[
            Shell::Bash,
            Shell::Elvish,
            Shell::Fish,
            Shell::PowerShell,
            Shell::Zsh,
        ]
    }

    fn to_possible_value(&self) -> Option<PossibleValue> {
        Some(match self {
            Shell::Bash => PossibleValue::new("bash"),
            Shell::Elvish => PossibleValue::new("elvish"),
            Shell::Fish => PossibleValue::new("fish"),
            Shell::PowerShell => PossibleValue::new("powershell"),
            Shell::Zsh => PossibleValue::new("zsh"),
        })
    }
}

impl Generator for Shell {
    fn file_name(&self, name: &str) -> String {
        match self {
            Shell::Bash => shells::Bash.file_name(name),
            Shell::Elvish => shells::Elvish.file_name(name),
            Shell::Fish => shells::Fish.file_name(name),
            Shell::PowerShell => shells::PowerShell.file_name(name),
            Shell::Zsh => shells::Zsh.file_name(name),
        }
    }

    fn generate(&self, cmd: &clap::Command, buf: &mut dyn std::io::Write) {
        match self {
            Shell::Bash => shells::Bash.generate(cmd, buf),
            Shell::Elvish => shells::Elvish.generate(cmd, buf),
            Shell::Fish => shells::Fish.generate(cmd, buf),
            Shell::PowerShell => shells::PowerShell.generate(cmd, buf),
            Shell::Zsh => shells::Zsh.generate(cmd, buf),
        }
    }
}

impl Shell {
    /// Parse a shell from a path to the executable for the shell
    ///
    /// # Examples
    ///
    /// ```
    /// use clap_complete::shells::Shell;
    ///
    /// assert_eq!(Shell::from_shell_path("/bin/bash"), Some(Shell::Bash));
    /// assert_eq!(Shell::from_shell_path("/usr/bin/zsh"), Some(Shell::Zsh));
    /// assert_eq!(Shell::from_shell_path("/opt/my_custom_shell"), None);
    /// ```
    pub fn from_shell_path<P: AsRef<Path>>(path: P) -> Option<Shell> {
        parse_shell_from_path(path.as_ref())
    }

    /// Determine the user's current shell from the environment
    ///
    /// This will read the SHELL environment variable and try to determine which shell is in use
    /// from that.
    ///
    /// If SHELL is not set, then on windows, it will default to powershell, and on
    /// other operating systems it will return `None`.
    ///
    /// If SHELL is set, but contains a value that doesn't correspond to one of the supported shell
    /// types, then return `None`.
    ///
    /// # Example:
    ///
    /// ```no_run
    /// # use clap::Command;
    /// use clap_complete::{generate, shells::Shell};
    /// # fn build_cli() -> Command {
    /// #     Command::new("compl")
    /// # }
    /// let mut cmd = build_cli();
    /// generate(Shell::from_env().unwrap_or(Shell::Bash), &mut cmd, "myapp", &mut std::io::stdout());
    /// ```
    pub fn from_env() -> Option<Shell> {
        if let Some(env_shell) = std::env::var_os("SHELL") {
            Shell::from_shell_path(env_shell)
        } else if cfg!(windows) {
            Some(Shell::PowerShell)
        } else {
            None
        }
    }
}

// use a separate function to avoid having to monomorphize the entire function due
// to from_shell_path being generic
fn parse_shell_from_path(path: &Path) -> Option<Shell> {
    let name = path.file_stem()?.to_str()?;
    match name {
        "bash" => Some(Shell::Bash),
        "zsh" => Some(Shell::Zsh),
        "fish" => Some(Shell::Fish),
        "elvish" => Some(Shell::Elvish),
        "powershell" | "powershell_ise" => Some(Shell::PowerShell),
        _ => None,
    }
}

```

`clap/clap_complete/src/aot/shells/zsh.rs`:

```rs
use std::io::Write;

use clap::{Arg, ArgAction, Command, ValueHint};

use crate::generator::{utils, Generator};
use crate::INTERNAL_ERROR_MSG;

/// Generate zsh completion file
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Zsh;

impl Generator for Zsh {
    fn file_name(&self, name: &str) -> String {
        format!("_{name}")
    }

    fn generate(&self, cmd: &Command, buf: &mut dyn Write) {
        let bin_name = cmd
            .get_bin_name()
            .expect("crate::generate should have set the bin_name");

        write!(
            buf,
            "#compdef {name}

autoload -U is-at-least

_{name}() {{
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext=\"$curcontext\" state line
    {initial_args}{subcommands}
}}

{subcommand_details}

if [ \"$funcstack[1]\" = \"_{name}\" ]; then
    _{name} \"$@\"
else
    compdef _{name} {name}
fi
",
            name = bin_name,
            initial_args = get_args_of(cmd, None),
            subcommands = get_subcommands_of(cmd),
            subcommand_details = subcommand_details(cmd)
        )
        .expect("failed to write completion file");
    }
}

// Displays the commands of a subcommand
// (( $+functions[_[bin_name_underscore]_commands] )) ||
// _[bin_name_underscore]_commands() {
//     local commands; commands=(
//         '[arg_name]:[arg_help]'
//     )
//     _describe -t commands '[bin_name] commands' commands "$@"
//
// Where the following variables are present:
//    [bin_name_underscore]: The full space delineated bin_name, where spaces have been replaced by
//                           underscore characters
//    [arg_name]: The name of the subcommand
//    [arg_help]: The help message of the subcommand
//    [bin_name]: The full space delineated bin_name
//
// Here's a snippet from rustup:
//
// (( $+functions[_rustup_commands] )) ||
// _rustup_commands() {
//     local commands; commands=(
//      'show:Show the active and installed toolchains'
//      'update:Update Rust toolchains'
//      # ... snip for brevity
//      'help:Print this message or the help of the given subcommand(s)'
//     )
//     _describe -t commands 'rustup commands' commands "$@"
//
fn subcommand_details(p: &Command) -> String {
    debug!("subcommand_details");

    let bin_name = p
        .get_bin_name()
        .expect("crate::generate should have set the bin_name");

    let mut ret = vec![];

    // First we do ourself
    let parent_text = format!(
        "\
(( $+functions[_{bin_name_underscore}_commands] )) ||
_{bin_name_underscore}_commands() {{
    local commands; commands=({subcommands_and_args})
    _describe -t commands '{bin_name} commands' commands \"$@\"
}}",
        bin_name_underscore = bin_name.replace(' ', "__"),
        bin_name = bin_name,
        subcommands_and_args = subcommands_of(p)
    );
    ret.push(parent_text);

    // Next we start looping through all the children, grandchildren, etc.
    let mut all_subcommand_bins: Vec<_> = utils::all_subcommands(p)
        .into_iter()
        .map(|(_sc_name, bin_name)| bin_name)
        .collect();

    all_subcommand_bins.sort();
    all_subcommand_bins.dedup();

    for bin_name in &all_subcommand_bins {
        debug!("subcommand_details:iter: bin_name={bin_name}");

        ret.push(format!(
            "\
(( $+functions[_{bin_name_underscore}_commands] )) ||
_{bin_name_underscore}_commands() {{
    local commands; commands=({subcommands_and_args})
    _describe -t commands '{bin_name} commands' commands \"$@\"
}}",
            bin_name_underscore = bin_name.replace(' ', "__"),
            bin_name = bin_name,
            subcommands_and_args =
                subcommands_of(parser_of(p, bin_name).expect(INTERNAL_ERROR_MSG))
        ));
    }

    ret.join("\n")
}

// Generates subcommand completions in form of
//
//         '[arg_name]:[arg_help]'
//
// Where:
//    [arg_name]: the subcommand's name
//    [arg_help]: the help message of the subcommand
//
// A snippet from rustup:
//         'show:Show the active and installed toolchains'
//      'update:Update Rust toolchains'
fn subcommands_of(p: &Command) -> String {
    debug!("subcommands_of");

    let mut segments = vec![];

    fn add_subcommands(subcommand: &Command, name: &str, ret: &mut Vec<String>) {
        debug!("add_subcommands");

        let text = format!(
            "'{name}:{help}' \\",
            name = name,
            help = escape_help(&subcommand.get_about().unwrap_or_default().to_string())
        );

        ret.push(text);
    }

    // The subcommands
    for command in p.get_subcommands() {
        debug!("subcommands_of:iter: subcommand={}", command.get_name());

        add_subcommands(command, command.get_name(), &mut segments);

        for alias in command.get_visible_aliases() {
            add_subcommands(command, alias, &mut segments);
        }
    }

    // Surround the text with newlines for proper formatting.
    // We need this to prevent weirdly formatted `command=(\n        \n)` sections.
    // When there are no (sub-)commands.
    if !segments.is_empty() {
        segments.insert(0, "".to_string());
        segments.push("    ".to_string());
    }

    segments.join("\n")
}

// Get's the subcommand section of a completion file
// This looks roughly like:
//
// case $state in
// ([bin_name]_args)
//     curcontext=\"${curcontext%:*:*}:[name_hyphen]-command-$words[1]:\"
//     case $line[1] in
//
//         ([name])
//         _arguments -C -s -S \
//             [subcommand_args]
//         && ret=0
//
//         [RECURSIVE_CALLS]
//
//         ;;",
//
//         [repeat]
//
//     esac
// ;;
// esac",
//
// Where the following variables are present:
//    [name] = The subcommand name in the form of "install" for "rustup toolchain install"
//    [bin_name] = The full space delineated bin_name such as "rustup toolchain install"
//    [name_hyphen] = The full space delineated bin_name, but replace spaces with hyphens
//    [repeat] = From the same recursive calls, but for all subcommands
//    [subcommand_args] = The same as zsh::get_args_of
fn get_subcommands_of(parent: &Command) -> String {
    debug!(
        "get_subcommands_of: Has subcommands...{:?}",
        parent.has_subcommands()
    );

    if !parent.has_subcommands() {
        return String::new();
    }

    let subcommand_names = utils::subcommands(parent);
    let mut all_subcommands = vec![];

    for (ref name, ref bin_name) in &subcommand_names {
        debug!(
            "get_subcommands_of:iter: parent={}, name={name}, bin_name={bin_name}",
            parent.get_name(),
        );
        let mut segments = vec![format!("({name})")];
        let subcommand_args = get_args_of(
            parser_of(parent, bin_name).expect(INTERNAL_ERROR_MSG),
            Some(parent),
        );

        if !subcommand_args.is_empty() {
            segments.push(subcommand_args);
        }

        // Get the help text of all child subcommands.
        let children = get_subcommands_of(parser_of(parent, bin_name).expect(INTERNAL_ERROR_MSG));

        if !children.is_empty() {
            segments.push(children);
        }

        segments.push(String::from(";;"));
        all_subcommands.push(segments.join("\n"));
    }

    let parent_bin_name = parent
        .get_bin_name()
        .expect("crate::generate should have set the bin_name");

    format!(
        "
    case $state in
    ({name})
        words=($line[{pos}] \"${{words[@]}}\")
        (( CURRENT += 1 ))
        curcontext=\"${{curcontext%:*:*}}:{name_hyphen}-command-$line[{pos}]:\"
        case $line[{pos}] in
            {subcommands}
        esac
    ;;
esac",
        name = parent.get_name(),
        name_hyphen = parent_bin_name.replace(' ', "-"),
        subcommands = all_subcommands.join("\n"),
        pos = parent.get_positionals().count() + 1
    )
}

// Get the Command for a given subcommand tree.
//
// Given the bin_name "a b c" and the Command for "a" this returns the "c" Command.
// Given the bin_name "a b c" and the Command for "b" this returns the "c" Command.
fn parser_of<'cmd>(parent: &'cmd Command, bin_name: &str) -> Option<&'cmd Command> {
    debug!("parser_of: p={}, bin_name={}", parent.get_name(), bin_name);

    if bin_name == parent.get_bin_name().unwrap_or_default() {
        return Some(parent);
    }

    for subcommand in parent.get_subcommands() {
        if let Some(ret) = parser_of(subcommand, bin_name) {
            return Some(ret);
        }
    }

    None
}

// Writes out the args section, which ends up being the flags, opts and positionals, and a jump to
// another ZSH function if there are subcommands.
// The structure works like this:
//    ([conflicting_args]) [multiple] arg [takes_value] [[help]] [: :(possible_values)]
//       ^-- list '-v -h'    ^--'*'          ^--'+'                   ^-- list 'one two three'
//
// An example from the rustup command:
//
// _arguments -C -s -S \
//         '(-h --help --verbose)-v[Enable verbose output]' \
//         '(-V -v --version --verbose --help)-h[Print help information]' \
//      # ... snip for brevity
//         ':: :_rustup_commands' \    # <-- displays subcommands
//         '*::: :->rustup' \          # <-- displays subcommand args and child subcommands
//     && ret=0
//
// The args used for _arguments are as follows:
//    -C: modify the $context internal variable
//    -s: Allow stacking of short args (i.e. -a -b -c => -abc)
//    -S: Do not complete anything after '--' and treat those as argument values
fn get_args_of(parent: &Command, p_global: Option<&Command>) -> String {
    debug!("get_args_of");

    let mut segments = vec![String::from("_arguments \"${_arguments_options[@]}\" : \\")];
    let opts = write_opts_of(parent, p_global);
    let flags = write_flags_of(parent, p_global);
    let positionals = write_positionals_of(parent);

    if !opts.is_empty() {
        segments.push(opts);
    }

    if !flags.is_empty() {
        segments.push(flags);
    }

    if !positionals.is_empty() {
        segments.push(positionals);
    }

    if parent.has_subcommands() {
        let parent_bin_name = parent
            .get_bin_name()
            .expect("crate::generate should have set the bin_name");
        let subcommand_bin_name = format!(
            "\":: :_{name}_commands\" \\",
            name = parent_bin_name.replace(' ', "__")
        );
        segments.push(subcommand_bin_name);

        let subcommand_text = format!("\"*::: :->{name}\" \\", name = parent.get_name());
        segments.push(subcommand_text);
    };

    segments.push(String::from("&& ret=0"));
    segments.join("\n")
}

// Uses either `possible_vals` or `value_hint` to give hints about possible argument values
fn value_completion(arg: &Arg) -> Option<String> {
    if let Some(values) = utils::possible_values(arg) {
        if values
            .iter()
            .any(|value| !value.is_hide_set() && value.get_help().is_some())
        {
            Some(format!(
                "(({}))",
                values
                    .iter()
                    .filter_map(|value| {
                        if value.is_hide_set() {
                            None
                        } else {
                            Some(format!(
                                r#"{name}\:"{tooltip}""#,
                                name = escape_value(value.get_name()),
                                tooltip =
                                    escape_help(&value.get_help().unwrap_or_default().to_string()),
                            ))
                        }
                    })
                    .collect::<Vec<_>>()
                    .join("\n")
            ))
        } else {
            Some(format!(
                "({})",
                values
                    .iter()
                    .filter(|pv| !pv.is_hide_set())
                    .map(|n| n.get_name())
                    .collect::<Vec<_>>()
                    .join(" ")
            ))
        }
    } else {
        // NB! If you change this, please also update the table in `ValueHint` documentation.
        Some(
            match arg.get_value_hint() {
                ValueHint::Unknown => "_default",
                ValueHint::Other => "",
                ValueHint::AnyPath => "_files",
                ValueHint::FilePath => "_files",
                ValueHint::DirPath => "_files -/",
                ValueHint::ExecutablePath => "_absolute_command_paths",
                ValueHint::CommandName => "_command_names -e",
                ValueHint::CommandString => "_cmdstring",
                ValueHint::CommandWithArguments => "_cmdambivalent",
                ValueHint::Username => "_users",
                ValueHint::Hostname => "_hosts",
                ValueHint::Url => "_urls",
                ValueHint::EmailAddress => "_email_addresses",
                _ => {
                    return None;
                }
            }
            .to_string(),
        )
    }
}

/// Escape help string inside single quotes and brackets
fn escape_help(string: &str) -> String {
    string
        .replace('\\', "\\\\")
        .replace('\'', "'\\''")
        .replace('[', "\\[")
        .replace(']', "\\]")
        .replace(':', "\\:")
        .replace('$', "\\$")
        .replace('`', "\\`")
        .replace('\n', " ")
}

/// Escape value string inside single quotes and parentheses
fn escape_value(string: &str) -> String {
    string
        .replace('\\', "\\\\")
        .replace('\'', "'\\''")
        .replace('[', "\\[")
        .replace(']', "\\]")
        .replace(':', "\\:")
        .replace('$', "\\$")
        .replace('`', "\\`")
        .replace('(', "\\(")
        .replace(')', "\\)")
        .replace(' ', "\\ ")
}

fn write_opts_of(p: &Command, p_global: Option<&Command>) -> String {
    debug!("write_opts_of");

    let mut ret = vec![];

    for o in p.get_opts() {
        debug!("write_opts_of:iter: o={}", o.get_id());

        let help = escape_help(&o.get_help().unwrap_or_default().to_string());
        let conflicts = arg_conflicts(p, o, p_global);

        let multiple = if let ArgAction::Count | ArgAction::Append = o.get_action() {
            "*"
        } else {
            ""
        };

        let vn = match o.get_value_names() {
            None => " ".to_string(),
            Some(val) => val[0].to_string(),
        };
        let vc = match value_completion(o) {
            Some(val) => format!(":{vn}:{val}"),
            None => format!(":{vn}: "),
        };
        let vc = vc.repeat(o.get_num_args().expect("built").min_values());

        if let Some(shorts) = o.get_short_and_visible_aliases() {
            for short in shorts {
                let s = format!("'{conflicts}{multiple}-{short}+[{help}]{vc}' \\");

                debug!("write_opts_of:iter: Wrote...{}", &*s);
                ret.push(s);
            }
        }
        if let Some(longs) = o.get_long_and_visible_aliases() {
            for long in longs {
                let l = format!("'{conflicts}{multiple}--{long}=[{help}]{vc}' \\");

                debug!("write_opts_of:iter: Wrote...{}", &*l);
                ret.push(l);
            }
        }
    }

    ret.join("\n")
}

fn arg_conflicts(cmd: &Command, arg: &Arg, app_global: Option<&Command>) -> String {
    fn push_conflicts(conflicts: &[&Arg], res: &mut Vec<String>) {
        for conflict in conflicts {
            if let Some(s) = conflict.get_short() {
                res.push(format!("-{s}"));
            }

            if let Some(l) = conflict.get_long() {
                res.push(format!("--{l}"));
            }
        }
    }

    let mut res = vec![];
    match (app_global, arg.is_global_set()) {
        (Some(x), true) => {
            let conflicts = x.get_arg_conflicts_with(arg);

            if conflicts.is_empty() {
                return String::new();
            }

            push_conflicts(&conflicts, &mut res);
        }
        (_, _) => {
            let conflicts = cmd.get_arg_conflicts_with(arg);

            if conflicts.is_empty() {
                return String::new();
            }

            push_conflicts(&conflicts, &mut res);
        }
    };

    format!("({})", res.join(" "))
}

fn write_flags_of(p: &Command, p_global: Option<&Command>) -> String {
    debug!("write_flags_of;");

    let mut ret = vec![];

    for f in utils::flags(p) {
        debug!("write_flags_of:iter: f={}", f.get_id());

        let help = escape_help(&f.get_help().unwrap_or_default().to_string());
        let conflicts = arg_conflicts(p, &f, p_global);

        let multiple = if let ArgAction::Count | ArgAction::Append = f.get_action() {
            "*"
        } else {
            ""
        };

        if let Some(short) = f.get_short() {
            let s = format!("'{conflicts}{multiple}-{short}[{help}]' \\");

            debug!("write_flags_of:iter: Wrote...{}", &*s);

            ret.push(s);

            if let Some(short_aliases) = f.get_visible_short_aliases() {
                for alias in short_aliases {
                    let s = format!("'{conflicts}{multiple}-{alias}[{help}]' \\",);

                    debug!("write_flags_of:iter: Wrote...{}", &*s);

                    ret.push(s);
                }
            }
        }

        if let Some(long) = f.get_long() {
            let l = format!("'{conflicts}{multiple}--{long}[{help}]' \\");

            debug!("write_flags_of:iter: Wrote...{}", &*l);

            ret.push(l);

            if let Some(aliases) = f.get_visible_aliases() {
                for alias in aliases {
                    let l = format!("'{conflicts}{multiple}--{alias}[{help}]' \\");

                    debug!("write_flags_of:iter: Wrote...{}", &*l);

                    ret.push(l);
                }
            }
        }
    }

    ret.join("\n")
}

fn write_positionals_of(p: &Command) -> String {
    debug!("write_positionals_of;");

    let mut ret = vec![];

    // Completions for commands that end with two Vec arguments require special care.
    // - You can have two Vec args separated with a custom value terminator.
    // - You can have two Vec args with the second one set to last (raw sets last)
    //   which will require a '--' separator to be used before the second argument
    //   on the command-line.
    //
    // We use the '-S' _arguments option to disable completion after '--'. Thus, the
    // completion for the second argument in scenario (B) does not need to be emitted
    // because it is implicitly handled by the '-S' option.
    // We only need to emit the first catch-all.
    //
    // Have we already emitted a catch-all multi-valued positional argument
    // without a custom value terminator?
    let mut catch_all_emitted = false;

    for arg in p.get_positionals() {
        debug!("write_positionals_of:iter: arg={}", arg.get_id());

        let num_args = arg.get_num_args().expect("built");
        let is_multi_valued = num_args.max_values() > 1;

        if catch_all_emitted && (arg.is_last_set() || is_multi_valued) {
            // This is the final argument and it also takes multiple arguments.
            // We've already emitted a catch-all positional argument so we don't need
            // to emit anything for this argument because it is implicitly handled by
            // the use of the '-S' _arguments option.
            continue;
        }

        let cardinality_value;
        // If we have any subcommands, we'll emit a catch-all argument, so we shouldn't
        // emit one here.
        let cardinality = if is_multi_valued && !p.has_subcommands() {
            match arg.get_value_terminator() {
                Some(terminator) => {
                    cardinality_value = format!("*{}:", escape_value(terminator));
                    cardinality_value.as_str()
                }
                None => {
                    catch_all_emitted = true;
                    "*:"
                }
            }
        } else if !arg.is_required_set() {
            ":"
        } else {
            ""
        };

        let a = format!(
            "'{cardinality}:{name}{help}:{value_completion}' \\",
            cardinality = cardinality,
            name = arg.get_id(),
            help = arg
                .get_help()
                .map(|s| s.to_string())
                .map(|v| " -- ".to_owned() + &v)
                .unwrap_or_else(|| "".to_owned())
                .replace('[', "\\[")
                .replace(']', "\\]")
                .replace('\'', "'\\''")
                .replace(':', "\\:"),
            value_completion = value_completion(arg).unwrap_or_default()
        );

        debug!("write_positionals_of:iter: Wrote...{a}");

        ret.push(a);
    }

    ret.join("\n")
}

#[cfg(test)]
mod tests {
    use super::{escape_help, escape_value};

    #[test]
    fn test_escape_value() {
        let raw_string = "\\ [foo]() `bar https://$PATH";
        assert_eq!(
            escape_value(raw_string),
            "\\\\\\ \\[foo\\]\\(\\)\\ \\`bar\\ https\\://\\$PATH"
        );
    }

    #[test]
    fn test_escape_help() {
        let raw_string = "\\ [foo]() `bar https://$PATH";
        assert_eq!(
            escape_help(raw_string),
            "\\\\ \\[foo\\]() \\`bar https\\://\\$PATH"
        );
    }
}

```

`clap/clap_complete/src/engine/candidate.rs`:

```rs
use std::ffi::OsStr;
use std::ffi::OsString;

use clap::builder::StyledStr;

/// A shell-agnostic completion candidate
#[derive(Default, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct CompletionCandidate {
    value: OsString,
    help: Option<StyledStr>,
    id: Option<String>,
    tag: Option<StyledStr>,
    display_order: Option<usize>,
    hidden: bool,
}

impl CompletionCandidate {
    /// Create a new completion candidate
    pub fn new(value: impl Into<OsString>) -> Self {
        let value = value.into();
        Self {
            value,
            ..Default::default()
        }
    }

    /// Set the help message of the completion candidate
    pub fn help(mut self, help: Option<StyledStr>) -> Self {
        self.help = help;
        self
    }

    /// Only first for a given Id is shown
    ///
    /// To reduce the risk of conflicts, this should likely contain a namespace.
    pub fn id(mut self, id: Option<String>) -> Self {
        self.id = id;
        self
    }

    /// Group candidates by tag
    ///
    /// Future: these may become user-visible
    pub fn tag(mut self, tag: Option<StyledStr>) -> Self {
        self.tag = tag;
        self
    }

    /// Sort weight within a [`CompletionCandidate::tag`]
    pub fn display_order(mut self, order: Option<usize>) -> Self {
        self.display_order = order;
        self
    }

    /// Set the visibility of the completion candidate
    ///
    /// Only shown when there is no visible candidate for completing the current argument.
    pub fn hide(mut self, hidden: bool) -> Self {
        self.hidden = hidden;
        self
    }

    /// Add a prefix to the value of completion candidate
    ///
    /// This is generally used for post-process by [`complete`][crate::engine::complete()] for
    /// things like pre-pending flags, merging delimiter-separated values, etc.
    pub fn add_prefix(mut self, prefix: impl Into<OsString>) -> Self {
        let suffix = self.value;
        let mut value = prefix.into();
        value.push(&suffix);
        self.value = value;
        self
    }
}

/// Reflection API
impl CompletionCandidate {
    /// Get the literal value being proposed for completion
    pub fn get_value(&self) -> &OsStr {
        &self.value
    }

    /// Get the help message of the completion candidate
    pub fn get_help(&self) -> Option<&StyledStr> {
        self.help.as_ref()
    }

    /// Get the id used for de-duplicating
    pub fn get_id(&self) -> Option<&String> {
        self.id.as_ref()
    }

    /// Get the grouping tag
    pub fn get_tag(&self) -> Option<&StyledStr> {
        self.tag.as_ref()
    }

    /// Get the grouping tag
    pub fn get_display_order(&self) -> Option<usize> {
        self.display_order
    }

    /// Get the visibility of the completion candidate
    pub fn is_hide_set(&self) -> bool {
        self.hidden
    }
}

impl<S: Into<OsString>> From<S> for CompletionCandidate {
    fn from(s: S) -> Self {
        CompletionCandidate::new(s.into())
    }
}

```

`clap/clap_complete/src/engine/complete.rs`:

```rs
use std::ffi::OsStr;
use std::ffi::OsString;

use clap_lex::OsStrExt as _;

use super::custom::complete_path;
use super::ArgValueCandidates;
use super::ArgValueCompleter;
use super::CompletionCandidate;
use super::SubcommandCandidates;

/// Complete the given command, shell-agnostic
pub fn complete(
    cmd: &mut clap::Command,
    args: Vec<OsString>,
    arg_index: usize,
    current_dir: Option<&std::path::Path>,
) -> Result<Vec<CompletionCandidate>, std::io::Error> {
    debug!("complete: args={args:?}, arg_index={arg_index:?}, current_dir={current_dir:?}");
    cmd.build();

    let raw_args = clap_lex::RawArgs::new(args);
    let mut cursor = raw_args.cursor();
    let mut target_cursor = raw_args.cursor();
    raw_args.seek(
        &mut target_cursor,
        clap_lex::SeekFrom::Start(arg_index as u64),
    );
    // As we loop, `cursor` will always be pointing to the next item
    raw_args.next_os(&mut target_cursor);
    debug!("complete: target_cursor={target_cursor:?}");

    // TODO: Multicall support
    if !cmd.is_no_binary_name_set() {
        raw_args.next_os(&mut cursor);
    }

    let mut current_cmd = &*cmd;
    let mut pos_index = 1;
    let mut is_escaped = false;
    let mut next_state = ParseState::ValueDone;
    while let Some(arg) = raw_args.next(&mut cursor) {
        let current_state = next_state;
        next_state = ParseState::ValueDone;
        debug!(
            "complete::next: arg={:?}, current_state={current_state:?}, cursor={cursor:?}",
            arg.to_value_os(),
        );
        if cursor == target_cursor {
            return complete_arg(&arg, current_cmd, current_dir, pos_index, current_state);
        }

        if let Ok(value) = arg.to_value() {
            if let Some(next_cmd) = current_cmd.find_subcommand(value) {
                current_cmd = next_cmd;
                pos_index = 1;
                continue;
            }
        }

        if is_escaped {
            (next_state, pos_index) =
                parse_positional(current_cmd, pos_index, is_escaped, current_state);
        } else if arg.is_escape() {
            is_escaped = true;
        } else if opt_allows_hyphen(&current_state, &arg) {
            match current_state {
                ParseState::Opt((opt, count)) => next_state = parse_opt_value(opt, count),
                _ => unreachable!("else branch is only reachable in Opt state"),
            }
        } else if let Some((flag, value)) = arg.to_long() {
            if let Ok(flag) = flag {
                let opt = current_cmd.get_arguments().find(|a| {
                    let longs = a.get_long_and_visible_aliases();
                    let is_find = longs.map(|v| {
                        let mut iter = v.into_iter();
                        let s = iter.find(|s| *s == flag);
                        s.is_some()
                    });
                    is_find.unwrap_or(false)
                });

                if let Some(opt) = opt {
                    if opt.get_num_args().expect("built").takes_values() && value.is_none() {
                        next_state = ParseState::Opt((opt, 1));
                    };
                } else if pos_allows_hyphen(current_cmd, pos_index) {
                    (next_state, pos_index) =
                        parse_positional(current_cmd, pos_index, is_escaped, current_state);
                }
            }
        } else if let Some(short) = arg.to_short() {
            let (_, takes_value_opt, mut short) = parse_shortflags(current_cmd, short);
            if let Some(opt) = takes_value_opt {
                if short.next_value_os().is_none() {
                    next_state = ParseState::Opt((opt, 1));
                }
            } else if pos_allows_hyphen(current_cmd, pos_index) {
                (next_state, pos_index) =
                    parse_positional(current_cmd, pos_index, is_escaped, current_state);
            }
        } else {
            match current_state {
                ParseState::ValueDone | ParseState::Pos(..) => {
                    (next_state, pos_index) =
                        parse_positional(current_cmd, pos_index, is_escaped, current_state);
                }
                ParseState::Opt((opt, count)) => next_state = parse_opt_value(opt, count),
            }
        }
    }

    Err(std::io::Error::new(
        std::io::ErrorKind::Other,
        "no completion generated",
    ))
}

#[derive(Debug, PartialEq, Eq, Clone)]
enum ParseState<'a> {
    /// Parsing a value done, there is no state to record.
    ValueDone,

    /// Parsing a positional argument after `--`. `Pos(pos_index`, `takes_num_args`)
    Pos((usize, usize)),

    /// Parsing a optional flag argument
    Opt((&'a clap::Arg, usize)),
}

fn complete_arg(
    arg: &clap_lex::ParsedArg<'_>,
    cmd: &clap::Command,
    current_dir: Option<&std::path::Path>,
    pos_index: usize,
    state: ParseState<'_>,
) -> Result<Vec<CompletionCandidate>, std::io::Error> {
    debug!(
        "complete_arg: arg={:?}, cmd={:?}, current_dir={:?}, pos_index={:?}, state={:?}",
        arg,
        cmd.get_name(),
        current_dir,
        pos_index,
        state
    );
    let mut completions = Vec::<CompletionCandidate>::new();

    match state {
        ParseState::ValueDone => {
            if let Ok(value) = arg.to_value() {
                completions.extend(complete_subcommand(value, cmd));
            }

            if let Some(positional) = cmd
                .get_positionals()
                .find(|p| p.get_index() == Some(pos_index))
            {
                completions.extend(complete_arg_value(arg.to_value(), positional, current_dir));
            }
            completions.extend(complete_option(arg, cmd, current_dir));
        }
        ParseState::Pos((_, num_arg)) => {
            if let Some(positional) = cmd
                .get_positionals()
                .find(|p| p.get_index() == Some(pos_index))
            {
                completions.extend(complete_arg_value(arg.to_value(), positional, current_dir));
                if positional
                    .get_num_args()
                    .is_some_and(|num_args| num_arg >= num_args.min_values())
                {
                    completions.extend(complete_option(arg, cmd, current_dir));
                }
            }
        }
        ParseState::Opt((opt, count)) => {
            completions.extend(complete_arg_value(arg.to_value(), opt, current_dir));
            let min = opt.get_num_args().map(|r| r.min_values()).unwrap_or(0);
            if count > min {
                // Also complete this raw_arg as a positional argument, flags, options and subcommand.
                completions.extend(complete_arg(
                    arg,
                    cmd,
                    current_dir,
                    pos_index,
                    ParseState::ValueDone,
                )?);
            }
        }
    }
    if completions.iter().any(|a| !a.is_hide_set()) {
        completions.retain(|a| !a.is_hide_set());
    }
    let mut seen_ids = std::collections::HashSet::new();
    completions.retain(move |a| {
        if let Some(id) = a.get_id().cloned() {
            seen_ids.insert(id)
        } else {
            true
        }
    });

    let mut tags = Vec::new();
    for candidate in &completions {
        let tag = candidate.get_tag().cloned();
        if !tags.contains(&tag) {
            tags.push(tag);
        }
    }
    completions.sort_by_key(|c| {
        (
            tags.iter().position(|t| c.get_tag() == t.as_ref()),
            c.get_display_order(),
        )
    });

    Ok(completions)
}

fn complete_option(
    arg: &clap_lex::ParsedArg<'_>,
    cmd: &clap::Command,
    current_dir: Option<&std::path::Path>,
) -> Vec<CompletionCandidate> {
    let mut completions = Vec::<CompletionCandidate>::new();
    if arg.is_empty() {
        completions.extend(longs_and_visible_aliases(cmd));
        completions.extend(hidden_longs_aliases(cmd));

        let dash_or_arg = if arg.is_empty() {
            "-".into()
        } else {
            arg.to_value_os().to_string_lossy()
        };
        completions.extend(
            shorts_and_visible_aliases(cmd)
                .into_iter()
                .map(|comp| comp.add_prefix(dash_or_arg.to_string())),
        );
    } else if arg.is_stdio() {
        // HACK: Assuming knowledge of is_stdio
        let dash_or_arg = if arg.is_empty() {
            "-".into()
        } else {
            arg.to_value_os().to_string_lossy()
        };
        completions.extend(
            shorts_and_visible_aliases(cmd)
                .into_iter()
                .map(|comp| comp.add_prefix(dash_or_arg.to_string())),
        );

        completions.extend(longs_and_visible_aliases(cmd));
        completions.extend(hidden_longs_aliases(cmd));
    } else if arg.is_escape() {
        // HACK: Assuming knowledge of is_escape
        completions.extend(longs_and_visible_aliases(cmd));
        completions.extend(hidden_longs_aliases(cmd));
    } else if let Some((flag, value)) = arg.to_long() {
        if let Ok(flag) = flag {
            if let Some(value) = value {
                if let Some(arg) = cmd.get_arguments().find(|a| a.get_long() == Some(flag)) {
                    completions.extend(
                        complete_arg_value(value.to_str().ok_or(value), arg, current_dir)
                            .into_iter()
                            .map(|comp| comp.add_prefix(format!("--{flag}="))),
                    );
                }
            } else {
                completions.extend(
                    longs_and_visible_aliases(cmd)
                        .into_iter()
                        .filter(|comp| comp.get_value().starts_with(format!("--{flag}").as_str())),
                );
                completions.extend(
                    hidden_longs_aliases(cmd)
                        .into_iter()
                        .filter(|comp| comp.get_value().starts_with(format!("--{flag}").as_str())),
                );
            }
        }
    } else if let Some(short) = arg.to_short() {
        if !short.is_negative_number() {
            // Find the first takes_values option.
            let (leading_flags, takes_value_opt, mut short) = parse_shortflags(cmd, short);

            // Clone `short` to `peek_short` to peek whether the next flag is a `=`.
            if let Some(opt) = takes_value_opt {
                let mut peek_short = short.clone();
                let has_equal = if let Some(Ok('=')) = peek_short.next_flag() {
                    short.next_flag();
                    true
                } else {
                    false
                };

                let value = short.next_value_os().unwrap_or(OsStr::new(""));
                completions.extend(
                    complete_arg_value(value.to_str().ok_or(value), opt, current_dir)
                        .into_iter()
                        .map(|comp| {
                            let sep = if has_equal { "=" } else { "" };
                            comp.add_prefix(format!("-{leading_flags}{sep}"))
                        }),
                );
            } else {
                completions.extend(
                    shorts_and_visible_aliases(cmd)
                        .into_iter()
                        .map(|comp| comp.add_prefix(format!("-{leading_flags}"))),
                );
            }
        }
    }
    completions
}

fn complete_arg_value(
    value: Result<&str, &OsStr>,
    arg: &clap::Arg,
    current_dir: Option<&std::path::Path>,
) -> Vec<CompletionCandidate> {
    let mut values = Vec::new();
    debug!("complete_arg_value: arg={arg:?}, value={value:?}");

    let (prefix, value) =
        rsplit_delimiter(value, arg.get_value_delimiter()).unwrap_or((None, value));

    let value_os = match value {
        Ok(value) => OsStr::new(value),
        Err(value_os) => value_os,
    };

    if let Some(completer) = arg.get::<ArgValueCompleter>() {
        values.extend(completer.complete(value_os));
    } else if let Some(completer) = arg.get::<ArgValueCandidates>() {
        values.extend(complete_custom_arg_value(value_os, completer));
    } else if let Some(possible_values) = possible_values(arg) {
        if let Ok(value) = value {
            values.extend(possible_values.into_iter().filter_map(|p| {
                let name = p.get_name();
                name.starts_with(value).then(|| {
                    CompletionCandidate::new(OsString::from(name))
                        .help(p.get_help().cloned())
                        .hide(p.is_hide_set())
                })
            }));
        }
    } else {
        match arg.get_value_hint() {
            clap::ValueHint::Unknown | clap::ValueHint::Other => {
                // Should not complete
            }
            clap::ValueHint::AnyPath => {
                values.extend(complete_path(value_os, current_dir, &|_| true));
            }
            clap::ValueHint::FilePath => {
                values.extend(complete_path(value_os, current_dir, &|p| p.is_file()));
            }
            clap::ValueHint::DirPath => {
                values.extend(complete_path(value_os, current_dir, &|p| p.is_dir()));
            }
            clap::ValueHint::ExecutablePath => {
                use is_executable::IsExecutable;
                values.extend(complete_path(value_os, current_dir, &|p| p.is_executable()));
            }
            clap::ValueHint::CommandName
            | clap::ValueHint::CommandString
            | clap::ValueHint::CommandWithArguments
            | clap::ValueHint::Username
            | clap::ValueHint::Hostname
            | clap::ValueHint::Url
            | clap::ValueHint::EmailAddress => {
                // No completion implementation
            }
            _ => {
                // Safe-ish fallback
                values.extend(complete_path(value_os, current_dir, &|_| true));
            }
        }

        values.sort();
    }

    if let Some(prefix) = prefix {
        values = values
            .into_iter()
            .map(|comp| comp.add_prefix(prefix))
            .collect();
    }
    values = values
        .into_iter()
        .map(|comp| {
            if comp.get_tag().is_some() {
                comp
            } else {
                comp.tag(Some(arg.to_string().into()))
            }
        })
        .collect();

    values
}

fn rsplit_delimiter<'s, 'o>(
    value: Result<&'s str, &'o OsStr>,
    delimiter: Option<char>,
) -> Option<(Option<&'s str>, Result<&'s str, &'o OsStr>)> {
    let delimiter = delimiter?;
    let value = value.ok()?;
    let pos = value.rfind(delimiter)?;
    let (prefix, value) = value.split_at(pos + delimiter.len_utf8());
    Some((Some(prefix), Ok(value)))
}

fn complete_custom_arg_value(
    value: &OsStr,
    completer: &ArgValueCandidates,
) -> Vec<CompletionCandidate> {
    debug!("complete_custom_arg_value: completer={completer:?}, value={value:?}");

    let mut values = completer.candidates();
    values.retain(|comp| comp.get_value().starts_with(&value.to_string_lossy()));
    values
}

fn complete_subcommand(value: &str, cmd: &clap::Command) -> Vec<CompletionCandidate> {
    debug!(
        "complete_subcommand: cmd={:?}, value={:?}",
        cmd.get_name(),
        value
    );

    let mut scs: Vec<CompletionCandidate> = subcommands(cmd)
        .into_iter()
        .filter(|x| x.get_value().starts_with(value))
        .collect();
    if cmd.is_allow_external_subcommands_set() {
        let external_completer = cmd.get::<SubcommandCandidates>();
        if let Some(completer) = external_completer {
            scs.extend(complete_external_subcommand(value, completer));
        }
    }

    scs.sort();
    scs.dedup();
    scs
}

fn complete_external_subcommand(
    value: &str,
    completer: &SubcommandCandidates,
) -> Vec<CompletionCandidate> {
    debug!("complete_custom_arg_value: completer={completer:?}, value={value:?}");

    let mut values = Vec::new();
    let custom_arg_values = completer.candidates();
    values.extend(custom_arg_values);

    values.retain(|comp| comp.get_value().starts_with(value));

    values
}

/// Gets all the long options, their visible aliases and flags of a [`clap::Command`] with formatted `--` prefix.
/// Includes `help` and `version` depending on the [`clap::Command`] settings.
fn longs_and_visible_aliases(p: &clap::Command) -> Vec<CompletionCandidate> {
    debug!("longs: name={}", p.get_name());

    p.get_arguments()
        .filter_map(|a| {
            a.get_long_and_visible_aliases().map(|longs| {
                longs
                    .into_iter()
                    .map(|s| populate_arg_candidate(CompletionCandidate::new(format!("--{s}")), a))
            })
        })
        .flatten()
        .collect()
}

/// Gets all the long hidden aliases and flags of a [`clap::Command`].
fn hidden_longs_aliases(p: &clap::Command) -> Vec<CompletionCandidate> {
    debug!("longs: name={}", p.get_name());

    p.get_arguments()
        .filter_map(|a| {
            a.get_aliases().map(|longs| {
                longs.into_iter().map(|s| {
                    populate_arg_candidate(CompletionCandidate::new(format!("--{s}")), a).hide(true)
                })
            })
        })
        .flatten()
        .collect()
}

/// Gets all the short options, their visible aliases and flags of a [`clap::Command`].
/// Includes `h` and `V` depending on the [`clap::Command`] settings.
fn shorts_and_visible_aliases(p: &clap::Command) -> Vec<CompletionCandidate> {
    debug!("shorts: name={}", p.get_name());

    p.get_arguments()
        .filter_map(|a| {
            a.get_short_and_visible_aliases().map(|shorts| {
                shorts.into_iter().map(|s| {
                    populate_arg_candidate(CompletionCandidate::new(s.to_string()), a).help(
                        a.get_help()
                            .cloned()
                            .or_else(|| a.get_long().map(|long| format!("--{long}").into())),
                    )
                })
            })
        })
        .flatten()
        .collect()
}

fn populate_arg_candidate(candidate: CompletionCandidate, arg: &clap::Arg) -> CompletionCandidate {
    candidate
        .help(arg.get_help().cloned())
        .id(Some(format!("arg::{}", arg.get_id())))
        .tag(Some(
            arg.get_help_heading()
                .unwrap_or("Options")
                .to_owned()
                .into(),
        ))
        .display_order(Some(arg.get_display_order()))
        .hide(arg.is_hide_set())
}

/// Get the possible values for completion
fn possible_values(a: &clap::Arg) -> Option<Vec<clap::builder::PossibleValue>> {
    if !a.get_num_args().expect("built").takes_values() {
        None
    } else {
        a.get_value_parser()
            .possible_values()
            .map(|pvs| pvs.collect())
    }
}

/// Gets subcommands of [`clap::Command`] in the form of `("name", "bin_name")`.
///
/// Subcommand `rustup toolchain install` would be converted to
/// `("install", "rustup toolchain install")`.
fn subcommands(p: &clap::Command) -> Vec<CompletionCandidate> {
    debug!("subcommands: name={}", p.get_name());
    debug!("subcommands: Has subcommands...{:?}", p.has_subcommands());
    p.get_subcommands()
        .flat_map(|sc| {
            sc.get_name_and_visible_aliases()
                .into_iter()
                .map(|s| populate_command_candidate(CompletionCandidate::new(s.to_string()), p, sc))
                .chain(sc.get_aliases().map(|s| {
                    populate_command_candidate(CompletionCandidate::new(s.to_string()), p, sc)
                        .hide(true)
                }))
        })
        .collect()
}

fn populate_command_candidate(
    candidate: CompletionCandidate,
    cmd: &clap::Command,
    subcommand: &clap::Command,
) -> CompletionCandidate {
    candidate
        .help(subcommand.get_about().cloned())
        .id(Some(format!("command::{}", subcommand.get_name())))
        .tag(Some(
            cmd.get_subcommand_help_heading()
                .unwrap_or("Commands")
                .to_owned()
                .into(),
        ))
        .display_order(Some(subcommand.get_display_order()))
        .hide(subcommand.is_hide_set())
}
/// Parse the short flags and find the first `takes_values` option.
fn parse_shortflags<'c, 's>(
    cmd: &'c clap::Command,
    mut short: clap_lex::ShortFlags<'s>,
) -> (String, Option<&'c clap::Arg>, clap_lex::ShortFlags<'s>) {
    let takes_value_opt;
    let mut leading_flags = String::new();
    // Find the first takes_values option.
    loop {
        match short.next_flag() {
            Some(Ok(opt)) => {
                leading_flags.push(opt);
                let opt = cmd.get_arguments().find(|a| {
                    let shorts = a.get_short_and_visible_aliases();
                    let is_find = shorts.map(|v| {
                        let mut iter = v.into_iter();
                        let c = iter.find(|c| *c == opt);
                        c.is_some()
                    });
                    is_find.unwrap_or(false)
                });
                if opt
                    .map(|o| o.get_num_args().expect("built").takes_values())
                    .unwrap_or(false)
                {
                    takes_value_opt = opt;
                    break;
                }
            }
            Some(Err(_)) | None => {
                takes_value_opt = None;
                break;
            }
        }
    }

    (leading_flags, takes_value_opt, short)
}

/// Parse the positional arguments. Return the new state and the new positional index.
fn parse_positional<'a>(
    cmd: &clap::Command,
    pos_index: usize,
    is_escaped: bool,
    state: ParseState<'a>,
) -> (ParseState<'a>, usize) {
    let pos_arg = cmd
        .get_positionals()
        .find(|p| p.get_index() == Some(pos_index));
    let num_args = pos_arg
        .and_then(|a| a.get_num_args().map(|r| r.max_values()))
        .unwrap_or(1);

    let update_state_with_new_positional = |pos_index| -> (ParseState<'a>, usize) {
        if num_args > 1 {
            (ParseState::Pos((pos_index, 1)), pos_index)
        } else {
            if is_escaped {
                (ParseState::Pos((pos_index, 1)), pos_index + 1)
            } else {
                (ParseState::ValueDone, pos_index + 1)
            }
        }
    };
    match state {
        ParseState::ValueDone => {
            update_state_with_new_positional(pos_index)
        },
        ParseState::Pos((prev_pos_index, num_arg)) => {
            if prev_pos_index == pos_index {
                if num_arg + 1 < num_args {
                    (ParseState::Pos((pos_index, num_arg + 1)), pos_index)
                } else {
                    if is_escaped {
                        (ParseState::Pos((pos_index, 1)), pos_index + 1)
                    } else {
                        (ParseState::ValueDone, pos_index + 1)
                    }
                }
            } else {
                update_state_with_new_positional(pos_index)
            }
        }
        ParseState::Opt(..) => unreachable!(
            "This branch won't be hit,
            because ParseState::Opt should not be seen as a positional argument and passed to this function."
        ),
    }
}

/// Parse optional flag argument. Return new state
fn parse_opt_value(opt: &clap::Arg, count: usize) -> ParseState<'_> {
    let range = opt.get_num_args().expect("built");
    let max = range.max_values();
    if count < max {
        ParseState::Opt((opt, count + 1))
    } else {
        ParseState::ValueDone
    }
}

fn pos_allows_hyphen(cmd: &clap::Command, pos_index: usize) -> bool {
    cmd.get_positionals()
        .find(|a| a.get_index() == Some(pos_index))
        .map(|p| p.is_allow_hyphen_values_set())
        .unwrap_or(false)
}

fn opt_allows_hyphen(state: &ParseState<'_>, arg: &clap_lex::ParsedArg<'_>) -> bool {
    let val = arg.to_value_os();
    if val.starts_with("-") {
        if let ParseState::Opt((opt, _)) = state {
            return opt.is_allow_hyphen_values_set();
        }
    }

    false
}

```

`clap/clap_complete/src/engine/custom.rs`:

```rs
use std::any::type_name;
use std::ffi::OsStr;
use std::sync::Arc;

use clap::builder::ArgExt;
use clap::builder::CommandExt;
use clap_lex::OsStrExt as _;

use super::CompletionCandidate;

/// Extend [`Arg`][clap::Arg] with a completer
///
/// # Example
///
/// ```rust
/// use clap::Parser;
/// use clap_complete::engine::{ArgValueCompleter, CompletionCandidate};
///
/// fn custom_completer(current: &std::ffi::OsStr) -> Vec<CompletionCandidate> {
///     let mut completions = vec![];
///     let Some(current) = current.to_str() else {
///         return completions;
///     };
///
///     if "foo".starts_with(current) {
///         completions.push(CompletionCandidate::new("foo"));
///     }
///     if "bar".starts_with(current) {
///         completions.push(CompletionCandidate::new("bar"));
///     }
///     if "baz".starts_with(current) {
///         completions.push(CompletionCandidate::new("baz"));
///     }
///     completions
/// }
///
/// #[derive(Debug, Parser)]
/// struct Cli {
///     #[arg(long, add = ArgValueCompleter::new(custom_completer))]
///     custom: Option<String>,
/// }
/// ```
#[derive(Clone)]
pub struct ArgValueCompleter(Arc<dyn ValueCompleter>);

impl ArgValueCompleter {
    /// Create a new `ArgValueCompleter` with a custom completer
    pub fn new<C>(completer: C) -> Self
    where
        C: ValueCompleter + 'static,
    {
        Self(Arc::new(completer))
    }

    /// Candidates that match `current`
    ///
    /// See [`CompletionCandidate`] for more information.
    pub fn complete(&self, current: &OsStr) -> Vec<CompletionCandidate> {
        self.0.complete(current)
    }
}

impl std::fmt::Debug for ArgValueCompleter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(type_name::<Self>())
    }
}

impl ArgExt for ArgValueCompleter {}

/// User-provided completion candidates for an [`Arg`][clap::Arg], see [`ArgValueCompleter`]
///
/// This is useful when predefined value hints are not enough.
pub trait ValueCompleter: Send + Sync {
    /// All potential candidates for an argument.
    ///
    /// See [`CompletionCandidate`] for more information.
    fn complete(&self, current: &OsStr) -> Vec<CompletionCandidate>;
}

impl<F> ValueCompleter for F
where
    F: Fn(&OsStr) -> Vec<CompletionCandidate> + Send + Sync,
{
    fn complete(&self, current: &OsStr) -> Vec<CompletionCandidate> {
        self(current)
    }
}

/// Extend [`Arg`][clap::Arg] with a [`ValueCandidates`]
///
/// # Example
///
/// ```rust
/// use clap::Parser;
/// use clap_complete::engine::{ArgValueCandidates, CompletionCandidate};
///
/// #[derive(Debug, Parser)]
/// struct Cli {
///     #[arg(long, add = ArgValueCandidates::new(|| { vec![
///         CompletionCandidate::new("foo"),
///         CompletionCandidate::new("bar"),
///         CompletionCandidate::new("baz")] }))]
///     custom: Option<String>,
/// }
/// ```
#[derive(Clone)]
pub struct ArgValueCandidates(Arc<dyn ValueCandidates>);

impl ArgValueCandidates {
    /// Create a new `ArgValueCandidates` with a custom completer
    pub fn new<C>(completer: C) -> Self
    where
        C: ValueCandidates + 'static,
    {
        Self(Arc::new(completer))
    }

    /// All potential candidates for an argument.
    ///
    /// See [`CompletionCandidate`] for more information.
    pub fn candidates(&self) -> Vec<CompletionCandidate> {
        self.0.candidates()
    }
}

impl std::fmt::Debug for ArgValueCandidates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(type_name::<Self>())
    }
}

impl ArgExt for ArgValueCandidates {}

/// Extend [`Command`][clap::Command] with a [`ValueCandidates`]
///
/// # Example
/// ```rust
/// use clap::Parser;
/// use clap_complete::engine::{SubcommandCandidates, CompletionCandidate};
/// #[derive(Debug, Parser)]
/// #[clap(name = "cli", add = SubcommandCandidates::new(|| { vec![
///     CompletionCandidate::new("foo"),
///     CompletionCandidate::new("bar"),
///     CompletionCandidate::new("baz")] }))]
/// struct Cli {
///     #[arg(long)]
///     input: Option<String>,
/// }
/// ```
#[derive(Clone)]
pub struct SubcommandCandidates(Arc<dyn ValueCandidates>);

impl SubcommandCandidates {
    /// Create a new `SubcommandCandidates` with a custom completer
    pub fn new<C>(completer: C) -> Self
    where
        C: ValueCandidates + 'static,
    {
        Self(Arc::new(completer))
    }

    /// All potential candidates for an external subcommand.
    ///
    /// See [`CompletionCandidate`] for more information.
    pub fn candidates(&self) -> Vec<CompletionCandidate> {
        self.0.candidates()
    }
}

impl std::fmt::Debug for SubcommandCandidates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(type_name::<Self>())
    }
}

impl CommandExt for SubcommandCandidates {}

/// User-provided completion candidates for an [`Arg`][clap::Arg], see [`ArgValueCandidates`]
///
/// User-provided completion candidates for an [`Subcommand`][clap::Subcommand], see [`SubcommandCandidates`]
///
/// This is useful when predefined value hints are not enough.
pub trait ValueCandidates: Send + Sync {
    /// All potential candidates for an argument.
    ///
    /// See [`CompletionCandidate`] for more information.
    fn candidates(&self) -> Vec<CompletionCandidate>;
}

impl<F> ValueCandidates for F
where
    F: Fn() -> Vec<CompletionCandidate> + Send + Sync,
{
    fn candidates(&self) -> Vec<CompletionCandidate> {
        self()
    }
}

/// Complete a value as a [`std::path::Path`]
///
/// # Example
///
/// ```rust
/// use clap::Parser;
/// use clap_complete::engine::{ArgValueCompleter, PathCompleter};
///
/// #[derive(Debug, Parser)]
/// struct Cli {
///     #[arg(long, add = ArgValueCompleter::new(PathCompleter::file()))]
///     custom: Option<String>,
/// }
/// ```
pub struct PathCompleter {
    current_dir: Option<std::path::PathBuf>,
    #[allow(clippy::type_complexity)]
    filter: Option<Box<dyn Fn(&std::path::Path) -> bool + Send + Sync>>,
    stdio: bool,
}

impl PathCompleter {
    /// Any path is allowed
    pub fn any() -> Self {
        Self {
            filter: None,
            current_dir: None,
            stdio: false,
        }
    }

    /// Complete only files
    pub fn file() -> Self {
        Self::any().filter(|p| p.is_file())
    }

    /// Complete only directories
    pub fn dir() -> Self {
        Self::any().filter(|p| p.is_dir())
    }

    /// Include stdio (`-`)
    pub fn stdio(mut self) -> Self {
        self.stdio = true;
        self
    }

    /// Select which paths should be completed
    pub fn filter(
        mut self,
        filter: impl Fn(&std::path::Path) -> bool + Send + Sync + 'static,
    ) -> Self {
        self.filter = Some(Box::new(filter));
        self
    }

    /// Override [`std::env::current_dir`]
    pub fn current_dir(mut self, path: impl Into<std::path::PathBuf>) -> Self {
        self.current_dir = Some(path.into());
        self
    }
}

impl Default for PathCompleter {
    fn default() -> Self {
        Self::any()
    }
}

impl ValueCompleter for PathCompleter {
    fn complete(&self, current: &OsStr) -> Vec<CompletionCandidate> {
        let filter = self.filter.as_deref().unwrap_or(&|_| true);
        let mut current_dir_actual = None;
        let current_dir = self.current_dir.as_deref().or_else(|| {
            current_dir_actual = std::env::current_dir().ok();
            current_dir_actual.as_deref()
        });
        let mut candidates = complete_path(current, current_dir, filter);
        if self.stdio && current.is_empty() {
            candidates.push(CompletionCandidate::new("-").help(Some("stdio".into())));
        }
        candidates
    }
}

pub(crate) fn complete_path(
    value_os: &OsStr,
    current_dir: Option<&std::path::Path>,
    is_wanted: &dyn Fn(&std::path::Path) -> bool,
) -> Vec<CompletionCandidate> {
    let mut completions = Vec::new();
    let mut potential = Vec::new();

    let value_path = std::path::Path::new(value_os);
    let (prefix, current) = split_file_name(value_path);
    let current = current.to_string_lossy();
    let search_root = if prefix.is_absolute() {
        prefix.to_owned()
    } else {
        let current_dir = match current_dir {
            Some(current_dir) => current_dir,
            None => {
                // Can't complete without a `current_dir`
                return completions;
            }
        };
        current_dir.join(prefix)
    };
    debug!("complete_path: search_root={search_root:?}, prefix={prefix:?}");

    if value_os.is_empty() && is_wanted(&search_root) {
        completions.push(".".into());
    }

    for entry in std::fs::read_dir(&search_root)
        .ok()
        .into_iter()
        .flatten()
        .filter_map(Result::ok)
    {
        let raw_file_name = entry.file_name();
        if !raw_file_name.starts_with(&current) {
            continue;
        }

        if entry.metadata().map(|m| m.is_dir()).unwrap_or(false) {
            let mut suggestion = prefix.join(raw_file_name);
            suggestion.push(""); // Ensure trailing `/`
            let candidate = CompletionCandidate::new(suggestion.as_os_str().to_owned());

            if is_wanted(&entry.path()) {
                completions.push(candidate);
            } else {
                potential.push(candidate);
            }
        } else {
            if is_wanted(&entry.path()) {
                let suggestion = prefix.join(raw_file_name);
                let candidate = CompletionCandidate::new(suggestion.as_os_str().to_owned());
                completions.push(candidate);
            }
        }
    }
    completions.sort();
    potential.sort();
    completions.extend(potential);

    completions
}

fn split_file_name(path: &std::path::Path) -> (&std::path::Path, &OsStr) {
    // Workaround that `Path::new("name/").file_name()` reports `"name"`
    if path_has_name(path) {
        (
            path.parent().unwrap_or_else(|| std::path::Path::new("")),
            path.file_name().expect("not called with `..`"),
        )
    } else {
        (path, Default::default())
    }
}

fn path_has_name(path: &std::path::Path) -> bool {
    let path_bytes = path.as_os_str().as_encoded_bytes();
    let Some(trailing) = path_bytes.last() else {
        return false;
    };
    let trailing = *trailing as char;
    !std::path::is_separator(trailing) && path.file_name().is_some()
}

```

`clap/clap_complete/src/engine/mod.rs`:

```rs
//! `clap`-native completion system
//!
//! See [`complete()`]

mod candidate;
mod complete;
mod custom;

pub use candidate::CompletionCandidate;
pub use complete::complete;
pub use custom::ArgValueCandidates;
pub use custom::ArgValueCompleter;
pub use custom::PathCompleter;
pub use custom::SubcommandCandidates;
pub use custom::ValueCandidates;
pub use custom::ValueCompleter;

```

`clap/clap_complete/src/env/mod.rs`:

```rs
//! [`COMPLETE=$SHELL <bin>`][CompleteEnv] completion integration
//!
//! See [`CompleteEnv`]:
//! ```rust
//! # use clap_complete::CompleteEnv;
//! fn cli() -> clap::Command {
//!     // ...
//! #   clap::Command::new("empty")
//! }
//!
//! fn main() {
//!     CompleteEnv::with_factory(cli)
//!         .complete();
//!
//!     // ... rest of application logic
//! }
//! ```
//!
//! To customize completions, see
//! - [`ValueHint`][crate::ValueHint]
//! - [`ValueEnum`][clap::ValueEnum]
//! - [`ArgValueCandidates`][crate::ArgValueCandidates]
//! - [`ArgValueCompleter`][crate::ArgValueCompleter]
//!
//! To source your completions:
//!
//! <div class="warning">
//!
//! **WARNING:** We recommend re-sourcing your completions on upgrade.
//! These completions work by generating shell code that calls into `your_program` while completing.
//! That interface is unstable and a mismatch between the shell code and `your_program` may result
//! in either invalid completions or no completions being generated.
//! For this reason, we recommend generating the shell code anew on shell startup so that it is
//! "self-correcting" on shell launch, rather than writing the generated completions to a file.
//!
//! </div>
//!
//! Bash
//! ```bash
//! echo "source <(COMPLETE=bash your_program)" >> ~/.bashrc
//! ```
//!
//! Elvish
//! ```elvish
//! echo "eval (E:COMPLETE=elvish your_program | slurp)" >> ~/.elvish/rc.elv
//! ```
//!
//! Fish
//! ```fish
//! echo "source (COMPLETE=fish your_program | psub)" >> ~/.config/fish/config.fish
//! ```
//!
//! Powershell
//! ```powershell
//! $env:COMPLETE = "powershell"
//! echo "your_program | Out-String | Invoke-Expression" >> $PROFILE
//! Remove-Item Env:\COMPLETE
//! ```
//!
//! Zsh
//! ```zsh
//! echo "source <(COMPLETE=zsh your_program)" >> ~/.zshrc
//! ```
//!
//! To disable completions, you can set `COMPLETE=` or `COMPLETE=0`

mod shells;

use std::ffi::OsString;
use std::io::Write as _;

pub use shells::*;

/// Environment-activated completions for your CLI
///
/// Benefits over a CLI completion argument or subcommand
/// - Performance: we don't need to generate [`clap::Command`] twice or parse arguments
/// - Flexibility: there is no concern over it interfering with other CLI logic
///
/// **Warning:** `stdout` should not be written to before [`CompleteEnv::complete`] has had a
/// chance to run.
///
/// # Examples
///
/// ```rust
/// # use clap_complete::CompleteEnv;
/// fn cli() -> clap::Command {
///     // ...
/// #   clap::Command::new("empty")
/// }
///
/// fn main() {
///     CompleteEnv::with_factory(cli)
///         .complete()
///
///     // ... rest of application logic
/// }
/// ```
pub struct CompleteEnv<'s, F> {
    factory: F,
    var: &'static str,
    bin: Option<String>,
    completer: Option<String>,
    shells: Shells<'s>,
}

impl<'s, F: Fn() -> clap::Command> CompleteEnv<'s, F> {
    /// Complete a [`clap::Command`]
    ///
    /// # Example
    ///
    /// Builder:
    /// ```rust
    /// # use clap_complete::CompleteEnv;
    /// fn cli() -> clap::Command {
    ///     // ...
    /// #   clap::Command::new("empty")
    /// }
    ///
    /// fn main() {
    ///     CompleteEnv::with_factory(cli)
    ///         .complete()
    ///
    ///     // ... rest of application logic
    /// }
    /// ```
    ///
    /// Derive:
    /// ```
    /// # use clap::Parser;
    /// # use clap_complete::CompleteEnv;
    /// use clap::CommandFactory as _;
    ///
    /// #[derive(Debug, Parser)]
    /// struct Cli {
    ///     custom: Option<String>,
    /// }
    ///
    /// fn main() {
    ///     CompleteEnv::with_factory(|| Cli::command())
    ///         .complete()
    ///
    ///     // ... rest of application logic
    /// }
    /// ```
    pub fn with_factory(factory: F) -> Self {
        Self {
            factory,
            var: "COMPLETE",
            bin: None,
            completer: None,
            shells: Shells::builtins(),
        }
    }

    /// Override the environment variable used for enabling completions
    pub fn var(mut self, var: &'static str) -> Self {
        self.var = var;
        self
    }

    /// Override the name of the binary to complete
    ///
    /// Default: `Command::get_bin_name`
    pub fn bin(mut self, bin: impl Into<String>) -> Self {
        self.bin = Some(bin.into());
        self
    }

    /// Override the binary to call to get completions
    ///
    /// Default: `args_os()[0]`
    pub fn completer(mut self, completer: impl Into<String>) -> Self {
        self.completer = Some(completer.into());
        self
    }

    /// Override the shells supported for completions
    pub fn shells(mut self, shells: Shells<'s>) -> Self {
        self.shells = shells;
        self
    }
}

impl<'s, F: Fn() -> clap::Command> CompleteEnv<'s, F> {
    /// Process the completion request and exit
    ///
    /// **Warning:** `stdout` should not be written to before this has had a
    /// chance to run.
    pub fn complete(self) {
        let args = std::env::args_os();
        let current_dir = std::env::current_dir().ok();
        if self
            .try_complete(args, current_dir.as_deref())
            .unwrap_or_else(|e| e.exit())
        {
            std::process::exit(0)
        }
    }

    /// Process the completion request
    ///
    /// **Warning:** `stdout` should not be written to before or after this has run.
    ///
    /// Returns `true` if a command was completed and `false` if this is a regular run of your
    /// application
    pub fn try_complete(
        self,
        args: impl IntoIterator<Item = impl Into<OsString>>,
        current_dir: Option<&std::path::Path>,
    ) -> clap::error::Result<bool> {
        self.try_complete_(args.into_iter().map(|a| a.into()).collect(), current_dir)
    }

    fn try_complete_(
        self,
        mut args: Vec<OsString>,
        current_dir: Option<&std::path::Path>,
    ) -> clap::error::Result<bool> {
        let Some(name) = std::env::var_os(self.var) else {
            return Ok(false);
        };
        if name.is_empty() || name == "0" {
            return Ok(false);
        }

        // Ensure any child processes called for custom completers don't activate their own
        // completion logic.
        std::env::remove_var(self.var);

        let shell = self.shell(std::path::Path::new(&name))?;

        let mut cmd = (self.factory)();
        cmd.build();

        let completer = args.remove(0);
        let escape_index = args
            .iter()
            .position(|a| *a == "--")
            .map(|i| i + 1)
            .unwrap_or(args.len());
        args.drain(0..escape_index);
        if args.is_empty() {
            let mut buf = Vec::new();
            self.write_registration(&cmd, current_dir, shell, completer, &mut buf)?;
            std::io::stdout().write_all(&buf)?;
        } else {
            let mut buf = Vec::new();
            shell.write_complete(&mut cmd, args, current_dir, &mut buf)?;
            std::io::stdout().write_all(&buf)?;
        }

        Ok(true)
    }

    fn shell(&self, name: &std::path::Path) -> Result<&dyn EnvCompleter, std::io::Error> {
        // Strip off the parent dir in case `$SHELL` was used
        let name = name.file_stem().unwrap_or(name.as_os_str());
        // lossy won't match but this will delegate to unknown
        // error
        let name = name.to_string_lossy();

        let shell = self.shells.completer(&name).ok_or_else(|| {
            let shells =
                self.shells
                    .names()
                    .enumerate()
                    .fold(String::new(), |mut seed, (i, name)| {
                        use std::fmt::Write as _;
                        let prefix = if i == 0 { "" } else { ", " };
                        let _ = write!(&mut seed, "{prefix}`{name}`");
                        seed
                    });
            std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("unknown shell `{name}`, expected one of {shells}"),
            )
        })?;
        Ok(shell)
    }

    fn write_registration(
        &self,
        cmd: &clap::Command,
        current_dir: Option<&std::path::Path>,
        shell: &dyn EnvCompleter,
        completer: OsString,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let name = cmd.get_name();
        let bin = self
            .bin
            .as_deref()
            .or_else(|| cmd.get_bin_name())
            .unwrap_or_else(|| cmd.get_name());
        let completer = if let Some(completer) = self.completer.as_deref() {
            completer.to_owned()
        } else {
            let mut completer = std::path::PathBuf::from(completer);
            if let Some(current_dir) = current_dir {
                if 1 < completer.components().count() {
                    completer = current_dir.join(completer);
                }
            }
            completer.to_string_lossy().into_owned()
        };

        shell.write_registration(self.var, name, bin, &completer, buf)?;

        Ok(())
    }
}

/// Collection of shell-specific completers
pub struct Shells<'s>(pub &'s [&'s dyn EnvCompleter]);

impl<'s> Shells<'s> {
    /// Select all of the built-in shells
    pub const fn builtins() -> Self {
        Self(&[&Bash, &Elvish, &Fish, &Powershell, &Zsh])
    }

    /// Find the specified [`EnvCompleter`]
    pub fn completer(&self, name: &str) -> Option<&dyn EnvCompleter> {
        self.0.iter().copied().find(|c| c.is(name))
    }

    /// Collect all [`EnvCompleter::name`]s
    pub fn names(&self) -> impl Iterator<Item = &'static str> + 's {
        self.0.iter().map(|c| c.name())
    }

    /// Iterate over [`EnvCompleter`]s
    pub fn iter(&self) -> impl Iterator<Item = &dyn EnvCompleter> {
        self.0.iter().copied()
    }
}

/// Shell-integration for completions
///
/// This will generally be called by [`CompleteEnv`].
///
/// This handles adapting between the shell and [`completer`][crate::engine::complete()].
/// A `EnvCompleter` can choose how much of that lives within the registration script or
/// lives in [`EnvCompleter::write_complete`].
pub trait EnvCompleter {
    /// Canonical name for this shell
    ///
    /// **Post-conditions:**
    /// ```rust,ignore
    /// assert!(completer.is(completer.name()));
    /// ```
    fn name(&self) -> &'static str;
    /// Whether the name matches this shell
    ///
    /// This should match [`EnvCompleter::name`] and any alternative names, particularly used by
    /// `$SHELL`.
    fn is(&self, name: &str) -> bool;
    /// Register for completions
    ///
    /// Write the `buf` the logic needed for calling into `<VAR>=<shell> <cmd> --`, passing needed
    /// arguments to [`EnvCompleter::write_complete`] through the environment.
    ///
    /// - `var`: see [`CompleteEnv::var`]
    /// - `name`: an identifier to use in the script
    /// - `bin`: see [`CompleteEnv::bin`]
    /// - `completer`: see [`CompleteEnv::completer`]
    ///
    /// <div class="warning">
    ///
    /// **WARNING:** There are no stability guarantees between the call to
    /// [`EnvCompleter::write_complete`] that this generates and actually calling [`EnvCompleter::write_complete`].
    /// Caching the results of this call may result in invalid or no completions to be generated.
    ///
    /// </div>
    fn write_registration(
        &self,
        var: &str,
        name: &str,
        bin: &str,
        completer: &str,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error>;
    /// Complete the given command
    ///
    /// Adapt information from arguments and [`EnvCompleter::write_registration`]-defined env
    /// variables to what is needed for [`completer`][crate::engine::complete()].
    ///
    /// Write out the [`CompletionCandidate`][crate::engine::CompletionCandidate]s in a way the shell will understand.
    fn write_complete(
        &self,
        cmd: &mut clap::Command,
        args: Vec<OsString>,
        current_dir: Option<&std::path::Path>,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error>;
}

```

`clap/clap_complete/src/env/shells.rs`:

```rs
use std::ffi::OsString;
use std::str::FromStr;

use super::EnvCompleter;

/// Bash completion adapter
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Bash;

impl EnvCompleter for Bash {
    fn name(&self) -> &'static str {
        "bash"
    }
    fn is(&self, name: &str) -> bool {
        name == "bash"
    }
    fn write_registration(
        &self,
        var: &str,
        name: &str,
        bin: &str,
        completer: &str,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let escaped_name = name.replace('-', "_");

        let completer =
            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

        let script = r#"
_clap_complete_NAME() {
    local IFS=$'\013'
    local _CLAP_COMPLETE_INDEX=${COMP_CWORD}
    local _CLAP_COMPLETE_COMP_TYPE=${COMP_TYPE}
    if compopt +o nospace 2> /dev/null; then
        local _CLAP_COMPLETE_SPACE=false
    else
        local _CLAP_COMPLETE_SPACE=true
    fi
    COMPREPLY=( $( \
        _CLAP_IFS="$IFS" \
        _CLAP_COMPLETE_INDEX="$_CLAP_COMPLETE_INDEX" \
        _CLAP_COMPLETE_COMP_TYPE="$_CLAP_COMPLETE_COMP_TYPE" \
        VAR="bash" \
        "COMPLETER" -- "${COMP_WORDS[@]}" \
    ) )
    if [[ $? != 0 ]]; then
        unset COMPREPLY
    elif [[ $SUPPRESS_SPACE == 1 ]] && [[ "${COMPREPLY-}" =~ [=/:]$ ]]; then
        compopt -o nospace
    fi
}
if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -o nospace -o bashdefault -o nosort -F _clap_complete_NAME BIN
else
    complete -o nospace -o bashdefault -F _clap_complete_NAME BIN
fi
"#
        .replace("NAME", &escaped_name)
        .replace("BIN", bin)
        .replace("COMPLETER", &completer)
        .replace("VAR", var);

        writeln!(buf, "{script}")?;
        Ok(())
    }
    fn write_complete(
        &self,
        cmd: &mut clap::Command,
        args: Vec<OsString>,
        current_dir: Option<&std::path::Path>,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let index: usize = std::env::var("_CLAP_COMPLETE_INDEX")
            .ok()
            .and_then(|i| i.parse().ok())
            .unwrap_or_default();
        let _comp_type: CompType = std::env::var("_CLAP_COMPLETE_COMP_TYPE")
            .ok()
            .and_then(|i| i.parse().ok())
            .unwrap_or_default();
        let _space: Option<bool> = std::env::var("_CLAP_COMPLETE_SPACE")
            .ok()
            .and_then(|i| i.parse().ok());
        let ifs: Option<String> = std::env::var("_CLAP_IFS").ok().and_then(|i| i.parse().ok());
        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

        for (i, candidate) in completions.iter().enumerate() {
            if i != 0 {
                write!(buf, "{}", ifs.as_deref().unwrap_or("\n"))?;
            }
            write!(buf, "{}", candidate.get_value().to_string_lossy())?;
        }
        Ok(())
    }
}

/// Type of completion attempted that caused a completion function to be called
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[non_exhaustive]
enum CompType {
    /// Normal completion
    Normal,
    /// List completions after successive tabs
    Successive,
    /// List alternatives on partial word completion
    Alternatives,
    /// List completions if the word is not unmodified
    Unmodified,
    /// Menu completion
    Menu,
}

impl FromStr for CompType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "9" => Ok(Self::Normal),
            "63" => Ok(Self::Successive),
            "33" => Ok(Self::Alternatives),
            "64" => Ok(Self::Unmodified),
            "37" => Ok(Self::Menu),
            _ => Err(format!("unsupported COMP_TYPE `{s}`")),
        }
    }
}

impl Default for CompType {
    fn default() -> Self {
        Self::Normal
    }
}

/// Elvish completion adapter
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Elvish;

impl EnvCompleter for Elvish {
    fn name(&self) -> &'static str {
        "elvish"
    }
    fn is(&self, name: &str) -> bool {
        name == "elvish"
    }
    fn write_registration(
        &self,
        var: &str,
        _name: &str,
        bin: &str,
        completer: &str,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let bin = shlex::try_quote(bin).unwrap_or(std::borrow::Cow::Borrowed(bin));
        let completer =
            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

        let script = r#"
set edit:completion:arg-completer[BIN] = { |@words|
    var index = (count $words)
    set index = (- $index 1)

    put (env _CLAP_IFS="\n" _CLAP_COMPLETE_INDEX=(to-string $index) VAR="elvish" COMPLETER -- $@words) | to-lines
}
"#
        .replace("COMPLETER", &completer)
        .replace("BIN", &bin)
        .replace("VAR", var);

        writeln!(buf, "{script}")?;
        Ok(())
    }
    fn write_complete(
        &self,
        cmd: &mut clap::Command,
        args: Vec<OsString>,
        current_dir: Option<&std::path::Path>,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let index: usize = std::env::var("_CLAP_COMPLETE_INDEX")
            .ok()
            .and_then(|i| i.parse().ok())
            .unwrap_or_default();
        let ifs: Option<String> = std::env::var("_CLAP_IFS").ok().and_then(|i| i.parse().ok());
        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

        for (i, candidate) in completions.iter().enumerate() {
            if i != 0 {
                write!(buf, "{}", ifs.as_deref().unwrap_or("\n"))?;
            }
            write!(buf, "{}", candidate.get_value().to_string_lossy())?;
        }
        Ok(())
    }
}

/// Fish completion adapter
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Fish;

impl EnvCompleter for Fish {
    fn name(&self) -> &'static str {
        "fish"
    }
    fn is(&self, name: &str) -> bool {
        name == "fish"
    }
    fn write_registration(
        &self,
        var: &str,
        _name: &str,
        bin: &str,
        completer: &str,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let bin = shlex::try_quote(bin).unwrap_or(std::borrow::Cow::Borrowed(bin));
        let completer =
            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

        writeln!(
            buf,
            r#"complete --keep-order --exclusive --command {bin} --arguments "({var}=fish "'{completer}'" -- (commandline --current-process --tokenize --cut-at-cursor) (commandline --current-token))""#
        )
    }
    fn write_complete(
        &self,
        cmd: &mut clap::Command,
        args: Vec<OsString>,
        current_dir: Option<&std::path::Path>,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let index = args.len() - 1;
        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

        for candidate in completions {
            write!(buf, "{}", candidate.get_value().to_string_lossy())?;
            if let Some(help) = candidate.get_help() {
                write!(
                    buf,
                    "\t{}",
                    help.to_string().lines().next().unwrap_or_default()
                )?;
            }
            writeln!(buf)?;
        }
        Ok(())
    }
}

/// Powershell completion adapter
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Powershell;

impl EnvCompleter for Powershell {
    fn name(&self) -> &'static str {
        "powershell"
    }
    fn is(&self, name: &str) -> bool {
        name == "powershell" || name == "powershell_ise"
    }
    fn write_registration(
        &self,
        var: &str,
        _name: &str,
        bin: &str,
        completer: &str,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let bin = shlex::try_quote(bin).unwrap_or(std::borrow::Cow::Borrowed(bin));
        let completer =
            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

        // `completer` may or may not be surrounded by double quotes, enclosing
        // the expression in a here-string ensures the whole thing is
        // interpreted as the first argument to the call operator
        writeln!(
            buf,
            r#"
Register-ArgumentCompleter -Native -CommandName {bin} -ScriptBlock {{
    param($wordToComplete, $commandAst, $cursorPosition)

    $prev = $env:{var};
    $env:{var} = "powershell";
    $results = Invoke-Expression @"
& {completer} -- $commandAst
"@;
    if ($null -eq $prev) {{
        Remove-Item Env:\{var};
    }} else {{
        $env:{var} = $prev;
    }}
    $results | ForEach-Object {{
        $split = $_.Split("`t");
        $cmd = $split[0];

        if ($split.Length -eq 2) {{
            $help = $split[1];
        }}
        else {{
            $help = $split[0];
        }}

        [System.Management.Automation.CompletionResult]::new($cmd, $cmd, 'ParameterValue', $help)
    }}
}};
        "#
        )
    }

    fn write_complete(
        &self,
        cmd: &mut clap::Command,
        args: Vec<OsString>,
        current_dir: Option<&std::path::Path>,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let index = args.len() - 1;
        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

        for candidate in completions {
            write!(buf, "{}", candidate.get_value().to_string_lossy())?;
            if let Some(help) = candidate.get_help() {
                write!(
                    buf,
                    "\t{}",
                    help.to_string().lines().next().unwrap_or_default()
                )?;
            }
            writeln!(buf)?;
        }
        Ok(())
    }
}

/// Zsh completion adapter
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Zsh;

impl EnvCompleter for Zsh {
    fn name(&self) -> &'static str {
        "zsh"
    }
    fn is(&self, name: &str) -> bool {
        name == "zsh"
    }
    fn write_registration(
        &self,
        var: &str,
        name: &str,
        bin: &str,
        completer: &str,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let escaped_name = name.replace('-', "_");
        let bin = shlex::try_quote(bin).unwrap_or(std::borrow::Cow::Borrowed(bin));
        let completer =
            shlex::try_quote(completer).unwrap_or(std::borrow::Cow::Borrowed(completer));

        let script = r#"#compdef BIN
function _clap_dynamic_completer_NAME() {
    local _CLAP_COMPLETE_INDEX=$(expr $CURRENT - 1)
    local _CLAP_IFS=$'\n'

    local completions=("${(@f)$( \
        _CLAP_IFS="$_CLAP_IFS" \
        _CLAP_COMPLETE_INDEX="$_CLAP_COMPLETE_INDEX" \
        VAR="zsh" \
        COMPLETER -- ${words} 2>/dev/null \
    )}")

    if [[ -n $completions ]]; then
        _describe 'values' completions
    fi
}

compdef _clap_dynamic_completer_NAME BIN"#
            .replace("NAME", &escaped_name)
            .replace("COMPLETER", &completer)
            .replace("BIN", &bin)
            .replace("VAR", var);

        writeln!(buf, "{script}")?;
        Ok(())
    }
    fn write_complete(
        &self,
        cmd: &mut clap::Command,
        args: Vec<OsString>,
        current_dir: Option<&std::path::Path>,
        buf: &mut dyn std::io::Write,
    ) -> Result<(), std::io::Error> {
        let index: usize = std::env::var("_CLAP_COMPLETE_INDEX")
            .ok()
            .and_then(|i| i.parse().ok())
            .unwrap_or_default();
        let ifs: Option<String> = std::env::var("_CLAP_IFS").ok().and_then(|i| i.parse().ok());

        // If the current word is empty, add an empty string to the args
        let mut args = args.clone();
        if args.len() == index {
            args.push("".into());
        }
        let completions = crate::engine::complete(cmd, args, index, current_dir)?;

        for (i, candidate) in completions.iter().enumerate() {
            if i != 0 {
                write!(buf, "{}", ifs.as_deref().unwrap_or("\n"))?;
            }
            write!(
                buf,
                "{}",
                Self::escape_value(&candidate.get_value().to_string_lossy())
            )?;
            if let Some(help) = candidate.get_help() {
                write!(
                    buf,
                    ":{}",
                    Self::escape_help(help.to_string().lines().next().unwrap_or_default())
                )?;
            }
        }
        Ok(())
    }
}

impl Zsh {
    /// Escape value string
    fn escape_value(string: &str) -> String {
        string.replace('\\', "\\\\").replace(':', "\\:")
    }

    /// Escape help string
    fn escape_help(string: &str) -> String {
        string.replace('\\', "\\\\")
    }
}

```

`clap/clap_complete/src/lib.rs`:

```rs
// Copyright ⓒ 2015-2018 Kevin B. Knapp
//
// `clap_complete` is distributed under the terms of both the MIT license and the Apache License
// (Version 2.0).
// See the [LICENSE-APACHE](LICENSE-APACHE) and [LICENSE-MIT](LICENSE-MIT) files in this repository
// for more information.

//! ## Quick Start
//!
//! - For generating at compile-time, see [`generate_to`]
//! - For generating at runtime, see [`generate`]
//!
//! [`Shell`] is a convenience `enum` for an argument value type that implements `Generator`
//! for each natively-supported shell type.
//!
//! ## Example
//!
//! ```rust,no_run
//! use clap::{Command, Arg, ValueHint, value_parser, ArgAction};
//! use clap_complete::aot::{generate, Generator, Shell};
//! use std::io;
//!
//! fn build_cli() -> Command {
//!     Command::new("example")
//!         .arg(Arg::new("file")
//!             .help("some input file")
//!             .value_hint(ValueHint::AnyPath))
//!         .arg(Arg::new("generator")
//!             .long("generate")
//!             .action(ArgAction::Set)
//!             .value_parser(value_parser!(Shell)))
//! }
//!
//! fn print_completions<G: Generator>(generator: G, cmd: &mut Command) {
//!     generate(generator, cmd, cmd.get_name().to_string(), &mut io::stdout());
//! }
//!
//! fn main() {
//!     let matches = build_cli().get_matches();
//!
//!     if let Some(generator) = matches.get_one::<Shell>("generator").copied() {
//!         let mut cmd = build_cli();
//!         eprintln!("Generating completion file for {generator}...");
//!         print_completions(generator, &mut cmd);
//!     }
//! }
//! ```

#![doc(html_logo_url = "https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png")]
#![doc = include_str!("../README.md")]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![forbid(unsafe_code)]
#![warn(missing_docs)]
#![allow(clippy::needless_doctest_main)]
#![warn(clippy::print_stderr)]
#![warn(clippy::print_stdout)]

const INTERNAL_ERROR_MSG: &str = "Fatal internal error. Please consider filing a bug \
                                  report at https://github.com/clap-rs/clap/issues";

#[macro_use]
#[allow(missing_docs)]
mod macros;

pub mod aot;
#[cfg(feature = "unstable-dynamic")]
pub mod engine;
#[cfg(feature = "unstable-dynamic")]
pub mod env;

pub use clap::ValueHint;
#[doc(inline)]
#[cfg(feature = "unstable-dynamic")]
pub use engine::ArgValueCandidates;
#[cfg(feature = "unstable-dynamic")]
pub use engine::ArgValueCompleter;
#[doc(inline)]
#[cfg(feature = "unstable-dynamic")]
pub use engine::CompletionCandidate;
#[cfg(feature = "unstable-dynamic")]
pub use engine::PathCompleter;
#[cfg(feature = "unstable-dynamic")]
pub use env::CompleteEnv;

/// Deprecated, see [`aot`]
pub mod generator {
    pub use crate::aot::generate;
    pub use crate::aot::generate_to;
    pub use crate::aot::utils;
    pub use crate::aot::Generator;
}
/// Deprecated, see [`aot`]
pub mod shells {
    pub use crate::aot::Bash;
    pub use crate::aot::Elvish;
    pub use crate::aot::Fish;
    pub use crate::aot::PowerShell;
    pub use crate::aot::Shell;
    pub use crate::aot::Zsh;
}
/// Deprecated, see [`aot::generate`]
pub use aot::generate;
/// Deprecated, see [`aot::generate_to`]
pub use aot::generate_to;
/// Deprecated, see [`aot::Generator`]
pub use aot::Generator;
/// Deprecated, see [`aot::Shell`]
pub use aot::Shell;

```

`clap/clap_complete/src/macros.rs`:

```rs
#[cfg(feature = "debug")]
macro_rules! debug {
    ($($arg:tt)*) => {
        eprint!("[{:>w$}] \t", module_path!(), w = 28);
        eprintln!($($arg)*)
    }
}

#[cfg(not(feature = "debug"))]
macro_rules! debug {
    ($($arg:tt)*) => {};
}

```

`clap/clap_complete/tests/examples.rs`:

```rs
#[test]
fn example_tests() {
    let t = trycmd::TestCases::new();
    let features: &[&str] = &[
        #[cfg(feature = "unstable-dynamic")]
        "unstable-dynamic",
    ];
    let features = features.join(" ");
    t.register_bins(trycmd::cargo::compile_examples(["--features", &features]).unwrap());
    t.case("examples/**/*.md");
}

```

`clap/clap_complete/tests/snapshots/aliases.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-F -f -O -o -h -V --flg --flag --opt --option --help --version [positional]"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                --option)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                --opt)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                -o)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                -O)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/aliases.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand -o 'cmd option'
            cand -O 'cmd option'
            cand --option 'cmd option'
            cand --opt 'cmd option'
            cand -f 'cmd flag'
            cand -F 'cmd flag'
            cand --flag 'cmd flag'
            cand --flg 'cmd flag'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/aliases.fish`:

```fish
complete -c my-app -s o -s O -l option -l opt -d 'cmd option' -r
complete -c my-app -s f -s F -l flag -l flg -d 'cmd flag'
complete -c my-app -s h -l help -d 'Print help'
complete -c my-app -s V -l version -d 'Print version'

```

`clap/clap_complete/tests/snapshots/aliases.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('-o', '-o', [CompletionResultType]::ParameterName, 'cmd option')
            [CompletionResult]::new('-O', '-O ', [CompletionResultType]::ParameterName, 'cmd option')
            [CompletionResult]::new('--option', '--option', [CompletionResultType]::ParameterName, 'cmd option')
            [CompletionResult]::new('--opt', '--opt', [CompletionResultType]::ParameterName, 'cmd option')
            [CompletionResult]::new('-f', '-f', [CompletionResultType]::ParameterName, 'cmd flag')
            [CompletionResult]::new('-F', '-F ', [CompletionResultType]::ParameterName, 'cmd flag')
            [CompletionResult]::new('--flag', '--flag', [CompletionResultType]::ParameterName, 'cmd flag')
            [CompletionResult]::new('--flg', '--flg', [CompletionResultType]::ParameterName, 'cmd flag')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/aliases.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'-o+[cmd option]: :_default' \
'-O+[cmd option]: :_default' \
'--option=[cmd option]: :_default' \
'--opt=[cmd option]: :_default' \
'-f[cmd flag]' \
'-F[cmd flag]' \
'--flag[cmd flag]' \
'--flg[cmd flag]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
'::positional:_default' \
&& ret=0
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=()
    _describe -t commands 'my-app commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/snapshots/basic.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            my__app,help)
                cmd="my__app__help"
                ;;
            my__app,test)
                cmd="my__app__test"
                ;;
            my__app__help,help)
                cmd="my__app__help__help"
                ;;
            my__app__help,test)
                cmd="my__app__help__test"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-c -v -h --help test help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help)
            opts="test help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__help)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__test)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__test)
            opts="-d -c -h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/basic.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand -c 'c'
            cand -v 'v'
            cand -h 'Print help'
            cand --help 'Print help'
            cand test 'Subcommand with a second line'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;test'= {
            cand -d 'd'
            cand -c 'c'
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'my-app;help'= {
            cand test 'Subcommand with a second line'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;help;test'= {
        }
        &'my-app;help;help'= {
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/basic.fish`:

```fish
# Print an optspec for argparse to handle cmd's options that are independent of any subcommand.
function __fish_my_app_global_optspecs
	string join \n c v h/help
end

function __fish_my_app_needs_command
	# Figure out if the current invocation already has a command.
	set -l cmd (commandline -opc)
	set -e cmd[1]
	argparse -s (__fish_my_app_global_optspecs) -- $cmd 2>/dev/null
	or return
	if set -q argv[1]
		# Also print the command, so this can be used to figure out what it is.
		echo $argv[1]
		return 1
	end
	return 0
end

function __fish_my_app_using_subcommand
	set -l cmd (__fish_my_app_needs_command)
	test -z "$cmd"
	and return 1
	contains -- $cmd[1] $argv
end

complete -c my-app -n "__fish_my_app_needs_command" -s c
complete -c my-app -n "__fish_my_app_needs_command" -s v
complete -c my-app -n "__fish_my_app_needs_command" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_needs_command" -f -a "test" -d 'Subcommand with a second line'
complete -c my-app -n "__fish_my_app_needs_command" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand test" -s d
complete -c my-app -n "__fish_my_app_using_subcommand test" -s c
complete -c my-app -n "__fish_my_app_using_subcommand test" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test help" -f -a "test" -d 'Subcommand with a second line'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'

```

`clap/clap_complete/tests/snapshots/basic.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('-c', '-c', [CompletionResultType]::ParameterName, 'c')
            [CompletionResult]::new('-v', '-v', [CompletionResultType]::ParameterName, 'v')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'Subcommand with a second line')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;test' {
            [CompletionResult]::new('-d', '-d', [CompletionResultType]::ParameterName, 'd')
            [CompletionResult]::new('-c', '-c', [CompletionResultType]::ParameterName, 'c')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'my-app;help' {
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'Subcommand with a second line')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;help;test' {
            break
        }
        'my-app;help;help' {
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/basic.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'-c[]' \
'(-c)-v[]' \
'-h[Print help]' \
'--help[Print help]' \
":: :_my-app_commands" \
"*::: :->my-app" \
&& ret=0
    case $state in
    (my-app)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-command-$line[1]:"
        case $line[1] in
            (test)
_arguments "${_arguments_options[@]}" : \
'*-d[]' \
'-c[]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_my-app__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-help-command-$line[1]:"
        case $line[1] in
            (test)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=(
'test:Subcommand with a second line' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app commands' commands "$@"
}
(( $+functions[_my-app__help_commands] )) ||
_my-app__help_commands() {
    local commands; commands=(
'test:Subcommand with a second line' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app help commands' commands "$@"
}
(( $+functions[_my-app__help__help_commands] )) ||
_my-app__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help help commands' commands "$@"
}
(( $+functions[_my-app__help__test_commands] )) ||
_my-app__help__test_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help test commands' commands "$@"
}
(( $+functions[_my-app__test_commands] )) ||
_my-app__test_commands() {
    local commands; commands=()
    _describe -t commands 'my-app test commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/snapshots/custom_bin_name.bash`:

```bash
_bin-name() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="bin__name"
                ;;
            bin__name,help)
                cmd="bin__name__help"
                ;;
            bin__name,test)
                cmd="bin__name__test"
                ;;
            bin__name__help,help)
                cmd="bin__name__help__help"
                ;;
            bin__name__help,test)
                cmd="bin__name__help__test"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        bin__name)
            opts="-c -v -h --help test help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        bin__name__help)
            opts="test help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        bin__name__help__help)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        bin__name__help__test)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        bin__name__test)
            opts="-d -c -h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _bin-name -o nosort -o bashdefault -o default bin-name
else
    complete -F _bin-name -o bashdefault -o default bin-name
fi

```

`clap/clap_complete/tests/snapshots/custom_bin_name.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[bin-name] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'bin-name'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'bin-name'= {
            cand -c 'c'
            cand -v 'v'
            cand -h 'Print help'
            cand --help 'Print help'
            cand test 'Subcommand with a second line'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'bin-name;test'= {
            cand -d 'd'
            cand -c 'c'
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'bin-name;help'= {
            cand test 'Subcommand with a second line'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'bin-name;help;test'= {
        }
        &'bin-name;help;help'= {
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/custom_bin_name.fish`:

```fish
# Print an optspec for argparse to handle cmd's options that are independent of any subcommand.
function __fish_bin_name_global_optspecs
	string join \n c v h/help
end

function __fish_bin_name_needs_command
	# Figure out if the current invocation already has a command.
	set -l cmd (commandline -opc)
	set -e cmd[1]
	argparse -s (__fish_bin_name_global_optspecs) -- $cmd 2>/dev/null
	or return
	if set -q argv[1]
		# Also print the command, so this can be used to figure out what it is.
		echo $argv[1]
		return 1
	end
	return 0
end

function __fish_bin_name_using_subcommand
	set -l cmd (__fish_bin_name_needs_command)
	test -z "$cmd"
	and return 1
	contains -- $cmd[1] $argv
end

complete -c bin-name -n "__fish_bin_name_needs_command" -s c
complete -c bin-name -n "__fish_bin_name_needs_command" -s v
complete -c bin-name -n "__fish_bin_name_needs_command" -s h -l help -d 'Print help'
complete -c bin-name -n "__fish_bin_name_needs_command" -f -a "test" -d 'Subcommand with a second line'
complete -c bin-name -n "__fish_bin_name_needs_command" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c bin-name -n "__fish_bin_name_using_subcommand test" -s d
complete -c bin-name -n "__fish_bin_name_using_subcommand test" -s c
complete -c bin-name -n "__fish_bin_name_using_subcommand test" -s h -l help -d 'Print help'
complete -c bin-name -n "__fish_bin_name_using_subcommand help; and not __fish_seen_subcommand_from test help" -f -a "test" -d 'Subcommand with a second line'
complete -c bin-name -n "__fish_bin_name_using_subcommand help; and not __fish_seen_subcommand_from test help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'

```

`clap/clap_complete/tests/snapshots/custom_bin_name.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'bin-name' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'bin-name'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'bin-name' {
            [CompletionResult]::new('-c', '-c', [CompletionResultType]::ParameterName, 'c')
            [CompletionResult]::new('-v', '-v', [CompletionResultType]::ParameterName, 'v')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'Subcommand with a second line')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'bin-name;test' {
            [CompletionResult]::new('-d', '-d', [CompletionResultType]::ParameterName, 'd')
            [CompletionResult]::new('-c', '-c', [CompletionResultType]::ParameterName, 'c')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'bin-name;help' {
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'Subcommand with a second line')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'bin-name;help;test' {
            break
        }
        'bin-name;help;help' {
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/custom_bin_name.zsh`:

```zsh
#compdef bin-name

autoload -U is-at-least

_bin-name() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'-c[]' \
'(-c)-v[]' \
'-h[Print help]' \
'--help[Print help]' \
":: :_bin-name_commands" \
"*::: :->my-app" \
&& ret=0
    case $state in
    (my-app)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:bin-name-command-$line[1]:"
        case $line[1] in
            (test)
_arguments "${_arguments_options[@]}" : \
'*-d[]' \
'-c[]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_bin-name__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:bin-name-help-command-$line[1]:"
        case $line[1] in
            (test)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
}

(( $+functions[_bin-name_commands] )) ||
_bin-name_commands() {
    local commands; commands=(
'test:Subcommand with a second line' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'bin-name commands' commands "$@"
}
(( $+functions[_bin-name__help_commands] )) ||
_bin-name__help_commands() {
    local commands; commands=(
'test:Subcommand with a second line' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'bin-name help commands' commands "$@"
}
(( $+functions[_bin-name__help__help_commands] )) ||
_bin-name__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'bin-name help help commands' commands "$@"
}
(( $+functions[_bin-name__help__test_commands] )) ||
_bin-name__help__test_commands() {
    local commands; commands=()
    _describe -t commands 'bin-name help test commands' commands "$@"
}
(( $+functions[_bin-name__test_commands] )) ||
_bin-name__test_commands() {
    local commands; commands=()
    _describe -t commands 'bin-name test commands' commands "$@"
}

if [ "$funcstack[1]" = "_bin-name" ]; then
    _bin-name "$@"
else
    compdef _bin-name bin-name
fi

```

`clap/clap_complete/tests/snapshots/feature_sample.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            my__app,help)
                cmd="my__app__help"
                ;;
            my__app,test)
                cmd="my__app__test"
                ;;
            my__app__help,help)
                cmd="my__app__help__help"
                ;;
            my__app__help,test)
                cmd="my__app__help__test"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-C -c -h -V --conf --config --help --version [file] first second test help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help)
            opts="test help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__help)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__test)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__test)
            opts="-h -V --case --help --version"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                --case)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/feature_sample.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand -c 'some config file'
            cand -C 'some config file'
            cand --config 'some config file'
            cand --conf 'some config file'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
            cand test 'tests things'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;test'= {
            cand --case 'the case to test'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'my-app;help'= {
            cand test 'tests things'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;help;test'= {
        }
        &'my-app;help;help'= {
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/feature_sample.fish`:

```fish
# Print an optspec for argparse to handle cmd's options that are independent of any subcommand.
function __fish_my_app_global_optspecs
	string join \n c/config h/help V/version
end

function __fish_my_app_needs_command
	# Figure out if the current invocation already has a command.
	set -l cmd (commandline -opc)
	set -e cmd[1]
	argparse -s (__fish_my_app_global_optspecs) -- $cmd 2>/dev/null
	or return
	if set -q argv[1]
		# Also print the command, so this can be used to figure out what it is.
		echo $argv[1]
		return 1
	end
	return 0
end

function __fish_my_app_using_subcommand
	set -l cmd (__fish_my_app_needs_command)
	test -z "$cmd"
	and return 1
	contains -- $cmd[1] $argv
end

complete -c my-app -n "__fish_my_app_needs_command" -s c -s C -l config -l conf -d 'some config file'
complete -c my-app -n "__fish_my_app_needs_command" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_needs_command" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_needs_command" -a "test" -d 'tests things'
complete -c my-app -n "__fish_my_app_needs_command" -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand test" -l case -d 'the case to test' -r
complete -c my-app -n "__fish_my_app_using_subcommand test" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand test" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test help" -f -a "test" -d 'tests things'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'

```

`clap/clap_complete/tests/snapshots/feature_sample.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('-c', '-c', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('-C', '-C ', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('--config', '--config', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('--conf', '--conf', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'tests things')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;test' {
            [CompletionResult]::new('--case', '--case', [CompletionResultType]::ParameterName, 'the case to test')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'my-app;help' {
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'tests things')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;help;test' {
            break
        }
        'my-app;help;help' {
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/feature_sample.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'*-c[some config file]' \
'*-C[some config file]' \
'*--config[some config file]' \
'*--conf[some config file]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
'::file -- some input file:_files' \
'::choice:(first second)' \
":: :_my-app_commands" \
"*::: :->my-app" \
&& ret=0
    case $state in
    (my-app)
        words=($line[3] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-command-$line[3]:"
        case $line[3] in
            (test)
_arguments "${_arguments_options[@]}" : \
'--case=[the case to test]: :_default' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_my-app__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-help-command-$line[1]:"
        case $line[1] in
            (test)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=(
'test:tests things' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app commands' commands "$@"
}
(( $+functions[_my-app__help_commands] )) ||
_my-app__help_commands() {
    local commands; commands=(
'test:tests things' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app help commands' commands "$@"
}
(( $+functions[_my-app__help__help_commands] )) ||
_my-app__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help help commands' commands "$@"
}
(( $+functions[_my-app__help__test_commands] )) ||
_my-app__help__test_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help test commands' commands "$@"
}
(( $+functions[_my-app__test_commands] )) ||
_my-app__test_commands() {
    local commands; commands=()
    _describe -t commands 'my-app test commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/snapshots/home/dynamic-env/exhaustive/elvish/elvish/rc.elv`:

```elv
set edit:rprompt = (constantly "")
set edit:prompt = (constantly "% ")

set edit:completion:arg-completer[exhaustive] = { |@words|
    var index = (count $words)
    set index = (- $index 1)

    put (env _CLAP_IFS="\n" _CLAP_COMPLETE_INDEX=(to-string $index) COMPLETE="elvish" exhaustive -- $@words) | to-lines
}



```

`clap/clap_complete/tests/snapshots/home/dynamic-env/exhaustive/fish/fish/completions/exhaustive.fish`:

```fish
complete --keep-order --exclusive --command exhaustive --arguments "(COMPLETE=fish "'exhaustive'" -- (commandline --current-process --tokenize --cut-at-cursor) (commandline --current-token))"

```

`clap/clap_complete/tests/snapshots/home/dynamic-env/exhaustive/fish/fish/config.fish`:

```fish
set -U fish_greeting ""
set -U fish_autosuggestion_enabled 0
function fish_title
end
function fish_prompt
    printf '%% '
end;

```

`clap/clap_complete/tests/snapshots/home/dynamic-env/exhaustive/zsh/zsh/_exhaustive`:

```
#compdef exhaustive
function _clap_dynamic_completer_exhaustive() {
    local _CLAP_COMPLETE_INDEX=$(expr $CURRENT - 1)
    local _CLAP_IFS=$'\n'

    local completions=("${(@f)$( \
        _CLAP_IFS="$_CLAP_IFS" \
        _CLAP_COMPLETE_INDEX="$_CLAP_COMPLETE_INDEX" \
        COMPLETE="zsh" \
        exhaustive -- ${words} 2>/dev/null \
    )}")

    if [[ -n $completions ]]; then
        _describe 'values' completions
    fi
}

compdef _clap_dynamic_completer_exhaustive exhaustive

```

`clap/clap_complete/tests/snapshots/home/static/exhaustive/elvish/elvish/rc.elv`:

```elv
set edit:rprompt = (constantly "")
set edit:prompt = (constantly "% ")

use builtin;
use str;

set edit:completion:arg-completer[exhaustive] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'exhaustive'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'exhaustive'= {
            cand --generate 'generate'
            cand --empty-choice 'empty-choice'
            cand -h 'Print help'
            cand --help 'Print help'
            cand empty 'empty'
            cand global 'global'
            cand action 'action'
            cand quote 'quote'
            cand value 'value'
            cand pacman 'pacman'
            cand last 'last'
            cand alias 'alias'
            cand hint 'hint'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;empty'= {
        }
        &'exhaustive;global'= {
            cand --global 'everywhere'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
            cand one 'one'
            cand two 'two'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;global;one'= {
            cand --global 'everywhere'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
            cand one-one 'one-one'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;global;one;one-one'= {
            cand --global 'everywhere'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'exhaustive;global;one;help'= {
            cand one-one 'one-one'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;global;one;help;one-one'= {
        }
        &'exhaustive;global;one;help;help'= {
        }
        &'exhaustive;global;two'= {
            cand --global 'everywhere'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'exhaustive;global;help'= {
            cand one 'one'
            cand two 'two'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;global;help;one'= {
            cand one-one 'one-one'
        }
        &'exhaustive;global;help;one;one-one'= {
        }
        &'exhaustive;global;help;two'= {
        }
        &'exhaustive;global;help;help'= {
        }
        &'exhaustive;action'= {
            cand --set 'value'
            cand --choice 'enum'
            cand --set-true 'bool'
            cand --count 'number'
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;quote'= {
            cand --choice 'choice'
            cand --single-quotes 'Can be ''always'', ''auto'', or ''never'''
            cand --double-quotes 'Can be "always", "auto", or "never"'
            cand --backticks 'For more information see `echo test`'
            cand --backslash 'Avoid ''\n'''
            cand --brackets 'List packages [filter]'
            cand --expansions 'Execute the shell command with $SHELL'
            cand -h 'Print help (see more with ''--help'')'
            cand --help 'Print help (see more with ''--help'')'
            cand cmd-single-quotes 'Can be ''always'', ''auto'', or ''never'''
            cand cmd-double-quotes 'Can be "always", "auto", or "never"'
            cand cmd-backticks 'For more information see `echo test`'
            cand cmd-backslash 'Avoid ''\n'''
            cand cmd-brackets 'List packages [filter]'
            cand cmd-expansions 'Execute the shell command with $SHELL'
            cand escape-help '\tab	"'' New Line'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;quote;cmd-single-quotes'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;quote;cmd-double-quotes'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;quote;cmd-backticks'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;quote;cmd-backslash'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;quote;cmd-brackets'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;quote;cmd-expansions'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;quote;escape-help'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;quote;help'= {
            cand cmd-single-quotes 'Can be ''always'', ''auto'', or ''never'''
            cand cmd-double-quotes 'Can be "always", "auto", or "never"'
            cand cmd-backticks 'For more information see `echo test`'
            cand cmd-backslash 'Avoid ''\n'''
            cand cmd-brackets 'List packages [filter]'
            cand cmd-expansions 'Execute the shell command with $SHELL'
            cand escape-help '\tab	"'' New Line'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;quote;help;cmd-single-quotes'= {
        }
        &'exhaustive;quote;help;cmd-double-quotes'= {
        }
        &'exhaustive;quote;help;cmd-backticks'= {
        }
        &'exhaustive;quote;help;cmd-backslash'= {
        }
        &'exhaustive;quote;help;cmd-brackets'= {
        }
        &'exhaustive;quote;help;cmd-expansions'= {
        }
        &'exhaustive;quote;help;escape-help'= {
        }
        &'exhaustive;quote;help;help'= {
        }
        &'exhaustive;value'= {
            cand --delim 'delim'
            cand --tuple 'tuple'
            cand --require-eq 'require-eq'
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;pacman'= {
            cand -h 'Print help'
            cand --help 'Print help'
            cand one 'one'
            cand two 'two'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;pacman;one'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;pacman;two'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;pacman;help'= {
            cand one 'one'
            cand two 'two'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;pacman;help;one'= {
        }
        &'exhaustive;pacman;help;two'= {
        }
        &'exhaustive;pacman;help;help'= {
        }
        &'exhaustive;last'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;alias'= {
            cand -o 'cmd option'
            cand -O 'cmd option'
            cand --option 'cmd option'
            cand --opt 'cmd option'
            cand -f 'cmd flag'
            cand -F 'cmd flag'
            cand --flag 'cmd flag'
            cand --flg 'cmd flag'
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;hint'= {
            cand --choice 'choice'
            cand --unknown 'unknown'
            cand --other 'other'
            cand -p 'p'
            cand --path 'path'
            cand -f 'f'
            cand --file 'file'
            cand -d 'd'
            cand --dir 'dir'
            cand -e 'e'
            cand --exe 'exe'
            cand --cmd-name 'cmd-name'
            cand -c 'c'
            cand --cmd 'cmd'
            cand -u 'u'
            cand --user 'user'
            cand -H 'H'
            cand --host 'host'
            cand --url 'url'
            cand --email 'email'
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'exhaustive;help'= {
            cand empty 'empty'
            cand global 'global'
            cand action 'action'
            cand quote 'quote'
            cand value 'value'
            cand pacman 'pacman'
            cand last 'last'
            cand alias 'alias'
            cand hint 'hint'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'exhaustive;help;empty'= {
        }
        &'exhaustive;help;global'= {
            cand one 'one'
            cand two 'two'
        }
        &'exhaustive;help;global;one'= {
            cand one-one 'one-one'
        }
        &'exhaustive;help;global;one;one-one'= {
        }
        &'exhaustive;help;global;two'= {
        }
        &'exhaustive;help;action'= {
        }
        &'exhaustive;help;quote'= {
            cand cmd-single-quotes 'Can be ''always'', ''auto'', or ''never'''
            cand cmd-double-quotes 'Can be "always", "auto", or "never"'
            cand cmd-backticks 'For more information see `echo test`'
            cand cmd-backslash 'Avoid ''\n'''
            cand cmd-brackets 'List packages [filter]'
            cand cmd-expansions 'Execute the shell command with $SHELL'
            cand escape-help '\tab	"'' New Line'
        }
        &'exhaustive;help;quote;cmd-single-quotes'= {
        }
        &'exhaustive;help;quote;cmd-double-quotes'= {
        }
        &'exhaustive;help;quote;cmd-backticks'= {
        }
        &'exhaustive;help;quote;cmd-backslash'= {
        }
        &'exhaustive;help;quote;cmd-brackets'= {
        }
        &'exhaustive;help;quote;cmd-expansions'= {
        }
        &'exhaustive;help;quote;escape-help'= {
        }
        &'exhaustive;help;value'= {
        }
        &'exhaustive;help;pacman'= {
            cand one 'one'
            cand two 'two'
        }
        &'exhaustive;help;pacman;one'= {
        }
        &'exhaustive;help;pacman;two'= {
        }
        &'exhaustive;help;last'= {
        }
        &'exhaustive;help;alias'= {
        }
        &'exhaustive;help;hint'= {
        }
        &'exhaustive;help;help'= {
        }
    ]
    $completions[$command]
}


```

`clap/clap_complete/tests/snapshots/home/static/exhaustive/fish/fish/completions/exhaustive.fish`:

```fish
# Print an optspec for argparse to handle cmd's options that are independent of any subcommand.
function __fish_exhaustive_global_optspecs
	string join \n generate= empty-choice= h/help
end

function __fish_exhaustive_needs_command
	# Figure out if the current invocation already has a command.
	set -l cmd (commandline -opc)
	set -e cmd[1]
	argparse -s (__fish_exhaustive_global_optspecs) -- $cmd 2>/dev/null
	or return
	if set -q argv[1]
		# Also print the command, so this can be used to figure out what it is.
		echo $argv[1]
		return 1
	end
	return 0
end

function __fish_exhaustive_using_subcommand
	set -l cmd (__fish_exhaustive_needs_command)
	test -z "$cmd"
	and return 1
	contains -- $cmd[1] $argv
end

complete -c exhaustive -n "__fish_exhaustive_needs_command" -l generate -d 'generate' -r -f -a "bash\t''
elvish\t''
fish\t''
powershell\t''
zsh\t''"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -l empty-choice -r -f -a ""
complete -c exhaustive -n "__fish_exhaustive_needs_command" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "empty"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "global"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "action"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "quote"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "value"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "pacman"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "last"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "alias"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "hint"
complete -c exhaustive -n "__fish_exhaustive_needs_command" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and not __fish_seen_subcommand_from one two help" -l global -d 'everywhere'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and not __fish_seen_subcommand_from one two help" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and not __fish_seen_subcommand_from one two help" -s V -l version -d 'Print version'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and not __fish_seen_subcommand_from one two help" -f -a "one"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and not __fish_seen_subcommand_from one two help" -f -a "two"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and not __fish_seen_subcommand_from one two help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from one" -l global -d 'everywhere'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from one" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from one" -s V -l version -d 'Print version'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from one" -f -a "one-one"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from one" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from two" -l global -d 'everywhere'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from two" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from two" -s V -l version -d 'Print version'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from help" -f -a "one"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from help" -f -a "two"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand global; and __fish_seen_subcommand_from help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand action" -l set -d 'value' -r
complete -c exhaustive -n "__fish_exhaustive_using_subcommand action" -l choice -d 'enum' -r -f -a "first\t''
second\t''"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand action" -l set-true -d 'bool'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand action" -l count -d 'number'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand action" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -l choice -r -f -a "another shell\t'something with a space'
bash\t'bash (shell)'
fish\t'fish shell'
zsh\t'zsh shell'"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -l single-quotes -d 'Can be \'always\', \'auto\', or \'never\''
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -l double-quotes -d 'Can be "always", "auto", or "never"'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -l backticks -d 'For more information see `echo test`'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -l backslash -d 'Avoid \'\\n\''
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -l brackets -d 'List packages [filter]'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -l expansions -d 'Execute the shell command with $SHELL'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -s h -l help -d 'Print help (see more with \'--help\')'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -f -a "cmd-single-quotes" -d 'Can be \'always\', \'auto\', or \'never\''
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -f -a "cmd-double-quotes" -d 'Can be "always", "auto", or "never"'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -f -a "cmd-backticks" -d 'For more information see `echo test`'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -f -a "cmd-backslash" -d 'Avoid \'\\n\''
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -f -a "cmd-brackets" -d 'List packages [filter]'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -f -a "cmd-expansions" -d 'Execute the shell command with $SHELL'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -f -a "escape-help" -d '\\tab	"\' New Line'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions escape-help help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from cmd-single-quotes" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from cmd-double-quotes" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from cmd-backticks" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from cmd-backslash" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from cmd-brackets" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from cmd-expansions" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from escape-help" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from help" -f -a "cmd-single-quotes" -d 'Can be \'always\', \'auto\', or \'never\''
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from help" -f -a "cmd-double-quotes" -d 'Can be "always", "auto", or "never"'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from help" -f -a "cmd-backticks" -d 'For more information see `echo test`'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from help" -f -a "cmd-backslash" -d 'Avoid \'\\n\''
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from help" -f -a "cmd-brackets" -d 'List packages [filter]'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from help" -f -a "cmd-expansions" -d 'Execute the shell command with $SHELL'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from help" -f -a "escape-help" -d '\\tab	"\' New Line'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand quote; and __fish_seen_subcommand_from help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand value" -l delim -r
complete -c exhaustive -n "__fish_exhaustive_using_subcommand value" -l tuple -r
complete -c exhaustive -n "__fish_exhaustive_using_subcommand value" -l require-eq -r
complete -c exhaustive -n "__fish_exhaustive_using_subcommand value" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand pacman; and not __fish_seen_subcommand_from one two help" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand pacman; and not __fish_seen_subcommand_from one two help" -f -a "one"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand pacman; and not __fish_seen_subcommand_from one two help" -f -a "two"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand pacman; and not __fish_seen_subcommand_from one two help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand pacman; and __fish_seen_subcommand_from one" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand pacman; and __fish_seen_subcommand_from two" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand pacman; and __fish_seen_subcommand_from help" -f -a "one"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand pacman; and __fish_seen_subcommand_from help" -f -a "two"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand pacman; and __fish_seen_subcommand_from help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand last" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand alias" -s o -s O -l option -l opt -d 'cmd option' -r
complete -c exhaustive -n "__fish_exhaustive_using_subcommand alias" -s f -s F -l flag -l flg -d 'cmd flag'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand alias" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -l choice -r -f -a "bash\t''
fish\t''
zsh\t''"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -l unknown -r
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -l other -r -f
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -s p -l path -r -F
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -s f -l file -r -F
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -s d -l dir -r -f -a "(__fish_complete_directories)"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -s e -l exe -r -F
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -l cmd-name -r -f -a "(__fish_complete_command)"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -s c -l cmd -r -f -a "(__fish_complete_command)"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -s u -l user -r -f -a "(__fish_complete_users)"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -s H -l host -r -f -a "(__fish_print_hostnames)"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -l url -r -f
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -l email -r -f
complete -c exhaustive -n "__fish_exhaustive_using_subcommand hint" -s h -l help -d 'Print help'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "empty"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "global"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "action"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "quote"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "value"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "pacman"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "last"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "alias"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "hint"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and not __fish_seen_subcommand_from empty global action quote value pacman last alias hint help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from global" -f -a "one"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from global" -f -a "two"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from quote" -f -a "cmd-single-quotes" -d 'Can be \'always\', \'auto\', or \'never\''
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from quote" -f -a "cmd-double-quotes" -d 'Can be "always", "auto", or "never"'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from quote" -f -a "cmd-backticks" -d 'For more information see `echo test`'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from quote" -f -a "cmd-backslash" -d 'Avoid \'\\n\''
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from quote" -f -a "cmd-brackets" -d 'List packages [filter]'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from quote" -f -a "cmd-expansions" -d 'Execute the shell command with $SHELL'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from quote" -f -a "escape-help" -d '\\tab	"\' New Line'
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from pacman" -f -a "one"
complete -c exhaustive -n "__fish_exhaustive_using_subcommand help; and __fish_seen_subcommand_from pacman" -f -a "two"

```

`clap/clap_complete/tests/snapshots/home/static/exhaustive/fish/fish/config.fish`:

```fish
set -U fish_greeting ""
set -U fish_autosuggestion_enabled 0
function fish_title
end
function fish_prompt
    printf '%% '
end;

```

`clap/clap_complete/tests/snapshots/home/static/exhaustive/powershell/powershell/Microsoft.PowerShell_profile.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'exhaustive' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'exhaustive'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'exhaustive' {
            [CompletionResult]::new('--generate', 'generate', [CompletionResultType]::ParameterName, 'generate')
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('action', 'action', [CompletionResultType]::ParameterValue, 'action')
            [CompletionResult]::new('quote', 'quote', [CompletionResultType]::ParameterValue, 'quote')
            [CompletionResult]::new('value', 'value', [CompletionResultType]::ParameterValue, 'value')
            [CompletionResult]::new('pacman', 'pacman', [CompletionResultType]::ParameterValue, 'pacman')
            [CompletionResult]::new('last', 'last', [CompletionResultType]::ParameterValue, 'last')
            [CompletionResult]::new('alias', 'alias', [CompletionResultType]::ParameterValue, 'alias')
            [CompletionResult]::new('hint', 'hint', [CompletionResultType]::ParameterValue, 'hint')
            [CompletionResult]::new('complete', 'complete', [CompletionResultType]::ParameterValue, 'Register shell completions for this program')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'exhaustive;action' {
            [CompletionResult]::new('--set', 'set', [CompletionResultType]::ParameterName, 'value')
            [CompletionResult]::new('--choice', 'choice', [CompletionResultType]::ParameterName, 'enum')
            [CompletionResult]::new('--set-true', 'set-true', [CompletionResultType]::ParameterName, 'bool')
            [CompletionResult]::new('--count', 'count', [CompletionResultType]::ParameterName, 'number')
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;quote' {
            [CompletionResult]::new('--choice', 'choice', [CompletionResultType]::ParameterName, 'choice')
            [CompletionResult]::new('--single-quotes', 'single-quotes', [CompletionResultType]::ParameterName, 'Can be ''always'', ''auto'', or ''never''')
            [CompletionResult]::new('--double-quotes', 'double-quotes', [CompletionResultType]::ParameterName, 'Can be "always", "auto", or "never"')
            [CompletionResult]::new('--backticks', 'backticks', [CompletionResultType]::ParameterName, 'For more information see `echo test`')
            [CompletionResult]::new('--backslash', 'backslash', [CompletionResultType]::ParameterName, 'Avoid ''\n''')
            [CompletionResult]::new('--brackets', 'brackets', [CompletionResultType]::ParameterName, 'List packages [filter]')
            [CompletionResult]::new('--expansions', 'expansions', [CompletionResultType]::ParameterName, 'Execute the shell command with $SHELL')
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help (see more with ''--help'')')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help (see more with ''--help'')')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('cmd-single-quotes', 'cmd-single-quotes', [CompletionResultType]::ParameterValue, 'Can be ''always'', ''auto'', or ''never''')
            [CompletionResult]::new('cmd-double-quotes', 'cmd-double-quotes', [CompletionResultType]::ParameterValue, 'Can be "always", "auto", or "never"')
            [CompletionResult]::new('cmd-backticks', 'cmd-backticks', [CompletionResultType]::ParameterValue, 'For more information see `echo test`')
            [CompletionResult]::new('cmd-backslash', 'cmd-backslash', [CompletionResultType]::ParameterValue, 'Avoid ''\n''')
            [CompletionResult]::new('cmd-brackets', 'cmd-brackets', [CompletionResultType]::ParameterValue, 'List packages [filter]')
            [CompletionResult]::new('cmd-expansions', 'cmd-expansions', [CompletionResultType]::ParameterValue, 'Execute the shell command with $SHELL')
            [CompletionResult]::new('escape-help', 'escape-help', [CompletionResultType]::ParameterValue, '\tab	"'' New Line')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'exhaustive;quote;cmd-single-quotes' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;quote;cmd-double-quotes' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;quote;cmd-backticks' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;quote;cmd-backslash' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;quote;cmd-brackets' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;quote;cmd-expansions' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;quote;escape-help' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;quote;help' {
            [CompletionResult]::new('cmd-single-quotes', 'cmd-single-quotes', [CompletionResultType]::ParameterValue, 'Can be ''always'', ''auto'', or ''never''')
            [CompletionResult]::new('cmd-double-quotes', 'cmd-double-quotes', [CompletionResultType]::ParameterValue, 'Can be "always", "auto", or "never"')
            [CompletionResult]::new('cmd-backticks', 'cmd-backticks', [CompletionResultType]::ParameterValue, 'For more information see `echo test`')
            [CompletionResult]::new('cmd-backslash', 'cmd-backslash', [CompletionResultType]::ParameterValue, 'Avoid ''\n''')
            [CompletionResult]::new('cmd-brackets', 'cmd-brackets', [CompletionResultType]::ParameterValue, 'List packages [filter]')
            [CompletionResult]::new('cmd-expansions', 'cmd-expansions', [CompletionResultType]::ParameterValue, 'Execute the shell command with $SHELL')
            [CompletionResult]::new('escape-help', 'escape-help', [CompletionResultType]::ParameterValue, '\tab	"'' New Line')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'exhaustive;quote;help;cmd-single-quotes' {
            break
        }
        'exhaustive;quote;help;cmd-double-quotes' {
            break
        }
        'exhaustive;quote;help;cmd-backticks' {
            break
        }
        'exhaustive;quote;help;cmd-backslash' {
            break
        }
        'exhaustive;quote;help;cmd-brackets' {
            break
        }
        'exhaustive;quote;help;cmd-expansions' {
            break
        }
        'exhaustive;quote;help;escape-help' {
            break
        }
        'exhaustive;quote;help;help' {
            break
        }
        'exhaustive;value' {
            [CompletionResult]::new('--delim', 'delim', [CompletionResultType]::ParameterName, 'delim')
            [CompletionResult]::new('--tuple', 'tuple', [CompletionResultType]::ParameterName, 'tuple')
            [CompletionResult]::new('--require-eq', 'require-eq', [CompletionResultType]::ParameterName, 'require-eq')
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;pacman' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('one', 'one', [CompletionResultType]::ParameterValue, 'one')
            [CompletionResult]::new('two', 'two', [CompletionResultType]::ParameterValue, 'two')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'exhaustive;pacman;one' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;pacman;two' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;pacman;help' {
            [CompletionResult]::new('one', 'one', [CompletionResultType]::ParameterValue, 'one')
            [CompletionResult]::new('two', 'two', [CompletionResultType]::ParameterValue, 'two')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'exhaustive;pacman;help;one' {
            break
        }
        'exhaustive;pacman;help;two' {
            break
        }
        'exhaustive;pacman;help;help' {
            break
        }
        'exhaustive;last' {
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;alias' {
            [CompletionResult]::new('-o', 'o', [CompletionResultType]::ParameterName, 'cmd option')
            [CompletionResult]::new('-O', 'O ', [CompletionResultType]::ParameterName, 'cmd option')
            [CompletionResult]::new('--option', 'option', [CompletionResultType]::ParameterName, 'cmd option')
            [CompletionResult]::new('--opt', 'opt', [CompletionResultType]::ParameterName, 'cmd option')
            [CompletionResult]::new('-f', 'f', [CompletionResultType]::ParameterName, 'cmd flag')
            [CompletionResult]::new('-F', 'F ', [CompletionResultType]::ParameterName, 'cmd flag')
            [CompletionResult]::new('--flag', 'flag', [CompletionResultType]::ParameterName, 'cmd flag')
            [CompletionResult]::new('--flg', 'flg', [CompletionResultType]::ParameterName, 'cmd flag')
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;hint' {
            [CompletionResult]::new('--choice', 'choice', [CompletionResultType]::ParameterName, 'choice')
            [CompletionResult]::new('--unknown', 'unknown', [CompletionResultType]::ParameterName, 'unknown')
            [CompletionResult]::new('--other', 'other', [CompletionResultType]::ParameterName, 'other')
            [CompletionResult]::new('-p', 'p', [CompletionResultType]::ParameterName, 'p')
            [CompletionResult]::new('--path', 'path', [CompletionResultType]::ParameterName, 'path')
            [CompletionResult]::new('-f', 'f', [CompletionResultType]::ParameterName, 'f')
            [CompletionResult]::new('--file', 'file', [CompletionResultType]::ParameterName, 'file')
            [CompletionResult]::new('-d', 'd', [CompletionResultType]::ParameterName, 'd')
            [CompletionResult]::new('--dir', 'dir', [CompletionResultType]::ParameterName, 'dir')
            [CompletionResult]::new('-e', 'e', [CompletionResultType]::ParameterName, 'e')
            [CompletionResult]::new('--exe', 'exe', [CompletionResultType]::ParameterName, 'exe')
            [CompletionResult]::new('--cmd-name', 'cmd-name', [CompletionResultType]::ParameterName, 'cmd-name')
            [CompletionResult]::new('-c', 'c', [CompletionResultType]::ParameterName, 'c')
            [CompletionResult]::new('--cmd', 'cmd', [CompletionResultType]::ParameterName, 'cmd')
            [CompletionResult]::new('-u', 'u', [CompletionResultType]::ParameterName, 'u')
            [CompletionResult]::new('--user', 'user', [CompletionResultType]::ParameterName, 'user')
            [CompletionResult]::new('-H', 'H ', [CompletionResultType]::ParameterName, 'H')
            [CompletionResult]::new('--host', 'host', [CompletionResultType]::ParameterName, 'host')
            [CompletionResult]::new('--url', 'url', [CompletionResultType]::ParameterName, 'url')
            [CompletionResult]::new('--email', 'email', [CompletionResultType]::ParameterName, 'email')
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;complete' {
            [CompletionResult]::new('--shell', 'shell', [CompletionResultType]::ParameterName, 'Specify shell to complete for')
            [CompletionResult]::new('--register', 'register', [CompletionResultType]::ParameterName, 'Path to write completion-registration to')
            [CompletionResult]::new('--global', 'global', [CompletionResultType]::ParameterName, 'everywhere')
            [CompletionResult]::new('-h', 'h', [CompletionResultType]::ParameterName, 'Print help (see more with ''--help'')')
            [CompletionResult]::new('--help', 'help', [CompletionResultType]::ParameterName, 'Print help (see more with ''--help'')')
            [CompletionResult]::new('-V', 'V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', 'version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'exhaustive;help' {
            [CompletionResult]::new('action', 'action', [CompletionResultType]::ParameterValue, 'action')
            [CompletionResult]::new('quote', 'quote', [CompletionResultType]::ParameterValue, 'quote')
            [CompletionResult]::new('value', 'value', [CompletionResultType]::ParameterValue, 'value')
            [CompletionResult]::new('pacman', 'pacman', [CompletionResultType]::ParameterValue, 'pacman')
            [CompletionResult]::new('last', 'last', [CompletionResultType]::ParameterValue, 'last')
            [CompletionResult]::new('alias', 'alias', [CompletionResultType]::ParameterValue, 'alias')
            [CompletionResult]::new('hint', 'hint', [CompletionResultType]::ParameterValue, 'hint')
            [CompletionResult]::new('complete', 'complete', [CompletionResultType]::ParameterValue, 'Register shell completions for this program')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'exhaustive;help;action' {
            break
        }
        'exhaustive;help;quote' {
            [CompletionResult]::new('cmd-single-quotes', 'cmd-single-quotes', [CompletionResultType]::ParameterValue, 'Can be ''always'', ''auto'', or ''never''')
            [CompletionResult]::new('cmd-double-quotes', 'cmd-double-quotes', [CompletionResultType]::ParameterValue, 'Can be "always", "auto", or "never"')
            [CompletionResult]::new('cmd-backticks', 'cmd-backticks', [CompletionResultType]::ParameterValue, 'For more information see `echo test`')
            [CompletionResult]::new('cmd-backslash', 'cmd-backslash', [CompletionResultType]::ParameterValue, 'Avoid ''\n''')
            [CompletionResult]::new('cmd-brackets', 'cmd-brackets', [CompletionResultType]::ParameterValue, 'List packages [filter]')
            [CompletionResult]::new('cmd-expansions', 'cmd-expansions', [CompletionResultType]::ParameterValue, 'Execute the shell command with $SHELL')
            [CompletionResult]::new('escape-help', 'escape-help', [CompletionResultType]::ParameterValue, '\tab	"'' New Line')
            break
        }
        'exhaustive;help;quote;cmd-single-quotes' {
            break
        }
        'exhaustive;help;quote;cmd-double-quotes' {
            break
        }
        'exhaustive;help;quote;cmd-backticks' {
            break
        }
        'exhaustive;help;quote;cmd-backslash' {
            break
        }
        'exhaustive;help;quote;cmd-brackets' {
            break
        }
        'exhaustive;help;quote;cmd-expansions' {
            break
        }
        'exhaustive;help;quote;escape-help' {
            break
        }
        'exhaustive;help;value' {
            break
        }
        'exhaustive;help;pacman' {
            [CompletionResult]::new('one', 'one', [CompletionResultType]::ParameterValue, 'one')
            [CompletionResult]::new('two', 'two', [CompletionResultType]::ParameterValue, 'two')
            break
        }
        'exhaustive;help;pacman;one' {
            break
        }
        'exhaustive;help;pacman;two' {
            break
        }
        'exhaustive;help;last' {
            break
        }
        'exhaustive;help;alias' {
            break
        }
        'exhaustive;help;hint' {
            break
        }
        'exhaustive;help;complete' {
            break
        }
        'exhaustive;help;help' {
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}
function prompt {
    '% '
}
Set-PSReadLineOption -PredictionSource None
```

`clap/clap_complete/tests/snapshots/home/static/exhaustive/zsh/zsh/_exhaustive`:

```
#compdef exhaustive

autoload -U is-at-least

_exhaustive() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'--generate=[generate]:SHELL:(bash elvish fish powershell zsh)' \
'--empty-choice=[]: :()' \
'-h[Print help]' \
'--help[Print help]' \
":: :_exhaustive_commands" \
"*::: :->exhaustive" \
&& ret=0
    case $state in
    (exhaustive)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-command-$line[1]:"
        case $line[1] in
            (empty)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(global)
_arguments "${_arguments_options[@]}" : \
'--global[everywhere]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
":: :_exhaustive__global_commands" \
"*::: :->global" \
&& ret=0

    case $state in
    (global)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-global-command-$line[1]:"
        case $line[1] in
            (one)
_arguments "${_arguments_options[@]}" : \
'--global[everywhere]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
":: :_exhaustive__global__one_commands" \
"*::: :->one" \
&& ret=0

    case $state in
    (one)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-global-one-command-$line[1]:"
        case $line[1] in
            (one-one)
_arguments "${_arguments_options[@]}" : \
'--global[everywhere]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__global__one__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-global-one-help-command-$line[1]:"
        case $line[1] in
            (one-one)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
;;
(two)
_arguments "${_arguments_options[@]}" : \
'--global[everywhere]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__global__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-global-help-command-$line[1]:"
        case $line[1] in
            (one)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__global__help__one_commands" \
"*::: :->one" \
&& ret=0

    case $state in
    (one)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-global-help-one-command-$line[1]:"
        case $line[1] in
            (one-one)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
(two)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
;;
(action)
_arguments "${_arguments_options[@]}" : \
'--set=[value]: :_default' \
'--choice=[enum]: :(first second)' \
'--set-true[bool]' \
'*--count[number]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(quote)
_arguments "${_arguments_options[@]}" : \
'--choice=[]: :((another\ shell\:"something with a space"
bash\:"bash (shell)"
fish\:"fish shell"
zsh\:"zsh shell"))' \
'--single-quotes[Can be '\''always'\'', '\''auto'\'', or '\''never'\'']' \
'--double-quotes[Can be "always", "auto", or "never"]' \
'--backticks[For more information see \`echo test\`]' \
'--backslash[Avoid '\''\\n'\'']' \
'--brackets[List packages \[filter\]]' \
'--expansions[Execute the shell command with \$SHELL]' \
'-h[Print help (see more with '\''--help'\'')]' \
'--help[Print help (see more with '\''--help'\'')]' \
":: :_exhaustive__quote_commands" \
"*::: :->quote" \
&& ret=0

    case $state in
    (quote)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-quote-command-$line[1]:"
        case $line[1] in
            (cmd-single-quotes)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-double-quotes)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-backticks)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-backslash)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-brackets)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-expansions)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(escape-help)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__quote__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-quote-help-command-$line[1]:"
        case $line[1] in
            (cmd-single-quotes)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-double-quotes)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-backticks)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-backslash)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-brackets)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-expansions)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(escape-help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
;;
(value)
_arguments "${_arguments_options[@]}" : \
'--delim=[]: :_default' \
'--tuple=[]: :_default: :_default' \
'--require-eq=[]: :_default' \
'-h[Print help]' \
'--help[Print help]' \
'*;::term:_default' \
&& ret=0
;;
(pacman)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
":: :_exhaustive__pacman_commands" \
"*::: :->pacman" \
&& ret=0

    case $state in
    (pacman)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-pacman-command-$line[1]:"
        case $line[1] in
            (one)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(two)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__pacman__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-pacman-help-command-$line[1]:"
        case $line[1] in
            (one)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(two)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
;;
(last)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
'::first:_default' \
'::free:_default' \
&& ret=0
;;
(alias)
_arguments "${_arguments_options[@]}" : \
'-o+[cmd option]: :_default' \
'-O+[cmd option]: :_default' \
'--option=[cmd option]: :_default' \
'--opt=[cmd option]: :_default' \
'-f[cmd flag]' \
'-F[cmd flag]' \
'--flag[cmd flag]' \
'--flg[cmd flag]' \
'-h[Print help]' \
'--help[Print help]' \
'::positional:_default' \
&& ret=0
;;
(hint)
_arguments "${_arguments_options[@]}" : \
'--choice=[]: :(bash fish zsh)' \
'--unknown=[]: :_default' \
'--other=[]: :' \
'-p+[]: :_files' \
'--path=[]: :_files' \
'-f+[]: :_files' \
'--file=[]: :_files' \
'-d+[]: :_files -/' \
'--dir=[]: :_files -/' \
'-e+[]: :_absolute_command_paths' \
'--exe=[]: :_absolute_command_paths' \
'--cmd-name=[]: :_command_names -e' \
'-c+[]: :_cmdstring' \
'--cmd=[]: :_cmdstring' \
'-u+[]: :_users' \
'--user=[]: :_users' \
'-H+[]: :_hosts' \
'--host=[]: :_hosts' \
'--url=[]: :_urls' \
'--email=[]: :_email_addresses' \
'-h[Print help]' \
'--help[Print help]' \
'*::command_with_args:_cmdambivalent' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-help-command-$line[1]:"
        case $line[1] in
            (empty)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(global)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__help__global_commands" \
"*::: :->global" \
&& ret=0

    case $state in
    (global)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-help-global-command-$line[1]:"
        case $line[1] in
            (one)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__help__global__one_commands" \
"*::: :->one" \
&& ret=0

    case $state in
    (one)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-help-global-one-command-$line[1]:"
        case $line[1] in
            (one-one)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
(two)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
(action)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(quote)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__help__quote_commands" \
"*::: :->quote" \
&& ret=0

    case $state in
    (quote)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-help-quote-command-$line[1]:"
        case $line[1] in
            (cmd-single-quotes)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-double-quotes)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-backticks)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-backslash)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-brackets)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-expansions)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(escape-help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
(value)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(pacman)
_arguments "${_arguments_options[@]}" : \
":: :_exhaustive__help__pacman_commands" \
"*::: :->pacman" \
&& ret=0

    case $state in
    (pacman)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:exhaustive-help-pacman-command-$line[1]:"
        case $line[1] in
            (one)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(two)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
(last)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(alias)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(hint)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
}

(( $+functions[_exhaustive_commands] )) ||
_exhaustive_commands() {
    local commands; commands=(
'empty:' \
'global:' \
'action:' \
'quote:' \
'value:' \
'pacman:' \
'last:' \
'alias:' \
'hint:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive commands' commands "$@"
}
(( $+functions[_exhaustive__action_commands] )) ||
_exhaustive__action_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive action commands' commands "$@"
}
(( $+functions[_exhaustive__alias_commands] )) ||
_exhaustive__alias_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive alias commands' commands "$@"
}
(( $+functions[_exhaustive__empty_commands] )) ||
_exhaustive__empty_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive empty commands' commands "$@"
}
(( $+functions[_exhaustive__global_commands] )) ||
_exhaustive__global_commands() {
    local commands; commands=(
'one:' \
'two:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive global commands' commands "$@"
}
(( $+functions[_exhaustive__global__help_commands] )) ||
_exhaustive__global__help_commands() {
    local commands; commands=(
'one:' \
'two:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive global help commands' commands "$@"
}
(( $+functions[_exhaustive__global__help__help_commands] )) ||
_exhaustive__global__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive global help help commands' commands "$@"
}
(( $+functions[_exhaustive__global__help__one_commands] )) ||
_exhaustive__global__help__one_commands() {
    local commands; commands=(
'one-one:' \
    )
    _describe -t commands 'exhaustive global help one commands' commands "$@"
}
(( $+functions[_exhaustive__global__help__one__one-one_commands] )) ||
_exhaustive__global__help__one__one-one_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive global help one one-one commands' commands "$@"
}
(( $+functions[_exhaustive__global__help__two_commands] )) ||
_exhaustive__global__help__two_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive global help two commands' commands "$@"
}
(( $+functions[_exhaustive__global__one_commands] )) ||
_exhaustive__global__one_commands() {
    local commands; commands=(
'one-one:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive global one commands' commands "$@"
}
(( $+functions[_exhaustive__global__one__help_commands] )) ||
_exhaustive__global__one__help_commands() {
    local commands; commands=(
'one-one:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive global one help commands' commands "$@"
}
(( $+functions[_exhaustive__global__one__help__help_commands] )) ||
_exhaustive__global__one__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive global one help help commands' commands "$@"
}
(( $+functions[_exhaustive__global__one__help__one-one_commands] )) ||
_exhaustive__global__one__help__one-one_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive global one help one-one commands' commands "$@"
}
(( $+functions[_exhaustive__global__one__one-one_commands] )) ||
_exhaustive__global__one__one-one_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive global one one-one commands' commands "$@"
}
(( $+functions[_exhaustive__global__two_commands] )) ||
_exhaustive__global__two_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive global two commands' commands "$@"
}
(( $+functions[_exhaustive__help_commands] )) ||
_exhaustive__help_commands() {
    local commands; commands=(
'empty:' \
'global:' \
'action:' \
'quote:' \
'value:' \
'pacman:' \
'last:' \
'alias:' \
'hint:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive help commands' commands "$@"
}
(( $+functions[_exhaustive__help__action_commands] )) ||
_exhaustive__help__action_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help action commands' commands "$@"
}
(( $+functions[_exhaustive__help__alias_commands] )) ||
_exhaustive__help__alias_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help alias commands' commands "$@"
}
(( $+functions[_exhaustive__help__empty_commands] )) ||
_exhaustive__help__empty_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help empty commands' commands "$@"
}
(( $+functions[_exhaustive__help__global_commands] )) ||
_exhaustive__help__global_commands() {
    local commands; commands=(
'one:' \
'two:' \
    )
    _describe -t commands 'exhaustive help global commands' commands "$@"
}
(( $+functions[_exhaustive__help__global__one_commands] )) ||
_exhaustive__help__global__one_commands() {
    local commands; commands=(
'one-one:' \
    )
    _describe -t commands 'exhaustive help global one commands' commands "$@"
}
(( $+functions[_exhaustive__help__global__one__one-one_commands] )) ||
_exhaustive__help__global__one__one-one_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help global one one-one commands' commands "$@"
}
(( $+functions[_exhaustive__help__global__two_commands] )) ||
_exhaustive__help__global__two_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help global two commands' commands "$@"
}
(( $+functions[_exhaustive__help__help_commands] )) ||
_exhaustive__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help help commands' commands "$@"
}
(( $+functions[_exhaustive__help__hint_commands] )) ||
_exhaustive__help__hint_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help hint commands' commands "$@"
}
(( $+functions[_exhaustive__help__last_commands] )) ||
_exhaustive__help__last_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help last commands' commands "$@"
}
(( $+functions[_exhaustive__help__pacman_commands] )) ||
_exhaustive__help__pacman_commands() {
    local commands; commands=(
'one:' \
'two:' \
    )
    _describe -t commands 'exhaustive help pacman commands' commands "$@"
}
(( $+functions[_exhaustive__help__pacman__one_commands] )) ||
_exhaustive__help__pacman__one_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help pacman one commands' commands "$@"
}
(( $+functions[_exhaustive__help__pacman__two_commands] )) ||
_exhaustive__help__pacman__two_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help pacman two commands' commands "$@"
}
(( $+functions[_exhaustive__help__quote_commands] )) ||
_exhaustive__help__quote_commands() {
    local commands; commands=(
'cmd-single-quotes:Can be '\''always'\'', '\''auto'\'', or '\''never'\''' \
'cmd-double-quotes:Can be "always", "auto", or "never"' \
'cmd-backticks:For more information see \`echo test\`' \
'cmd-backslash:Avoid '\''\\n'\''' \
'cmd-brackets:List packages \[filter\]' \
'cmd-expansions:Execute the shell command with \$SHELL' \
'escape-help:\\tab	"'\'' New Line' \
    )
    _describe -t commands 'exhaustive help quote commands' commands "$@"
}
(( $+functions[_exhaustive__help__quote__cmd-backslash_commands] )) ||
_exhaustive__help__quote__cmd-backslash_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help quote cmd-backslash commands' commands "$@"
}
(( $+functions[_exhaustive__help__quote__cmd-backticks_commands] )) ||
_exhaustive__help__quote__cmd-backticks_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help quote cmd-backticks commands' commands "$@"
}
(( $+functions[_exhaustive__help__quote__cmd-brackets_commands] )) ||
_exhaustive__help__quote__cmd-brackets_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help quote cmd-brackets commands' commands "$@"
}
(( $+functions[_exhaustive__help__quote__cmd-double-quotes_commands] )) ||
_exhaustive__help__quote__cmd-double-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help quote cmd-double-quotes commands' commands "$@"
}
(( $+functions[_exhaustive__help__quote__cmd-expansions_commands] )) ||
_exhaustive__help__quote__cmd-expansions_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help quote cmd-expansions commands' commands "$@"
}
(( $+functions[_exhaustive__help__quote__cmd-single-quotes_commands] )) ||
_exhaustive__help__quote__cmd-single-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help quote cmd-single-quotes commands' commands "$@"
}
(( $+functions[_exhaustive__help__quote__escape-help_commands] )) ||
_exhaustive__help__quote__escape-help_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help quote escape-help commands' commands "$@"
}
(( $+functions[_exhaustive__help__value_commands] )) ||
_exhaustive__help__value_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive help value commands' commands "$@"
}
(( $+functions[_exhaustive__hint_commands] )) ||
_exhaustive__hint_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive hint commands' commands "$@"
}
(( $+functions[_exhaustive__last_commands] )) ||
_exhaustive__last_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive last commands' commands "$@"
}
(( $+functions[_exhaustive__pacman_commands] )) ||
_exhaustive__pacman_commands() {
    local commands; commands=(
'one:' \
'two:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive pacman commands' commands "$@"
}
(( $+functions[_exhaustive__pacman__help_commands] )) ||
_exhaustive__pacman__help_commands() {
    local commands; commands=(
'one:' \
'two:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive pacman help commands' commands "$@"
}
(( $+functions[_exhaustive__pacman__help__help_commands] )) ||
_exhaustive__pacman__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive pacman help help commands' commands "$@"
}
(( $+functions[_exhaustive__pacman__help__one_commands] )) ||
_exhaustive__pacman__help__one_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive pacman help one commands' commands "$@"
}
(( $+functions[_exhaustive__pacman__help__two_commands] )) ||
_exhaustive__pacman__help__two_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive pacman help two commands' commands "$@"
}
(( $+functions[_exhaustive__pacman__one_commands] )) ||
_exhaustive__pacman__one_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive pacman one commands' commands "$@"
}
(( $+functions[_exhaustive__pacman__two_commands] )) ||
_exhaustive__pacman__two_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive pacman two commands' commands "$@"
}
(( $+functions[_exhaustive__quote_commands] )) ||
_exhaustive__quote_commands() {
    local commands; commands=(
'cmd-single-quotes:Can be '\''always'\'', '\''auto'\'', or '\''never'\''' \
'cmd-double-quotes:Can be "always", "auto", or "never"' \
'cmd-backticks:For more information see \`echo test\`' \
'cmd-backslash:Avoid '\''\\n'\''' \
'cmd-brackets:List packages \[filter\]' \
'cmd-expansions:Execute the shell command with \$SHELL' \
'escape-help:\\tab	"'\'' New Line' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive quote commands' commands "$@"
}
(( $+functions[_exhaustive__quote__cmd-backslash_commands] )) ||
_exhaustive__quote__cmd-backslash_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote cmd-backslash commands' commands "$@"
}
(( $+functions[_exhaustive__quote__cmd-backticks_commands] )) ||
_exhaustive__quote__cmd-backticks_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote cmd-backticks commands' commands "$@"
}
(( $+functions[_exhaustive__quote__cmd-brackets_commands] )) ||
_exhaustive__quote__cmd-brackets_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote cmd-brackets commands' commands "$@"
}
(( $+functions[_exhaustive__quote__cmd-double-quotes_commands] )) ||
_exhaustive__quote__cmd-double-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote cmd-double-quotes commands' commands "$@"
}
(( $+functions[_exhaustive__quote__cmd-expansions_commands] )) ||
_exhaustive__quote__cmd-expansions_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote cmd-expansions commands' commands "$@"
}
(( $+functions[_exhaustive__quote__cmd-single-quotes_commands] )) ||
_exhaustive__quote__cmd-single-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote cmd-single-quotes commands' commands "$@"
}
(( $+functions[_exhaustive__quote__escape-help_commands] )) ||
_exhaustive__quote__escape-help_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote escape-help commands' commands "$@"
}
(( $+functions[_exhaustive__quote__help_commands] )) ||
_exhaustive__quote__help_commands() {
    local commands; commands=(
'cmd-single-quotes:Can be '\''always'\'', '\''auto'\'', or '\''never'\''' \
'cmd-double-quotes:Can be "always", "auto", or "never"' \
'cmd-backticks:For more information see \`echo test\`' \
'cmd-backslash:Avoid '\''\\n'\''' \
'cmd-brackets:List packages \[filter\]' \
'cmd-expansions:Execute the shell command with \$SHELL' \
'escape-help:\\tab	"'\'' New Line' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'exhaustive quote help commands' commands "$@"
}
(( $+functions[_exhaustive__quote__help__cmd-backslash_commands] )) ||
_exhaustive__quote__help__cmd-backslash_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote help cmd-backslash commands' commands "$@"
}
(( $+functions[_exhaustive__quote__help__cmd-backticks_commands] )) ||
_exhaustive__quote__help__cmd-backticks_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote help cmd-backticks commands' commands "$@"
}
(( $+functions[_exhaustive__quote__help__cmd-brackets_commands] )) ||
_exhaustive__quote__help__cmd-brackets_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote help cmd-brackets commands' commands "$@"
}
(( $+functions[_exhaustive__quote__help__cmd-double-quotes_commands] )) ||
_exhaustive__quote__help__cmd-double-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote help cmd-double-quotes commands' commands "$@"
}
(( $+functions[_exhaustive__quote__help__cmd-expansions_commands] )) ||
_exhaustive__quote__help__cmd-expansions_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote help cmd-expansions commands' commands "$@"
}
(( $+functions[_exhaustive__quote__help__cmd-single-quotes_commands] )) ||
_exhaustive__quote__help__cmd-single-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote help cmd-single-quotes commands' commands "$@"
}
(( $+functions[_exhaustive__quote__help__escape-help_commands] )) ||
_exhaustive__quote__help__escape-help_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote help escape-help commands' commands "$@"
}
(( $+functions[_exhaustive__quote__help__help_commands] )) ||
_exhaustive__quote__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive quote help help commands' commands "$@"
}
(( $+functions[_exhaustive__value_commands] )) ||
_exhaustive__value_commands() {
    local commands; commands=()
    _describe -t commands 'exhaustive value commands' commands "$@"
}

if [ "$funcstack[1]" = "_exhaustive" ]; then
    _exhaustive "$@"
else
    compdef _exhaustive exhaustive
fi

```

`clap/clap_complete/tests/snapshots/quoting.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            my__app,cmd-backslash)
                cmd="my__app__cmd__backslash"
                ;;
            my__app,cmd-backticks)
                cmd="my__app__cmd__backticks"
                ;;
            my__app,cmd-brackets)
                cmd="my__app__cmd__brackets"
                ;;
            my__app,cmd-double-quotes)
                cmd="my__app__cmd__double__quotes"
                ;;
            my__app,cmd-expansions)
                cmd="my__app__cmd__expansions"
                ;;
            my__app,cmd-single-quotes)
                cmd="my__app__cmd__single__quotes"
                ;;
            my__app,help)
                cmd="my__app__help"
                ;;
            my__app__help,cmd-backslash)
                cmd="my__app__help__cmd__backslash"
                ;;
            my__app__help,cmd-backticks)
                cmd="my__app__help__cmd__backticks"
                ;;
            my__app__help,cmd-brackets)
                cmd="my__app__help__cmd__brackets"
                ;;
            my__app__help,cmd-double-quotes)
                cmd="my__app__help__cmd__double__quotes"
                ;;
            my__app__help,cmd-expansions)
                cmd="my__app__help__cmd__expansions"
                ;;
            my__app__help,cmd-single-quotes)
                cmd="my__app__help__cmd__single__quotes"
                ;;
            my__app__help,help)
                cmd="my__app__help__help"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-h -V --single-quotes --double-quotes --backticks --backslash --brackets --expansions --help --version cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__cmd__backslash)
            opts="-h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__cmd__backticks)
            opts="-h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__cmd__brackets)
            opts="-h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__cmd__double__quotes)
            opts="-h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__cmd__expansions)
            opts="-h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__cmd__single__quotes)
            opts="-h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help)
            opts="cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__cmd__backslash)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__cmd__backticks)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__cmd__brackets)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__cmd__double__quotes)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__cmd__expansions)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__cmd__single__quotes)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__help)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/quoting.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand --single-quotes 'Can be ''always'', ''auto'', or ''never'''
            cand --double-quotes 'Can be "always", "auto", or "never"'
            cand --backticks 'For more information see `echo test`'
            cand --backslash 'Avoid ''\n'''
            cand --brackets 'List packages [filter]'
            cand --expansions 'Execute the shell command with $SHELL'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
            cand cmd-single-quotes 'Can be ''always'', ''auto'', or ''never'''
            cand cmd-double-quotes 'Can be "always", "auto", or "never"'
            cand cmd-backticks 'For more information see `echo test`'
            cand cmd-backslash 'Avoid ''\n'''
            cand cmd-brackets 'List packages [filter]'
            cand cmd-expansions 'Execute the shell command with $SHELL'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;cmd-single-quotes'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'my-app;cmd-double-quotes'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'my-app;cmd-backticks'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'my-app;cmd-backslash'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'my-app;cmd-brackets'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'my-app;cmd-expansions'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'my-app;help'= {
            cand cmd-single-quotes 'Can be ''always'', ''auto'', or ''never'''
            cand cmd-double-quotes 'Can be "always", "auto", or "never"'
            cand cmd-backticks 'For more information see `echo test`'
            cand cmd-backslash 'Avoid ''\n'''
            cand cmd-brackets 'List packages [filter]'
            cand cmd-expansions 'Execute the shell command with $SHELL'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;help;cmd-single-quotes'= {
        }
        &'my-app;help;cmd-double-quotes'= {
        }
        &'my-app;help;cmd-backticks'= {
        }
        &'my-app;help;cmd-backslash'= {
        }
        &'my-app;help;cmd-brackets'= {
        }
        &'my-app;help;cmd-expansions'= {
        }
        &'my-app;help;help'= {
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/quoting.fish`:

```fish
# Print an optspec for argparse to handle cmd's options that are independent of any subcommand.
function __fish_my_app_global_optspecs
	string join \n single-quotes double-quotes backticks backslash brackets expansions h/help V/version
end

function __fish_my_app_needs_command
	# Figure out if the current invocation already has a command.
	set -l cmd (commandline -opc)
	set -e cmd[1]
	argparse -s (__fish_my_app_global_optspecs) -- $cmd 2>/dev/null
	or return
	if set -q argv[1]
		# Also print the command, so this can be used to figure out what it is.
		echo $argv[1]
		return 1
	end
	return 0
end

function __fish_my_app_using_subcommand
	set -l cmd (__fish_my_app_needs_command)
	test -z "$cmd"
	and return 1
	contains -- $cmd[1] $argv
end

complete -c my-app -n "__fish_my_app_needs_command" -l single-quotes -d 'Can be \'always\', \'auto\', or \'never\''
complete -c my-app -n "__fish_my_app_needs_command" -l double-quotes -d 'Can be "always", "auto", or "never"'
complete -c my-app -n "__fish_my_app_needs_command" -l backticks -d 'For more information see `echo test`'
complete -c my-app -n "__fish_my_app_needs_command" -l backslash -d 'Avoid \'\\n\''
complete -c my-app -n "__fish_my_app_needs_command" -l brackets -d 'List packages [filter]'
complete -c my-app -n "__fish_my_app_needs_command" -l expansions -d 'Execute the shell command with $SHELL'
complete -c my-app -n "__fish_my_app_needs_command" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_needs_command" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_needs_command" -f -a "cmd-single-quotes" -d 'Can be \'always\', \'auto\', or \'never\''
complete -c my-app -n "__fish_my_app_needs_command" -f -a "cmd-double-quotes" -d 'Can be "always", "auto", or "never"'
complete -c my-app -n "__fish_my_app_needs_command" -f -a "cmd-backticks" -d 'For more information see `echo test`'
complete -c my-app -n "__fish_my_app_needs_command" -f -a "cmd-backslash" -d 'Avoid \'\\n\''
complete -c my-app -n "__fish_my_app_needs_command" -f -a "cmd-brackets" -d 'List packages [filter]'
complete -c my-app -n "__fish_my_app_needs_command" -f -a "cmd-expansions" -d 'Execute the shell command with $SHELL'
complete -c my-app -n "__fish_my_app_needs_command" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand cmd-single-quotes" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand cmd-double-quotes" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand cmd-backticks" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand cmd-backslash" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand cmd-brackets" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand cmd-expansions" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions help" -f -a "cmd-single-quotes" -d 'Can be \'always\', \'auto\', or \'never\''
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions help" -f -a "cmd-double-quotes" -d 'Can be "always", "auto", or "never"'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions help" -f -a "cmd-backticks" -d 'For more information see `echo test`'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions help" -f -a "cmd-backslash" -d 'Avoid \'\\n\''
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions help" -f -a "cmd-brackets" -d 'List packages [filter]'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions help" -f -a "cmd-expansions" -d 'Execute the shell command with $SHELL'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from cmd-single-quotes cmd-double-quotes cmd-backticks cmd-backslash cmd-brackets cmd-expansions help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'

```

`clap/clap_complete/tests/snapshots/quoting.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('--single-quotes', '--single-quotes', [CompletionResultType]::ParameterName, 'Can be ''always'', ''auto'', or ''never''')
            [CompletionResult]::new('--double-quotes', '--double-quotes', [CompletionResultType]::ParameterName, 'Can be "always", "auto", or "never"')
            [CompletionResult]::new('--backticks', '--backticks', [CompletionResultType]::ParameterName, 'For more information see `echo test`')
            [CompletionResult]::new('--backslash', '--backslash', [CompletionResultType]::ParameterName, 'Avoid ''\n''')
            [CompletionResult]::new('--brackets', '--brackets', [CompletionResultType]::ParameterName, 'List packages [filter]')
            [CompletionResult]::new('--expansions', '--expansions', [CompletionResultType]::ParameterName, 'Execute the shell command with $SHELL')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('cmd-single-quotes', 'cmd-single-quotes', [CompletionResultType]::ParameterValue, 'Can be ''always'', ''auto'', or ''never''')
            [CompletionResult]::new('cmd-double-quotes', 'cmd-double-quotes', [CompletionResultType]::ParameterValue, 'Can be "always", "auto", or "never"')
            [CompletionResult]::new('cmd-backticks', 'cmd-backticks', [CompletionResultType]::ParameterValue, 'For more information see `echo test`')
            [CompletionResult]::new('cmd-backslash', 'cmd-backslash', [CompletionResultType]::ParameterValue, 'Avoid ''\n''')
            [CompletionResult]::new('cmd-brackets', 'cmd-brackets', [CompletionResultType]::ParameterValue, 'List packages [filter]')
            [CompletionResult]::new('cmd-expansions', 'cmd-expansions', [CompletionResultType]::ParameterValue, 'Execute the shell command with $SHELL')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;cmd-single-quotes' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'my-app;cmd-double-quotes' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'my-app;cmd-backticks' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'my-app;cmd-backslash' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'my-app;cmd-brackets' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'my-app;cmd-expansions' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'my-app;help' {
            [CompletionResult]::new('cmd-single-quotes', 'cmd-single-quotes', [CompletionResultType]::ParameterValue, 'Can be ''always'', ''auto'', or ''never''')
            [CompletionResult]::new('cmd-double-quotes', 'cmd-double-quotes', [CompletionResultType]::ParameterValue, 'Can be "always", "auto", or "never"')
            [CompletionResult]::new('cmd-backticks', 'cmd-backticks', [CompletionResultType]::ParameterValue, 'For more information see `echo test`')
            [CompletionResult]::new('cmd-backslash', 'cmd-backslash', [CompletionResultType]::ParameterValue, 'Avoid ''\n''')
            [CompletionResult]::new('cmd-brackets', 'cmd-brackets', [CompletionResultType]::ParameterValue, 'List packages [filter]')
            [CompletionResult]::new('cmd-expansions', 'cmd-expansions', [CompletionResultType]::ParameterValue, 'Execute the shell command with $SHELL')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;help;cmd-single-quotes' {
            break
        }
        'my-app;help;cmd-double-quotes' {
            break
        }
        'my-app;help;cmd-backticks' {
            break
        }
        'my-app;help;cmd-backslash' {
            break
        }
        'my-app;help;cmd-brackets' {
            break
        }
        'my-app;help;cmd-expansions' {
            break
        }
        'my-app;help;help' {
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/quoting.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'--single-quotes[Can be '\''always'\'', '\''auto'\'', or '\''never'\'']' \
'--double-quotes[Can be "always", "auto", or "never"]' \
'--backticks[For more information see \`echo test\`]' \
'--backslash[Avoid '\''\\n'\'']' \
'--brackets[List packages \[filter\]]' \
'--expansions[Execute the shell command with \$SHELL]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
":: :_my-app_commands" \
"*::: :->my-app" \
&& ret=0
    case $state in
    (my-app)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-command-$line[1]:"
        case $line[1] in
            (cmd-single-quotes)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-double-quotes)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-backticks)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-backslash)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-brackets)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(cmd-expansions)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_my-app__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-help-command-$line[1]:"
        case $line[1] in
            (cmd-single-quotes)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-double-quotes)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-backticks)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-backslash)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-brackets)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(cmd-expansions)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=(
'cmd-single-quotes:Can be '\''always'\'', '\''auto'\'', or '\''never'\''' \
'cmd-double-quotes:Can be "always", "auto", or "never"' \
'cmd-backticks:For more information see \`echo test\`' \
'cmd-backslash:Avoid '\''\\n'\''' \
'cmd-brackets:List packages \[filter\]' \
'cmd-expansions:Execute the shell command with \$SHELL' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app commands' commands "$@"
}
(( $+functions[_my-app__cmd-backslash_commands] )) ||
_my-app__cmd-backslash_commands() {
    local commands; commands=()
    _describe -t commands 'my-app cmd-backslash commands' commands "$@"
}
(( $+functions[_my-app__cmd-backticks_commands] )) ||
_my-app__cmd-backticks_commands() {
    local commands; commands=()
    _describe -t commands 'my-app cmd-backticks commands' commands "$@"
}
(( $+functions[_my-app__cmd-brackets_commands] )) ||
_my-app__cmd-brackets_commands() {
    local commands; commands=()
    _describe -t commands 'my-app cmd-brackets commands' commands "$@"
}
(( $+functions[_my-app__cmd-double-quotes_commands] )) ||
_my-app__cmd-double-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'my-app cmd-double-quotes commands' commands "$@"
}
(( $+functions[_my-app__cmd-expansions_commands] )) ||
_my-app__cmd-expansions_commands() {
    local commands; commands=()
    _describe -t commands 'my-app cmd-expansions commands' commands "$@"
}
(( $+functions[_my-app__cmd-single-quotes_commands] )) ||
_my-app__cmd-single-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'my-app cmd-single-quotes commands' commands "$@"
}
(( $+functions[_my-app__help_commands] )) ||
_my-app__help_commands() {
    local commands; commands=(
'cmd-single-quotes:Can be '\''always'\'', '\''auto'\'', or '\''never'\''' \
'cmd-double-quotes:Can be "always", "auto", or "never"' \
'cmd-backticks:For more information see \`echo test\`' \
'cmd-backslash:Avoid '\''\\n'\''' \
'cmd-brackets:List packages \[filter\]' \
'cmd-expansions:Execute the shell command with \$SHELL' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app help commands' commands "$@"
}
(( $+functions[_my-app__help__cmd-backslash_commands] )) ||
_my-app__help__cmd-backslash_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help cmd-backslash commands' commands "$@"
}
(( $+functions[_my-app__help__cmd-backticks_commands] )) ||
_my-app__help__cmd-backticks_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help cmd-backticks commands' commands "$@"
}
(( $+functions[_my-app__help__cmd-brackets_commands] )) ||
_my-app__help__cmd-brackets_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help cmd-brackets commands' commands "$@"
}
(( $+functions[_my-app__help__cmd-double-quotes_commands] )) ||
_my-app__help__cmd-double-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help cmd-double-quotes commands' commands "$@"
}
(( $+functions[_my-app__help__cmd-expansions_commands] )) ||
_my-app__help__cmd-expansions_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help cmd-expansions commands' commands "$@"
}
(( $+functions[_my-app__help__cmd-single-quotes_commands] )) ||
_my-app__help__cmd-single-quotes_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help cmd-single-quotes commands' commands "$@"
}
(( $+functions[_my-app__help__help_commands] )) ||
_my-app__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help help commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/snapshots/register_dynamic.fish`:

```fish
complete -x -c my-app -a 'my-app'" complete --shell fish -- (commandline --current-process --tokenize --cut-at-cursor) (commandline --current-token)"

```

`clap/clap_complete/tests/snapshots/register_minimal.bash`:

```bash

_clap_complete_my_app() {
    local IFS=$'/013'
    local _CLAP_COMPLETE_INDEX=${COMP_CWORD}
    local _CLAP_COMPLETE_COMP_TYPE=${COMP_TYPE}
    if compopt +o nospace 2> /dev/null; then
        local _CLAP_COMPLETE_SPACE=false
    else
        local _CLAP_COMPLETE_SPACE=true
    fi
    COMPREPLY=( $( /
        IFS="$IFS" /
        _CLAP_COMPLETE_INDEX="$_CLAP_COMPLETE_INDEX" /
        _CLAP_COMPLETE_COMP_TYPE="$_CLAP_COMPLETE_COMP_TYPE" /
        _CLAP_COMPLETE_SPACE="$_CLAP_COMPLETE_SPACE" /
        "my-app" complete bash -- "${COMP_WORDS[@]}" /
    ) )
    if [[ $? != 0 ]]; then
        unset COMPREPLY
    elif [[ $SUPPRESS_SPACE == 1 ]] && [[ "${COMPREPLY-}" =~ [=/:]$ ]]; then
        compopt -o nospace
    fi
}
if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -o nospace -o bashdefault -o nosort -F _clap_complete_my_app my-app
else
    complete -o nospace -o bashdefault -F _clap_complete_my_app my-app
fi


```

`clap/clap_complete/tests/snapshots/special_commands.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            my__app,help)
                cmd="my__app__help"
                ;;
            my__app,some-cmd-with-hyphens)
                cmd="my__app__some__cmd__with__hyphens"
                ;;
            my__app,some-hidden-cmd)
                cmd="my__app__some__hidden__cmd"
                ;;
            my__app,some_cmd)
                cmd="my__app__some_cmd"
                ;;
            my__app,test)
                cmd="my__app__test"
                ;;
            my__app__help,help)
                cmd="my__app__help__help"
                ;;
            my__app__help,some-cmd-with-hyphens)
                cmd="my__app__help__some__cmd__with__hyphens"
                ;;
            my__app__help,some-hidden-cmd)
                cmd="my__app__help__some__hidden__cmd"
                ;;
            my__app__help,some_cmd)
                cmd="my__app__help__some_cmd"
                ;;
            my__app__help,test)
                cmd="my__app__help__test"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-C -c -h -V --conf --config --help --version [file] first second test some_cmd some-cmd-with-hyphens some-hidden-cmd help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help)
            opts="test some_cmd some-cmd-with-hyphens some-hidden-cmd help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__help)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__some__cmd__with__hyphens)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__some__hidden__cmd)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__some_cmd)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__test)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__some__cmd__with__hyphens)
            opts="-h -V --help --version"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__some__hidden__cmd)
            opts="-h -V --help --version"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__some_cmd)
            opts="-h -V --config --help --version [path]..."
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                --config)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__test)
            opts="-h -V --case --help --version"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                --case)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/special_commands.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand -c 'some config file'
            cand -C 'some config file'
            cand --config 'some config file'
            cand --conf 'some config file'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
            cand test 'tests things'
            cand some_cmd 'tests other things'
            cand some-cmd-with-hyphens 'some-cmd-with-hyphens'
            cand some-hidden-cmd 'some-hidden-cmd'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;test'= {
            cand --case 'the case to test'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'my-app;some_cmd'= {
            cand --config 'the other case to test'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'my-app;some-cmd-with-hyphens'= {
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'my-app;some-hidden-cmd'= {
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'my-app;help'= {
            cand test 'tests things'
            cand some_cmd 'tests other things'
            cand some-cmd-with-hyphens 'some-cmd-with-hyphens'
            cand some-hidden-cmd 'some-hidden-cmd'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;help;test'= {
        }
        &'my-app;help;some_cmd'= {
        }
        &'my-app;help;some-cmd-with-hyphens'= {
        }
        &'my-app;help;some-hidden-cmd'= {
        }
        &'my-app;help;help'= {
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/special_commands.fish`:

```fish
# Print an optspec for argparse to handle cmd's options that are independent of any subcommand.
function __fish_my_app_global_optspecs
	string join \n c/config h/help V/version
end

function __fish_my_app_needs_command
	# Figure out if the current invocation already has a command.
	set -l cmd (commandline -opc)
	set -e cmd[1]
	argparse -s (__fish_my_app_global_optspecs) -- $cmd 2>/dev/null
	or return
	if set -q argv[1]
		# Also print the command, so this can be used to figure out what it is.
		echo $argv[1]
		return 1
	end
	return 0
end

function __fish_my_app_using_subcommand
	set -l cmd (__fish_my_app_needs_command)
	test -z "$cmd"
	and return 1
	contains -- $cmd[1] $argv
end

complete -c my-app -n "__fish_my_app_needs_command" -s c -s C -l config -l conf -d 'some config file'
complete -c my-app -n "__fish_my_app_needs_command" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_needs_command" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_needs_command" -a "test" -d 'tests things'
complete -c my-app -n "__fish_my_app_needs_command" -a "some_cmd" -d 'tests other things'
complete -c my-app -n "__fish_my_app_needs_command" -a "some-cmd-with-hyphens"
complete -c my-app -n "__fish_my_app_needs_command" -a "some-hidden-cmd"
complete -c my-app -n "__fish_my_app_needs_command" -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand test" -l case -d 'the case to test' -r
complete -c my-app -n "__fish_my_app_using_subcommand test" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand test" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd" -l config -d 'the other case to test' -r
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand some-cmd-with-hyphens" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand some-cmd-with-hyphens" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand some-hidden-cmd" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand some-hidden-cmd" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test some_cmd some-cmd-with-hyphens some-hidden-cmd help" -f -a "test" -d 'tests things'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test some_cmd some-cmd-with-hyphens some-hidden-cmd help" -f -a "some_cmd" -d 'tests other things'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test some_cmd some-cmd-with-hyphens some-hidden-cmd help" -f -a "some-cmd-with-hyphens"
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test some_cmd some-cmd-with-hyphens some-hidden-cmd help" -f -a "some-hidden-cmd"
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test some_cmd some-cmd-with-hyphens some-hidden-cmd help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'

```

`clap/clap_complete/tests/snapshots/special_commands.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('-c', '-c', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('-C', '-C ', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('--config', '--config', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('--conf', '--conf', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'tests things')
            [CompletionResult]::new('some_cmd', 'some_cmd', [CompletionResultType]::ParameterValue, 'tests other things')
            [CompletionResult]::new('some-cmd-with-hyphens', 'some-cmd-with-hyphens', [CompletionResultType]::ParameterValue, 'some-cmd-with-hyphens')
            [CompletionResult]::new('some-hidden-cmd', 'some-hidden-cmd', [CompletionResultType]::ParameterValue, 'some-hidden-cmd')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;test' {
            [CompletionResult]::new('--case', '--case', [CompletionResultType]::ParameterName, 'the case to test')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'my-app;some_cmd' {
            [CompletionResult]::new('--config', '--config', [CompletionResultType]::ParameterName, 'the other case to test')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'my-app;some-cmd-with-hyphens' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'my-app;some-hidden-cmd' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'my-app;help' {
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'tests things')
            [CompletionResult]::new('some_cmd', 'some_cmd', [CompletionResultType]::ParameterValue, 'tests other things')
            [CompletionResult]::new('some-cmd-with-hyphens', 'some-cmd-with-hyphens', [CompletionResultType]::ParameterValue, 'some-cmd-with-hyphens')
            [CompletionResult]::new('some-hidden-cmd', 'some-hidden-cmd', [CompletionResultType]::ParameterValue, 'some-hidden-cmd')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;help;test' {
            break
        }
        'my-app;help;some_cmd' {
            break
        }
        'my-app;help;some-cmd-with-hyphens' {
            break
        }
        'my-app;help;some-hidden-cmd' {
            break
        }
        'my-app;help;help' {
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/special_commands.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'*-c[some config file]' \
'*-C[some config file]' \
'*--config[some config file]' \
'*--conf[some config file]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
'::file -- some input file:_files' \
'::choice:(first second)' \
":: :_my-app_commands" \
"*::: :->my-app" \
&& ret=0
    case $state in
    (my-app)
        words=($line[3] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-command-$line[3]:"
        case $line[3] in
            (test)
_arguments "${_arguments_options[@]}" : \
'--case=[the case to test]: :_default' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
&& ret=0
;;
(some_cmd)
_arguments "${_arguments_options[@]}" : \
'--config=[the other case to test]: :_default' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
'*::path:_default' \
&& ret=0
;;
(some-cmd-with-hyphens)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
&& ret=0
;;
(some-hidden-cmd)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_my-app__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-help-command-$line[1]:"
        case $line[1] in
            (test)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(some_cmd)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(some-cmd-with-hyphens)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(some-hidden-cmd)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=(
'test:tests things' \
'some_cmd:tests other things' \
'some-cmd-with-hyphens:' \
'some-hidden-cmd:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app commands' commands "$@"
}
(( $+functions[_my-app__help_commands] )) ||
_my-app__help_commands() {
    local commands; commands=(
'test:tests things' \
'some_cmd:tests other things' \
'some-cmd-with-hyphens:' \
'some-hidden-cmd:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app help commands' commands "$@"
}
(( $+functions[_my-app__help__help_commands] )) ||
_my-app__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help help commands' commands "$@"
}
(( $+functions[_my-app__help__some-cmd-with-hyphens_commands] )) ||
_my-app__help__some-cmd-with-hyphens_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help some-cmd-with-hyphens commands' commands "$@"
}
(( $+functions[_my-app__help__some-hidden-cmd_commands] )) ||
_my-app__help__some-hidden-cmd_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help some-hidden-cmd commands' commands "$@"
}
(( $+functions[_my-app__help__some_cmd_commands] )) ||
_my-app__help__some_cmd_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help some_cmd commands' commands "$@"
}
(( $+functions[_my-app__help__test_commands] )) ||
_my-app__help__test_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help test commands' commands "$@"
}
(( $+functions[_my-app__some-cmd-with-hyphens_commands] )) ||
_my-app__some-cmd-with-hyphens_commands() {
    local commands; commands=()
    _describe -t commands 'my-app some-cmd-with-hyphens commands' commands "$@"
}
(( $+functions[_my-app__some-hidden-cmd_commands] )) ||
_my-app__some-hidden-cmd_commands() {
    local commands; commands=()
    _describe -t commands 'my-app some-hidden-cmd commands' commands "$@"
}
(( $+functions[_my-app__some_cmd_commands] )) ||
_my-app__some_cmd_commands() {
    local commands; commands=()
    _describe -t commands 'my-app some_cmd commands' commands "$@"
}
(( $+functions[_my-app__test_commands] )) ||
_my-app__test_commands() {
    local commands; commands=()
    _describe -t commands 'my-app test commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/snapshots/sub_subcommands.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            my__app,help)
                cmd="my__app__help"
                ;;
            my__app,some_cmd)
                cmd="my__app__some_cmd"
                ;;
            my__app,some_cmd_alias)
                cmd="my__app__some_cmd"
                ;;
            my__app,test)
                cmd="my__app__test"
                ;;
            my__app__help,help)
                cmd="my__app__help__help"
                ;;
            my__app__help,some_cmd)
                cmd="my__app__help__some_cmd"
                ;;
            my__app__help,test)
                cmd="my__app__help__test"
                ;;
            my__app__help__some_cmd,sub_cmd)
                cmd="my__app__help__some_cmd__sub_cmd"
                ;;
            my__app__some_cmd,help)
                cmd="my__app__some_cmd__help"
                ;;
            my__app__some_cmd,sub_cmd)
                cmd="my__app__some_cmd__sub_cmd"
                ;;
            my__app__some_cmd__help,help)
                cmd="my__app__some_cmd__help__help"
                ;;
            my__app__some_cmd__help,sub_cmd)
                cmd="my__app__some_cmd__help__sub_cmd"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-C -c -h -V --conf --config --help --version [file] first second test some_cmd some_cmd_alias help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help)
            opts="test some_cmd help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__help)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__some_cmd)
            opts="sub_cmd"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__some_cmd__sub_cmd)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 4 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__test)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__some_cmd)
            opts="-h -V --help --version sub_cmd help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__some_cmd__help)
            opts="sub_cmd help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__some_cmd__help__help)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 4 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__some_cmd__help__sub_cmd)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 4 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__some_cmd__sub_cmd)
            opts="-h -V --config --help --version"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                --config)
                    COMPREPLY=($(compgen -W "Lest quotes, aren't escaped. Second to trigger display of options" -- "${cur}"))
                    return 0
                    ;;
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__test)
            opts="-h -V --case --help --version"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                --case)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/sub_subcommands.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand -c 'some config file'
            cand -C 'some config file'
            cand --config 'some config file'
            cand --conf 'some config file'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
            cand test 'tests things'
            cand some_cmd 'top level subcommand'
            cand some_cmd_alias 'top level subcommand'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;test'= {
            cand --case 'the case to test'
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'my-app;some_cmd'= {
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
            cand sub_cmd 'sub-subcommand'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;some_cmd_alias'= {
            cand -h 'Print help'
            cand --help 'Print help'
            cand -V 'Print version'
            cand --version 'Print version'
            cand sub_cmd 'sub-subcommand'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;some_cmd;sub_cmd'= {
            cand --config 'the other case to test'
            cand -h 'Print help (see more with ''--help'')'
            cand --help 'Print help (see more with ''--help'')'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'my-app;some_cmd_alias;sub_cmd'= {
            cand --config 'the other case to test'
            cand -h 'Print help (see more with ''--help'')'
            cand --help 'Print help (see more with ''--help'')'
            cand -V 'Print version'
            cand --version 'Print version'
        }
        &'my-app;some_cmd;help'= {
            cand sub_cmd 'sub-subcommand'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;some_cmd;help;sub_cmd'= {
        }
        &'my-app;some_cmd;help;help'= {
        }
        &'my-app;some_cmd_alias;help'= {
            cand sub_cmd 'sub-subcommand'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;some_cmd_alias;help;sub_cmd'= {
        }
        &'my-app;some_cmd_alias;help;help'= {
        }
        &'my-app;help'= {
            cand test 'tests things'
            cand some_cmd 'top level subcommand'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;help;test'= {
        }
        &'my-app;help;some_cmd'= {
            cand sub_cmd 'sub-subcommand'
        }
        &'my-app;help;some_cmd;sub_cmd'= {
        }
        &'my-app;help;help'= {
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/sub_subcommands.fish`:

```fish
# Print an optspec for argparse to handle cmd's options that are independent of any subcommand.
function __fish_my_app_global_optspecs
	string join \n c/config h/help V/version
end

function __fish_my_app_needs_command
	# Figure out if the current invocation already has a command.
	set -l cmd (commandline -opc)
	set -e cmd[1]
	argparse -s (__fish_my_app_global_optspecs) -- $cmd 2>/dev/null
	or return
	if set -q argv[1]
		# Also print the command, so this can be used to figure out what it is.
		echo $argv[1]
		return 1
	end
	return 0
end

function __fish_my_app_using_subcommand
	set -l cmd (__fish_my_app_needs_command)
	test -z "$cmd"
	and return 1
	contains -- $cmd[1] $argv
end

complete -c my-app -n "__fish_my_app_needs_command" -s c -s C -l config -l conf -d 'some config file'
complete -c my-app -n "__fish_my_app_needs_command" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_needs_command" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_needs_command" -a "test" -d 'tests things'
complete -c my-app -n "__fish_my_app_needs_command" -a "some_cmd" -d 'top level subcommand'
complete -c my-app -n "__fish_my_app_needs_command" -a "some_cmd_alias" -d 'top level subcommand'
complete -c my-app -n "__fish_my_app_needs_command" -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand test" -l case -d 'the case to test' -r
complete -c my-app -n "__fish_my_app_using_subcommand test" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand test" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd; and not __fish_seen_subcommand_from sub_cmd help" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd; and not __fish_seen_subcommand_from sub_cmd help" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd; and not __fish_seen_subcommand_from sub_cmd help" -f -a "sub_cmd" -d 'sub-subcommand'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd; and not __fish_seen_subcommand_from sub_cmd help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd; and __fish_seen_subcommand_from sub_cmd" -l config -d 'the other case to test' -r -f -a "Lest quotes\, aren\'t escaped.\t'help,with,comma'
Second to trigger display of options\t''"
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd; and __fish_seen_subcommand_from sub_cmd" -s h -l help -d 'Print help (see more with \'--help\')'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd; and __fish_seen_subcommand_from sub_cmd" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd; and __fish_seen_subcommand_from help" -f -a "sub_cmd" -d 'sub-subcommand'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd; and __fish_seen_subcommand_from help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd_alias; and not __fish_seen_subcommand_from sub_cmd help" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd_alias; and not __fish_seen_subcommand_from sub_cmd help" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd_alias; and not __fish_seen_subcommand_from sub_cmd help" -f -a "sub_cmd" -d 'sub-subcommand'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd_alias; and not __fish_seen_subcommand_from sub_cmd help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd_alias; and __fish_seen_subcommand_from sub_cmd" -l config -d 'the other case to test' -r -f -a "Lest quotes\, aren\'t escaped.\t'help,with,comma'
Second to trigger display of options\t''"
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd_alias; and __fish_seen_subcommand_from sub_cmd" -s h -l help -d 'Print help (see more with \'--help\')'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd_alias; and __fish_seen_subcommand_from sub_cmd" -s V -l version -d 'Print version'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd_alias; and __fish_seen_subcommand_from help" -f -a "sub_cmd" -d 'sub-subcommand'
complete -c my-app -n "__fish_my_app_using_subcommand some_cmd_alias; and __fish_seen_subcommand_from help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test some_cmd help" -f -a "test" -d 'tests things'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test some_cmd help" -f -a "some_cmd" -d 'top level subcommand'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from test some_cmd help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand help; and __fish_seen_subcommand_from some_cmd" -f -a "sub_cmd" -d 'sub-subcommand'

```

`clap/clap_complete/tests/snapshots/sub_subcommands.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('-c', '-c', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('-C', '-C ', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('--config', '--config', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('--conf', '--conf', [CompletionResultType]::ParameterName, 'some config file')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'tests things')
            [CompletionResult]::new('some_cmd', 'some_cmd', [CompletionResultType]::ParameterValue, 'top level subcommand')
            [CompletionResult]::new('some_cmd_alias', 'some_cmd_alias', [CompletionResultType]::ParameterValue, 'top level subcommand')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;test' {
            [CompletionResult]::new('--case', '--case', [CompletionResultType]::ParameterName, 'the case to test')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'my-app;some_cmd' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('sub_cmd', 'sub_cmd', [CompletionResultType]::ParameterValue, 'sub-subcommand')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;some_cmd_alias' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('sub_cmd', 'sub_cmd', [CompletionResultType]::ParameterValue, 'sub-subcommand')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;some_cmd;sub_cmd' {
            [CompletionResult]::new('--config', '--config', [CompletionResultType]::ParameterName, 'the other case to test')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help (see more with ''--help'')')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help (see more with ''--help'')')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'my-app;some_cmd_alias;sub_cmd' {
            [CompletionResult]::new('--config', '--config', [CompletionResultType]::ParameterName, 'the other case to test')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help (see more with ''--help'')')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help (see more with ''--help'')')
            [CompletionResult]::new('-V', '-V ', [CompletionResultType]::ParameterName, 'Print version')
            [CompletionResult]::new('--version', '--version', [CompletionResultType]::ParameterName, 'Print version')
            break
        }
        'my-app;some_cmd;help' {
            [CompletionResult]::new('sub_cmd', 'sub_cmd', [CompletionResultType]::ParameterValue, 'sub-subcommand')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;some_cmd;help;sub_cmd' {
            break
        }
        'my-app;some_cmd;help;help' {
            break
        }
        'my-app;some_cmd_alias;help' {
            [CompletionResult]::new('sub_cmd', 'sub_cmd', [CompletionResultType]::ParameterValue, 'sub-subcommand')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;some_cmd_alias;help;sub_cmd' {
            break
        }
        'my-app;some_cmd_alias;help;help' {
            break
        }
        'my-app;help' {
            [CompletionResult]::new('test', 'test', [CompletionResultType]::ParameterValue, 'tests things')
            [CompletionResult]::new('some_cmd', 'some_cmd', [CompletionResultType]::ParameterValue, 'top level subcommand')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;help;test' {
            break
        }
        'my-app;help;some_cmd' {
            [CompletionResult]::new('sub_cmd', 'sub_cmd', [CompletionResultType]::ParameterValue, 'sub-subcommand')
            break
        }
        'my-app;help;some_cmd;sub_cmd' {
            break
        }
        'my-app;help;help' {
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/sub_subcommands.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'*-c[some config file]' \
'*-C[some config file]' \
'*--config[some config file]' \
'*--conf[some config file]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
'::file -- some input file:_files' \
'::choice:(first second)' \
":: :_my-app_commands" \
"*::: :->my-app" \
&& ret=0
    case $state in
    (my-app)
        words=($line[3] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-command-$line[3]:"
        case $line[3] in
            (test)
_arguments "${_arguments_options[@]}" : \
'--case=[the case to test]: :_default' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
&& ret=0
;;
(some_cmd)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
":: :_my-app__some_cmd_commands" \
"*::: :->some_cmd" \
&& ret=0

    case $state in
    (some_cmd)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-some_cmd-command-$line[1]:"
        case $line[1] in
            (sub_cmd)
_arguments "${_arguments_options[@]}" : \
'--config=[the other case to test]: :((Lest\ quotes,\ aren'\''t\ escaped.\:"help,with,comma"
Second\ to\ trigger\ display\ of\ options\:""))' \
'-h[Print help (see more with '\''--help'\'')]' \
'--help[Print help (see more with '\''--help'\'')]' \
'-V[Print version]' \
'--version[Print version]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_my-app__some_cmd__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-some_cmd-help-command-$line[1]:"
        case $line[1] in
            (sub_cmd)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
;;
(some_cmd_alias)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
":: :_my-app__some_cmd_commands" \
"*::: :->some_cmd" \
&& ret=0

    case $state in
    (some_cmd)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-some_cmd-command-$line[1]:"
        case $line[1] in
            (sub_cmd)
_arguments "${_arguments_options[@]}" : \
'--config=[the other case to test]: :((Lest\ quotes,\ aren'\''t\ escaped.\:"help,with,comma"
Second\ to\ trigger\ display\ of\ options\:""))' \
'-h[Print help (see more with '\''--help'\'')]' \
'--help[Print help (see more with '\''--help'\'')]' \
'-V[Print version]' \
'--version[Print version]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_my-app__some_cmd__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-some_cmd-help-command-$line[1]:"
        case $line[1] in
            (sub_cmd)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_my-app__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-help-command-$line[1]:"
        case $line[1] in
            (test)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(some_cmd)
_arguments "${_arguments_options[@]}" : \
":: :_my-app__help__some_cmd_commands" \
"*::: :->some_cmd" \
&& ret=0

    case $state in
    (some_cmd)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-help-some_cmd-command-$line[1]:"
        case $line[1] in
            (sub_cmd)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=(
'test:tests things' \
'some_cmd:top level subcommand' \
'some_cmd_alias:top level subcommand' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app commands' commands "$@"
}
(( $+functions[_my-app__help_commands] )) ||
_my-app__help_commands() {
    local commands; commands=(
'test:tests things' \
'some_cmd:top level subcommand' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app help commands' commands "$@"
}
(( $+functions[_my-app__help__help_commands] )) ||
_my-app__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help help commands' commands "$@"
}
(( $+functions[_my-app__help__some_cmd_commands] )) ||
_my-app__help__some_cmd_commands() {
    local commands; commands=(
'sub_cmd:sub-subcommand' \
    )
    _describe -t commands 'my-app help some_cmd commands' commands "$@"
}
(( $+functions[_my-app__help__some_cmd__sub_cmd_commands] )) ||
_my-app__help__some_cmd__sub_cmd_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help some_cmd sub_cmd commands' commands "$@"
}
(( $+functions[_my-app__help__test_commands] )) ||
_my-app__help__test_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help test commands' commands "$@"
}
(( $+functions[_my-app__some_cmd_commands] )) ||
_my-app__some_cmd_commands() {
    local commands; commands=(
'sub_cmd:sub-subcommand' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app some_cmd commands' commands "$@"
}
(( $+functions[_my-app__some_cmd__help_commands] )) ||
_my-app__some_cmd__help_commands() {
    local commands; commands=(
'sub_cmd:sub-subcommand' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app some_cmd help commands' commands "$@"
}
(( $+functions[_my-app__some_cmd__help__help_commands] )) ||
_my-app__some_cmd__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'my-app some_cmd help help commands' commands "$@"
}
(( $+functions[_my-app__some_cmd__help__sub_cmd_commands] )) ||
_my-app__some_cmd__help__sub_cmd_commands() {
    local commands; commands=()
    _describe -t commands 'my-app some_cmd help sub_cmd commands' commands "$@"
}
(( $+functions[_my-app__some_cmd__sub_cmd_commands] )) ||
_my-app__some_cmd__sub_cmd_commands() {
    local commands; commands=()
    _describe -t commands 'my-app some_cmd sub_cmd commands' commands "$@"
}
(( $+functions[_my-app__test_commands] )) ||
_my-app__test_commands() {
    local commands; commands=()
    _describe -t commands 'my-app test commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/snapshots/subcommand_last.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            my__app,bar)
                cmd="my__app__bar"
                ;;
            my__app,foo)
                cmd="my__app__foo"
                ;;
            my__app,help)
                cmd="my__app__help"
                ;;
            my__app__help,bar)
                cmd="my__app__help__bar"
                ;;
            my__app__help,foo)
                cmd="my__app__help__foo"
                ;;
            my__app__help,help)
                cmd="my__app__help__help"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-h --help [free] foo bar help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__bar)
            opts="-h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__foo)
            opts="-h --help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help)
            opts="foo bar help"
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__bar)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__foo)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
        my__app__help__help)
            opts=""
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/subcommand_last.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand -h 'Print help'
            cand --help 'Print help'
            cand foo 'foo'
            cand bar 'bar'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;foo'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'my-app;bar'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
        &'my-app;help'= {
            cand foo 'foo'
            cand bar 'bar'
            cand help 'Print this message or the help of the given subcommand(s)'
        }
        &'my-app;help;foo'= {
        }
        &'my-app;help;bar'= {
        }
        &'my-app;help;help'= {
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/subcommand_last.fish`:

```fish
# Print an optspec for argparse to handle cmd's options that are independent of any subcommand.
function __fish_my_app_global_optspecs
	string join \n h/help
end

function __fish_my_app_needs_command
	# Figure out if the current invocation already has a command.
	set -l cmd (commandline -opc)
	set -e cmd[1]
	argparse -s (__fish_my_app_global_optspecs) -- $cmd 2>/dev/null
	or return
	if set -q argv[1]
		# Also print the command, so this can be used to figure out what it is.
		echo $argv[1]
		return 1
	end
	return 0
end

function __fish_my_app_using_subcommand
	set -l cmd (__fish_my_app_needs_command)
	test -z "$cmd"
	and return 1
	contains -- $cmd[1] $argv
end

complete -c my-app -n "__fish_my_app_needs_command" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_needs_command" -a "foo"
complete -c my-app -n "__fish_my_app_needs_command" -a "bar"
complete -c my-app -n "__fish_my_app_needs_command" -a "help" -d 'Print this message or the help of the given subcommand(s)'
complete -c my-app -n "__fish_my_app_using_subcommand foo" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand bar" -s h -l help -d 'Print help'
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from foo bar help" -f -a "foo"
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from foo bar help" -f -a "bar"
complete -c my-app -n "__fish_my_app_using_subcommand help; and not __fish_seen_subcommand_from foo bar help" -f -a "help" -d 'Print this message or the help of the given subcommand(s)'

```

`clap/clap_complete/tests/snapshots/subcommand_last.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('foo', 'foo', [CompletionResultType]::ParameterValue, 'foo')
            [CompletionResult]::new('bar', 'bar', [CompletionResultType]::ParameterValue, 'bar')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;foo' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'my-app;bar' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
        'my-app;help' {
            [CompletionResult]::new('foo', 'foo', [CompletionResultType]::ParameterValue, 'foo')
            [CompletionResult]::new('bar', 'bar', [CompletionResultType]::ParameterValue, 'bar')
            [CompletionResult]::new('help', 'help', [CompletionResultType]::ParameterValue, 'Print this message or the help of the given subcommand(s)')
            break
        }
        'my-app;help;foo' {
            break
        }
        'my-app;help;bar' {
            break
        }
        'my-app;help;help' {
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/subcommand_last.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
'::free:_default' \
":: :_my-app_commands" \
"*::: :->my-app" \
&& ret=0
    case $state in
    (my-app)
        words=($line[2] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-command-$line[2]:"
        case $line[2] in
            (foo)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(bar)
_arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
":: :_my-app__help_commands" \
"*::: :->help" \
&& ret=0

    case $state in
    (help)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:my-app-help-command-$line[1]:"
        case $line[1] in
            (foo)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(bar)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
&& ret=0
;;
        esac
    ;;
esac
;;
        esac
    ;;
esac
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=(
'foo:' \
'bar:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app commands' commands "$@"
}
(( $+functions[_my-app__bar_commands] )) ||
_my-app__bar_commands() {
    local commands; commands=()
    _describe -t commands 'my-app bar commands' commands "$@"
}
(( $+functions[_my-app__foo_commands] )) ||
_my-app__foo_commands() {
    local commands; commands=()
    _describe -t commands 'my-app foo commands' commands "$@"
}
(( $+functions[_my-app__help_commands] )) ||
_my-app__help_commands() {
    local commands; commands=(
'foo:' \
'bar:' \
'help:Print this message or the help of the given subcommand(s)' \
    )
    _describe -t commands 'my-app help commands' commands "$@"
}
(( $+functions[_my-app__help__bar_commands] )) ||
_my-app__help__bar_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help bar commands' commands "$@"
}
(( $+functions[_my-app__help__foo_commands] )) ||
_my-app__help__foo_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help foo commands' commands "$@"
}
(( $+functions[_my-app__help__help_commands] )) ||
_my-app__help__help_commands() {
    local commands; commands=()
    _describe -t commands 'my-app help help commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/snapshots/two_multi_valued_arguments.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-h --help [first]... [second]..."
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/two_multi_valued_arguments.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/two_multi_valued_arguments.fish`:

```fish
complete -c my-app -s h -l help -d 'Print help'

```

`clap/clap_complete/tests/snapshots/two_multi_valued_arguments.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/two_multi_valued_arguments.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
'*::first -- first multi-valued argument:_default' \
&& ret=0
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=()
    _describe -t commands 'my-app commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/snapshots/value_hint.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-p -f -d -e -c -u -H -h --choice --unknown --other --path --file --dir --exe --cmd-name --cmd --user --host --url --email --help [command_with_args]..."
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                --choice)
                    COMPREPLY=($(compgen -W "bash fish zsh" -- "${cur}"))
                    return 0
                    ;;
                --unknown)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                --other)
                    COMPREPLY=("${cur}")
                    if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then
                        compopt -o nospace
                    fi
                    return 0
                    ;;
                --path)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                -p)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                --file)
                    local oldifs
                    if [ -n "${IFS+x}" ]; then
                        oldifs="$IFS"
                    fi
                    IFS=$'\n'
                    COMPREPLY=($(compgen -f "${cur}"))
                    if [ -n "${oldifs+x}" ]; then
                        IFS="$oldifs"
                    fi
                    if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then
                        compopt -o filenames
                    fi
                    return 0
                    ;;
                -f)
                    local oldifs
                    if [ -n "${IFS+x}" ]; then
                        oldifs="$IFS"
                    fi
                    IFS=$'\n'
                    COMPREPLY=($(compgen -f "${cur}"))
                    if [ -n "${oldifs+x}" ]; then
                        IFS="$oldifs"
                    fi
                    if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then
                        compopt -o filenames
                    fi
                    return 0
                    ;;
                --dir)
                    COMPREPLY=()
                    if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then
                        compopt -o plusdirs
                    fi
                    return 0
                    ;;
                -d)
                    COMPREPLY=()
                    if [[ "${BASH_VERSINFO[0]}" -ge 4 ]]; then
                        compopt -o plusdirs
                    fi
                    return 0
                    ;;
                --exe)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                -e)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                --cmd-name)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                --cmd)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                -c)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                --user)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                -u)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                --host)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                -H)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                --url)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                --email)
                    COMPREPLY=($(compgen -f "${cur}"))
                    return 0
                    ;;
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/value_hint.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand --choice 'choice'
            cand --unknown 'unknown'
            cand --other 'other'
            cand -p 'p'
            cand --path 'path'
            cand -f 'f'
            cand --file 'file'
            cand -d 'd'
            cand --dir 'dir'
            cand -e 'e'
            cand --exe 'exe'
            cand --cmd-name 'cmd-name'
            cand -c 'c'
            cand --cmd 'cmd'
            cand -u 'u'
            cand --user 'user'
            cand -H 'H'
            cand --host 'host'
            cand --url 'url'
            cand --email 'email'
            cand -h 'Print help'
            cand --help 'Print help'
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/value_hint.fish`:

```fish
complete -c my-app -l choice -r -f -a "bash\t''
fish\t''
zsh\t''"
complete -c my-app -l unknown -r
complete -c my-app -l other -r -f
complete -c my-app -s p -l path -r -F
complete -c my-app -s f -l file -r -F
complete -c my-app -s d -l dir -r -f -a "(__fish_complete_directories)"
complete -c my-app -s e -l exe -r -F
complete -c my-app -l cmd-name -r -f -a "(__fish_complete_command)"
complete -c my-app -s c -l cmd -r -f -a "(__fish_complete_command)"
complete -c my-app -s u -l user -r -f -a "(__fish_complete_users)"
complete -c my-app -s H -l host -r -f -a "(__fish_print_hostnames)"
complete -c my-app -l url -r -f
complete -c my-app -l email -r -f
complete -c my-app -s h -l help -d 'Print help'

```

`clap/clap_complete/tests/snapshots/value_hint.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('--choice', '--choice', [CompletionResultType]::ParameterName, 'choice')
            [CompletionResult]::new('--unknown', '--unknown', [CompletionResultType]::ParameterName, 'unknown')
            [CompletionResult]::new('--other', '--other', [CompletionResultType]::ParameterName, 'other')
            [CompletionResult]::new('-p', '-p', [CompletionResultType]::ParameterName, 'p')
            [CompletionResult]::new('--path', '--path', [CompletionResultType]::ParameterName, 'path')
            [CompletionResult]::new('-f', '-f', [CompletionResultType]::ParameterName, 'f')
            [CompletionResult]::new('--file', '--file', [CompletionResultType]::ParameterName, 'file')
            [CompletionResult]::new('-d', '-d', [CompletionResultType]::ParameterName, 'd')
            [CompletionResult]::new('--dir', '--dir', [CompletionResultType]::ParameterName, 'dir')
            [CompletionResult]::new('-e', '-e', [CompletionResultType]::ParameterName, 'e')
            [CompletionResult]::new('--exe', '--exe', [CompletionResultType]::ParameterName, 'exe')
            [CompletionResult]::new('--cmd-name', '--cmd-name', [CompletionResultType]::ParameterName, 'cmd-name')
            [CompletionResult]::new('-c', '-c', [CompletionResultType]::ParameterName, 'c')
            [CompletionResult]::new('--cmd', '--cmd', [CompletionResultType]::ParameterName, 'cmd')
            [CompletionResult]::new('-u', '-u', [CompletionResultType]::ParameterName, 'u')
            [CompletionResult]::new('--user', '--user', [CompletionResultType]::ParameterName, 'user')
            [CompletionResult]::new('-H', '-H ', [CompletionResultType]::ParameterName, 'H')
            [CompletionResult]::new('--host', '--host', [CompletionResultType]::ParameterName, 'host')
            [CompletionResult]::new('--url', '--url', [CompletionResultType]::ParameterName, 'url')
            [CompletionResult]::new('--email', '--email', [CompletionResultType]::ParameterName, 'email')
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/value_hint.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'--choice=[]: :(bash fish zsh)' \
'--unknown=[]: :_default' \
'--other=[]: :' \
'-p+[]: :_files' \
'--path=[]: :_files' \
'-f+[]: :_files' \
'--file=[]: :_files' \
'-d+[]: :_files -/' \
'--dir=[]: :_files -/' \
'-e+[]: :_absolute_command_paths' \
'--exe=[]: :_absolute_command_paths' \
'--cmd-name=[]: :_command_names -e' \
'-c+[]: :_cmdstring' \
'--cmd=[]: :_cmdstring' \
'-u+[]: :_users' \
'--user=[]: :_users' \
'-H+[]: :_hosts' \
'--host=[]: :_hosts' \
'--url=[]: :_urls' \
'--email=[]: :_email_addresses' \
'-h[Print help]' \
'--help[Print help]' \
'*::command_with_args:_cmdambivalent' \
&& ret=0
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=()
    _describe -t commands 'my-app commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/snapshots/value_terminator.bash`:

```bash
_my-app() {
    local i cur prev opts cmd
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    cmd=""
    opts=""

    for i in ${COMP_WORDS[@]}
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="my__app"
                ;;
            *)
                ;;
        esac
    done

    case "${cmd}" in
        my__app)
            opts="-h --help [arguments]..."
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]] ; then
                COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
                return 0
            fi
            case "${prev}" in
                *)
                    COMPREPLY=()
                    ;;
            esac
            COMPREPLY=( $(compgen -W "${opts}" -- "${cur}") )
            return 0
            ;;
    esac
}

if [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -ge 4 || "${BASH_VERSINFO[0]}" -gt 4 ]]; then
    complete -F _my-app -o nosort -o bashdefault -o default my-app
else
    complete -F _my-app -o bashdefault -o default my-app
fi

```

`clap/clap_complete/tests/snapshots/value_terminator.elvish`:

```elvish

use builtin;
use str;

set edit:completion:arg-completer[my-app] = {|@words|
    fn spaces {|n|
        builtin:repeat $n ' ' | str:join ''
    }
    fn cand {|text desc|
        edit:complex-candidate $text &display=$text' '(spaces (- 14 (wcswidth $text)))$desc
    }
    var command = 'my-app'
    for word $words[1..-1] {
        if (str:has-prefix $word '-') {
            break
        }
        set command = $command';'$word
    }
    var completions = [
        &'my-app'= {
            cand -h 'Print help'
            cand --help 'Print help'
        }
    ]
    $completions[$command]
}

```

`clap/clap_complete/tests/snapshots/value_terminator.fish`:

```fish
complete -c my-app -s h -l help -d 'Print help'

```

`clap/clap_complete/tests/snapshots/value_terminator.ps1`:

```ps1

using namespace System.Management.Automation
using namespace System.Management.Automation.Language

Register-ArgumentCompleter -Native -CommandName 'my-app' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)

    $commandElements = $commandAst.CommandElements
    $command = @(
        'my-app'
        for ($i = 1; $i -lt $commandElements.Count; $i++) {
            $element = $commandElements[$i]
            if ($element -isnot [StringConstantExpressionAst] -or
                $element.StringConstantType -ne [StringConstantType]::BareWord -or
                $element.Value.StartsWith('-') -or
                $element.Value -eq $wordToComplete) {
                break
        }
        $element.Value
    }) -join ';'

    $completions = @(switch ($command) {
        'my-app' {
            [CompletionResult]::new('-h', '-h', [CompletionResultType]::ParameterName, 'Print help')
            [CompletionResult]::new('--help', '--help', [CompletionResultType]::ParameterName, 'Print help')
            break
        }
    })

    $completions.Where{ $_.CompletionText -like "$wordToComplete*" } |
        Sort-Object -Property ListItemText
}

```

`clap/clap_complete/tests/snapshots/value_terminator.zsh`:

```zsh
#compdef my-app

autoload -U is-at-least

_my-app() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'-h[Print help]' \
'--help[Print help]' \
'*;::arguments -- multi-valued argument with a value terminator:_default' \
&& ret=0
}

(( $+functions[_my-app_commands] )) ||
_my-app_commands() {
    local commands; commands=()
    _describe -t commands 'my-app commands' commands "$@"
}

if [ "$funcstack[1]" = "_my-app" ]; then
    _my-app "$@"
else
    compdef _my-app my-app
fi

```

`clap/clap_complete/tests/testsuite/bash.rs`:

```rs
#[allow(unused_imports)]
use snapbox::assert_data_eq;

use crate::common;

#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
const CMD: &str = "bash";
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
type RuntimeBuilder = completest_pty::BashRuntimeBuilder;

#[test]
fn basic() {
    let name = "my-app";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/basic.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
fn feature_sample() {
    let name = "my-app";
    let cmd = common::feature_sample_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/feature_sample.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
fn special_commands() {
    let name = "my-app";
    let cmd = common::special_commands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/special_commands.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
fn quoting() {
    let name = "my-app";
    let cmd = common::quoting_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/quoting.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
fn aliases() {
    let name = "my-app";
    let cmd = common::aliases_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/aliases.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
fn sub_subcommands() {
    let name = "my-app";
    let cmd = common::sub_subcommands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/sub_subcommands.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
fn custom_bin_name() {
    let name = "my-app";
    let bin_name = "bin-name";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/custom_bin_name.bash"],
        clap_complete::shells::Bash,
        cmd,
        bin_name,
    );
}

#[test]
fn value_hint() {
    let name = "my-app";
    let cmd = common::value_hint_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_hint.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
fn value_terminator() {
    let name = "my-app";
    let cmd = common::value_terminator_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_terminator.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
fn two_multi_valued_arguments() {
    let name = "my-app";
    let cmd = common::two_multi_valued_arguments_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/two_multi_valued_arguments.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
fn subcommand_last() {
    let name = "my-app";
    let cmd = common::subcommand_last(name);
    common::assert_matches(
        snapbox::file!["../snapshots/subcommand_last.bash"],
        clap_complete::shells::Bash,
        cmd,
        name,
    );
}

#[test]
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
fn register_completion() {
    common::register_example::<RuntimeBuilder>("static", "exhaustive");
}

#[test]
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
fn complete() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("static", "exhaustive");

    let input = "exhaustive \t\t";
    let expected = snapbox::str![[r#"
% 
-h              --empty-choice  empty           action          value           last            hint
--generate      --help          global          quote           pacman          alias           help
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive empty \t";
    let expected = snapbox::str!["exhaustive empty        % exhaustive empty "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive --empty=\t";
    let expected = snapbox::str!["exhaustive --empty=     % exhaustive --empty="];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    // Issue 5239 (https://github.com/clap-rs/clap/issues/5239)
    let input = "exhaustive hint --file test\t";
    let expected = snapbox::str!["exhaustive hint --file test     % exhaustive hint --file tests/"];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    {
        use std::fs::File;
        use std::path::Path;

        let testdir = snapbox::dir::DirRoot::mutable_temp().unwrap();
        let testdir_path = testdir.path().unwrap();

        File::create(Path::new(testdir_path).join("a_file")).unwrap();
        File::create(Path::new(testdir_path).join("b_file")).unwrap();
        std::fs::create_dir_all(Path::new(testdir_path).join("c_dir")).unwrap();
        std::fs::create_dir_all(Path::new(testdir_path).join("d_dir")).unwrap();

        let input = format!(
            "exhaustive hint --file {}/\t\t",
            testdir_path.to_string_lossy()
        );
        let actual = runtime.complete(input.as_str(), &term).unwrap();
        assert!(
            actual.contains("a_file")
                && actual.contains("b_file")
                && actual.contains("c_dir")
                && actual.contains("d_dir"),
            "Actual output:\n{actual}"
        );

        let input = format!(
            "exhaustive hint --dir {}/\t\t",
            testdir_path.to_string_lossy()
        );
        let actual = runtime.complete(input.as_str(), &term).unwrap();
        assert!(
            !actual.contains("a_file")
                && !actual.contains("b_file")
                && actual.contains("c_dir")
                && actual.contains("d_dir"),
            "Actual output:\n{actual}"
        );
    }

    {
        use std::fs::File;
        use std::path::Path;

        let testdir = snapbox::dir::DirRoot::mutable_temp().unwrap();
        let testdir_path = testdir.path().unwrap();

        File::create(Path::new(testdir_path).join("foo bar.txt")).unwrap();
        File::create(Path::new(testdir_path).join("baz\tqux.txt")).unwrap();

        let input = format!(
            "exhaustive hint --file {}/b\t",
            testdir_path.to_string_lossy()
        );
        let actual = runtime.complete(input.as_str(), &term).unwrap();
        assert!(!actual.contains("foo"), "Actual output:\n{actual}");
    }

    let input = "exhaustive hint --other \t";
    let expected = snapbox::str!["exhaustive hint --other         % exhaustive hint --other "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn register_dynamic_env() {
    common::register_example::<RuntimeBuilder>("dynamic-env", "exhaustive");
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_toplevel() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive \t\t";
    let expected = snapbox::str![[r#"
% 
empty           action          value           last            hint            --generate      --help
global          quote           pacman          alias           help            --empty-choice  
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_quoted_help() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive quote \t\t";
    let expected = snapbox::str![[r#"
% 
cmd-single-quotes  cmd-backslash      escape-help        --double-quotes    --brackets         --help
cmd-double-quotes  cmd-brackets       help               --backticks        --expansions       
cmd-backticks      cmd-expansions     --single-quotes    --backslash        --choice           
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_option_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive action --choice=\t\t";
    let expected = snapbox::str!["% "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive action --choice=f\t";
    let expected = snapbox::str!["exhaustive action --choice=f    % exhaustive action --choice=f"];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_quoted_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive quote --choice \t\t";
    let expected = snapbox::str![[r#"
% 
another shell  bash           fish           zsh            
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive quote --choice an\t";
    let expected =
        snapbox::str!["exhaustive quote --choice an    % exhaustive quote --choice another shell "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_empty_subcommand() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive empty \t";
    let expected = snapbox::str!["exhaustive empty        % exhaustive empty "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_empty_option_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive --empty=\t";
    let expected = snapbox::str!["exhaustive --empty=     % exhaustive --empty="];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

```

`clap/clap_complete/tests/testsuite/common.rs`:

```rs
use clap::builder::PossibleValue;
use snapbox::prelude::*;

pub(crate) fn basic_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .arg(
            clap::Arg::new("config")
                .short('c')
                .global(true)
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            clap::Arg::new("v")
                .short('v')
                .conflicts_with("config")
                .action(clap::ArgAction::SetTrue),
        )
        .subcommand(
            clap::Command::new("test")
                .about("Subcommand\nwith a second line")
                .arg(
                    clap::Arg::new("debug")
                        .short('d')
                        .action(clap::ArgAction::Count),
                ),
        )
}

pub(crate) fn feature_sample_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .version("3.0")
        .propagate_version(true)
        .about("Tests completions")
        .arg(
            clap::Arg::new("file")
                .value_hint(clap::ValueHint::FilePath)
                .help("some input file"),
        )
        .arg(
            clap::Arg::new("config")
                .action(clap::ArgAction::Count)
                .help("some config file")
                .short('c')
                .visible_short_alias('C')
                .long("config")
                .visible_alias("conf"),
        )
        .arg(clap::Arg::new("choice").value_parser(["first", "second"]))
        .subcommand(
            clap::Command::new("test").about("tests things").arg(
                clap::Arg::new("case")
                    .long("case")
                    .action(clap::ArgAction::Set)
                    .help("the case to test"),
            ),
        )
}

pub(crate) fn special_commands_command(name: &'static str) -> clap::Command {
    feature_sample_command(name)
        .subcommand(
            clap::Command::new("some_cmd")
                .about("tests other things")
                .arg(
                    clap::Arg::new("config")
                        .long("config")
                        .hide(true)
                        .action(clap::ArgAction::Set)
                        .require_equals(true)
                        .help("the other case to test"),
                )
                .arg(clap::Arg::new("path").num_args(1..)),
        )
        .subcommand(clap::Command::new("some-cmd-with-hyphens").alias("hyphen"))
        .subcommand(clap::Command::new("some-hidden-cmd").hide(true))
}

pub(crate) fn quoting_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .version("3.0")
        .arg(
            clap::Arg::new("single-quotes")
                .long("single-quotes")
                .action(clap::ArgAction::SetTrue)
                .help("Can be 'always', 'auto', or 'never'"),
        )
        .arg(
            clap::Arg::new("double-quotes")
                .long("double-quotes")
                .action(clap::ArgAction::SetTrue)
                .help("Can be \"always\", \"auto\", or \"never\""),
        )
        .arg(
            clap::Arg::new("backticks")
                .long("backticks")
                .action(clap::ArgAction::SetTrue)
                .help("For more information see `echo test`"),
        )
        .arg(
            clap::Arg::new("backslash")
                .long("backslash")
                .action(clap::ArgAction::SetTrue)
                .help("Avoid '\\n'"),
        )
        .arg(
            clap::Arg::new("brackets")
                .long("brackets")
                .action(clap::ArgAction::SetTrue)
                .help("List packages [filter]"),
        )
        .arg(
            clap::Arg::new("expansions")
                .long("expansions")
                .action(clap::ArgAction::SetTrue)
                .help("Execute the shell command with $SHELL"),
        )
        .subcommands([
            clap::Command::new("cmd-single-quotes").about("Can be 'always', 'auto', or 'never'"),
            clap::Command::new("cmd-double-quotes")
                .about("Can be \"always\", \"auto\", or \"never\""),
            clap::Command::new("cmd-backticks").about("For more information see `echo test`"),
            clap::Command::new("cmd-backslash").about("Avoid '\\n'"),
            clap::Command::new("cmd-brackets").about("List packages [filter]"),
            clap::Command::new("cmd-expansions").about("Execute the shell command with $SHELL"),
        ])
}

pub(crate) fn aliases_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .version("3.0")
        .about("testing bash completions")
        .arg(
            clap::Arg::new("flag")
                .short('f')
                .visible_short_alias('F')
                .long("flag")
                .action(clap::ArgAction::SetTrue)
                .visible_alias("flg")
                .help("cmd flag"),
        )
        .arg(
            clap::Arg::new("option")
                .short('o')
                .visible_short_alias('O')
                .long("option")
                .visible_alias("opt")
                .help("cmd option")
                .action(clap::ArgAction::Set),
        )
        .arg(clap::Arg::new("positional"))
}

pub(crate) fn sub_subcommands_command(name: &'static str) -> clap::Command {
    feature_sample_command(name).subcommand(
        clap::Command::new("some_cmd")
            .about("top level subcommand")
            .visible_alias("some_cmd_alias")
            .subcommand(
                clap::Command::new("sub_cmd").about("sub-subcommand").arg(
                    clap::Arg::new("config")
                        .long("config")
                        .action(clap::ArgAction::Set)
                        .value_parser([
                            PossibleValue::new("Lest quotes, aren't escaped.")
                                .help("help,with,comma"),
                            PossibleValue::new("Second to trigger display of options"),
                        ])
                        .help("the other case to test"),
                ),
            ),
    )
}

pub(crate) fn value_hint_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .arg(
            clap::Arg::new("choice")
                .long("choice")
                .action(clap::ArgAction::Set)
                .value_parser(["bash", "fish", "zsh"]),
        )
        .arg(
            clap::Arg::new("unknown")
                .long("unknown")
                .value_hint(clap::ValueHint::Unknown),
        )
        .arg(
            clap::Arg::new("other")
                .long("other")
                .value_hint(clap::ValueHint::Other),
        )
        .arg(
            clap::Arg::new("path")
                .long("path")
                .short('p')
                .value_hint(clap::ValueHint::AnyPath),
        )
        .arg(
            clap::Arg::new("file")
                .long("file")
                .short('f')
                .value_hint(clap::ValueHint::FilePath),
        )
        .arg(
            clap::Arg::new("dir")
                .long("dir")
                .short('d')
                .value_hint(clap::ValueHint::DirPath),
        )
        .arg(
            clap::Arg::new("exe")
                .long("exe")
                .short('e')
                .value_hint(clap::ValueHint::ExecutablePath),
        )
        .arg(
            clap::Arg::new("cmd_name")
                .long("cmd-name")
                .value_hint(clap::ValueHint::CommandName),
        )
        .arg(
            clap::Arg::new("cmd")
                .long("cmd")
                .short('c')
                .value_hint(clap::ValueHint::CommandString),
        )
        .arg(
            clap::Arg::new("command_with_args")
                .action(clap::ArgAction::Set)
                .num_args(1..)
                .trailing_var_arg(true)
                .value_hint(clap::ValueHint::CommandWithArguments),
        )
        .arg(
            clap::Arg::new("user")
                .short('u')
                .long("user")
                .value_hint(clap::ValueHint::Username),
        )
        .arg(
            clap::Arg::new("host")
                .short('H')
                .long("host")
                .value_hint(clap::ValueHint::Hostname),
        )
        .arg(
            clap::Arg::new("url")
                .long("url")
                .value_hint(clap::ValueHint::Url),
        )
        .arg(
            clap::Arg::new("email")
                .long("email")
                .value_hint(clap::ValueHint::EmailAddress),
        )
}

pub(crate) fn value_terminator_command(name: &'static str) -> clap::Command {
    clap::Command::new(name).arg(
        clap::Arg::new("arguments")
            .help("multi-valued argument with a value terminator")
            .num_args(1..)
            .value_terminator(";"),
    )
}

pub(crate) fn two_multi_valued_arguments_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .arg(
            clap::Arg::new("first")
                .help("first multi-valued argument")
                .num_args(1..),
        )
        .arg(
            clap::Arg::new("second")
                .help("second multi-valued argument")
                .raw(true),
        )
}

pub(crate) fn subcommand_last(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .arg(clap::Arg::new("free").last(true))
        .subcommands([clap::Command::new("foo"), clap::Command::new("bar")])
}

pub(crate) fn assert_matches(
    expected: impl IntoData,
    generator: impl clap_complete::Generator,
    mut cmd: clap::Command,
    name: &'static str,
) {
    let mut buf = vec![];
    clap_complete::generate(generator, &mut cmd, name, &mut buf);

    snapbox::Assert::new()
        .action_env(snapbox::assert::DEFAULT_ACTION_ENV)
        .normalize_paths(false)
        .eq(buf, expected);
}

#[cfg(feature = "unstable-shell-tests")]
pub(crate) fn register_example<R: completest::RuntimeBuilder>(context: &str, name: &str) {
    use completest::Runtime as _;

    let scratch = snapbox::dir::DirRoot::mutable_temp().unwrap();
    let scratch_path = scratch.path().unwrap();

    let shell_name = R::name();
    let home = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("tests/snapshots/home")
        .join(context)
        .join(name)
        .join(shell_name);
    println!("Compiling");
    let manifest_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR")).join("Cargo.toml");
    let bin_path = snapbox::cmd::compile_example(
        name,
        [
            "--manifest-path",
            manifest_path.to_str().unwrap(),
            // Unconditionally include to avoid completion file tests failing based on the how
            // `cargo test` is invoked
            "--features=unstable-dynamic",
        ],
    )
    .unwrap();
    println!("Compiled");
    let bin_root = bin_path.parent().unwrap().to_owned();

    let mut registration = std::process::Command::new(&bin_path);
    match context {
        "static" => registration.args([format!("--generate={shell_name}")]),
        "dynamic-command" => registration.args(["complete", shell_name]),
        "dynamic-env" => registration.env("COMPLETE", shell_name),
        _ => unreachable!("unsupported context {}", context),
    };
    let registration = registration.output().unwrap();
    assert!(
        registration.status.success(),
        "{}",
        String::from_utf8_lossy(&registration.stderr)
    );
    let registration = std::str::from_utf8(&registration.stdout).unwrap();
    assert!(!registration.is_empty());

    let mut runtime = R::new(bin_root, scratch_path.to_owned()).unwrap();

    runtime.register(name, registration).unwrap();

    snapbox::assert_subset_eq(home, scratch_path);

    scratch.close().unwrap();
}

#[cfg(feature = "unstable-shell-tests")]
pub(crate) fn load_runtime<R: completest::RuntimeBuilder>(
    context: &str,
    name: &str,
) -> Box<dyn completest::Runtime>
where
    <R as completest::RuntimeBuilder>::Runtime: 'static,
{
    let shell_name = R::name();
    let home = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("tests/snapshots/home")
        .join(context)
        .join(name)
        .join(shell_name);
    let scratch = snapbox::dir::DirRoot::mutable_temp()
        .unwrap()
        .with_template(&home)
        .unwrap();
    let home = scratch.path().unwrap().to_owned();
    println!("Compiling");
    let manifest_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR")).join("Cargo.toml");
    let bin_path = snapbox::cmd::compile_example(
        name,
        [
            "--manifest-path",
            manifest_path.to_str().unwrap(),
            // Unconditionally include to avoid completion file tests failing based on the how
            // `cargo test` is invoked
            "--features=unstable-dynamic",
        ],
    )
    .unwrap();
    println!("Compiled");
    let bin_root = bin_path.parent().unwrap().to_owned();

    let runtime = R::with_home(bin_root, home).unwrap();

    Box::new(ScratchRuntime {
        _scratch: scratch,
        runtime: Box::new(runtime),
    })
}

#[cfg(feature = "unstable-shell-tests")]
#[derive(Debug)]
struct ScratchRuntime {
    _scratch: snapbox::dir::DirRoot,
    runtime: Box<dyn completest::Runtime>,
}

#[cfg(feature = "unstable-shell-tests")]
impl completest::Runtime for ScratchRuntime {
    fn home(&self) -> &std::path::Path {
        self.runtime.home()
    }

    fn register(&mut self, name: &str, content: &str) -> std::io::Result<()> {
        self.runtime.register(name, content)
    }

    fn complete(&mut self, input: &str, term: &completest::Term) -> std::io::Result<String> {
        let output = self.runtime.complete(input, term)?;
        // HACK: elvish prints and clears this message when a completer takes too long which is
        // dependent on a lot of factors, making this show up or no sometimes (especially if we
        // aren't clearing the screen properly for fish)
        let output = output.replace("\nCOMPLETING argument\n", "\n");
        Ok(output)
    }
}

#[cfg(feature = "unstable-shell-tests")]
pub(crate) fn has_command(command: &str) -> bool {
    let output = match std::process::Command::new(command)
        .arg("--version")
        .output()
    {
        Ok(output) => output,
        Err(e) => {
            // CI is expected to support all of the commands
            if is_ci() && cfg!(target_os = "linux") {
                panic!("expected command `{command}` to be somewhere in PATH: {e}");
            }
            return false;
        }
    };
    if !output.status.success() {
        panic!(
            "expected command `{}` to be runnable, got error {}:\n\
            stderr:{}\n\
            stdout:{}\n",
            command,
            output.status,
            String::from_utf8_lossy(&output.stderr),
            String::from_utf8_lossy(&output.stdout)
        );
    }
    let stdout = String::from_utf8_lossy(&output.stdout);
    println!(
        "$ {command} --version
{stdout}"
    );
    if cfg!(target_os = "macos") && stdout.starts_with("GNU bash, version 3") {
        return false;
    }
    if cfg!(target_os = "macos") && command == "zsh" {
        // HACK: At least on CI, the prompt override is not working
        return false;
    }

    true
}

/// Whether or not this running in a Continuous Integration environment.
#[cfg(feature = "unstable-shell-tests")]
fn is_ci() -> bool {
    // Consider using `tracked_env` instead of option_env! when it is stabilized.
    // `tracked_env` will handle changes, but not require rebuilding the macro
    // itself like option_env does.
    option_env!("CI").is_some() || option_env!("TF_BUILD").is_some()
}

```

`clap/clap_complete/tests/testsuite/elvish.rs`:

```rs
use crate::common;
#[allow(unused_imports)]
use snapbox::assert_data_eq;

#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
const CMD: &str = "elvish";
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
type RuntimeBuilder = completest_pty::ElvishRuntimeBuilder;

#[test]
fn basic() {
    let name = "my-app";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/basic.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
fn feature_sample() {
    let name = "my-app";
    let cmd = common::feature_sample_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/feature_sample.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
fn special_commands() {
    let name = "my-app";
    let cmd = common::special_commands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/special_commands.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
fn quoting() {
    let name = "my-app";
    let cmd = common::quoting_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/quoting.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
fn aliases() {
    let name = "my-app";
    let cmd = common::aliases_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/aliases.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
fn sub_subcommands() {
    let name = "my-app";
    let cmd = common::sub_subcommands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/sub_subcommands.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
fn custom_bin_name() {
    let name = "my-app";
    let bin_name = "bin-name";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/custom_bin_name.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        bin_name,
    );
}

#[test]
fn value_hint() {
    let name = "my-app";
    let cmd = common::value_hint_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_hint.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
fn value_terminator() {
    let name = "my-app";
    let cmd = common::value_terminator_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_terminator.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
fn two_multi_valued_arguments() {
    let name = "my-app";
    let cmd = common::two_multi_valued_arguments_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/two_multi_valued_arguments.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
fn subcommand_last() {
    let name = "my-app";
    let cmd = common::subcommand_last(name);
    common::assert_matches(
        snapbox::file!["../snapshots/subcommand_last.elvish"],
        clap_complete::shells::Elvish,
        cmd,
        name,
    );
}

#[test]
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
fn register_completion() {
    common::register_example::<RuntimeBuilder>("static", "exhaustive");
}

#[test]
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
fn complete() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("static", "exhaustive");

    let input = "exhaustive \t";
    let expected = snapbox::str![[r#"
% exhaustive --empty-choice
 COMPLETING argument  
--empty-choice empty-choice                                             
--generate     generate                                                 
--help         Print help                                               
-h             Print help                                               
action         action                                                   
alias          alias                                                    
empty          empty                                                    
global         global                                                   
help           Print this message or the help of the given subcommand(s)
hint           hint                                                     
last           last                                                     
pacman         pacman                                                   
quote          quote                                                    
value          value                                                    
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive empty \t";
    let expected = snapbox::str![[r#"
no candidates
% exhaustive empty 
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive --empty=\t";
    let expected = snapbox::str![[r#"
no candidates
% exhaustive --empty=
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn register_dynamic_env() {
    common::register_example::<RuntimeBuilder>("dynamic-env", "exhaustive");
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_toplevel() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive \t";
    let expected = snapbox::str![[r#"
% exhaustive --empty-choice
 COMPLETING argument  
--empty-choice  --help  alias  global  hint  pacman  value
--generate      action  empty  help    last  quote 
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_quoted_help() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive quote \t";
    let expected = snapbox::str![[r#"
% exhaustive quote --backslash
 COMPLETING argument  
--backslash  --choice         --help           cmd-backticks      cmd-expansions     help
--backticks  --double-quotes  --single-quotes  cmd-brackets       cmd-single-quotes
--brackets   --expansions     cmd-backslash    cmd-double-quotes  escape-help      
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_option_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive action --choice=\t";
    let expected = snapbox::str![[r#"
% exhaustive action '--choice=first'
 COMPLETING argument  
--choice=first  --choice=second
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive action --choice=f\t";
    let expected = snapbox::str![[r#"
% exhaustive action '--choice=first'
 COMPLETING argument  
--choice=first
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_quoted_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive quote --choice \t";
    let expected = snapbox::str![[r#"
% exhaustive quote --choice 'another shell'
 COMPLETING argument  
another shell  bash  fish  zsh
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive quote --choice an\t";
    let expected = snapbox::str![[r#"
% exhaustive quote --choice 'another shell'
 COMPLETING argument  
another shell
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_empty_subcommand() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive empty \t\t";
    let expected = snapbox::str![[r#"
no candidates
no candidates
% exhaustive empty 
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_empty_option_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive --empty=\t";
    let expected = snapbox::str![[r#"
no candidates
% exhaustive --empty=
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

```

`clap/clap_complete/tests/testsuite/engine.rs`:

```rs
#![cfg(feature = "unstable-dynamic")]

use std::fs;
use std::path::Path;

use clap::{builder::PossibleValue, Command};
use clap_complete::engine::{
    ArgValueCandidates, ArgValueCompleter, CompletionCandidate, PathCompleter, SubcommandCandidates,
};
use snapbox::assert_data_eq;

macro_rules! complete {
    ($cmd:expr, $input:expr$(, current_dir = $current_dir:expr)? $(,)?) => {
        {
            #[allow(unused)]
            let current_dir: Option<&Path> = None;
            $(let current_dir = $current_dir;)?
            complete(&mut $cmd, $input, current_dir)
        }
    }
}

#[test]
fn suggest_subcommand_subset() {
    let mut cmd = Command::new("exhaustive")
        .subcommand(Command::new("hello-world"))
        .subcommand(Command::new("hello-moon"))
        .subcommand(Command::new("goodbye-world"));

    assert_data_eq!(
        complete!(cmd, "he"),
        snapbox::str![[r#"
hello-world
hello-moon
help	Print this message or the help of the given subcommand(s)
"#]],
    );
}

#[test]
fn suggest_hidden_long_flags() {
    let mut cmd = Command::new("exhaustive")
        .arg(clap::Arg::new("hello-world-visible").long("hello-world-visible"))
        .arg(
            clap::Arg::new("hello-world-hidden")
                .long("hello-world-hidden")
                .hide(true),
        );

    assert_data_eq!(
        complete!(cmd, "--hello-world"),
        snapbox::str!["--hello-world-visible"]
    );

    assert_data_eq!(
        complete!(cmd, "--hello-world-h"),
        snapbox::str!["--hello-world-hidden"]
    );
}

#[test]
fn suggest_hidden_subcommand_and_aliases() {
    let mut cmd = Command::new("exhaustive")
        .subcommand(
            Command::new("test_visible")
                .visible_alias("test_visible-alias_visible")
                .alias("test_visible-alias_hidden"),
        )
        .subcommand(
            Command::new("test_hidden")
                .visible_alias("test_hidden-alias_visible")
                .alias("test_hidden-alias_hidden")
                .hide(true),
        );

    assert_data_eq!(complete!(cmd, "test"), snapbox::str!["test_visible"]);

    assert_data_eq!(complete!(cmd, "test_h"), snapbox::str!["test_hidden"]);

    assert_data_eq!(
        complete!(cmd, "test_hidden-alias_h"),
        snapbox::str!["test_hidden-alias_hidden"]
    );
}

#[test]
fn suggest_subcommand_aliases() {
    let mut cmd = Command::new("exhaustive")
        .subcommand(
            Command::new("hello-world")
                .visible_alias("hello-world-foo")
                .alias("hidden-world"),
        )
        .subcommand(
            Command::new("hello-moon")
                .visible_alias("hello-moon-foo")
                .alias("hidden-moon"),
        )
        .subcommand(
            Command::new("goodbye-world")
                .visible_alias("goodbye-world-foo")
                .alias("hidden-goodbye"),
        );

    assert_data_eq!(
        complete!(cmd, "hello"),
        snapbox::str![[r#"
hello-world
hello-moon
"#]],
    );
}

#[test]
fn suggest_hidden_possible_value() {
    let mut cmd = Command::new("exhaustive").arg(
        clap::Arg::new("possible_value").long("test").value_parser([
            PossibleValue::new("test-visible").help("Say hello to the world"),
            PossibleValue::new("test-hidden")
                .help("Say hello to the moon")
                .hide(true),
        ]),
    );

    assert_data_eq!(
        complete!(cmd, "--test=test"),
        snapbox::str!["--test=test-visible	Say hello to the world"]
    );

    assert_data_eq!(
        complete!(cmd, "--test=test-h"),
        snapbox::str!["--test=test-hidden	Say hello to the moon"]
    );
}

#[test]
fn suggest_hidden_long_flag_aliases() {
    let mut cmd = Command::new("exhaustive")
        .arg(
            clap::Arg::new("test_visible")
                .long("test_visible")
                .visible_alias("test_visible-alias_visible")
                .alias("test_visible-alias_hidden"),
        )
        .arg(
            clap::Arg::new("test_hidden")
                .long("test_hidden")
                .visible_alias("test_hidden-alias_visible")
                .alias("test_hidden-alias_hidden")
                .hide(true),
        );

    assert_data_eq!(complete!(cmd, "--test"), snapbox::str!["--test_visible"]);

    assert_data_eq!(complete!(cmd, "--test_h"), snapbox::str!["--test_hidden"]);

    assert_data_eq!(
        complete!(cmd, "--test_visible-alias_h"),
        snapbox::str!["--test_visible-alias_hidden"]
    );

    assert_data_eq!(
        complete!(cmd, "--test_hidden-alias_h"),
        snapbox::str!["--test_hidden-alias_hidden"]
    );
}

#[test]
fn suggest_long_flag_subset() {
    let mut cmd = Command::new("exhaustive")
        .arg(
            clap::Arg::new("hello-world")
                .long("hello-world")
                .action(clap::ArgAction::Count),
        )
        .arg(
            clap::Arg::new("hello-moon")
                .long("hello-moon")
                .action(clap::ArgAction::Count),
        )
        .arg(
            clap::Arg::new("goodbye-world")
                .long("goodbye-world")
                .action(clap::ArgAction::Count),
        );

    assert_data_eq!(
        complete!(cmd, "--he"),
        snapbox::str![[r#"
--hello-world
--hello-moon
--help	Print help
"#]],
    );
}

#[test]
fn suggest_possible_value_subset() {
    let name = "exhaustive";
    let mut cmd = Command::new(name).arg(clap::Arg::new("hello-world").value_parser([
        PossibleValue::new("hello-world").help("Say hello to the world"),
        "hello-moon".into(),
        "goodbye-world".into(),
    ]));

    assert_data_eq!(
        complete!(cmd, "hello"),
        snapbox::str![[r#"
hello-world	Say hello to the world
hello-moon
"#]],
    );
}

#[test]
fn suggest_additional_short_flags() {
    let mut cmd = Command::new("exhaustive")
        .arg(
            clap::Arg::new("a")
                .short('a')
                .action(clap::ArgAction::Count),
        )
        .arg(
            clap::Arg::new("b")
                .short('b')
                .action(clap::ArgAction::Count),
        )
        .arg(
            clap::Arg::new("c")
                .short('c')
                .action(clap::ArgAction::Count),
        );

    assert_data_eq!(
        complete!(cmd, "-a"),
        snapbox::str![[r#"
-aa
-ab
-ac
-ah	Print help
"#]],
    );
}

#[test]
fn suggest_subcommand_positional() {
    let mut cmd = Command::new("exhaustive").subcommand(Command::new("hello-world").arg(
        clap::Arg::new("hello-world").value_parser([
            PossibleValue::new("hello-world").help("Say hello to the world"),
            "hello-moon".into(),
            "goodbye-world".into(),
        ]),
    ));

    assert_data_eq!(
        complete!(cmd, "hello-world [TAB]"),
        snapbox::str![[r#"
hello-world	Say hello to the world
hello-moon
goodbye-world
--help	Print help (see more with '--help')
"#]],
    );
}

#[test]
fn suggest_argument_value() {
    let mut cmd = Command::new("dynamic")
        .arg(
            clap::Arg::new("format")
                .long("format")
                .short('F')
                .value_parser(["json", "yaml", "toml"]),
        )
        .arg(
            clap::Arg::new("stream")
                .long("stream")
                .short('S')
                .value_parser(["stdout", "stderr"]),
        )
        .arg(
            clap::Arg::new("count")
                .long("count")
                .short('c')
                .action(clap::ArgAction::Count),
        )
        .arg(clap::Arg::new("positional").value_parser(["pos_a", "pos_b", "pos_c"]))
        .args_conflicts_with_subcommands(true);

    assert_data_eq!(
        complete!(cmd, "--format [TAB]"),
        snapbox::str![[r#"
json
yaml
toml
"#]],
    );

    assert_data_eq!(
        complete!(cmd, "-F [TAB]"),
        snapbox::str![[r#"
json
yaml
toml
"#]],
    );

    assert_data_eq!(complete!(cmd, "--format j[TAB]"), snapbox::str!["json"],);

    assert_data_eq!(complete!(cmd, "-F j[TAB]"), snapbox::str!["json"],);

    assert_data_eq!(complete!(cmd, "--format t[TAB]"), snapbox::str!["toml"],);

    assert_data_eq!(complete!(cmd, "-F t[TAB]"), snapbox::str!["toml"],);

    assert_data_eq!(
        complete!(cmd, "-cccF [TAB]"),
        snapbox::str![[r#"
json
yaml
toml
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--format toml [TAB]"),
        snapbox::str![[r#"
pos_a
pos_b
pos_c
--format
--stream
--count
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-cS[TAB]"),
        snapbox::str![[r#"
-cSstdout
-cSstderr
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-cS=[TAB]"),
        snapbox::str![[r#"
-cS=stdout
-cS=stderr
"#]]
    );

    assert_data_eq!(complete!(cmd, "-cS=stdo[TAB]"), snapbox::str!["-cS=stdout"]);

    assert_data_eq!(complete!(cmd, "-cSF[TAB]"), snapbox::str![]);

    assert_data_eq!(complete!(cmd, "-cSF=[TAB]"), snapbox::str![]);
}

#[test]
fn suggest_argument_multi_values() {
    let mut cmd = Command::new("dynamic")
        .arg(
            clap::Arg::new("certain-num")
                .long("certain-num")
                .short('Y')
                .value_parser(["val1", "val2", "val3"])
                .num_args(3),
        )
        .arg(
            clap::Arg::new("uncertain-num")
                .long("uncertain-num")
                .short('N')
                .value_parser(["val1", "val2", "val3"])
                .num_args(1..=3),
        );

    assert_data_eq!(
        complete!(cmd, "--certain-num [TAB]"),
        snapbox::str![[r#"
val1
val2
val3
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--certain-num val1 [TAB]"),
        snapbox::str![[r#"
val1
val2
val3
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--certain-num val1 val2 val3 [TAB]"),
        snapbox::str![[r#"
--certain-num
--uncertain-num
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--uncertain-num [TAB]"),
        snapbox::str![[r#"
val1
val2
val3
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--uncertain-num val1 [TAB]"),
        snapbox::str![[r#"
val1
val2
val3
--certain-num
--uncertain-num
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--uncertain-num val1 val2 val3 [TAB]"),
        snapbox::str![[r#"
--certain-num
--uncertain-num
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-Y [TAB]"),
        snapbox::str![[r#"
val1
val2
val3
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-Y val1 [TAB]"),
        snapbox::str![[r#"
val1
val2
val3
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-Y val1 val2 val3 [TAB]"),
        snapbox::str![[r#"
--certain-num
--uncertain-num
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-N [TAB]"),
        snapbox::str![[r#"
val1
val2
val3
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-N val1 [TAB]"),
        snapbox::str![[r#"
val1
val2
val3
--certain-num
--uncertain-num
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-N val1 val2 val3 [TAB]"),
        snapbox::str![[r#"
--certain-num
--uncertain-num
--help	Print help
"#]]
    );
}

#[test]
fn suggest_value_hint_file_path() {
    let mut cmd = Command::new("dynamic")
        .arg(
            clap::Arg::new("input")
                .long("input")
                .short('i')
                .value_hint(clap::ValueHint::FilePath),
        )
        .args_conflicts_with_subcommands(true);

    let testdir = snapbox::dir::DirRoot::mutable_temp().unwrap();
    let testdir_path = testdir.path().unwrap();

    fs::write(testdir_path.join("a_file"), "").unwrap();
    fs::write(testdir_path.join("b_file"), "").unwrap();
    fs::create_dir_all(testdir_path.join("c_dir")).unwrap();
    fs::create_dir_all(testdir_path.join("d_dir")).unwrap();

    assert_data_eq!(
        complete!(cmd, "--input [TAB]", current_dir = Some(testdir_path)),
        snapbox::str![[r#"
a_file
b_file
c_dir/
d_dir/
"#]],
    );

    assert_data_eq!(
        complete!(cmd, "--input a[TAB]", current_dir = Some(testdir_path)),
        snapbox::str!["a_file"],
    );
}

#[test]
fn suggest_value_path_file() {
    let testdir = snapbox::dir::DirRoot::mutable_temp().unwrap();
    let testdir_path = testdir.path().unwrap();
    fs::write(testdir_path.join("a_file"), "").unwrap();
    fs::write(testdir_path.join("b_file"), "").unwrap();
    fs::create_dir_all(testdir_path.join("c_dir")).unwrap();
    fs::create_dir_all(testdir_path.join("d_dir")).unwrap();

    let mut cmd = Command::new("dynamic")
        .arg(
            clap::Arg::new("input")
                .long("input")
                .short('i')
                .add(ArgValueCompleter::new(
                    PathCompleter::file()
                        .stdio()
                        .current_dir(testdir_path.to_owned()),
                )),
        )
        .args_conflicts_with_subcommands(true);

    assert_data_eq!(
        complete!(cmd, "--input [TAB]", current_dir = Some(testdir_path)),
        snapbox::str![[r#"
a_file
b_file
c_dir/
d_dir/
-	stdio
"#]],
    );

    assert_data_eq!(
        complete!(cmd, "--input a[TAB]", current_dir = Some(testdir_path)),
        snapbox::str!["a_file"],
    );
}

#[test]
fn suggest_value_path_dir() {
    let testdir = snapbox::dir::DirRoot::mutable_temp().unwrap();
    let testdir_path = testdir.path().unwrap();
    fs::write(testdir_path.join("a_file"), "").unwrap();
    fs::write(testdir_path.join("b_file"), "").unwrap();
    fs::create_dir_all(testdir_path.join("c_dir")).unwrap();
    fs::create_dir_all(testdir_path.join("d_dir")).unwrap();

    let mut cmd = Command::new("dynamic")
        .arg(
            clap::Arg::new("input")
                .long("input")
                .short('i')
                .add(ArgValueCompleter::new(
                    PathCompleter::dir().current_dir(testdir_path.to_owned()),
                )),
        )
        .args_conflicts_with_subcommands(true);

    assert_data_eq!(
        complete!(cmd, "--input [TAB]", current_dir = Some(testdir_path)),
        snapbox::str![[r#"
.
c_dir/
d_dir/
"#]],
    );

    assert_data_eq!(
        complete!(cmd, "--input c[TAB]", current_dir = Some(testdir_path)),
        snapbox::str!["c_dir/"],
    );
}

#[test]
fn suggest_custom_arg_value() {
    fn custom_completer() -> Vec<CompletionCandidate> {
        vec![
            CompletionCandidate::new("foo"),
            CompletionCandidate::new("bar"),
            CompletionCandidate::new("baz"),
        ]
    }

    let mut cmd = Command::new("dynamic").arg(
        clap::Arg::new("custom")
            .long("custom")
            .add(ArgValueCandidates::new(custom_completer)),
    );

    assert_data_eq!(
        complete!(cmd, "--custom [TAB]"),
        snapbox::str![[r#"
foo
bar
baz
"#]],
    );

    assert_data_eq!(
        complete!(cmd, "--custom b[TAB]"),
        snapbox::str![[r#"
bar
baz
"#]],
    );
}

#[test]
fn suggest_custom_arg_completer() {
    fn custom_completer(current: &std::ffi::OsStr) -> Vec<CompletionCandidate> {
        let mut completions = vec![];
        let Some(current) = current.to_str() else {
            return completions;
        };

        if "foo".starts_with(current) {
            completions.push(CompletionCandidate::new("foo"));
        }
        if "bar".starts_with(current) {
            completions.push(CompletionCandidate::new("bar"));
        }
        if "baz".starts_with(current) {
            completions.push(CompletionCandidate::new("baz"));
        }
        completions
    }

    let mut cmd = Command::new("dynamic").arg(
        clap::Arg::new("custom")
            .long("custom")
            .add(ArgValueCompleter::new(custom_completer)),
    );

    assert_data_eq!(
        complete!(cmd, "--custom [TAB]"),
        snapbox::str![[r#"
foo
bar
baz
"#]]
    );
    assert_data_eq!(
        complete!(cmd, "--custom b[TAB]"),
        snapbox::str![[r#"
bar
baz
"#]]
    );
}

#[test]
fn suggest_multi_positional() {
    let mut cmd = Command::new("dynamic")
        .arg(clap::Arg::new("positional-1").value_parser(["pos_1_a", "pos_1_b", "pos_1_c"]))
        .arg(
            clap::Arg::new("positional-2")
                .value_parser(["pos_2_a", "pos_2_b", "pos_2_c"])
                .num_args(3),
        )
        .arg(
            clap::Arg::new("--format")
                .long("format")
                .short('F')
                .value_parser(["json", "yaml", "toml"]),
        );

    assert_data_eq!(
        complete!(cmd, "pos_1_a pos_2_a [TAB]"),
        snapbox::str![[r#"
pos_2_a
pos_2_b
pos_2_c
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "pos_1_a pos_2_a pos_2_b [TAB]"),
        snapbox::str![[r#"
pos_2_a
pos_2_b
pos_2_c
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--format json pos_1_a [TAB]"),
        snapbox::str![[r#"
pos_2_a
pos_2_b
pos_2_c
--format
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--format json pos_1_a pos_2_a [TAB]"),
        snapbox::str![[r#"
pos_2_a
pos_2_b
pos_2_c
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--format json pos_1_a pos_2_a pos_2_b pos_2_c [TAB]"),
        snapbox::str![[r#"
--format
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--format json -- pos_1_a pos_2_a [TAB]"),
        snapbox::str![[r#"
pos_2_a
pos_2_b
pos_2_c
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--format json -- pos_1_a pos_2_a pos_2_b [TAB]"),
        snapbox::str![[r#"
pos_2_a
pos_2_b
pos_2_c
"#]]
    );

    assert_data_eq!(
        complete!(
            cmd,
            "--format json -- pos_1_a pos_2_a pos_2_b pos_2_c [TAB]"
        ),
        snapbox::str![]
    );
}

#[test]
fn suggest_multi_positional_unbounded() {
    let mut cmd = Command::new("dynamic")
        .arg(
            clap::Arg::new("positional-1")
                .value_parser(["pos_1_a", "pos_1_b", "pos_1_c"])
                .num_args(2..),
        )
        .arg(
            clap::Arg::new("--format")
                .long("format")
                .short('F')
                .value_parser(["json", "yaml", "toml"]),
        );

    assert_data_eq!(
        complete!(cmd, "pos_1_a [TAB]"),
        snapbox::str![[r#"
pos_1_a
pos_1_b
pos_1_c
"#]]
    );
    assert_data_eq!(complete!(cmd, "pos_1_a --[TAB]"), snapbox::str![""]);
    assert_data_eq!(
        complete!(cmd, "pos_1_a --format [TAB]"),
        snapbox::str![[r#"
json
yaml
toml
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "pos_1_a --format json [TAB]"),
        snapbox::str![[r#"
pos_1_a
pos_1_b
pos_1_c
--format
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "pos_1_a pos_1_b [TAB]"),
        snapbox::str![[r#"
pos_1_a
pos_1_b
pos_1_c
--format
--help	Print help
"#]]
    );
    assert_data_eq!(
        complete!(cmd, "pos_1_a pos_1_b --[TAB]"),
        snapbox::str![[r#"
--format
--help	Print help
"#]]
    );
    assert_data_eq!(
        complete!(cmd, "pos_1_a pos_1_b --format [TAB]"),
        snapbox::str![[r#"
json
yaml
toml
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "pos_1_a pos_1_b --format json [TAB]"),
        snapbox::str![[r#"
pos_1_a
pos_1_b
pos_1_c
--format
--help	Print help
"#]]
    );
}

#[test]
fn suggest_delimiter_values() {
    let mut cmd = Command::new("delimiter")
        .arg(
            clap::Arg::new("delimiter")
                .long("delimiter")
                .short('D')
                .value_parser([
                    PossibleValue::new("comma"),
                    PossibleValue::new("space"),
                    PossibleValue::new("tab"),
                ])
                .value_delimiter(','),
        )
        .arg(
            clap::Arg::new("pos")
                .value_parser(["a_pos", "b_pos", "c_pos"])
                .value_delimiter(','),
        );

    assert_data_eq!(
        complete!(cmd, "--delimiter [TAB]"),
        snapbox::str![[r#"
comma
space
tab
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--delimiter=[TAB]"),
        snapbox::str![[r#"
--delimiter=comma
--delimiter=space
--delimiter=tab
"#]]
    );

    assert_data_eq!(complete!(cmd, "--delimiter c[TAB]"), snapbox::str!["comma"]);

    assert_data_eq!(
        complete!(cmd, "--delimiter=c[TAB]"),
        snapbox::str!["--delimiter=comma"]
    );

    assert_data_eq!(
        complete!(cmd, "--delimiter comma,[TAB]"),
        snapbox::str![[r#"
comma,comma
comma,space
comma,tab
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--delimiter=comma,[TAB]"),
        snapbox::str![[r#"
--delimiter=comma,a_pos
--delimiter=comma,b_pos
--delimiter=comma,c_pos
--delimiter=comma,comma
--delimiter=comma,space
--delimiter=comma,tab
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--delimiter comma,s[TAB]"),
        snapbox::str!["comma,space"]
    );

    assert_data_eq!(
        complete!(cmd, "--delimiter=comma,s[TAB]"),
        snapbox::str!["--delimiter=comma,space"]
    );

    assert_data_eq!(
        complete!(cmd, "-D [TAB]"),
        snapbox::str![[r#"
comma
space
tab
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-D=[TAB]"),
        snapbox::str![[r#"
-D=comma
-D=space
-D=tab
"#]]
    );

    assert_data_eq!(complete!(cmd, "-D c[TAB]"), snapbox::str!["comma"]);

    assert_data_eq!(complete!(cmd, "-D=c[TAB]"), snapbox::str!["-D=comma"]);

    assert_data_eq!(
        complete!(cmd, "-D comma,[TAB]"),
        snapbox::str![[r#"
comma,comma
comma,space
comma,tab
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-D=comma,[TAB]"),
        snapbox::str![[r#"
-D=comma,a_pos
-D=comma,b_pos
-D=comma,c_pos
-D=comma,comma
-D=comma,space
-D=comma,tab
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-D comma,s[TAB]"),
        snapbox::str!["comma,space"]
    );

    assert_data_eq!(
        complete!(cmd, "-D=comma,s[TAB]"),
        snapbox::str!["-D=comma,space"]
    );

    assert_data_eq!(
        complete!(cmd, "-- [TAB]"),
        snapbox::str![[r#"
a_pos
b_pos
c_pos
--delimiter
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, " -- a_pos,[TAB]"),
        snapbox::str![[r#"
a_pos,a_pos
a_pos,b_pos
a_pos,c_pos
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-- a_pos,b[TAB]"),
        snapbox::str!["a_pos,b_pos"]
    );
}

#[test]
fn suggest_allow_hyphen() {
    let mut cmd = Command::new("exhaustive")
        .arg(
            clap::Arg::new("format")
                .long("format")
                .short('F')
                .allow_hyphen_values(true)
                .value_parser(["--json", "--toml", "--yaml"]),
        )
        .arg(clap::Arg::new("json").long("json"));

    assert_data_eq!(complete!(cmd, "--format --j[TAB]"), snapbox::str!["--json"]);
    assert_data_eq!(complete!(cmd, "-F --j[TAB]"), snapbox::str!["--json"]);
    assert_data_eq!(complete!(cmd, "--format --t[TAB]"), snapbox::str!["--toml"]);
    assert_data_eq!(complete!(cmd, "-F --t[TAB]"), snapbox::str!["--toml"]);

    assert_data_eq!(
        complete!(cmd, "--format --[TAB]"),
        snapbox::str![[r#"
--json
--toml
--yaml
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "-F --[TAB]"),
        snapbox::str![[r#"
--json
--toml
--yaml
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--format --json --j[TAB]"),
        snapbox::str!["--json"]
    );

    assert_data_eq!(
        complete!(cmd, "-F --json --j[TAB]"),
        snapbox::str!["--json"]
    );
}

#[test]
fn suggest_positional_long_allow_hyphen() {
    let mut cmd = Command::new("exhaustive")
        .arg(
            clap::Arg::new("format")
                .long("format")
                .short('F')
                .allow_hyphen_values(true)
                .value_parser(["--json", "--toml", "--yaml"]),
        )
        .arg(
            clap::Arg::new("positional_a")
                .value_parser(["--pos_a"])
                .allow_hyphen_values(true),
        )
        .arg(clap::Arg::new("positional_b").value_parser(["pos_b"]));

    assert_data_eq!(
        complete!(cmd, "--format --json --pos[TAB]"),
        snapbox::str!["--pos_a"]
    );
    assert_data_eq!(
        complete!(cmd, "-F --json --pos[TAB]"),
        snapbox::str!["--pos_a"]
    );

    assert_data_eq!(
        complete!(cmd, "--format --json --pos_a [TAB]"),
        snapbox::str![[r#"
pos_b
--format
--help	Print help
"#]]
    );
    assert_data_eq!(
        complete!(cmd, "-F --json --pos_a [TAB]"),
        snapbox::str![[r#"
pos_b
--format
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--format --json --pos_a p[TAB]"),
        snapbox::str!["pos_b"]
    );
    assert_data_eq!(
        complete!(cmd, "-F --json --pos_a p[TAB]"),
        snapbox::str!["pos_b"]
    );
}

#[test]
fn suggest_positional_short_allow_hyphen() {
    let mut cmd = Command::new("exhaustive")
        .arg(
            clap::Arg::new("format")
                .long("format")
                .short('F')
                .allow_hyphen_values(true)
                .value_parser(["--json", "--toml", "--yaml"]),
        )
        .arg(
            clap::Arg::new("positional_a")
                .value_parser(["-a"])
                .allow_hyphen_values(true),
        )
        .arg(clap::Arg::new("positional_b").value_parser(["pos_b"]));

    assert_data_eq!(
        complete!(cmd, "--format --json -a [TAB]"),
        snapbox::str![[r#"
pos_b
--format
--help	Print help
"#]]
    );
    assert_data_eq!(
        complete!(cmd, "-F --json -a [TAB]"),
        snapbox::str![[r#"
pos_b
--format
--help	Print help
"#]]
    );

    assert_data_eq!(
        complete!(cmd, "--format --json -a p[TAB]"),
        snapbox::str!["pos_b"]
    );
    assert_data_eq!(
        complete!(cmd, "-F --json -a p[TAB]"),
        snapbox::str!["pos_b"]
    );
}

#[test]
fn suggest_external_subcommand() {
    let mut cmd = Command::new("dynamic")
        .allow_external_subcommands(true)
        .add(SubcommandCandidates::new(|| {
            vec![CompletionCandidate::new("external")]
        }))
        .arg(clap::Arg::new("positional").value_parser(["pos1", "pos2", "pos3"]));

    assert_data_eq!(
        complete!(cmd, " [TAB]"),
        snapbox::str![
            "external
pos1
pos2
pos3
--help\tPrint help
"
        ]
    );

    assert_data_eq!(complete!(cmd, "e[TAB]"), snapbox::str!["external"]);
}

#[test]
fn sort_and_filter() {
    let mut cmd = Command::new("exhaustive")
        .args([
            clap::Arg::new("required-flag")
                .long("required-flag")
                .visible_alias("required-flag2")
                .short('r')
                .required(true),
            clap::Arg::new("optional-flag")
                .long("optional-flag")
                .visible_alias("2optional-flag")
                .short('o'),
            clap::Arg::new("long-flag").long("long-flag"),
            clap::Arg::new("short-flag").short('s'),
            clap::Arg::new("positional").value_parser(["pos-a", "pos-b", "pos-c"]),
        ])
        .subcommands([Command::new("sub")]);

    assert_data_eq!(
        complete!(cmd, " [TAB]"),
        snapbox::str![[r#"
sub
help	Print this message or the help of the given subcommand(s)
pos-a
pos-b
pos-c
--required-flag
--optional-flag
--long-flag
-s
--help	Print help
"#]]
    );
    assert_data_eq!(
        complete!(cmd, "-[TAB]"),
        snapbox::str![[r#"
-r	--required-flag
-o	--optional-flag
--long-flag
-s
-h	Print help
"#]]
    );
    assert_data_eq!(
        complete!(cmd, "--[TAB]"),
        snapbox::str![[r#"
--required-flag
--optional-flag
--long-flag
--help	Print help
"#]]
    );
}

fn complete(cmd: &mut Command, args: impl AsRef<str>, current_dir: Option<&Path>) -> String {
    let input = args.as_ref();
    let mut args = vec![std::ffi::OsString::from(cmd.get_name())];
    let arg_index;

    if let Some((prior, after)) = input.split_once("[TAB]") {
        args.extend(prior.split_whitespace().map(From::from));
        if prior.ends_with(char::is_whitespace) {
            args.push(std::ffi::OsString::default());
        }
        arg_index = args.len() - 1;
        // HACK: this cannot handle in-word '[TAB]'
        args.extend(after.split_whitespace().map(From::from));
    } else {
        args.extend(input.split_whitespace().map(From::from));
        if input.ends_with(char::is_whitespace) {
            args.push(std::ffi::OsString::default());
        }
        arg_index = args.len() - 1;
    }

    clap_complete::engine::complete(cmd, args, arg_index, current_dir)
        .unwrap()
        .into_iter()
        .map(|candidate| {
            let compl = candidate.get_value().to_str().unwrap();
            if let Some(help) = candidate.get_help() {
                format!("{compl}\t{help}")
            } else {
                compl.to_owned()
            }
        })
        .collect::<Vec<_>>()
        .join("\n")
}

```

`clap/clap_complete/tests/testsuite/fish.rs`:

```rs
use crate::common;
#[allow(unused_imports)]
use snapbox::assert_data_eq;

#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
const CMD: &str = "fish";
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
type RuntimeBuilder = completest_pty::FishRuntimeBuilder;

#[test]
fn basic() {
    let name = "my-app";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/basic.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
fn feature_sample() {
    let name = "my-app";
    let cmd = common::feature_sample_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/feature_sample.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
fn special_commands() {
    let name = "my-app";
    let cmd = common::special_commands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/special_commands.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
fn quoting() {
    let name = "my-app";
    let cmd = common::quoting_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/quoting.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
fn aliases() {
    let name = "my-app";
    let cmd = common::aliases_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/aliases.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
fn sub_subcommands() {
    let name = "my-app";
    let cmd = common::sub_subcommands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/sub_subcommands.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
fn custom_bin_name() {
    let name = "my-app";
    let bin_name = "bin-name";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/custom_bin_name.fish"],
        clap_complete::shells::Fish,
        cmd,
        bin_name,
    );
}

#[test]
fn value_hint() {
    let name = "my-app";
    let cmd = common::value_hint_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_hint.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
fn value_terminator() {
    let name = "my-app";
    let cmd = common::value_terminator_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_terminator.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
fn two_multi_valued_arguments() {
    let name = "my-app";
    let cmd = common::two_multi_valued_arguments_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/two_multi_valued_arguments.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
fn subcommand_last() {
    let name = "my-app";
    let cmd = common::subcommand_last(name);
    common::assert_matches(
        snapbox::file!["../snapshots/subcommand_last.fish"],
        clap_complete::shells::Fish,
        cmd,
        name,
    );
}

#[test]
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
fn register_completion() {
    common::register_example::<RuntimeBuilder>("static", "exhaustive");
}

#[test]
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
fn complete() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("static", "exhaustive");

    let input = "exhaustive \t";
    let expected = snapbox::str![[r#"
% exhaustive 
action  empty   help  (Print this message or the help of the given subcommand(s))  last    quote
alias   global  hint                                                               pacman  value
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive empty \t";
    let expected = snapbox::str![[r#"
% exhaustive empty 
Cargo.toml    CONTRIBUTING.md  LICENSE-APACHE  README.md  tests/
CHANGELOG.md  examples/        LICENSE-MIT     src/       
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive --empty=\t";
    let expected = snapbox::str!["% exhaustive --empty="];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive quote --choice \t";
    let actual = runtime.complete(input, &term).unwrap();
    let expected = snapbox::str![[r#"
% exhaustive quote --choice 
another  bash  (bash (shell))  fish  (fish shell)  shell  (something with a space)  zsh  (zsh shell)
"#]];
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn register_dynamic_env() {
    common::register_example::<RuntimeBuilder>("dynamic-env", "exhaustive");
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_toplevel() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive \t\t";
    let expected = snapbox::str![[r#"
% exhaustive empty 
empty   quote   last   help  (Print this message or the help of the given subcommand(s))  --help  (Print help)
global  value   alias  --generate                                             (generate)  
action  pacman  hint   --empty-choice                                                     
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_quoted_help() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive quote \t\t";
    let expected = snapbox::str![[r#"
% exhaustive quote 
cmd-single-quotes           (Can be 'always', 'auto', or 'never')
cmd-double-quotes           (Can be "always", "auto", or "never")
cmd-backticks              (For more information see `echo test`)
cmd-backslash                                        (Avoid '/n')
cmd-brackets                             (List packages [filter])
cmd-expansions            (Execute the shell command with $SHELL)
escape-help                                             (/tab "')
help  (Print this message or the help of the given subcommand(s))
--single-quotes             (Can be 'always', 'auto', or 'never')
--double-quotes             (Can be "always", "auto", or "never")
--backticks                (For more information see `echo test`)
--backslash                                          (Avoid '/n')
--brackets                               (List packages [filter])
--expansions              (Execute the shell command with $SHELL)
--choice                                                         
--help                      (Print help (see more with '--help'))
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_option_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive action --choice=\t\t";
    let expected = snapbox::str![[r#"
% exhaustive action --choice=first 
--choice=first  --choice=second
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive action --choice=f\t";
    let expected = snapbox::str!["% exhaustive action --choice=first "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_quoted_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive quote --choice \t\t";
    let expected = snapbox::str![[r#"
% exhaustive quote --choice another/ shell 
another shell  (something with a space)  bash  (bash (shell))  fish  (fish shell)  zsh  (zsh shell)
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive quote --choice an\t";
    let expected = snapbox::str!["% exhaustive quote --choice another/ shell "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_empty_subcommand() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive empty \t\t";
    let expected = snapbox::str!["% exhaustive empty "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_empty_option_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive --empty=\t";
    let expected = snapbox::str!["% exhaustive --empty="];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

```

`clap/clap_complete/tests/testsuite/general.rs`:

```rs
#[test]
fn infer_value_hint_for_path_buf() {
    let mut cmd = clap::Command::new("completer")
        .arg(clap::Arg::new("input").value_parser(clap::value_parser!(std::path::PathBuf)));
    cmd.build();
    let input = cmd
        .get_arguments()
        .find(|arg| arg.get_id() == "input")
        .unwrap();
    assert_eq!(input.get_value_hint(), clap::builder::ValueHint::AnyPath);
}

```

`clap/clap_complete/tests/testsuite/main.rs`:

```rs
automod::dir!("tests/testsuite");

```

`clap/clap_complete/tests/testsuite/powershell.rs`:

```rs
use crate::common;

#[test]
fn basic() {
    let name = "my-app";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/basic.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

#[test]
fn feature_sample() {
    let name = "my-app";
    let cmd = common::feature_sample_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/feature_sample.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

#[test]
fn special_commands() {
    let name = "my-app";
    let cmd = common::special_commands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/special_commands.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

#[test]
fn quoting() {
    let name = "my-app";
    let cmd = common::quoting_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/quoting.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

#[test]
fn aliases() {
    let name = "my-app";
    let cmd = common::aliases_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/aliases.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

#[test]
fn sub_subcommands() {
    let name = "my-app";
    let cmd = common::sub_subcommands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/sub_subcommands.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

#[test]
fn custom_bin_name() {
    let name = "my-app";
    let bin_name = "bin-name";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/custom_bin_name.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        bin_name,
    );
}

#[test]
fn value_hint() {
    let name = "my-app";
    let cmd = common::value_hint_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_hint.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

#[test]
fn value_terminator() {
    let name = "my-app";
    let cmd = common::value_terminator_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_terminator.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

#[test]
fn two_multi_valued_arguments() {
    let name = "my-app";
    let cmd = common::two_multi_valued_arguments_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/two_multi_valued_arguments.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

#[test]
fn subcommand_last() {
    let name = "my-app";
    let cmd = common::subcommand_last(name);
    common::assert_matches(
        snapbox::file!["../snapshots/subcommand_last.ps1"],
        clap_complete::shells::PowerShell,
        cmd,
        name,
    );
}

```

`clap/clap_complete/tests/testsuite/zsh.rs`:

```rs
#[allow(unused_imports)]
use snapbox::assert_data_eq;

use crate::common;

#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
const CMD: &str = "zsh";
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
type RuntimeBuilder = completest_pty::ZshRuntimeBuilder;

#[test]
fn basic() {
    let name = "my-app";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/basic.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
fn feature_sample() {
    let name = "my-app";
    let cmd = common::feature_sample_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/feature_sample.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
fn special_commands() {
    let name = "my-app";
    let cmd = common::special_commands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/special_commands.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
fn quoting() {
    let name = "my-app";
    let cmd = common::quoting_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/quoting.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
fn aliases() {
    let name = "my-app";
    let cmd = common::aliases_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/aliases.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
fn sub_subcommands() {
    let name = "my-app";
    let cmd = common::sub_subcommands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/sub_subcommands.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
fn custom_bin_name() {
    let name = "my-app";
    let bin_name = "bin-name";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/custom_bin_name.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        bin_name,
    );
}

#[test]
fn value_hint() {
    let name = "my-app";
    let cmd = common::value_hint_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_hint.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
fn value_terminator() {
    let name = "my-app";
    let cmd = common::value_terminator_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_terminator.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
fn two_multi_valued_arguments() {
    let name = "my-app";
    let cmd = common::two_multi_valued_arguments_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/two_multi_valued_arguments.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
fn subcommand_last() {
    let name = "my-app";
    let cmd = common::subcommand_last(name);
    common::assert_matches(
        snapbox::file!["../snapshots/subcommand_last.zsh"],
        clap_complete::shells::Zsh,
        cmd,
        name,
    );
}

#[test]
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
fn register_completion() {
    common::register_example::<RuntimeBuilder>("static", "exhaustive");
}

#[test]
#[cfg(unix)]
#[cfg(feature = "unstable-shell-tests")]
fn complete() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("static", "exhaustive");

    let input = "exhaustive \t";
    let expected = snapbox::str![[r#"
% exhaustive
help                                                      -- Print this message or the help of the given subcommand(s)
hint                                                      
pacman  action  global  alias  value  quote  empty  last  --                                                          
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive empty \t";
    let expected = snapbox::str!["% exhaustive empty "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive --empty=\t";
    let expected = snapbox::str!["% exhaustive --empty="];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn register_dynamic_env() {
    common::register_example::<RuntimeBuilder>("dynamic-env", "exhaustive");
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_toplevel() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive \t\t";
    let expected = snapbox::str![[r#"
% exhaustive
--generate      -- generate
--help          -- Print help
help            -- Print this message or the help of the given subcommand(s)
--empty-choice  alias           global          last            quote           
action          empty           hint            pacman          value           
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_quoted_help() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive quote \t\t";
    let expected = snapbox::str![[r#"
% exhaustive quote
--help                              -- Print help (see more with '--help')                                            
cmd-backslash      --backslash      -- Avoid '/n'                                                                     
cmd-backticks      --backticks      -- For more information see `echo test`                                           
cmd-brackets       --brackets       -- List packages [filter]                                                         
cmd-double-quotes  --double-quotes  -- Can be "always", "auto", or "never"                                            
cmd-expansions     --expansions     -- Execute the shell command with $SHELL                                          
cmd-single-quotes  --single-quotes  -- Can be 'always', 'auto', or 'never'                                            
escape-help                         -- /tab/t"'                                                                       
help                                -- Print this message or the help of the given subcommand(s)                      
--choice
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_option_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive action --choice=\t\t";
    let expected = snapbox::str![[r#"
% exhaustive action --choice=
--choice=first   --choice=second
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive action --choice=f\t\t";
    let expected = snapbox::str!["% exhaustive action --choice=first "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_env_quoted_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive quote --choice \t\t";
    let expected = snapbox::str![[r#"
% exhaustive quote --choice
another shell  -- something with a space
bash           -- bash (shell)
fish           -- fish shell
zsh            -- zsh shell
"#]];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "exhaustive quote --choice an\t\t";
    let expected = snapbox::str!["% exhaustive quote --choice another/ shell "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_empty_subcommand() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive empty \t\t";
    let expected = snapbox::str!["% exhaustive empty "];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
#[cfg(all(unix, feature = "unstable-dynamic"))]
#[cfg(feature = "unstable-shell-tests")]
fn complete_dynamic_empty_option_value() {
    if !common::has_command(CMD) {
        return;
    }

    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<RuntimeBuilder>("dynamic-env", "exhaustive");

    let input = "exhaustive --empty=\t";
    let expected = snapbox::str!["% exhaustive --empty="];
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

```

`clap/clap_complete_nushell/CHANGELOG.md`:

```md
# Change Log
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/)
and this project adheres to [Semantic Versioning](http://semver.org/).

<!-- next-header -->
## [Unreleased] - ReleaseDate

## [4.5.5] - 2025-01-02

### Features

- Respect `ValueHint` for paths

## [4.5.4] - 2024-10-08

## [4.5.3] - 2024-07-25

## [4.5.2] - 2024-06-06

## [4.5.1] - 2024-02-16

### Fixes

- Correctly handle completion descriptions with newlines

## [4.5.0] - 2024-02-08

### Compatibility

- Update MSRV to 1.74

## [4.4.2] - 2023-10-24

## [4.4.1] - 2023-09-11

### Features

- Allow completions to be used with `use` and `overlay use`

## [4.4.0] - 2023-08-24

### Compatibility

- Update MSRV to 1.70.0

## [4.3.2] - 2023-08-08

## [4.3.1] - 2023-06-02

## [4.3.0] - 2023-05-24

<!-- next-url -->
[Unreleased]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.5.5...HEAD
[4.5.5]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.5.4...clap_complete_nushell-v4.5.5
[4.5.4]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.5.3...clap_complete_nushell-v4.5.4
[4.5.3]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.5.2...clap_complete_nushell-v4.5.3
[4.5.2]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.5.1...clap_complete_nushell-v4.5.2
[4.5.1]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.5.0...clap_complete_nushell-v4.5.1
[4.5.0]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.4.2...clap_complete_nushell-v4.5.0
[4.4.2]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.4.1...clap_complete_nushell-v4.4.2
[4.4.1]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.4.0...clap_complete_nushell-v4.4.1
[4.4.0]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.3.2...clap_complete_nushell-v4.4.0
[4.3.2]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.3.1...clap_complete_nushell-v4.3.2
[4.3.1]: https://github.com/clap-rs/clap/compare/clap_complete_nushell-v4.3.0...clap_complete_nushell-v4.3.1
[4.3.0]: https://github.com/clap-rs/clap/compare/bd163098e122bb65e053a61b773931c8f36d2e7d...clap_complete_nushell-v4.3.0

```

`clap/clap_complete_nushell/Cargo.toml`:

```toml
[package]
name = "clap_complete_nushell"
version = "4.5.5"
description = "A generator library used with clap for Nushell completion scripts"
categories = ["command-line-interface"]
keywords = [
  "clap",
  "cli",
  "completion",
  "nushell"
]
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
include.workspace = true

[package.metadata.docs.rs]
targets = ["x86_64-unknown-linux-gnu"]

[package.metadata.release]
pre-release-replacements = [
  {file="CHANGELOG.md", search="Unreleased", replace="{{version}}", min=1},
  {file="CHANGELOG.md", search="\\.\\.\\.HEAD", replace="...{{tag_name}}", exactly=1},
  {file="CHANGELOG.md", search="ReleaseDate", replace="{{date}}", min=1},
  {file="CHANGELOG.md", search="<!-- next-header -->", replace="<!-- next-header -->\n## [Unreleased] - ReleaseDate\n", exactly=1},
  {file="CHANGELOG.md", search="<!-- next-url -->", replace="<!-- next-url -->\n[Unreleased]: https://github.com/clap-rs/clap/compare/{{tag_name}}...HEAD", exactly=1},
]

[lib]
bench = false

[dependencies]
clap = { path = "../", version = "4.0.0", default-features = false, features = ["std"] }
clap_complete = { path = "../clap_complete", version = "4.0.0" }
completest = { version = "0.4.0", optional = true }
completest-nu = { version = "0.4.0", optional = true }

[dev-dependencies]
snapbox = { version = "0.6.0", features = ["diff", "examples", "dir"] }
clap = { path = "../", version = "4.0.0", default-features = false, features = ["std", "help"] }

[features]
default = []
unstable-shell-tests = ["dep:completest", "dep:completest-nu"]

[lints]
workspace = true

```

`clap/clap_complete_nushell/LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`clap/clap_complete_nushell/LICENSE-MIT`:

```
The MIT License (MIT)

Copyright (c) 2022 nibon7 <nibon7@163.com>  and Clap Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`clap/clap_complete_nushell/README.md`:

```md
# clap_complete_nushell

Generates [Nushell](https://github.com/nushell/nushell) completions for [`clap`](https://github.com/clap-rs/clap) based CLIs

[![Crates.io](https://img.shields.io/crates/v/clap_complete_nushell)](https://crates.io/crates/clap_complete_nushell)
[![Crates.io](https://img.shields.io/crates/d/clap_complete_nushell)](https://crates.io/crates/clap_complete_nushell)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue)](LICENSE-APACHE)
[![License](https://img.shields.io/badge/license-MIT-blue)](LICENSE-MIT)
[![docs.rs](https://img.shields.io/docsrs/clap_complete_nushell)](https://docs.rs/clap_complete_nushell)

- [Questions & Discussions](https://github.com/clap-rs/clap/discussions)
- [CONTRIBUTING](../CONTRIBUTING.md)

## Examples

### myapp.rs

```rust
use clap::{builder::PossibleValue, Arg, ArgAction, Command, ValueHint};
use clap_complete::generate;
use clap_complete_nushell::Nushell;
use std::io;

fn main() {
    let mut cmd = Command::new("myapp")
        .version("3.0")
        .propagate_version(true)
        .about("Tests completions")
        .arg(
            Arg::new("file")
                .value_hint(ValueHint::FilePath)
                .help("some input file"),
        )
        .arg(
            Arg::new("config")
                .action(ArgAction::Count)
                .help("some config file")
                .short('c')
                .visible_short_alias('C')
                .long("config")
                .visible_alias("conf"),
        )
        .arg(Arg::new("choice").value_parser(["first", "second"]))
        .subcommand(
            Command::new("test").about("tests things").arg(
                Arg::new("case")
                    .long("case")
                    .action(ArgAction::Set)
                    .help("the case to test"),
            ),
        )
        .subcommand(
            Command::new("some_cmd")
                .about("top level subcommand")
                .subcommand(
                    Command::new("sub_cmd").about("sub-subcommand").arg(
                        Arg::new("config")
                            .long("config")
                            .action(ArgAction::Set)
                            .value_parser([PossibleValue::new("Lest quotes aren't escaped.")])
                            .help("the other case to test"),
                    ),
                ),
        );

    generate(Nushell, &mut cmd, "myapp", &mut io::stdout());
}

```

### myapp.nu

```nu
module completions {

  def "nu-complete myapp choice" [] {
    [ "first" "second" ]
  }

  # Tests completions
  export extern myapp [
    file?: string             # some input file
    --config(-c)              # some config file
    --conf                    # some config file
    -C                        # some config file
    choice?: string@"nu-complete myapp choice"
    --version(-V)             # Print version
  ]

  # tests things
  export extern "myapp test" [
    --case: string            # the case to test
    --version(-V)             # Print version
  ]

  # top level subcommand
  export extern "myapp some_cmd" [
    --version(-V)             # Print version
  ]

  def "nu-complete myapp some_cmd sub_cmd config" [] {
    [ "\"Lest quotes aren't escaped.\"" ]
  }

  # sub-subcommand
  export extern "myapp some_cmd sub_cmd" [
    --config: string@"nu-complete myapp some_cmd sub_cmd config" # the other case to test
    --version(-V)             # Print version
  ]

}

use completions *
```

```

`clap/clap_complete_nushell/examples/nushell_completion.rs`:

```rs
use clap::Command;
use clap_complete::generate;
use clap_complete_nushell::Nushell;
use std::io;

fn main() {
    let mut cmd = Command::new("myapp")
        .subcommand(Command::new("test").subcommand(Command::new("config")))
        .subcommand(Command::new("hello"));

    generate(Nushell, &mut cmd, "myapp", &mut io::stdout());
}

```

`clap/clap_complete_nushell/examples/sub_subcommands.rs`:

```rs
use clap::{builder::PossibleValue, Arg, ArgAction, Command, ValueHint};
use clap_complete::generate;
use clap_complete_nushell::Nushell;
use std::io;

fn main() {
    let mut cmd = Command::new("myapp")
        .version("3.0")
        .propagate_version(true)
        .about("Tests completions")
        .arg(
            Arg::new("file")
                .value_hint(ValueHint::FilePath)
                .help("some input file"),
        )
        .arg(
            Arg::new("config")
                .action(ArgAction::Count)
                .help("some config file")
                .short('c')
                .visible_short_alias('C')
                .long("config")
                .visible_alias("conf"),
        )
        .arg(Arg::new("choice").value_parser(["first", "second"]))
        .subcommand(
            Command::new("test").about("tests things").arg(
                Arg::new("case")
                    .long("case")
                    .action(ArgAction::Set)
                    .help("the case to test"),
            ),
        )
        .subcommand(
            Command::new("some_cmd")
                .about("top level subcommand")
                .subcommand(
                    Command::new("sub_cmd").about("sub-subcommand").arg(
                        Arg::new("config")
                            .long("config")
                            .action(ArgAction::Set)
                            .value_parser([PossibleValue::new("Lest quotes aren't escaped.")])
                            .help("the other case to test"),
                    ),
                ),
        );

    generate(Nushell, &mut cmd, "myapp", &mut io::stdout());
}

```

`clap/clap_complete_nushell/examples/test.rs`:

```rs
use clap_complete::generate;
use clap_complete_nushell::Nushell;

fn main() {
    let matches = cli().get_matches();
    if matches.contains_id("generate") {
        let mut cmd = cli();
        generate(Nushell, &mut cmd, "test", &mut std::io::stdout());
    } else {
        println!("{matches:?}");
    }
}

fn cli() -> clap::Command {
    clap::Command::new("test")
        .version("3.0")
        .propagate_version(true)
        .args([
            clap::Arg::new("global")
                .long("global")
                .global(true)
                .action(clap::ArgAction::SetTrue)
                .help("everywhere"),
            clap::Arg::new("generate").long("generate").help("generate"),
        ])
        .subcommands([
            clap::Command::new("action").args([
                clap::Arg::new("set-true")
                    .long("set-true")
                    .action(clap::ArgAction::SetTrue)
                    .help("bool"),
                clap::Arg::new("set")
                    .long("set")
                    .action(clap::ArgAction::Set)
                    .help("value"),
                clap::Arg::new("count")
                    .long("count")
                    .action(clap::ArgAction::Count)
                    .help("number"),
                clap::Arg::new("choice")
                    .long("choice")
                    .value_parser(["first", "second"])
                    .help("enum"),
            ]),
            clap::Command::new("quote")
                .args([
                    clap::Arg::new("single-quotes")
                        .long("single-quotes")
                        .action(clap::ArgAction::SetTrue)
                        .help("Can be 'always', 'auto', or 'never'"),
                    clap::Arg::new("double-quotes")
                        .long("double-quotes")
                        .action(clap::ArgAction::SetTrue)
                        .help("Can be \"always\", \"auto\", or \"never\""),
                    clap::Arg::new("backticks")
                        .long("backticks")
                        .action(clap::ArgAction::SetTrue)
                        .help("For more information see `echo test`"),
                    clap::Arg::new("backslash")
                        .long("backslash")
                        .action(clap::ArgAction::SetTrue)
                        .help("Avoid '\\n'"),
                    clap::Arg::new("brackets")
                        .long("brackets")
                        .action(clap::ArgAction::SetTrue)
                        .help("List packages [filter]"),
                    clap::Arg::new("expansions")
                        .long("expansions")
                        .action(clap::ArgAction::SetTrue)
                        .help("Execute the shell command with $SHELL"),
                ])
                .subcommands([
                    clap::Command::new("cmd-single-quotes")
                        .about("Can be 'always', 'auto', or 'never'"),
                    clap::Command::new("cmd-double-quotes")
                        .about("Can be \"always\", \"auto\", or \"never\""),
                    clap::Command::new("cmd-backticks")
                        .about("For more information see `echo test`"),
                    clap::Command::new("cmd-backslash").about("Avoid '\\n'"),
                    clap::Command::new("cmd-brackets").about("List packages [filter]"),
                    clap::Command::new("cmd-expansions")
                        .about("Execute the shell command with $SHELL"),
                ]),
            clap::Command::new("value").args([
                clap::Arg::new("delim").long("delim").value_delimiter(','),
                clap::Arg::new("tuple").long("tuple").num_args(2),
                clap::Arg::new("require-eq")
                    .long("require-eq")
                    .require_equals(true),
                clap::Arg::new("term").num_args(1..).value_terminator(";"),
            ]),
            clap::Command::new("pacman").subcommands([
                clap::Command::new("one").long_flag("one").short_flag('o'),
                clap::Command::new("two").long_flag("two").short_flag('t'),
            ]),
            clap::Command::new("last")
                .args([clap::Arg::new("first"), clap::Arg::new("free").last(true)]),
            clap::Command::new("alias").args([
                clap::Arg::new("flag")
                    .short('f')
                    .visible_short_alias('F')
                    .long("flag")
                    .action(clap::ArgAction::SetTrue)
                    .visible_alias("flg")
                    .help("cmd flag"),
                clap::Arg::new("option")
                    .short('o')
                    .visible_short_alias('O')
                    .long("option")
                    .visible_alias("opt")
                    .help("cmd option")
                    .action(clap::ArgAction::Set),
                clap::Arg::new("positional"),
            ]),
            clap::Command::new("hint").args([
                clap::Arg::new("choice")
                    .long("choice")
                    .action(clap::ArgAction::Set)
                    .value_parser(["bash", "fish", "zsh"]),
                clap::Arg::new("unknown")
                    .long("unknown")
                    .value_hint(clap::ValueHint::Unknown),
                clap::Arg::new("other")
                    .long("other")
                    .value_hint(clap::ValueHint::Other),
                clap::Arg::new("path")
                    .long("path")
                    .short('p')
                    .value_hint(clap::ValueHint::AnyPath),
                clap::Arg::new("file")
                    .long("file")
                    .short('f')
                    .value_hint(clap::ValueHint::FilePath),
                clap::Arg::new("dir")
                    .long("dir")
                    .short('d')
                    .value_hint(clap::ValueHint::DirPath),
                clap::Arg::new("exe")
                    .long("exe")
                    .short('e')
                    .value_hint(clap::ValueHint::ExecutablePath),
                clap::Arg::new("cmd_name")
                    .long("cmd-name")
                    .value_hint(clap::ValueHint::CommandName),
                clap::Arg::new("cmd")
                    .long("cmd")
                    .short('c')
                    .value_hint(clap::ValueHint::CommandString),
                clap::Arg::new("command_with_args")
                    .action(clap::ArgAction::Set)
                    .num_args(1..)
                    .trailing_var_arg(true)
                    .value_hint(clap::ValueHint::CommandWithArguments),
                clap::Arg::new("user")
                    .short('u')
                    .long("user")
                    .value_hint(clap::ValueHint::Username),
                clap::Arg::new("host")
                    .short('H')
                    .long("host")
                    .value_hint(clap::ValueHint::Hostname),
                clap::Arg::new("url")
                    .long("url")
                    .value_hint(clap::ValueHint::Url),
                clap::Arg::new("email")
                    .long("email")
                    .value_hint(clap::ValueHint::EmailAddress),
            ]),
        ])
}

```

`clap/clap_complete_nushell/src/lib.rs`:

```rs
//! Generates [Nushell](https://github.com/nushell/nushell) completions for [`clap`](https://github.com/clap-rs/clap) based CLIs
//!
//! ## Example
//!
//! ```
//! use clap::Command;
//! use clap_complete::generate;
//! use clap_complete_nushell::Nushell;
//! use std::io;
//!
//! let mut cmd = Command::new("myapp")
//!     .subcommand(Command::new("test").subcommand(Command::new("config")))
//!     .subcommand(Command::new("hello"));
//!
//! generate(Nushell, &mut cmd, "myapp", &mut io::stdout());
//! ```

#![doc(html_logo_url = "https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png")]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![forbid(unsafe_code)]
#![warn(missing_docs)]
#![warn(clippy::print_stderr)]
#![warn(clippy::print_stdout)]

use clap::builder::StyledStr;
use clap::ValueHint;
use clap::{builder::PossibleValue, Arg, ArgAction, Command};
use clap_complete::Generator;

/// Generate Nushell complete file
pub struct Nushell;

impl Generator for Nushell {
    fn file_name(&self, name: &str) -> String {
        format!("{name}.nu")
    }

    fn generate(&self, cmd: &Command, buf: &mut dyn std::io::Write) {
        let mut completions = String::new();

        completions.push_str("module completions {\n\n");

        generate_completion(&mut completions, cmd, false);

        for sub in cmd.get_subcommands() {
            generate_completion(&mut completions, sub, true);
        }

        completions.push_str("}\n\n");
        completions.push_str("export use completions *\n");

        buf.write_all(completions.as_bytes())
            .expect("Failed to write to generated file");
    }
}

fn append_value_completion_and_help(
    arg: &Arg,
    name: &str,
    possible_values: &[PossibleValue],
    s: &mut String,
) {
    let takes_values = arg
        .get_num_args()
        .map(|r| r.takes_values())
        .unwrap_or(false);

    if takes_values {
        let nu_type = match arg.get_value_hint() {
            ValueHint::Unknown => "string",
            ValueHint::Other => "string",
            ValueHint::AnyPath => "path",
            ValueHint::FilePath => "path",
            ValueHint::DirPath => "path",
            ValueHint::ExecutablePath => "path",
            ValueHint::CommandName => "string",
            ValueHint::CommandString => "string",
            ValueHint::CommandWithArguments => "string",
            ValueHint::Username => "string",
            ValueHint::Hostname => "string",
            ValueHint::Url => "string",
            ValueHint::EmailAddress => "string",
            _ => "string",
        };
        s.push_str(format!(": {nu_type}").as_str());

        if !possible_values.is_empty() {
            s.push_str(format!(r#"@"nu-complete {} {}""#, name, arg.get_id()).as_str());
        }
    }

    if let Some(help) = arg.get_help() {
        let indent: usize = 30;
        let width = match s.lines().last() {
            Some(line) => indent.saturating_sub(line.len()),
            None => 0,
        };

        s.push_str(format!("{:>width$}# {}", ' ', single_line_styled_str(help)).as_str());
    }

    s.push('\n');
}

fn append_value_completion_defs(arg: &Arg, name: &str, s: &mut String) {
    let possible_values = arg.get_possible_values();
    if possible_values.is_empty() {
        return;
    }

    s.push_str(format!(r#"  def "nu-complete {} {}" [] {{"#, name, arg.get_id()).as_str());
    s.push_str("\n    [");

    for value in possible_values {
        let vname = value.get_name();
        if vname.contains(|c: char| c.is_whitespace()) {
            s.push_str(format!(r#" "\"{vname}\"""#).as_str());
        } else {
            s.push_str(format!(r#" "{vname}""#).as_str());
        }
    }

    s.push_str(" ]\n  }\n\n");
}

fn append_argument(arg: &Arg, name: &str, s: &mut String) {
    let possible_values = arg.get_possible_values();

    if arg.is_positional() {
        // rest arguments
        if matches!(arg.get_action(), ArgAction::Append) {
            s.push_str(format!("    ...{}", arg.get_id()).as_str());
        } else {
            s.push_str(format!("    {}", arg.get_id()).as_str());

            if !arg.is_required_set() {
                s.push('?');
            }
        }

        append_value_completion_and_help(arg, name, &possible_values, s);

        return;
    }

    let shorts = arg.get_short_and_visible_aliases();
    let longs = arg.get_long_and_visible_aliases();

    match shorts {
        Some(shorts) => match longs {
            Some(longs) => {
                // short options and long options
                s.push_str(
                    format!(
                        "    --{}(-{})",
                        longs.first().expect("At least one long option expected"),
                        shorts.first().expect("At lease one short option expected")
                    )
                    .as_str(),
                );
                append_value_completion_and_help(arg, name, &possible_values, s);

                // long alias
                for long in longs.iter().skip(1) {
                    s.push_str(format!("    --{long}").as_str());
                    append_value_completion_and_help(arg, name, &possible_values, s);
                }

                // short alias
                for short in shorts.iter().skip(1) {
                    s.push_str(format!("    -{short}").as_str());
                    append_value_completion_and_help(arg, name, &possible_values, s);
                }
            }
            None => {
                // short options only
                for short in shorts {
                    s.push_str(format!("    -{short}").as_str());
                    append_value_completion_and_help(arg, name, &possible_values, s);
                }
            }
        },
        None => match longs {
            Some(longs) => {
                // long options only
                for long in longs {
                    s.push_str(format!("    --{long}").as_str());
                    append_value_completion_and_help(arg, name, &possible_values, s);
                }
            }
            None => unreachable!("No short or long options found"),
        },
    }
}

fn generate_completion(completions: &mut String, cmd: &Command, is_subcommand: bool) {
    let name = cmd.get_bin_name().expect("Failed to get bin name");

    for arg in cmd.get_arguments() {
        append_value_completion_defs(arg, name, completions);
    }

    if let Some(about) = cmd.get_about() {
        let about = single_line_styled_str(about);
        completions.push_str(format!("  # {about}\n").as_str());
    }

    if is_subcommand {
        completions.push_str(format!("  export extern \"{name}\" [\n").as_str());
    } else {
        completions.push_str(format!("  export extern {name} [\n").as_str());
    }

    for arg in cmd.get_arguments() {
        append_argument(arg, name, completions);
    }

    completions.push_str("  ]\n\n");

    if is_subcommand {
        for sub in cmd.get_subcommands() {
            generate_completion(completions, sub, true);
        }
    }
}

fn single_line_styled_str(text: &StyledStr) -> String {
    text.to_string().replace('\n', " ")
}

```

`clap/clap_complete_nushell/tests/common.rs`:

```rs
#![allow(dead_code)] // shared with other test modules

use clap::{builder::PossibleValue, Arg, ArgAction, Command, ValueHint};
use snapbox::prelude::*;

pub(crate) fn basic_command(name: &'static str) -> Command {
    Command::new(name)
        .arg(
            Arg::new("config")
                .short('c')
                .global(true)
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("v")
                .short('v')
                .conflicts_with("config")
                .action(ArgAction::SetTrue),
        )
        .subcommand(
            Command::new("test")
                .about("Subcommand\nwith a second line")
                .arg(Arg::new("debug").short('d').action(ArgAction::Count)),
        )
}

pub(crate) fn feature_sample_command(name: &'static str) -> Command {
    Command::new(name)
        .version("3.0")
        .propagate_version(true)
        .about("Tests completions")
        .arg(
            Arg::new("file")
                .value_hint(ValueHint::FilePath)
                .help("some input file"),
        )
        .arg(
            Arg::new("config")
                .action(ArgAction::Count)
                .help("some config file\nwith another line")
                .short('c')
                .visible_short_alias('C')
                .long("config")
                .visible_alias("conf"),
        )
        .arg(Arg::new("choice").value_parser(["first", "second"]))
        .subcommand(
            Command::new("test").about("tests things").arg(
                Arg::new("case")
                    .long("case")
                    .action(ArgAction::Set)
                    .help("the case to test"),
            ),
        )
}

pub(crate) fn special_commands_command(name: &'static str) -> Command {
    feature_sample_command(name)
        .subcommand(
            Command::new("some_cmd")
                .about("tests other things")
                .arg(
                    Arg::new("config")
                        .long("config")
                        .hide(true)
                        .action(ArgAction::Set)
                        .require_equals(true)
                        .help("the other case to test"),
                )
                .arg(Arg::new("path").num_args(1..)),
        )
        .subcommand(Command::new("some-cmd-with-hyphens").alias("hyphen"))
        .subcommand(Command::new("some-hidden-cmd").hide(true))
}

pub(crate) fn quoting_command(name: &'static str) -> Command {
    Command::new(name)
        .version("3.0")
        .arg(
            Arg::new("single-quotes")
                .long("single-quotes")
                .action(ArgAction::SetTrue)
                .help("Can be 'always', 'auto', or 'never'"),
        )
        .arg(
            Arg::new("double-quotes")
                .long("double-quotes")
                .action(ArgAction::SetTrue)
                .help("Can be \"always\", \"auto\", or \"never\""),
        )
        .arg(
            Arg::new("backticks")
                .long("backticks")
                .action(ArgAction::SetTrue)
                .help("For more information see `echo test`"),
        )
        .arg(
            Arg::new("backslash")
                .long("backslash")
                .action(ArgAction::SetTrue)
                .help("Avoid '\\n'"),
        )
        .arg(
            Arg::new("brackets")
                .long("brackets")
                .action(ArgAction::SetTrue)
                .help("List packages [filter]"),
        )
        .arg(
            Arg::new("expansions")
                .long("expansions")
                .action(ArgAction::SetTrue)
                .help("Execute the shell command with $SHELL"),
        )
        .subcommands([
            Command::new("cmd-single-quotes").about("Can be 'always', 'auto', or 'never'"),
            Command::new("cmd-double-quotes").about("Can be \"always\", \"auto\", or \"never\""),
            Command::new("cmd-backticks").about("For more information see `echo test`"),
            Command::new("cmd-backslash").about("Avoid '\\n'"),
            Command::new("cmd-brackets").about("List packages [filter]"),
            Command::new("cmd-expansions").about("Execute the shell command with $SHELL"),
        ])
}

pub(crate) fn aliases_command(name: &'static str) -> Command {
    Command::new(name)
        .version("3.0")
        .about("testing nushell completions")
        .arg(
            Arg::new("flag")
                .short('f')
                .visible_short_alias('F')
                .long("flag")
                .action(ArgAction::SetTrue)
                .visible_alias("flg")
                .help("cmd flag"),
        )
        .arg(
            Arg::new("option")
                .short('o')
                .visible_short_alias('O')
                .long("option")
                .visible_alias("opt")
                .help("cmd option")
                .action(ArgAction::Set),
        )
        .arg(Arg::new("positional"))
}

pub(crate) fn sub_subcommands_command(name: &'static str) -> Command {
    feature_sample_command(name).subcommand(
        Command::new("some_cmd")
            .about("top level subcommand")
            .visible_alias("some_cmd_alias")
            .subcommand(
                Command::new("sub_cmd").about("sub-subcommand").arg(
                    Arg::new("config")
                        .long("config")
                        .action(ArgAction::Set)
                        .value_parser([
                            PossibleValue::new("Lest quotes, aren't escaped.")
                                .help("help,with,comma"),
                            PossibleValue::new("Second to trigger display of options"),
                        ])
                        .help("the other case to test"),
                ),
            ),
    )
}

pub(crate) fn value_hint_command(name: &'static str) -> Command {
    Command::new(name)
        .arg(
            Arg::new("choice")
                .long("choice")
                .action(ArgAction::Set)
                .value_parser(["bash", "fish", "zsh"]),
        )
        .arg(
            Arg::new("unknown")
                .long("unknown")
                .value_hint(ValueHint::Unknown),
        )
        .arg(Arg::new("other").long("other").value_hint(ValueHint::Other))
        .arg(
            Arg::new("path")
                .long("path")
                .short('p')
                .value_hint(ValueHint::AnyPath),
        )
        .arg(
            Arg::new("file")
                .long("file")
                .short('f')
                .value_hint(ValueHint::FilePath),
        )
        .arg(
            Arg::new("dir")
                .long("dir")
                .short('d')
                .value_hint(ValueHint::DirPath),
        )
        .arg(
            Arg::new("exe")
                .long("exe")
                .short('e')
                .value_hint(ValueHint::ExecutablePath),
        )
        .arg(
            Arg::new("cmd_name")
                .long("cmd-name")
                .value_hint(ValueHint::CommandName),
        )
        .arg(
            Arg::new("cmd")
                .long("cmd")
                .short('c')
                .value_hint(ValueHint::CommandString),
        )
        .arg(
            Arg::new("command_with_args")
                .action(ArgAction::Set)
                .num_args(1..)
                .trailing_var_arg(true)
                .value_hint(ValueHint::CommandWithArguments),
        )
        .arg(
            Arg::new("user")
                .short('u')
                .long("user")
                .value_hint(ValueHint::Username),
        )
        .arg(
            Arg::new("host")
                .short('H')
                .long("host")
                .value_hint(ValueHint::Hostname),
        )
        .arg(Arg::new("url").long("url").value_hint(ValueHint::Url))
        .arg(
            Arg::new("email")
                .long("email")
                .value_hint(ValueHint::EmailAddress),
        )
}

pub(crate) fn assert_matches(
    expected: impl IntoData,
    generator: impl clap_complete::Generator,
    mut cmd: Command,
    name: &'static str,
) {
    let mut buf = vec![];
    clap_complete::generate(generator, &mut cmd, name, &mut buf);

    snapbox::Assert::new()
        .action_env(snapbox::assert::DEFAULT_ACTION_ENV)
        .normalize_paths(false)
        .eq(buf, expected);
}

#[cfg(feature = "unstable-shell-tests")]
pub(crate) fn register_example<R: completest::RuntimeBuilder>(context: &str, name: &str) {
    use completest::Runtime as _;

    let scratch = snapbox::dir::DirRoot::mutable_temp().unwrap();
    let scratch_path = scratch.path().unwrap();

    let shell_name = R::name();
    let home = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("tests/snapshots/home")
        .join(context)
        .join(name)
        .join(shell_name);
    println!("Compiling");
    let manifest_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR")).join("Cargo.toml");
    let bin_path =
        snapbox::cmd::compile_example(name, ["--manifest-path", manifest_path.to_str().unwrap()])
            .unwrap();
    println!("Compiled");
    let bin_root = bin_path.parent().unwrap().to_owned();

    let mut registration = std::process::Command::new(&bin_path);
    match context {
        "static" => registration.args([format!("--generate={shell_name}")]),
        "dynamic" => registration.args([
            "complete".to_owned(),
            "--register=-".to_owned(),
            format!("--shell={shell_name}"),
        ]),
        _ => unreachable!("unsupported context {}", context),
    };
    let registration = registration.output().unwrap();
    assert!(
        registration.status.success(),
        "{}",
        String::from_utf8_lossy(&registration.stderr)
    );
    let registration = std::str::from_utf8(&registration.stdout).unwrap();
    assert!(!registration.is_empty());

    let mut runtime = R::new(bin_root, scratch_path.to_owned()).unwrap();

    runtime.register(name, registration).unwrap();

    snapbox::assert_subset_eq(home, scratch_path);

    scratch.close().unwrap();
}

#[cfg(feature = "unstable-shell-tests")]
pub(crate) fn load_runtime<R: completest::RuntimeBuilder>(
    context: &str,
    name: &str,
) -> Box<dyn completest::Runtime>
where
    <R as completest::RuntimeBuilder>::Runtime: 'static,
{
    let shell_name = R::name();
    let home = std::path::Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("tests/snapshots/home")
        .join(context)
        .join(name)
        .join(shell_name);
    let scratch = snapbox::dir::DirRoot::mutable_temp()
        .unwrap()
        .with_template(&home)
        .unwrap();
    let home = scratch.path().unwrap().to_owned();
    println!("Compiling");
    let manifest_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR")).join("Cargo.toml");
    let bin_path =
        snapbox::cmd::compile_example(name, ["--manifest-path", manifest_path.to_str().unwrap()])
            .unwrap();
    println!("Compiled");
    let bin_root = bin_path.parent().unwrap().to_owned();

    let runtime = R::with_home(bin_root, home).unwrap();

    Box::new(ScratchRuntime {
        _scratch: scratch,
        runtime: Box::new(runtime),
    })
}

#[derive(Debug)]
#[cfg(feature = "unstable-shell-tests")]
struct ScratchRuntime {
    _scratch: snapbox::dir::DirRoot,
    runtime: Box<dyn completest::Runtime>,
}

#[cfg(feature = "unstable-shell-tests")]
impl completest::Runtime for ScratchRuntime {
    fn home(&self) -> &std::path::Path {
        self.runtime.home()
    }

    fn register(&mut self, name: &str, content: &str) -> std::io::Result<()> {
        self.runtime.register(name, content)
    }

    fn complete(&mut self, input: &str, term: &completest::Term) -> std::io::Result<String> {
        let output = self.runtime.complete(input, term)?;
        // HACK: elvish prints and clears this message when a completer takes too long which is
        // dependent on a lot of factors, making this show up or no sometimes (especially if we
        // aren't clearing the screen properly for fish)
        let output = output.replace("\nCOMPLETING argument\n", "\n");
        Ok(output)
    }
}

#[cfg(feature = "unstable-shell-tests")]
pub(crate) fn has_command(command: &str) -> bool {
    let output = match std::process::Command::new(command)
        .arg("--version")
        .output()
    {
        Ok(output) => output,
        Err(e) => {
            // CI is expected to support all of the commands
            if is_ci() && cfg!(target_os = "linux") {
                panic!("expected command `{command}` to be somewhere in PATH: {e}");
            }
            return false;
        }
    };
    if !output.status.success() {
        panic!(
            "expected command `{}` to be runnable, got error {}:\n\
            stderr:{}\n\
            stdout:{}\n",
            command,
            output.status,
            String::from_utf8_lossy(&output.stderr),
            String::from_utf8_lossy(&output.stdout)
        );
    }
    let stdout = String::from_utf8_lossy(&output.stdout);
    println!(
        "$ {command} --version
{stdout}"
    );
    if cfg!(target_os = "macos") && stdout.starts_with("GNU bash, version 3") {
        return false;
    }
    if cfg!(target_os = "macos") && command == "zsh" {
        // HACK: At least on CI, the prompt override is not working
        return false;
    }

    true
}

/// Whether or not this running in a Continuous Integration environment.
#[cfg(feature = "unstable-shell-tests")]
fn is_ci() -> bool {
    // Consider using `tracked_env` instead of option_env! when it is stabilized.
    // `tracked_env` will handle changes, but not require rebuilding the macro
    // itself like option_env does.
    option_env!("CI").is_some() || option_env!("TF_BUILD").is_some()
}

```

`clap/clap_complete_nushell/tests/completion.rs`:

```rs
#![cfg(feature = "unstable-shell-tests")]

mod common;

use snapbox::assert_data_eq;

#[test]
fn register_completion() {
    common::register_example::<completest_nu::NuRuntimeBuilder>("static", "test");
}

#[test]
fn completion() {
    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<completest_nu::NuRuntimeBuilder>("static", "test");

    let input = "test -\t";
    let expected = r#"% test -
--generate    generate
--global    everywhere
--help    Print help
--version    Print version
-V    Print version
-h    Print help
"#;
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "test action -\t";
    let expected = r#"% test action -
--choice    enum
--count    number
--global    everywhere
--help    Print help
--set    value
--set-true    bool
--version    Print version
-V    Print version
-h    Print help
"#;
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

#[test]
fn completion_value_hint() {
    let term = completest::Term::new();
    let mut runtime = common::load_runtime::<completest_nu::NuRuntimeBuilder>("static", "test");

    let input = "test hint -\t";
    let expected = r#"% test hint -
--choice
--cmd
--cmd-name
--dir
--email
--exe
--file
--global    everywhere
--help    Print help
--host
--other
--path
--unknown
--url
--user
--version    Print version
-H
-V    Print version
-c
-d
-e
-f
-h    Print help
-p
-u
"#;
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);

    let input = "test hint --choice \t";
    let expected = r#"% test hint --choice 
bash
fish
zsh
"#;
    let actual = runtime.complete(input, &term).unwrap();
    assert_data_eq!(actual, expected);
}

```

`clap/clap_complete_nushell/tests/nushell.rs`:

```rs
mod common;

#[test]
fn basic() {
    let name = "my-app";
    let cmd = common::basic_command(name);
    common::assert_matches(
        snapbox::file!["snapshots/basic.nu"],
        clap_complete_nushell::Nushell,
        cmd,
        name,
    );
}

#[test]
fn feature_sample() {
    let name = "my-app";
    let cmd = common::feature_sample_command(name);
    common::assert_matches(
        snapbox::file!["snapshots/feature_sample.nu"],
        clap_complete_nushell::Nushell,
        cmd,
        name,
    );
}

#[test]
fn special_commands() {
    let name = "my-app";
    let cmd = common::special_commands_command(name);
    common::assert_matches(
        snapbox::file!["snapshots/special_commands.nu"],
        clap_complete_nushell::Nushell,
        cmd,
        name,
    );
}

#[test]
fn quoting() {
    let name = "my-app";
    let cmd = common::quoting_command(name);
    common::assert_matches(
        snapbox::file!["snapshots/quoting.nu"],
        clap_complete_nushell::Nushell,
        cmd,
        name,
    );
}

#[test]
fn aliases() {
    let name = "my-app";
    let cmd = common::aliases_command(name);
    common::assert_matches(
        snapbox::file!["snapshots/aliases.nu"],
        clap_complete_nushell::Nushell,
        cmd,
        name,
    );
}

#[test]
fn sub_subcommands() {
    let name = "my-app";
    let cmd = common::sub_subcommands_command(name);
    common::assert_matches(
        snapbox::file!["snapshots/sub_subcommands.nu"],
        clap_complete_nushell::Nushell,
        cmd,
        name,
    );
}

#[test]
fn value_hint() {
    let name = "my-app";
    let cmd = common::value_hint_command(name);
    common::assert_matches(
        snapbox::file!["snapshots/value_hint.nu"],
        clap_complete_nushell::Nushell,
        cmd,
        name,
    );
}

```

`clap/clap_complete_nushell/tests/snapshots/aliases.nu`:

```nu
module completions {

  # testing nushell completions
  export extern my-app [
    --flag(-f)                # cmd flag
    --flg                     # cmd flag
    -F                        # cmd flag
    --option(-o): string      # cmd option
    --opt: string             # cmd option
    -O: string                # cmd option
    positional?: string
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

}

export use completions *

```

`clap/clap_complete_nushell/tests/snapshots/basic.nu`:

```nu
module completions {

  export extern my-app [
    -c
    -v
    --help(-h)                # Print help
  ]

  # Subcommand with a second line
  export extern "my-app test" [
    -d
    -c
    --help(-h)                # Print help
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help" [
  ]

  # Subcommand with a second line
  export extern "my-app help test" [
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help help" [
  ]

}

export use completions *

```

`clap/clap_complete_nushell/tests/snapshots/feature_sample.nu`:

```nu
module completions {

  def "nu-complete my-app choice" [] {
    [ "first" "second" ]
  }

  # Tests completions
  export extern my-app [
    file?: path               # some input file
    --config(-c)              # some config file with another line
    --conf                    # some config file with another line
    -C                        # some config file with another line
    choice?: string@"nu-complete my-app choice"
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  # tests things
  export extern "my-app test" [
    --case: string            # the case to test
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help" [
  ]

  # tests things
  export extern "my-app help test" [
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help help" [
  ]

}

export use completions *

```

`clap/clap_complete_nushell/tests/snapshots/quoting.nu`:

```nu
module completions {

  export extern my-app [
    --single-quotes           # Can be 'always', 'auto', or 'never'
    --double-quotes           # Can be "always", "auto", or "never"
    --backticks               # For more information see `echo test`
    --backslash               # Avoid '\n'
    --brackets                # List packages [filter]
    --expansions              # Execute the shell command with $SHELL
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  # Can be 'always', 'auto', or 'never'
  export extern "my-app cmd-single-quotes" [
    --help(-h)                # Print help
  ]

  # Can be "always", "auto", or "never"
  export extern "my-app cmd-double-quotes" [
    --help(-h)                # Print help
  ]

  # For more information see `echo test`
  export extern "my-app cmd-backticks" [
    --help(-h)                # Print help
  ]

  # Avoid '\n'
  export extern "my-app cmd-backslash" [
    --help(-h)                # Print help
  ]

  # List packages [filter]
  export extern "my-app cmd-brackets" [
    --help(-h)                # Print help
  ]

  # Execute the shell command with $SHELL
  export extern "my-app cmd-expansions" [
    --help(-h)                # Print help
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help" [
  ]

  # Can be 'always', 'auto', or 'never'
  export extern "my-app help cmd-single-quotes" [
  ]

  # Can be "always", "auto", or "never"
  export extern "my-app help cmd-double-quotes" [
  ]

  # For more information see `echo test`
  export extern "my-app help cmd-backticks" [
  ]

  # Avoid '\n'
  export extern "my-app help cmd-backslash" [
  ]

  # List packages [filter]
  export extern "my-app help cmd-brackets" [
  ]

  # Execute the shell command with $SHELL
  export extern "my-app help cmd-expansions" [
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help help" [
  ]

}

export use completions *

```

`clap/clap_complete_nushell/tests/snapshots/special_commands.nu`:

```nu
module completions {

  def "nu-complete my-app choice" [] {
    [ "first" "second" ]
  }

  # Tests completions
  export extern my-app [
    file?: path               # some input file
    --config(-c)              # some config file with another line
    --conf                    # some config file with another line
    -C                        # some config file with another line
    choice?: string@"nu-complete my-app choice"
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  # tests things
  export extern "my-app test" [
    --case: string            # the case to test
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  # tests other things
  export extern "my-app some_cmd" [
    --config: string          # the other case to test
    ...path: string
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  export extern "my-app some-cmd-with-hyphens" [
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  export extern "my-app some-hidden-cmd" [
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help" [
  ]

  # tests things
  export extern "my-app help test" [
  ]

  # tests other things
  export extern "my-app help some_cmd" [
  ]

  export extern "my-app help some-cmd-with-hyphens" [
  ]

  export extern "my-app help some-hidden-cmd" [
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help help" [
  ]

}

export use completions *

```

`clap/clap_complete_nushell/tests/snapshots/sub_subcommands.nu`:

```nu
module completions {

  def "nu-complete my-app choice" [] {
    [ "first" "second" ]
  }

  # Tests completions
  export extern my-app [
    file?: path               # some input file
    --config(-c)              # some config file with another line
    --conf                    # some config file with another line
    -C                        # some config file with another line
    choice?: string@"nu-complete my-app choice"
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  # tests things
  export extern "my-app test" [
    --case: string            # the case to test
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  # top level subcommand
  export extern "my-app some_cmd" [
    --help(-h)                # Print help
    --version(-V)             # Print version
  ]

  def "nu-complete my-app some_cmd sub_cmd config" [] {
    [ "\"Lest quotes, aren't escaped.\"" "\"Second to trigger display of options\"" ]
  }

  # sub-subcommand
  export extern "my-app some_cmd sub_cmd" [
    --config: string@"nu-complete my-app some_cmd sub_cmd config" # the other case to test
    --help(-h)                # Print help (see more with '--help')
    --version(-V)             # Print version
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app some_cmd help" [
  ]

  # sub-subcommand
  export extern "my-app some_cmd help sub_cmd" [
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app some_cmd help help" [
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help" [
  ]

  # tests things
  export extern "my-app help test" [
  ]

  # top level subcommand
  export extern "my-app help some_cmd" [
  ]

  # sub-subcommand
  export extern "my-app help some_cmd sub_cmd" [
  ]

  # Print this message or the help of the given subcommand(s)
  export extern "my-app help help" [
  ]

}

export use completions *

```

`clap/clap_complete_nushell/tests/snapshots/value_hint.nu`:

```nu
module completions {

  def "nu-complete my-app choice" [] {
    [ "bash" "fish" "zsh" ]
  }

  export extern my-app [
    --choice: string@"nu-complete my-app choice"
    --unknown: string
    --other: string
    --path(-p): path
    --file(-f): path
    --dir(-d): path
    --exe(-e): path
    --cmd-name: string
    --cmd(-c): string
    command_with_args?: string
    --user(-u): string
    --host(-H): string
    --url: string
    --email: string
    --help(-h)                # Print help
  ]

}

export use completions *

```

`clap/clap_derive/CONTRIBUTING.md`:

```md
# How to Contribute

See the [clap-wide CONTRIBUTING.md](../CONTRIBUTING.md).  This will contain `clap_derive` specific notes.

## Derive Gotchas

- Always prefix generated variables with `__clap_` to minimize clashes with the user's variables, see [#2934](https://github.com/clap-rs/clap/issues/2934).
- Prefer the path `clap` over `::clap` to allow users to re-export clap, see [#2258](https://github.com/clap-rs/clap/pull/2258).
- Prefer substituting variable names to avoid problems with `macro_rules`, see [#2823](https://github.com/clap-rs/clap/pull/2823).
- Prefer `::std::result::Result` and `::std::option::Option`, see [#3092](https://github.com/clap-rs/clap/pull/3092).
- Put whitespace between `#quoted #variables`.
- New "magic" attributes must be documented in the [derive reference](../src/_derive.rs)
  - If there is no related builder method, a `#![doc(alias = "")]` should also be added, see [#4984](https://github.com/clap-rs/clap/pull/4984)

```

`clap/clap_derive/Cargo.toml`:

```toml
[package]
name = "clap_derive"
version = "4.5.32"
description = "Parse command line argument by defining a struct, derive crate."
categories = ["command-line-interface", "development-tools::procedural-macro-helpers"]
keywords = [
  "clap",
  "cli",
  "parse",
  "derive",
  "proc_macro"
]
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
include.workspace = true

[package.metadata.docs.rs]
targets = ["x86_64-unknown-linux-gnu"]

[package.metadata.release]
shared-version = true
dependent-version = "upgrade"
tag-name = "v{{version}}"

[lib]
proc-macro = true
bench = false

[dependencies]
syn = { version = "2.0.8", features = ["full"] }
quote = "1.0.9"
proc-macro2 = "1.0.69"
heck = "0.5.0"
pulldown-cmark = { version = "0.13.0", default-features = false, optional = true}
anstyle = {version ="1.0.10", optional = true}

[features]
default = []
debug = []
unstable-v5 = ["deprecated"]
deprecated = []
raw-deprecated = ["deprecated"]
unstable-markdown = ["dep:pulldown-cmark", "dep:anstyle"]

[lints]
workspace = true

```

`clap/clap_derive/LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`clap/clap_derive/LICENSE-MIT`:

```
The MIT License (MIT)

Copyright (c) 2015-2022 Kevin B. Knapp and Clap Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`clap/clap_derive/README.md`:

```md
# `clap_derive`

Macro implementation for clap's derives.

[docs.rs](https://docs.rs/clap)
- [Derive Tutorial](https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html)
- [Derive Reference](https://docs.rs/clap/latest/clap/_derive/index.html)

## License

Licensed under either of

- Apache License, Version 2.0 ([LICENSE-APACHE](LICENSE-APACHE) or <https://www.apache.org/licenses/LICENSE-2.0>)
- MIT license ([LICENSE-MIT](LICENSE-MIT) or <https://opensource.org/licenses/MIT>)

at your option.

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in the work by you, as defined in the Apache-2.0 license, shall be
dual licensed as above, without any additional terms or conditions.

See [CONTRIBUTING](CONTRIBUTING.md) for more details.

```

`clap/clap_derive/src/attr.rs`:

```rs
use std::iter::FromIterator;

use proc_macro2::TokenStream;
use quote::quote;
use quote::ToTokens;
use syn::spanned::Spanned;
use syn::{
    parenthesized,
    parse::{Parse, ParseStream},
    punctuated::Punctuated,
    Attribute, Expr, Ident, LitStr, Token,
};

use crate::utils::Sp;

#[derive(Clone)]
pub(crate) struct ClapAttr {
    pub(crate) kind: Sp<AttrKind>,
    pub(crate) name: Ident,
    pub(crate) magic: Option<MagicAttrName>,
    pub(crate) value: Option<AttrValue>,
}

impl ClapAttr {
    pub(crate) fn parse_all(all_attrs: &[Attribute]) -> Result<Vec<Self>, syn::Error> {
        let mut parsed = Vec::new();
        for attr in all_attrs {
            let kind = if attr.path().is_ident("clap") {
                Sp::new(AttrKind::Clap, attr.path().span())
            } else if attr.path().is_ident("structopt") {
                Sp::new(AttrKind::StructOpt, attr.path().span())
            } else if attr.path().is_ident("command") {
                Sp::new(AttrKind::Command, attr.path().span())
            } else if attr.path().is_ident("group") {
                Sp::new(AttrKind::Group, attr.path().span())
            } else if attr.path().is_ident("arg") {
                Sp::new(AttrKind::Arg, attr.path().span())
            } else if attr.path().is_ident("value") {
                Sp::new(AttrKind::Value, attr.path().span())
            } else {
                continue;
            };
            for mut attr in
                attr.parse_args_with(Punctuated::<ClapAttr, Token![,]>::parse_terminated)?
            {
                attr.kind = kind;
                parsed.push(attr);
            }
        }
        Ok(parsed)
    }

    pub(crate) fn value_or_abort(&self) -> Result<&AttrValue, syn::Error> {
        self.value
            .as_ref()
            .ok_or_else(|| format_err!(self.name, "attribute `{}` requires a value", self.name))
    }

    pub(crate) fn lit_str_or_abort(&self) -> Result<&LitStr, syn::Error> {
        let value = self.value_or_abort()?;
        match value {
            AttrValue::LitStr(tokens) => Ok(tokens),
            AttrValue::Expr(_) | AttrValue::Call(_) => {
                abort!(
                    self.name,
                    "attribute `{}` can only accept string literals",
                    self.name
                )
            }
        }
    }
}

impl Parse for ClapAttr {
    fn parse(input: ParseStream<'_>) -> syn::Result<Self> {
        let name: Ident = input.parse()?;
        let name_str = name.to_string();

        let magic = match name_str.as_str() {
            "rename_all" => Some(MagicAttrName::RenameAll),
            "rename_all_env" => Some(MagicAttrName::RenameAllEnv),
            "skip" => Some(MagicAttrName::Skip),
            "next_display_order" => Some(MagicAttrName::NextDisplayOrder),
            "next_help_heading" => Some(MagicAttrName::NextHelpHeading),
            "default_value_t" => Some(MagicAttrName::DefaultValueT),
            "default_values_t" => Some(MagicAttrName::DefaultValuesT),
            "default_value_os_t" => Some(MagicAttrName::DefaultValueOsT),
            "default_values_os_t" => Some(MagicAttrName::DefaultValuesOsT),
            "long" => Some(MagicAttrName::Long),
            "short" => Some(MagicAttrName::Short),
            "value_parser" => Some(MagicAttrName::ValueParser),
            "action" => Some(MagicAttrName::Action),
            "env" => Some(MagicAttrName::Env),
            "flatten" => Some(MagicAttrName::Flatten),
            "value_enum" => Some(MagicAttrName::ValueEnum),
            "from_global" => Some(MagicAttrName::FromGlobal),
            "subcommand" => Some(MagicAttrName::Subcommand),
            "external_subcommand" => Some(MagicAttrName::ExternalSubcommand),
            "verbatim_doc_comment" => Some(MagicAttrName::VerbatimDocComment),
            "about" => Some(MagicAttrName::About),
            "long_about" => Some(MagicAttrName::LongAbout),
            "long_help" => Some(MagicAttrName::LongHelp),
            "author" => Some(MagicAttrName::Author),
            "version" => Some(MagicAttrName::Version),
            _ => None,
        };

        let value = if input.peek(Token![=]) {
            // `name = value` attributes.
            let assign_token = input.parse::<Token![=]>()?; // skip '='
            if input.peek(LitStr) {
                let lit: LitStr = input.parse()?;
                Some(AttrValue::LitStr(lit))
            } else {
                match input.parse::<Expr>() {
                    Ok(expr) => Some(AttrValue::Expr(expr)),

                    Err(_) => abort! {
                        assign_token,
                        "expected `string literal` or `expression` after `=`"
                    },
                }
            }
        } else if input.peek(syn::token::Paren) {
            // `name(...)` attributes.
            let nested;
            parenthesized!(nested in input);

            let method_args: Punctuated<_, _> = nested.parse_terminated(Expr::parse, Token![,])?;
            Some(AttrValue::Call(Vec::from_iter(method_args)))
        } else {
            None
        };

        Ok(Self {
            kind: Sp::new(AttrKind::Clap, name.span()),
            name,
            magic,
            value,
        })
    }
}

#[derive(Copy, Clone, PartialEq, Eq)]
pub(crate) enum MagicAttrName {
    Short,
    Long,
    ValueParser,
    Action,
    Env,
    Flatten,
    ValueEnum,
    FromGlobal,
    Subcommand,
    VerbatimDocComment,
    ExternalSubcommand,
    About,
    LongAbout,
    LongHelp,
    Author,
    Version,
    RenameAllEnv,
    RenameAll,
    Skip,
    DefaultValueT,
    DefaultValuesT,
    DefaultValueOsT,
    DefaultValuesOsT,
    NextDisplayOrder,
    NextHelpHeading,
}

#[derive(Clone)]
#[allow(clippy::large_enum_variant)]
pub(crate) enum AttrValue {
    LitStr(LitStr),
    Expr(Expr),
    Call(Vec<Expr>),
}

impl ToTokens for AttrValue {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            Self::LitStr(t) => t.to_tokens(tokens),
            Self::Expr(t) => t.to_tokens(tokens),
            Self::Call(t) => {
                let t = quote!(#(#t),*);
                t.to_tokens(tokens);
            }
        }
    }
}

#[derive(Copy, Clone, PartialEq, Eq)]
pub(crate) enum AttrKind {
    Clap,
    StructOpt,
    Command,
    Group,
    Arg,
    Value,
}

impl AttrKind {
    pub(crate) fn as_str(&self) -> &'static str {
        match self {
            Self::Clap => "clap",
            Self::StructOpt => "structopt",
            Self::Command => "command",
            Self::Group => "group",
            Self::Arg => "arg",
            Self::Value => "value",
        }
    }
}

```

`clap/clap_derive/src/derives/args.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use proc_macro2::{Ident, Span, TokenStream};
use quote::{format_ident, quote, quote_spanned};
use syn::{
    punctuated::Punctuated, spanned::Spanned, token::Comma, Data, DataStruct, DeriveInput, Field,
    Fields, FieldsNamed, Generics,
};

use crate::item::{Item, Kind, Name};
use crate::utils::{inner_type, sub_type, Sp, Ty};

pub(crate) fn derive_args(input: &DeriveInput) -> Result<TokenStream, syn::Error> {
    let ident = &input.ident;

    match input.data {
        Data::Struct(DataStruct {
            fields: Fields::Named(ref fields),
            ..
        }) => {
            let name = Name::Derived(ident.clone());
            let item = Item::from_args_struct(input, name)?;
            let fields = collect_args_fields(&item, fields)?;
            gen_for_struct(&item, ident, &input.generics, &fields)
        }
        Data::Struct(DataStruct {
            fields: Fields::Unit,
            ..
        }) => {
            let name = Name::Derived(ident.clone());
            let item = Item::from_args_struct(input, name)?;
            let fields = Punctuated::<Field, Comma>::new();
            let fields = fields
                .iter()
                .map(|field| {
                    let item = Item::from_args_field(field, item.casing(), item.env_casing())?;
                    Ok((field, item))
                })
                .collect::<Result<Vec<_>, syn::Error>>()?;
            gen_for_struct(&item, ident, &input.generics, &fields)
        }
        _ => abort_call_site!("`#[derive(Args)]` only supports non-tuple structs"),
    }
}

pub(crate) fn gen_for_struct(
    item: &Item,
    item_name: &Ident,
    generics: &Generics,
    fields: &[(&Field, Item)],
) -> Result<TokenStream, syn::Error> {
    if !matches!(&*item.kind(), Kind::Command(_)) {
        abort! { item.kind().span(),
            "`{}` cannot be used with `command`",
            item.kind().name(),
        }
    }

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let constructor = gen_constructor(fields)?;
    let updater = gen_updater(fields, true)?;
    let raw_deprecated = raw_deprecated();

    let app_var = Ident::new("__clap_app", Span::call_site());
    let augmentation = gen_augment(fields, &app_var, item, false)?;
    let augmentation_update = gen_augment(fields, &app_var, item, true)?;

    let group_id = if item.skip_group() {
        quote!(None)
    } else {
        let group_id = item.group_id();
        quote!(Some(clap::Id::from(#group_id)))
    };

    Ok(quote! {
        #[allow(
            dead_code,
            unreachable_code,
            unused_variables,
            unused_braces,
            unused_qualifications,
        )]
        #[allow(
            clippy::style,
            clippy::complexity,
            clippy::pedantic,
            clippy::restriction,
            clippy::perf,
            clippy::deprecated,
            clippy::nursery,
            clippy::cargo,
            clippy::suspicious_else_formatting,
            clippy::almost_swapped,
            clippy::redundant_locals,
        )]
        #[automatically_derived]
        impl #impl_generics clap::FromArgMatches for #item_name #ty_generics #where_clause {
            fn from_arg_matches(__clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
                Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
            }

            fn from_arg_matches_mut(__clap_arg_matches: &mut clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
                #raw_deprecated
                let v = #item_name #constructor;
                ::std::result::Result::Ok(v)
            }

            fn update_from_arg_matches(&mut self, __clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<(), clap::Error> {
                self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
            }

            fn update_from_arg_matches_mut(&mut self, __clap_arg_matches: &mut clap::ArgMatches) -> ::std::result::Result<(), clap::Error> {
                #raw_deprecated
                #updater
                ::std::result::Result::Ok(())
            }
        }

        #[allow(
            dead_code,
            unreachable_code,
            unused_variables,
            unused_braces,
            unused_qualifications,
        )]
        #[allow(
            clippy::style,
            clippy::complexity,
            clippy::pedantic,
            clippy::restriction,
            clippy::perf,
            clippy::deprecated,
            clippy::nursery,
            clippy::cargo,
            clippy::suspicious_else_formatting,
            clippy::almost_swapped,
            clippy::redundant_locals,
        )]
        #[automatically_derived]
        impl #impl_generics clap::Args for #item_name #ty_generics #where_clause {
            fn group_id() -> Option<clap::Id> {
                #group_id
            }
            fn augment_args<'b>(#app_var: clap::Command) -> clap::Command {
                #augmentation
            }
            fn augment_args_for_update<'b>(#app_var: clap::Command) -> clap::Command {
                #augmentation_update
            }
        }
    })
}

/// Generate a block of code to add arguments/subcommands corresponding to
/// the `fields` to an cmd.
pub(crate) fn gen_augment(
    fields: &[(&Field, Item)],
    app_var: &Ident,
    parent_item: &Item,
    override_required: bool,
) -> Result<TokenStream, syn::Error> {
    let mut subcommand_specified = false;
    let mut args = Vec::new();
    for (field, item) in fields {
        let kind = item.kind();
        let genned = match &*kind {
            Kind::Command(_)
            | Kind::Value
            | Kind::Skip(_, _)
            | Kind::FromGlobal(_)
            | Kind::ExternalSubcommand => None,
            Kind::Subcommand(ty) => {
                if subcommand_specified {
                    abort!(
                        field.span(),
                        "`#[command(subcommand)]` can only be used once per container"
                    );
                }
                subcommand_specified = true;

                let subcmd_type = match (**ty, sub_type(&field.ty)) {
                    (Ty::Option, Some(sub_type)) => sub_type,
                    _ => &field.ty,
                };
                let implicit_methods = if **ty == Ty::Option {
                    quote!()
                } else {
                    quote_spanned! { kind.span()=>
                        .subcommand_required(true)
                        .arg_required_else_help(true)
                    }
                };

                let override_methods = if override_required {
                    quote_spanned! { kind.span()=>
                        .subcommand_required(false)
                        .arg_required_else_help(false)
                    }
                } else {
                    quote!()
                };

                Some(quote! {
                    let #app_var = <#subcmd_type as clap::Subcommand>::augment_subcommands( #app_var );
                    let #app_var = #app_var
                        #implicit_methods
                        #override_methods;
                })
            }
            Kind::Flatten(ty) => {
                let inner_type = match (**ty, sub_type(&field.ty)) {
                    (Ty::Option, Some(sub_type)) => sub_type,
                    _ => &field.ty,
                };

                let next_help_heading = item.next_help_heading();
                let next_display_order = item.next_display_order();
                let flatten_group_assert = if matches!(**ty, Ty::Option) {
                    quote_spanned! { kind.span()=>
                        <#inner_type as clap::Args>::group_id().expect("cannot `#[flatten]` an `Option<Args>` with `#[group(skip)]`");
                    }
                } else {
                    quote! {}
                };
                if override_required {
                    Some(quote_spanned! { kind.span()=>
                        #flatten_group_assert
                        let #app_var = #app_var
                            #next_help_heading
                            #next_display_order;
                        let #app_var = <#inner_type as clap::Args>::augment_args_for_update(#app_var);
                    })
                } else {
                    Some(quote_spanned! { kind.span()=>
                        #flatten_group_assert
                        let #app_var = #app_var
                            #next_help_heading
                            #next_display_order;
                        let #app_var = <#inner_type as clap::Args>::augment_args(#app_var);
                    })
                }
            }
            Kind::Arg(ty) => {
                let value_parser = item.value_parser(&field.ty);
                let action = item.action(&field.ty);
                let value_name = item.value_name();

                let implicit_methods = match **ty {
                    Ty::Unit => {
                        // Leaving out `value_parser` as it will always fail
                        quote_spanned! { ty.span()=>
                            .value_name(#value_name)
                            #action
                        }
                    }
                    Ty::Option => {
                        quote_spanned! { ty.span()=>
                            .value_name(#value_name)
                            #value_parser
                            #action
                        }
                    }

                    Ty::OptionOption => quote_spanned! { ty.span()=>
                        .value_name(#value_name)
                        .num_args(0..=1)
                        #value_parser
                        #action
                    },

                    Ty::OptionVec => {
                        if item.is_positional() {
                            quote_spanned! { ty.span()=>
                                .value_name(#value_name)
                                .num_args(1..)  // action won't be sufficient for getting multiple
                                #value_parser
                                #action
                            }
                        } else {
                            quote_spanned! { ty.span()=>
                                .value_name(#value_name)
                                #value_parser
                                #action
                            }
                        }
                    }

                    Ty::Vec => {
                        if item.is_positional() {
                            quote_spanned! { ty.span()=>
                                .value_name(#value_name)
                                .num_args(1..)  // action won't be sufficient for getting multiple
                                #value_parser
                                #action
                            }
                        } else {
                            quote_spanned! { ty.span()=>
                                .value_name(#value_name)
                                #value_parser
                                #action
                            }
                        }
                    }

                    Ty::VecVec | Ty::OptionVecVec => {
                        quote_spanned! { ty.span() =>
                            .value_name(#value_name)
                            #value_parser
                            #action
                        }
                    }

                    Ty::Other => {
                        let required = item.find_default_method().is_none();
                        // `ArgAction::takes_values` is assuming `ArgAction::default_value` will be
                        // set though that won't always be true but this should be good enough,
                        // otherwise we'll report an "arg required" error when unwrapping.
                        let action_value = action.args();
                        quote_spanned! { ty.span()=>
                            .value_name(#value_name)
                            .required(#required && #action_value.takes_values())
                            #value_parser
                            #action
                        }
                    }
                };

                let id = item.id();
                let explicit_methods = item.field_methods();
                let deprecations = if !override_required {
                    item.deprecations()
                } else {
                    quote!()
                };
                let override_methods = if override_required {
                    quote_spanned! { kind.span()=>
                        .required(false)
                    }
                } else {
                    quote!()
                };

                Some(quote_spanned! { field.span()=>
                    let #app_var = #app_var.arg({
                        #deprecations

                        #[allow(deprecated)]
                        let arg = clap::Arg::new(#id)
                            #implicit_methods;

                        let arg = arg
                            #explicit_methods;

                        let arg = arg
                            #override_methods;

                        arg
                    });
                })
            }
        };
        args.push(genned);
    }

    let deprecations = if !override_required {
        parent_item.deprecations()
    } else {
        quote!()
    };
    let initial_app_methods = parent_item.initial_top_level_methods();
    let final_app_methods = parent_item.final_top_level_methods();
    let group_app_methods = if parent_item.skip_group() {
        quote!()
    } else {
        let group_id = parent_item.group_id();
        let literal_group_members = fields
            .iter()
            .filter_map(|(_field, item)| {
                let kind = item.kind();
                if matches!(*kind, Kind::Arg(_)) {
                    Some(item.id())
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();
        let literal_group_members_len = literal_group_members.len();
        let mut literal_group_members = quote! {{
            let members: [clap::Id; #literal_group_members_len] = [#( clap::Id::from(#literal_group_members) ),* ];
            members
        }};
        // HACK: Validation isn't ready yet for nested arg groups, so just don't populate the group in
        // that situation
        let possible_group_members_len = fields
            .iter()
            .filter(|(_field, item)| {
                let kind = item.kind();
                matches!(*kind, Kind::Flatten(_))
            })
            .count();
        if 0 < possible_group_members_len {
            literal_group_members = quote! {{
                let members: [clap::Id; 0] = [];
                members
            }};
        }

        let group_methods = parent_item.group_methods();

        quote!(
            .group(
                clap::ArgGroup::new(#group_id)
                    .multiple(true)
                    #group_methods
                    .args(#literal_group_members)
            )
        )
    };
    Ok(quote! {{
        #deprecations
        let #app_var = #app_var
            #initial_app_methods
            #group_app_methods
            ;
        #( #args )*
        #app_var #final_app_methods
    }})
}

pub(crate) fn gen_constructor(fields: &[(&Field, Item)]) -> Result<TokenStream, syn::Error> {
    let fields = fields.iter().map(|(field, item)| {
        let field_name = field.ident.as_ref().unwrap();
        let kind = item.kind();
        let arg_matches = format_ident!("__clap_arg_matches");
        let genned = match &*kind {
            Kind::Command(_)
            | Kind::Value
            | Kind::ExternalSubcommand => {
                abort! { kind.span(),
                    "`{}` cannot be used with `arg`",
                    kind.name(),
                }
            }
            Kind::Subcommand(ty) => {
                let subcmd_type = match (**ty, sub_type(&field.ty)) {
                    (Ty::Option, Some(sub_type)) => sub_type,
                    _ => &field.ty,
                };
                match **ty {
                    Ty::Option => {
                        quote_spanned! { kind.span()=>
                            #field_name: {
                                if #arg_matches.subcommand_name().map(<#subcmd_type as clap::Subcommand>::has_subcommand).unwrap_or(false) {
                                    Some(<#subcmd_type as clap::FromArgMatches>::from_arg_matches_mut(#arg_matches)?)
                                } else {
                                    None
                                }
                            }
                        }
                    },
                    Ty::Other => {
                        quote_spanned! { kind.span()=>
                            #field_name: {
                                <#subcmd_type as clap::FromArgMatches>::from_arg_matches_mut(#arg_matches)?
                            }
                        }
                    },
                    Ty::Unit |
                    Ty::Vec |
                    Ty::OptionOption |
                    Ty::OptionVec |
                    Ty::VecVec |
                    Ty::OptionVecVec => {
                        abort!(
                            ty.span(),
                            "{} types are not supported for subcommand",
                            ty.as_str()
                        );
                    }
                }
            }

            Kind::Flatten(ty) => {
                let inner_type = match (**ty, sub_type(&field.ty)) {
                    (Ty::Option, Some(sub_type)) => sub_type,
                    _ => &field.ty,
                };
                match **ty {
                    Ty::Other => {
                        quote_spanned! { kind.span()=>
                            #field_name: <#inner_type as clap::FromArgMatches>::from_arg_matches_mut(#arg_matches)?
                        }
                    },
                    Ty::Option => {
                        quote_spanned! { kind.span()=>
                            #field_name: {
                                let group_id = <#inner_type as clap::Args>::group_id()
                                    .expect("asserted during `Arg` creation");
                                if #arg_matches.contains_id(group_id.as_str()) {
                                    Some(
                                        <#inner_type as clap::FromArgMatches>::from_arg_matches_mut(#arg_matches)?
                                    )
                                } else {
                                    None
                                }
                            }
                        }
                    },
                    Ty::Unit |
                    Ty::Vec |
                    Ty::OptionOption |
                    Ty::OptionVec |
                    Ty::VecVec |
                    Ty::OptionVecVec => {
                        abort!(
                            ty.span(),
                            "{} types are not supported for flatten",
                            ty.as_str()
                        );
                    }
                }
            },

            Kind::Skip(val, _) => match val {
                None => quote_spanned!(kind.span()=> #field_name: Default::default()),
                Some(val) => quote_spanned!(kind.span()=> #field_name: (#val).into()),
            },

            Kind::Arg(ty) | Kind::FromGlobal(ty) => {
                gen_parsers(item, ty, field_name, field, None)?
            }
        };
        Ok(genned)
    }).collect::<Result<Vec<_>, syn::Error>>()?;

    Ok(quote! {{
        #( #fields ),*
    }})
}

pub(crate) fn gen_updater(
    fields: &[(&Field, Item)],
    use_self: bool,
) -> Result<TokenStream, syn::Error> {
    let mut genned_fields = Vec::new();
    for (field, item) in fields {
        let field_name = field.ident.as_ref().unwrap();
        let kind = item.kind();

        let access = if use_self {
            quote! {
                #[allow(non_snake_case)]
                let #field_name = &mut self.#field_name;
            }
        } else {
            quote!()
        };
        let arg_matches = format_ident!("__clap_arg_matches");

        let genned = match &*kind {
            Kind::Command(_) | Kind::Value | Kind::ExternalSubcommand => {
                abort! { kind.span(),
                    "`{}` cannot be used with `arg`",
                    kind.name(),
                }
            }
            Kind::Subcommand(ty) => {
                let subcmd_type = match (**ty, sub_type(&field.ty)) {
                    (Ty::Option, Some(sub_type)) => sub_type,
                    _ => &field.ty,
                };

                let updater = quote_spanned! { ty.span()=>
                    <#subcmd_type as clap::FromArgMatches>::update_from_arg_matches_mut(#field_name, #arg_matches)?;
                };

                let updater = match **ty {
                    Ty::Option => quote_spanned! { kind.span()=>
                        if let Some(#field_name) = #field_name.as_mut() {
                            #updater
                        } else {
                            *#field_name = Some(<#subcmd_type as clap::FromArgMatches>::from_arg_matches_mut(
                                #arg_matches
                            )?);
                        }
                    },
                    _ => quote_spanned! { kind.span()=>
                        #updater
                    },
                };

                quote_spanned! { kind.span()=>
                    {
                        #access
                        #updater
                    }
                }
            }

            Kind::Flatten(ty) => {
                let inner_type = match (**ty, sub_type(&field.ty)) {
                    (Ty::Option, Some(sub_type)) => sub_type,
                    _ => &field.ty,
                };

                let updater = quote_spanned! { ty.span()=>
                    <#inner_type as clap::FromArgMatches>::update_from_arg_matches_mut(#field_name, #arg_matches)?;
                };

                let updater = match **ty {
                    Ty::Option => quote_spanned! { kind.span()=>
                        if let Some(#field_name) = #field_name.as_mut() {
                            #updater
                        } else {
                            *#field_name = Some(<#inner_type as clap::FromArgMatches>::from_arg_matches_mut(
                                #arg_matches
                            )?);
                        }
                    },
                    _ => quote_spanned! { kind.span()=>
                        #updater
                    },
                };

                quote_spanned! { kind.span()=>
                    {
                        #access
                        #updater
                    }
                }
            }

            Kind::Skip(_, _) => quote!(),

            Kind::Arg(ty) | Kind::FromGlobal(ty) => {
                gen_parsers(item, ty, field_name, field, Some(&access))?
            }
        };
        genned_fields.push(genned);
    }

    Ok(quote! {
        #( #genned_fields )*
    })
}

fn gen_parsers(
    item: &Item,
    ty: &Sp<Ty>,
    field_name: &Ident,
    field: &Field,
    update: Option<&TokenStream>,
) -> Result<TokenStream, syn::Error> {
    let span = ty.span();
    let convert_type = inner_type(&field.ty);
    let id = item.id();
    let get_one = quote_spanned!(span=> remove_one::<#convert_type>);
    let get_many = quote_spanned!(span=> remove_many::<#convert_type>);
    let get_occurrences = quote_spanned!(span=> remove_occurrences::<#convert_type>);

    // Give this identifier the same hygiene
    // as the `arg_matches` parameter definition. This
    // allows us to refer to `arg_matches` within a `quote_spanned` block
    let arg_matches = format_ident!("__clap_arg_matches");

    let field_value = match **ty {
        Ty::Unit => {
            quote_spanned! { ty.span()=>
                ()
            }
        }

        Ty::Option => {
            quote_spanned! { ty.span()=>
                #arg_matches.#get_one(#id)
            }
        }

        Ty::OptionOption => quote_spanned! { ty.span()=>
            if #arg_matches.contains_id(#id) {
                Some(
                    #arg_matches.#get_one(#id)
                )
            } else {
                None
            }
        },

        Ty::OptionVec => quote_spanned! { ty.span()=>
            if #arg_matches.contains_id(#id) {
                Some(#arg_matches.#get_many(#id)
                    .map(|v| v.collect::<Vec<_>>())
                    .unwrap_or_else(Vec::new))
            } else {
                None
            }
        },

        Ty::Vec => {
            quote_spanned! { ty.span()=>
                #arg_matches.#get_many(#id)
                    .map(|v| v.collect::<Vec<_>>())
                    .unwrap_or_else(Vec::new)
            }
        }

        Ty::VecVec => quote_spanned! { ty.span()=>
            #arg_matches.#get_occurrences(#id)
                .map(|g| g.map(::std::iter::Iterator::collect).collect::<Vec<Vec<_>>>())
                .unwrap_or_else(Vec::new)
        },

        Ty::OptionVecVec => quote_spanned! { ty.span()=>
            #arg_matches.#get_occurrences(#id)
                .map(|g| g.map(::std::iter::Iterator::collect).collect::<Vec<Vec<_>>>())
        },

        Ty::Other => {
            // Prefer `concat` where possible for reduced code size but fallback to `format!` to
            // allow non-literal `id`s
            match id {
                Name::Assigned(_) => {
                    quote_spanned! { ty.span()=>
                        #arg_matches.#get_one(#id)
                            .ok_or_else(|| clap::Error::raw(clap::error::ErrorKind::MissingRequiredArgument, format!("The following required argument was not provided: {}", #id)))?
                    }
                }
                Name::Derived(_) => {
                    quote_spanned! { ty.span()=>
                        #arg_matches.#get_one(#id)
                            .ok_or_else(|| clap::Error::raw(clap::error::ErrorKind::MissingRequiredArgument, concat!("The following required argument was not provided: ", #id)))?
                    }
                }
            }
        }
    };

    let genned = if let Some(access) = update {
        quote_spanned! { field.span()=>
            if #arg_matches.contains_id(#id) {
                #access
                *#field_name = #field_value
            }
        }
    } else {
        quote_spanned!(field.span()=> #field_name: #field_value )
    };
    Ok(genned)
}

#[cfg(feature = "raw-deprecated")]
pub(crate) fn raw_deprecated() -> TokenStream {
    quote! {}
}

#[cfg(not(feature = "raw-deprecated"))]
pub(crate) fn raw_deprecated() -> TokenStream {
    quote! {
        #![allow(deprecated)]  // Assuming any deprecation in here will be related to a deprecation in `Args`

    }
}

pub(crate) fn collect_args_fields<'a>(
    item: &'a Item,
    fields: &'a FieldsNamed,
) -> Result<Vec<(&'a Field, Item)>, syn::Error> {
    fields
        .named
        .iter()
        .map(|field| {
            let item = Item::from_args_field(field, item.casing(), item.env_casing())?;
            Ok((field, item))
        })
        .collect()
}

```

`clap/clap_derive/src/derives/into_app.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::{Generics, Ident};

use crate::item::Item;

pub(crate) fn gen_for_struct(
    item: &Item,
    item_name: &Ident,
    generics: &Generics,
) -> Result<TokenStream, syn::Error> {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let name = item.cased_name();
    let app_var = Ident::new("__clap_app", Span::call_site());

    let tokens = quote! {
        #[allow(
            dead_code,
            unreachable_code,
            unused_variables,
            unused_braces,
            unused_qualifications,
        )]
        #[allow(
            clippy::style,
            clippy::complexity,
            clippy::pedantic,
            clippy::restriction,
            clippy::perf,
            clippy::deprecated,
            clippy::nursery,
            clippy::cargo,
            clippy::suspicious_else_formatting,
            clippy::almost_swapped,
            clippy::redundant_locals,
        )]
        #[automatically_derived]
        impl #impl_generics clap::CommandFactory for #item_name #ty_generics #where_clause {
            fn command<'b>() -> clap::Command {
                let #app_var = clap::Command::new(#name);
                <Self as clap::Args>::augment_args(#app_var)
            }

            fn command_for_update<'b>() -> clap::Command {
                let #app_var = clap::Command::new(#name);
                <Self as clap::Args>::augment_args_for_update(#app_var)
            }
        }
    };

    Ok(tokens)
}

pub(crate) fn gen_for_enum(
    item: &Item,
    item_name: &Ident,
    generics: &Generics,
) -> Result<TokenStream, syn::Error> {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let name = item.cased_name();
    let app_var = Ident::new("__clap_app", Span::call_site());

    Ok(quote! {
        #[allow(
            dead_code,
            unreachable_code,
            unused_variables,
            unused_braces,
            unused_qualifications,
        )]
        #[allow(
            clippy::style,
            clippy::complexity,
            clippy::pedantic,
            clippy::restriction,
            clippy::perf,
            clippy::deprecated,
            clippy::nursery,
            clippy::cargo,
            clippy::suspicious_else_formatting,
            clippy::almost_swapped,
            clippy::redundant_locals,
        )]
        #[automatically_derived]
        impl #impl_generics clap::CommandFactory for #item_name #ty_generics #where_clause {
            fn command<'b>() -> clap::Command {
                let #app_var = clap::Command::new(#name)
                    .subcommand_required(true)
                    .arg_required_else_help(true);
                <Self as clap::Subcommand>::augment_subcommands(#app_var)
            }

            fn command_for_update<'b>() -> clap::Command {
                let #app_var = clap::Command::new(#name);
                <Self as clap::Subcommand>::augment_subcommands_for_update(#app_var)
                    .subcommand_required(false)
                    .arg_required_else_help(false)
            }
        }
    })
}

```

`clap/clap_derive/src/derives/mod.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.
mod args;
mod into_app;
mod parser;
mod subcommand;
mod value_enum;

pub(crate) use self::parser::derive_parser;
pub(crate) use args::derive_args;
pub(crate) use subcommand::derive_subcommand;
pub(crate) use value_enum::derive_value_enum;

```

`clap/clap_derive/src/derives/parser.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use proc_macro2::TokenStream;
use quote::quote;
use syn::Ident;
use syn::Variant;
use syn::{
    self, punctuated::Punctuated, token::Comma, Data, DataStruct, DeriveInput, Field, Fields,
    Generics,
};

use crate::derives::args::collect_args_fields;
use crate::derives::{args, into_app, subcommand};
use crate::item::Item;
use crate::item::Name;

pub(crate) fn derive_parser(input: &DeriveInput) -> Result<TokenStream, syn::Error> {
    let ident = &input.ident;
    let pkg_name = std::env::var("CARGO_PKG_NAME").ok().unwrap_or_default();

    match input.data {
        Data::Struct(DataStruct {
            fields: Fields::Named(ref fields),
            ..
        }) => {
            let name = Name::Assigned(quote!(#pkg_name));
            let item = Item::from_args_struct(input, name)?;
            let fields = collect_args_fields(&item, fields)?;
            gen_for_struct(&item, ident, &input.generics, &fields)
        }
        Data::Struct(DataStruct {
            fields: Fields::Unit,
            ..
        }) => {
            let name = Name::Assigned(quote!(#pkg_name));
            let item = Item::from_args_struct(input, name)?;
            let fields = Punctuated::<Field, Comma>::new();
            let fields = fields
                .iter()
                .map(|field| {
                    let item = Item::from_args_field(field, item.casing(), item.env_casing())?;
                    Ok((field, item))
                })
                .collect::<Result<Vec<_>, syn::Error>>()?;
            gen_for_struct(&item, ident, &input.generics, &fields)
        }
        Data::Enum(ref e) => {
            let name = Name::Assigned(quote!(#pkg_name));
            let item = Item::from_subcommand_enum(input, name)?;
            let variants = e
                .variants
                .iter()
                .map(|variant| {
                    let item =
                        Item::from_subcommand_variant(variant, item.casing(), item.env_casing())?;
                    Ok((variant, item))
                })
                .collect::<Result<Vec<_>, syn::Error>>()?;
            gen_for_enum(&item, ident, &input.generics, &variants)
        }
        _ => abort_call_site!("`#[derive(Parser)]` only supports non-tuple structs and enums"),
    }
}

fn gen_for_struct(
    item: &Item,
    item_name: &Ident,
    generics: &Generics,
    fields: &[(&Field, Item)],
) -> Result<TokenStream, syn::Error> {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let into_app = into_app::gen_for_struct(item, item_name, generics)?;
    let args = args::gen_for_struct(item, item_name, generics, fields)?;

    Ok(quote! {
        #[automatically_derived]
        #[allow(
            unused_qualifications,
            clippy::redundant_locals,
        )]
        impl #impl_generics clap::Parser for #item_name #ty_generics #where_clause {}

        #into_app
        #args
    })
}

fn gen_for_enum(
    item: &Item,
    item_name: &Ident,
    generics: &Generics,
    variants: &[(&Variant, Item)],
) -> Result<TokenStream, syn::Error> {
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let into_app = into_app::gen_for_enum(item, item_name, generics)?;
    let subcommand = subcommand::gen_for_enum(item, item_name, generics, variants)?;

    Ok(quote! {
        #[automatically_derived]
        impl #impl_generics clap::Parser for #item_name #ty_generics #where_clause {}

        #into_app
        #subcommand
    })
}

```

`clap/clap_derive/src/derives/subcommand.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use proc_macro2::{Ident, Span, TokenStream};
use quote::{format_ident, quote, quote_spanned};
use syn::{spanned::Spanned, Data, DeriveInput, FieldsUnnamed, Generics, Variant};

use crate::derives::args;
use crate::derives::args::collect_args_fields;
use crate::item::{Item, Kind, Name};
use crate::utils::{is_simple_ty, subty_if_name};

pub(crate) fn derive_subcommand(input: &DeriveInput) -> Result<TokenStream, syn::Error> {
    let ident = &input.ident;

    match input.data {
        Data::Enum(ref e) => {
            let name = Name::Derived(ident.clone());
            let item = Item::from_subcommand_enum(input, name)?;
            let variants = e
                .variants
                .iter()
                .map(|variant| {
                    let item =
                        Item::from_subcommand_variant(variant, item.casing(), item.env_casing())?;
                    Ok((variant, item))
                })
                .collect::<Result<Vec<_>, syn::Error>>()?;
            gen_for_enum(&item, ident, &input.generics, &variants)
        }
        _ => abort_call_site!("`#[derive(Subcommand)]` only supports enums"),
    }
}

pub(crate) fn gen_for_enum(
    item: &Item,
    item_name: &Ident,
    generics: &Generics,
    variants: &[(&Variant, Item)],
) -> Result<TokenStream, syn::Error> {
    if !matches!(&*item.kind(), Kind::Command(_)) {
        abort! { item.kind().span(),
            "`{}` cannot be used with `command`",
            item.kind().name(),
        }
    }

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    let from_arg_matches = gen_from_arg_matches(variants)?;
    let update_from_arg_matches = gen_update_from_arg_matches(variants)?;

    let augmentation = gen_augment(variants, item, false)?;
    let augmentation_update = gen_augment(variants, item, true)?;
    let has_subcommand = gen_has_subcommand(variants)?;

    Ok(quote! {
        #[allow(
            dead_code,
            unreachable_code,
            unused_variables,
            unused_braces,
            unused_qualifications,
        )]
        #[allow(
            clippy::style,
            clippy::complexity,
            clippy::pedantic,
            clippy::restriction,
            clippy::perf,
            clippy::deprecated,
            clippy::nursery,
            clippy::cargo,
            clippy::suspicious_else_formatting,
            clippy::almost_swapped,
            clippy::redundant_locals,
        )]
        #[automatically_derived]
        impl #impl_generics clap::FromArgMatches for #item_name #ty_generics #where_clause {
            fn from_arg_matches(__clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
                Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
            }

            #from_arg_matches

            fn update_from_arg_matches(&mut self, __clap_arg_matches: &clap::ArgMatches) -> ::std::result::Result<(), clap::Error> {
                self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
            }
            #update_from_arg_matches
        }

        #[allow(
            dead_code,
            unreachable_code,
            unused_variables,
            unused_braces,
            unused_qualifications,
        )]
        #[allow(
            clippy::style,
            clippy::complexity,
            clippy::pedantic,
            clippy::restriction,
            clippy::perf,
            clippy::deprecated,
            clippy::nursery,
            clippy::cargo,
            clippy::suspicious_else_formatting,
            clippy::almost_swapped,
            clippy::redundant_locals,
        )]
        #[automatically_derived]
        impl #impl_generics clap::Subcommand for #item_name #ty_generics #where_clause {
            fn augment_subcommands <'b>(__clap_app: clap::Command) -> clap::Command {
                #augmentation
            }
            fn augment_subcommands_for_update <'b>(__clap_app: clap::Command) -> clap::Command {
                #augmentation_update
            }
            fn has_subcommand(__clap_name: &str) -> bool {
                #has_subcommand
            }
        }
    })
}

fn gen_augment(
    variants: &[(&Variant, Item)],
    parent_item: &Item,
    override_required: bool,
) -> Result<TokenStream, syn::Error> {
    use syn::Fields::{Named, Unit, Unnamed};

    let app_var = Ident::new("__clap_app", Span::call_site());

    let mut subcommands = Vec::new();
    for (variant, item) in variants {
        let kind = item.kind();

        let genned = match &*kind {
            Kind::Skip(_, _) | Kind::Arg(_) | Kind::FromGlobal(_) | Kind::Value => None,

            Kind::ExternalSubcommand => {
                let ty = match variant.fields {
                    Unnamed(ref fields) if fields.unnamed.len() == 1 => &fields.unnamed[0].ty,

                    _ => abort!(
                        variant,
                        "The enum variant marked with `external_subcommand` must be \
                             a single-typed tuple, and the type must be either `Vec<String>` \
                             or `Vec<OsString>`."
                    ),
                };
                let deprecations = if !override_required {
                    item.deprecations()
                } else {
                    quote!()
                };
                let subty = subty_if_name(ty, "Vec").ok_or_else(|| {
                    format_err!(
                        ty.span(),
                        "The type must be `Vec<_>` \
                             to be used with `external_subcommand`."
                    )
                })?;
                let subcommand = quote_spanned! { kind.span()=>
                    #deprecations
                    let #app_var = #app_var
                        .external_subcommand_value_parser(clap::value_parser!(#subty));
                };
                Some(subcommand)
            }

            Kind::Flatten(_) => match variant.fields {
                Unnamed(FieldsUnnamed { ref unnamed, .. }) if unnamed.len() == 1 => {
                    let ty = &unnamed[0].ty;
                    let deprecations = if !override_required {
                        item.deprecations()
                    } else {
                        quote!()
                    };
                    let next_help_heading = item.next_help_heading();
                    let next_display_order = item.next_display_order();
                    let subcommand = if override_required {
                        quote! {
                            #deprecations
                            let #app_var = #app_var
                                #next_help_heading
                                #next_display_order;
                            let #app_var = <#ty as clap::Subcommand>::augment_subcommands_for_update(#app_var);
                        }
                    } else {
                        quote! {
                            #deprecations
                            let #app_var = #app_var
                                #next_help_heading
                                #next_display_order;
                            let #app_var = <#ty as clap::Subcommand>::augment_subcommands(#app_var);
                        }
                    };
                    Some(subcommand)
                }
                _ => abort!(
                    variant,
                    "`flatten` is usable only with single-typed tuple variants"
                ),
            },

            Kind::Subcommand(_) => {
                let subcommand_var = Ident::new("__clap_subcommand", Span::call_site());
                let arg_block = match variant.fields {
                    Named(_) => {
                        abort!(variant, "non single-typed tuple enums are not supported")
                    }
                    Unit => quote!( #subcommand_var ),
                    Unnamed(FieldsUnnamed { ref unnamed, .. }) if unnamed.len() == 1 => {
                        let ty = &unnamed[0].ty;
                        if override_required {
                            quote_spanned! { ty.span()=>
                                {
                                    <#ty as clap::Subcommand>::augment_subcommands_for_update(#subcommand_var)
                                }
                            }
                        } else {
                            quote_spanned! { ty.span()=>
                                {
                                    <#ty as clap::Subcommand>::augment_subcommands(#subcommand_var)
                                }
                            }
                        }
                    }
                    Unnamed(..) => {
                        abort!(variant, "non single-typed tuple enums are not supported")
                    }
                };

                let name = item.cased_name();
                let deprecations = if !override_required {
                    item.deprecations()
                } else {
                    quote!()
                };
                let initial_app_methods = item.initial_top_level_methods();
                let final_from_attrs = item.final_top_level_methods();
                let override_methods = if override_required {
                    quote_spanned! { kind.span()=>
                        .subcommand_required(false)
                        .arg_required_else_help(false)
                    }
                } else {
                    quote!()
                };
                let subcommand = quote! {
                    let #app_var = #app_var.subcommand({
                        #deprecations;
                        let #subcommand_var = clap::Command::new(#name);
                        let #subcommand_var = #subcommand_var
                            .subcommand_required(true)
                            .arg_required_else_help(true);
                        let #subcommand_var = #subcommand_var #initial_app_methods;
                        let #subcommand_var = #arg_block;
                        #subcommand_var #final_from_attrs #override_methods
                    });
                };
                Some(subcommand)
            }

            Kind::Command(_) => {
                let subcommand_var = Ident::new("__clap_subcommand", Span::call_site());
                let sub_augment = match variant.fields {
                    Named(ref fields) => {
                        // Defer to `gen_augment` for adding cmd methods
                        let fields = collect_args_fields(item, fields)?;
                        args::gen_augment(&fields, &subcommand_var, item, override_required)?
                    }
                    Unit => {
                        let arg_block = quote!( #subcommand_var );
                        let initial_app_methods = item.initial_top_level_methods();
                        let final_from_attrs = item.final_top_level_methods();
                        quote! {
                            let #subcommand_var = #subcommand_var #initial_app_methods;
                            let #subcommand_var = #arg_block;
                            #subcommand_var #final_from_attrs
                        }
                    }
                    Unnamed(FieldsUnnamed { ref unnamed, .. }) if unnamed.len() == 1 => {
                        let ty = &unnamed[0].ty;
                        let arg_block = if override_required {
                            quote_spanned! { ty.span()=>
                                {
                                    <#ty as clap::Args>::augment_args_for_update(#subcommand_var)
                                }
                            }
                        } else {
                            quote_spanned! { ty.span()=>
                                {
                                    <#ty as clap::Args>::augment_args(#subcommand_var)
                                }
                            }
                        };
                        let initial_app_methods = item.initial_top_level_methods();
                        let final_from_attrs = item.final_top_level_methods();
                        quote! {
                            let #subcommand_var = #subcommand_var #initial_app_methods;
                            let #subcommand_var = #arg_block;
                            #subcommand_var #final_from_attrs
                        }
                    }
                    Unnamed(..) => {
                        abort!(variant, "non single-typed tuple enums are not supported")
                    }
                };

                let deprecations = if !override_required {
                    item.deprecations()
                } else {
                    quote!()
                };
                let name = item.cased_name();
                let subcommand = quote! {
                    let #app_var = #app_var.subcommand({
                        #deprecations
                        let #subcommand_var = clap::Command::new(#name);
                        #sub_augment
                    });
                };
                Some(subcommand)
            }
        };
        subcommands.push(genned);
    }

    let deprecations = if !override_required {
        parent_item.deprecations()
    } else {
        quote!()
    };
    let initial_app_methods = parent_item.initial_top_level_methods();
    let final_app_methods = parent_item.final_top_level_methods();
    Ok(quote! {
        #deprecations;
        let #app_var = #app_var #initial_app_methods;
        #( #subcommands )*;
        #app_var #final_app_methods
    })
}

fn gen_has_subcommand(variants: &[(&Variant, Item)]) -> Result<TokenStream, syn::Error> {
    use syn::Fields::Unnamed;

    let mut ext_subcmd = false;

    let (flatten_variants, variants): (Vec<_>, Vec<_>) = variants
        .iter()
        .filter_map(|(variant, item)| {
            let kind = item.kind();
            match &*kind {
                Kind::Skip(_, _) | Kind::Arg(_) | Kind::FromGlobal(_) | Kind::Value => None,

                Kind::ExternalSubcommand => {
                    ext_subcmd = true;
                    None
                }
                Kind::Flatten(_) | Kind::Subcommand(_) | Kind::Command(_) => Some((variant, item)),
            }
        })
        .partition(|(_, item)| {
            let kind = item.kind();
            matches!(&*kind, Kind::Flatten(_))
        });

    let subcommands = variants.iter().map(|(_variant, item)| {
        let sub_name = item.cased_name();
        quote! {
            if #sub_name == __clap_name {
                return true
            }
        }
    });
    let child_subcommands = flatten_variants
        .iter()
        .map(|(variant, _attrs)| match variant.fields {
            Unnamed(ref fields) if fields.unnamed.len() == 1 => {
                let ty = &fields.unnamed[0].ty;
                Ok(quote! {
                    if <#ty as clap::Subcommand>::has_subcommand(__clap_name) {
                        return true;
                    }
                })
            }
            _ => abort!(
                variant,
                "`flatten` is usable only with single-typed tuple variants"
            ),
        })
        .collect::<Result<Vec<_>, syn::Error>>()?;

    let genned = if ext_subcmd {
        quote! { true }
    } else {
        quote! {
            #( #subcommands )*

            #( #child_subcommands )else*

            false
        }
    };
    Ok(genned)
}

fn gen_from_arg_matches(variants: &[(&Variant, Item)]) -> Result<TokenStream, syn::Error> {
    use syn::Fields::{Named, Unit, Unnamed};

    let subcommand_name_var = format_ident!("__clap_name");
    let sub_arg_matches_var = format_ident!("__clap_arg_matches");

    let mut ext_subcmd = None;
    let mut flatten_variants = Vec::new();
    let mut unflatten_variants = Vec::new();
    for (variant, item) in variants {
        let kind = item.kind();
        match &*kind {
            Kind::Skip(_, _) | Kind::Arg(_) | Kind::FromGlobal(_) | Kind::Value => {}

            Kind::ExternalSubcommand => {
                if ext_subcmd.is_some() {
                    abort!(
                        item.kind().span(),
                        "Only one variant can be marked with `external_subcommand`, \
                         this is the second"
                    );
                }

                let ty = match variant.fields {
                    Unnamed(ref fields) if fields.unnamed.len() == 1 => &fields.unnamed[0].ty,

                    _ => abort!(
                        variant,
                        "The enum variant marked with `external_subcommand` must be \
                         a single-typed tuple, and the type must be either `Vec<String>` \
                         or `Vec<OsString>`."
                    ),
                };

                let (span, str_ty) = match subty_if_name(ty, "Vec") {
                    Some(subty) => {
                        if is_simple_ty(subty, "String") {
                            (subty.span(), quote!(::std::string::String))
                        } else if is_simple_ty(subty, "OsString") {
                            (subty.span(), quote!(::std::ffi::OsString))
                        } else {
                            abort!(
                                ty.span(),
                                "The type must be either `Vec<String>` or `Vec<OsString>` \
                                 to be used with `external_subcommand`."
                            );
                        }
                    }

                    None => abort!(
                        ty.span(),
                        "The type must be either `Vec<String>` or `Vec<OsString>` \
                         to be used with `external_subcommand`."
                    ),
                };

                ext_subcmd = Some((span, &variant.ident, str_ty));
            }
            Kind::Flatten(_) | Kind::Subcommand(_) | Kind::Command(_) => {
                if matches!(&*item.kind(), Kind::Flatten(_)) {
                    flatten_variants.push((variant, item));
                } else {
                    unflatten_variants.push((variant, item));
                }
            }
        }
    }

    let subcommands = unflatten_variants.iter().map(|(variant, item)| {
        let sub_name = item.cased_name();
        let variant_name = &variant.ident;
        let constructor_block = match variant.fields {
            Named(ref fields) => {
                let fields = collect_args_fields(item, fields)?;
                args::gen_constructor(&fields)?
            },
            Unit => quote!(),
            Unnamed(ref fields) if fields.unnamed.len() == 1 => {
                let ty = &fields.unnamed[0].ty;
                quote!( ( <#ty as clap::FromArgMatches>::from_arg_matches_mut(__clap_arg_matches)? ) )
            }
            Unnamed(..) => abort_call_site!("{}: tuple enums are not supported", variant.ident),
        };

        Ok(quote! {
            if #subcommand_name_var == #sub_name && !#sub_arg_matches_var.contains_id("") {
                return ::std::result::Result::Ok(Self :: #variant_name #constructor_block)
            }
        })
    }).collect::<Result<Vec<_>, syn::Error>>()?;
    let child_subcommands = flatten_variants.iter().map(|(variant, _attrs)| {
        let variant_name = &variant.ident;
        match variant.fields {
            Unnamed(ref fields) if fields.unnamed.len() == 1 => {
                let ty = &fields.unnamed[0].ty;
                Ok(quote! {
                    if __clap_arg_matches
                        .subcommand_name()
                        .map(|__clap_name| <#ty as clap::Subcommand>::has_subcommand(__clap_name))
                        .unwrap_or_default()
                    {
                        let __clap_res = <#ty as clap::FromArgMatches>::from_arg_matches_mut(__clap_arg_matches)?;
                        return ::std::result::Result::Ok(Self :: #variant_name (__clap_res));
                    }
                })
            }
            _ => abort!(
                variant,
                "`flatten` is usable only with single-typed tuple variants"
            ),
        }
    }).collect::<Result<Vec<_>, syn::Error>>()?;

    let wildcard = match ext_subcmd {
        Some((span, var_name, str_ty)) => quote_spanned! { span=>
                ::std::result::Result::Ok(Self::#var_name(
                    ::std::iter::once(#str_ty::from(#subcommand_name_var))
                    .chain(
                        #sub_arg_matches_var
                            .remove_many::<#str_ty>("")
                            .unwrap()
                            .map(#str_ty::from)
                    )
                    .collect::<::std::vec::Vec<_>>()
                ))
        },

        None => quote! {
            ::std::result::Result::Err(clap::Error::raw(clap::error::ErrorKind::InvalidSubcommand, format!("The subcommand '{}' wasn't recognized", #subcommand_name_var)))
        },
    };

    let raw_deprecated = args::raw_deprecated();
    Ok(quote! {
        fn from_arg_matches_mut(__clap_arg_matches: &mut clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
            #raw_deprecated

            #( #child_subcommands )else*

            if let Some((#subcommand_name_var, mut __clap_arg_sub_matches)) = __clap_arg_matches.remove_subcommand() {
                let #sub_arg_matches_var = &mut __clap_arg_sub_matches;
                #( #subcommands )*

                #wildcard
            } else {
                ::std::result::Result::Err(clap::Error::raw(clap::error::ErrorKind::MissingSubcommand, "A subcommand is required but one was not provided."))
            }
        }
    })
}

fn gen_update_from_arg_matches(variants: &[(&Variant, Item)]) -> Result<TokenStream, syn::Error> {
    use syn::Fields::{Named, Unit, Unnamed};

    let (flatten, variants): (Vec<_>, Vec<_>) = variants
        .iter()
        .filter_map(|(variant, item)| {
            let kind = item.kind();
            match &*kind {
                // Fallback to `from_arg_matches_mut`
                Kind::Skip(_, _)
                | Kind::Arg(_)
                | Kind::FromGlobal(_)
                | Kind::Value
                | Kind::ExternalSubcommand => None,
                Kind::Flatten(_) | Kind::Subcommand(_) | Kind::Command(_) => Some((variant, item)),
            }
        })
        .partition(|(_, item)| {
            let kind = item.kind();
            matches!(&*kind, Kind::Flatten(_))
        });

    let subcommands = variants.iter().map(|(variant, item)| {
        let sub_name = item.cased_name();
        let variant_name = &variant.ident;
        let (pattern, updater) = match variant.fields {
            Named(ref fields) => {
                let field_names = fields.named.iter().map(|field| {
                    field.ident.as_ref().unwrap()
                }).collect::<Vec<_>>();
                let fields = collect_args_fields(item, fields)?;
                let update = args::gen_updater(&fields, false)?;
                (quote!( { #( #field_names, )* }), quote!( { #update } ))
            }
            Unit => (quote!(), quote!({})),
            Unnamed(ref fields) => {
                if fields.unnamed.len() == 1 {
                    (
                        quote!((ref mut __clap_arg)),
                        quote!(clap::FromArgMatches::update_from_arg_matches_mut(
                            __clap_arg,
                            __clap_arg_matches
                        )?),
                    )
                } else {
                    abort_call_site!("{}: tuple enums are not supported", variant.ident)
                }
            }
        };

        Ok(quote! {
            Self :: #variant_name #pattern if #sub_name == __clap_name => {
                let (_, mut __clap_arg_sub_matches) = __clap_arg_matches.remove_subcommand().unwrap();
                let __clap_arg_matches = &mut __clap_arg_sub_matches;
                #updater
            }
        })
    }).collect::<Result<Vec<_>, _>>()?;

    let child_subcommands = flatten.iter().map(|(variant, _attrs)| {
        let variant_name = &variant.ident;
        match variant.fields {
            Unnamed(ref fields) if fields.unnamed.len() == 1 => {
                let ty = &fields.unnamed[0].ty;
                Ok(quote! {
                    if <#ty as clap::Subcommand>::has_subcommand(__clap_name) {
                        if let Self :: #variant_name (child) = s {
                            <#ty as clap::FromArgMatches>::update_from_arg_matches_mut(child, __clap_arg_matches)?;
                            return ::std::result::Result::Ok(());
                        }
                    }
                })
            }
            _ => abort!(
                variant,
                "`flatten` is usable only with single-typed tuple variants"
            ),
        }
    }).collect::<Result<Vec<_>, _>>()?;

    let raw_deprecated = args::raw_deprecated();
    Ok(quote! {
        fn update_from_arg_matches_mut<'b>(
            &mut self,
            __clap_arg_matches: &mut clap::ArgMatches,
        ) -> ::std::result::Result<(), clap::Error> {
            #raw_deprecated

            if let Some(__clap_name) = __clap_arg_matches.subcommand_name() {
                match self {
                    #( #subcommands ),*
                    s => {
                        #( #child_subcommands )*
                        *s = <Self as clap::FromArgMatches>::from_arg_matches_mut(__clap_arg_matches)?;
                    }
                }
            }
            ::std::result::Result::Ok(())
        }
    })
}

```

`clap/clap_derive/src/derives/value_enum.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use proc_macro2::TokenStream;
use quote::quote;
use quote::quote_spanned;
use syn::{spanned::Spanned, Data, DeriveInput, Fields, Ident, Variant};

use crate::item::{Item, Kind, Name};

pub(crate) fn derive_value_enum(input: &DeriveInput) -> Result<TokenStream, syn::Error> {
    let ident = &input.ident;

    match input.data {
        Data::Enum(ref e) => {
            let name = Name::Derived(ident.clone());
            let item = Item::from_value_enum(input, name)?;
            let mut variants = Vec::new();
            for variant in &e.variants {
                let item =
                    Item::from_value_enum_variant(variant, item.casing(), item.env_casing())?;
                variants.push((variant, item));
            }
            gen_for_enum(&item, ident, &variants)
        }
        _ => abort_call_site!("`#[derive(ValueEnum)]` only supports enums"),
    }
}

pub(crate) fn gen_for_enum(
    item: &Item,
    item_name: &Ident,
    variants: &[(&Variant, Item)],
) -> Result<TokenStream, syn::Error> {
    if !matches!(&*item.kind(), Kind::Value) {
        abort! { item.kind().span(),
            "`{}` cannot be used with `value`",
            item.kind().name(),
        }
    }

    let lits = lits(variants)?;
    let value_variants = gen_value_variants(&lits);
    let to_possible_value = gen_to_possible_value(item, &lits);

    Ok(quote! {
        #[allow(
            dead_code,
            unreachable_code,
            unused_variables,
            unused_braces,
            unused_qualifications,
        )]
        #[allow(
            clippy::style,
            clippy::complexity,
            clippy::pedantic,
            clippy::restriction,
            clippy::perf,
            clippy::deprecated,
            clippy::nursery,
            clippy::cargo,
            clippy::suspicious_else_formatting,
            clippy::almost_swapped,
            clippy::redundant_locals,
        )]
        #[automatically_derived]
        impl clap::ValueEnum for #item_name {
            #value_variants
            #to_possible_value
        }
    })
}

fn lits(variants: &[(&Variant, Item)]) -> Result<Vec<(TokenStream, Ident)>, syn::Error> {
    let mut genned = Vec::new();
    for (variant, item) in variants {
        if let Kind::Skip(_, _) = &*item.kind() {
            continue;
        }
        if !matches!(variant.fields, Fields::Unit) {
            abort!(variant.span(), "`#[derive(ValueEnum)]` only supports unit variants. Non-unit variants must be skipped");
        }
        let fields = item.field_methods();
        let deprecations = item.deprecations();
        let name = item.cased_name();
        genned.push((
            quote_spanned! { variant.span()=> {
                #deprecations
                clap::builder::PossibleValue::new(#name)
                #fields
            }},
            variant.ident.clone(),
        ));
    }
    Ok(genned)
}

fn gen_value_variants(lits: &[(TokenStream, Ident)]) -> TokenStream {
    let lit = lits.iter().map(|l| &l.1).collect::<Vec<_>>();

    quote! {
        fn value_variants<'a>() -> &'a [Self]{
            &[#(Self::#lit),*]
        }
    }
}

fn gen_to_possible_value(item: &Item, lits: &[(TokenStream, Ident)]) -> TokenStream {
    let (lit, variant): (Vec<TokenStream>, Vec<Ident>) = lits.iter().cloned().unzip();

    let deprecations = item.deprecations();

    quote! {
        fn to_possible_value<'a>(&self) -> ::std::option::Option<clap::builder::PossibleValue> {
            #deprecations
            match self {
                #(Self::#variant => Some(#lit),)*
                _ => None
            }
        }
    }
}

```

`clap/clap_derive/src/dummies.rs`:

```rs
//! Dummy implementations that we emit along with an error.

use proc_macro2::Ident;
use quote::quote;

#[must_use]
pub(crate) fn parser(name: &Ident) -> proc_macro2::TokenStream {
    let into_app = into_app(name);
    quote!(
        #[automatically_derived]
        impl clap::Parser for #name {}
        #into_app
    )
}

#[must_use]
pub(crate) fn into_app(name: &Ident) -> proc_macro2::TokenStream {
    quote! {
        #[automatically_derived]
        impl clap::CommandFactory for #name {
            fn command<'b>() -> clap::Command {
                unimplemented!()
            }
            fn command_for_update<'b>() -> clap::Command {
                unimplemented!()
            }
        }
    }
}

#[must_use]
pub(crate) fn from_arg_matches(name: &Ident) -> proc_macro2::TokenStream {
    quote! {
        #[automatically_derived]
        impl clap::FromArgMatches for #name {
            fn from_arg_matches(_m: &clap::ArgMatches) -> ::std::result::Result<Self, clap::Error> {
                unimplemented!()
            }
            fn update_from_arg_matches(&mut self, matches: &clap::ArgMatches) -> ::std::result::Result<(), clap::Error>{
                unimplemented!()
            }
        }
    }
}

#[must_use]
pub(crate) fn subcommand(name: &Ident) -> proc_macro2::TokenStream {
    let from_arg_matches = from_arg_matches(name);
    quote! {
        #[automatically_derived]
        impl clap::Subcommand for #name {
            fn augment_subcommands(_cmd: clap::Command) -> clap::Command {
                unimplemented!()
            }
            fn augment_subcommands_for_update(_cmd: clap::Command) -> clap::Command {
                unimplemented!()
            }
            fn has_subcommand(name: &str) -> bool {
                unimplemented!()
            }
        }
        #from_arg_matches
    }
}

#[must_use]
pub(crate) fn args(name: &Ident) -> proc_macro2::TokenStream {
    let from_arg_matches = from_arg_matches(name);
    quote! {
        #[automatically_derived]
        impl clap::Args for #name {
            fn augment_args(_cmd: clap::Command) -> clap::Command {
                unimplemented!()
            }
            fn augment_args_for_update(_cmd: clap::Command) -> clap::Command {
                unimplemented!()
            }
        }
        #from_arg_matches
    }
}

#[must_use]
pub(crate) fn value_enum(name: &Ident) -> proc_macro2::TokenStream {
    quote! {
        #[automatically_derived]
        impl clap::ValueEnum for #name {
            fn value_variants<'a>() -> &'a [Self]{
                unimplemented!()
            }
            fn from_str(_input: &str, _ignore_case: bool) -> ::std::result::Result<Self, String> {
                unimplemented!()
            }
            fn to_possible_value<'a>(&self) -> ::std::option::Option<clap::builder::PossibleValue>{
                unimplemented!()
            }
        }
    }
}

```

`clap/clap_derive/src/item.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use std::env;

use heck::{ToKebabCase, ToLowerCamelCase, ToShoutySnakeCase, ToSnakeCase, ToUpperCamelCase};
use proc_macro2::{self, Span, TokenStream};
use quote::{format_ident, quote, quote_spanned, ToTokens};
use syn::DeriveInput;
use syn::{self, ext::IdentExt, spanned::Spanned, Attribute, Field, Ident, LitStr, Type, Variant};

use crate::attr::{AttrKind, AttrValue, ClapAttr, MagicAttrName};
use crate::utils::{extract_doc_comment, format_doc_comment, inner_type, is_simple_ty, Sp, Ty};

/// Default casing style for generated arguments.
pub(crate) const DEFAULT_CASING: CasingStyle = CasingStyle::Kebab;

/// Default casing style for environment variables
pub(crate) const DEFAULT_ENV_CASING: CasingStyle = CasingStyle::ScreamingSnake;

#[derive(Clone)]
pub(crate) struct Item {
    name: Name,
    casing: Sp<CasingStyle>,
    env_casing: Sp<CasingStyle>,
    ty: Option<Type>,
    doc_comment: Vec<Method>,
    methods: Vec<Method>,
    deprecations: Vec<Deprecation>,
    value_parser: Option<ValueParser>,
    action: Option<Action>,
    verbatim_doc_comment: bool,
    force_long_help: bool,
    next_display_order: Option<Method>,
    next_help_heading: Option<Method>,
    is_enum: bool,
    is_positional: bool,
    skip_group: bool,
    group_id: Name,
    group_methods: Vec<Method>,
    kind: Sp<Kind>,
}

impl Item {
    pub(crate) fn from_args_struct(input: &DeriveInput, name: Name) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let span = input.ident.span();
        let attrs = &input.attrs;
        let argument_casing = Sp::new(DEFAULT_CASING, span);
        let env_casing = Sp::new(DEFAULT_ENV_CASING, span);
        let kind = Sp::new(Kind::Command(Sp::new(Ty::Other, span)), span);

        let mut res = Self::new(name, ident, None, argument_casing, env_casing, kind);
        let parsed_attrs = ClapAttr::parse_all(attrs)?;
        res.infer_kind(&parsed_attrs)?;
        res.push_attrs(&parsed_attrs)?;
        res.push_doc_comment(attrs, "about", Some("long_about"));

        Ok(res)
    }

    pub(crate) fn from_subcommand_enum(
        input: &DeriveInput,
        name: Name,
    ) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let span = input.ident.span();
        let attrs = &input.attrs;
        let argument_casing = Sp::new(DEFAULT_CASING, span);
        let env_casing = Sp::new(DEFAULT_ENV_CASING, span);
        let kind = Sp::new(Kind::Command(Sp::new(Ty::Other, span)), span);

        let mut res = Self::new(name, ident, None, argument_casing, env_casing, kind);
        let parsed_attrs = ClapAttr::parse_all(attrs)?;
        res.infer_kind(&parsed_attrs)?;
        res.push_attrs(&parsed_attrs)?;
        res.push_doc_comment(attrs, "about", Some("long_about"));

        Ok(res)
    }

    pub(crate) fn from_value_enum(input: &DeriveInput, name: Name) -> Result<Self, syn::Error> {
        let ident = input.ident.clone();
        let span = input.ident.span();
        let attrs = &input.attrs;
        let argument_casing = Sp::new(DEFAULT_CASING, span);
        let env_casing = Sp::new(DEFAULT_ENV_CASING, span);
        let kind = Sp::new(Kind::Value, span);

        let mut res = Self::new(name, ident, None, argument_casing, env_casing, kind);
        let parsed_attrs = ClapAttr::parse_all(attrs)?;
        res.infer_kind(&parsed_attrs)?;
        res.push_attrs(&parsed_attrs)?;
        // Ignoring `push_doc_comment` as there is no top-level clap builder to add documentation
        // to

        if res.has_explicit_methods() {
            abort!(
                res.methods[0].name.span(),
                "{} doesn't exist for `ValueEnum` enums",
                res.methods[0].name
            );
        }

        Ok(res)
    }

    pub(crate) fn from_subcommand_variant(
        variant: &Variant,
        struct_casing: Sp<CasingStyle>,
        env_casing: Sp<CasingStyle>,
    ) -> Result<Self, syn::Error> {
        let name = variant.ident.clone();
        let ident = variant.ident.clone();
        let span = variant.span();
        let ty = match variant.fields {
            syn::Fields::Unnamed(syn::FieldsUnnamed { ref unnamed, .. }) if unnamed.len() == 1 => {
                Ty::from_syn_ty(&unnamed[0].ty)
            }
            syn::Fields::Named(_) | syn::Fields::Unnamed(..) | syn::Fields::Unit => {
                Sp::new(Ty::Other, span)
            }
        };
        let kind = Sp::new(Kind::Command(ty), span);
        let mut res = Self::new(
            Name::Derived(name),
            ident,
            None,
            struct_casing,
            env_casing,
            kind,
        );
        let parsed_attrs = ClapAttr::parse_all(&variant.attrs)?;
        res.infer_kind(&parsed_attrs)?;
        res.push_attrs(&parsed_attrs)?;
        if matches!(&*res.kind, Kind::Command(_) | Kind::Subcommand(_)) {
            res.push_doc_comment(&variant.attrs, "about", Some("long_about"));
        }

        match &*res.kind {
            Kind::Flatten(_) => {
                if res.has_explicit_methods() {
                    abort!(
                        res.kind.span(),
                        "methods are not allowed for flattened entry"
                    );
                }
            }

            Kind::Subcommand(_)
            | Kind::ExternalSubcommand
            | Kind::FromGlobal(_)
            | Kind::Skip(_, _)
            | Kind::Command(_)
            | Kind::Value
            | Kind::Arg(_) => (),
        }

        Ok(res)
    }

    pub(crate) fn from_value_enum_variant(
        variant: &Variant,
        argument_casing: Sp<CasingStyle>,
        env_casing: Sp<CasingStyle>,
    ) -> Result<Self, syn::Error> {
        let ident = variant.ident.clone();
        let span = variant.span();
        let kind = Sp::new(Kind::Value, span);
        let mut res = Self::new(
            Name::Derived(variant.ident.clone()),
            ident,
            None,
            argument_casing,
            env_casing,
            kind,
        );
        let parsed_attrs = ClapAttr::parse_all(&variant.attrs)?;
        res.infer_kind(&parsed_attrs)?;
        res.push_attrs(&parsed_attrs)?;
        if matches!(&*res.kind, Kind::Value) {
            res.push_doc_comment(&variant.attrs, "help", None);
        }

        Ok(res)
    }

    pub(crate) fn from_args_field(
        field: &Field,
        struct_casing: Sp<CasingStyle>,
        env_casing: Sp<CasingStyle>,
    ) -> Result<Self, syn::Error> {
        let name = field.ident.clone().unwrap();
        let ident = field.ident.clone().unwrap();
        let span = field.span();
        let ty = Ty::from_syn_ty(&field.ty);
        let kind = Sp::new(Kind::Arg(ty), span);
        let mut res = Self::new(
            Name::Derived(name),
            ident,
            Some(field.ty.clone()),
            struct_casing,
            env_casing,
            kind,
        );
        let parsed_attrs = ClapAttr::parse_all(&field.attrs)?;
        res.infer_kind(&parsed_attrs)?;
        res.push_attrs(&parsed_attrs)?;
        if matches!(&*res.kind, Kind::Arg(_)) {
            res.push_doc_comment(&field.attrs, "help", Some("long_help"));
        }

        match &*res.kind {
            Kind::Flatten(_) => {
                if res.has_explicit_methods() {
                    abort!(
                        res.kind.span(),
                        "methods are not allowed for flattened entry"
                    );
                }
            }

            Kind::Subcommand(_) => {
                if res.has_explicit_methods() {
                    abort!(
                        res.kind.span(),
                        "methods in attributes are not allowed for subcommand"
                    );
                }
            }
            Kind::Skip(_, _)
            | Kind::FromGlobal(_)
            | Kind::Arg(_)
            | Kind::Command(_)
            | Kind::Value
            | Kind::ExternalSubcommand => {}
        }

        Ok(res)
    }

    fn new(
        name: Name,
        ident: Ident,
        ty: Option<Type>,
        casing: Sp<CasingStyle>,
        env_casing: Sp<CasingStyle>,
        kind: Sp<Kind>,
    ) -> Self {
        let group_id = Name::Derived(ident);
        Self {
            name,
            ty,
            casing,
            env_casing,
            doc_comment: vec![],
            methods: vec![],
            deprecations: vec![],
            value_parser: None,
            action: None,
            verbatim_doc_comment: false,
            force_long_help: false,
            next_display_order: None,
            next_help_heading: None,
            is_enum: false,
            is_positional: true,
            skip_group: false,
            group_id,
            group_methods: vec![],
            kind,
        }
    }

    fn push_method(&mut self, kind: AttrKind, name: Ident, arg: impl ToTokens) {
        self.push_method_(kind, name, arg.to_token_stream());
    }

    fn push_method_(&mut self, kind: AttrKind, name: Ident, arg: TokenStream) {
        if name == "id" {
            match kind {
                AttrKind::Command | AttrKind::Value => {
                    self.deprecations.push(Deprecation {
                        span: name.span(),
                        id: "id_is_only_for_arg",
                        version: "4.0.0",
                        description: format!(
                            "`#[{}(id)] was allowed by mistake, instead use `#[{}(name)]`",
                            kind.as_str(),
                            kind.as_str()
                        ),
                    });
                    self.name = Name::Assigned(arg);
                }
                AttrKind::Group => {
                    self.group_id = Name::Assigned(arg);
                }
                AttrKind::Arg | AttrKind::Clap | AttrKind::StructOpt => {
                    self.name = Name::Assigned(arg);
                }
            }
        } else if name == "name" {
            match kind {
                AttrKind::Arg => {
                    self.deprecations.push(Deprecation {
                        span: name.span(),
                        id: "id_is_only_for_arg",
                        version: "4.0.0",
                        description: format!(
                            "`#[{}(name)] was allowed by mistake, instead use `#[{}(id)]` or `#[{}(value_name)]`",
                            kind.as_str(),
                            kind.as_str(),
                            kind.as_str()
                        ),
                    });
                    self.name = Name::Assigned(arg);
                }
                AttrKind::Group => self.group_methods.push(Method::new(name, arg)),
                AttrKind::Command | AttrKind::Value | AttrKind::Clap | AttrKind::StructOpt => {
                    self.name = Name::Assigned(arg);
                }
            }
        } else if name == "value_parser" {
            self.value_parser = Some(ValueParser::Explicit(Method::new(name, arg)));
        } else if name == "action" {
            self.action = Some(Action::Explicit(Method::new(name, arg)));
        } else {
            if name == "short" || name == "long" {
                self.is_positional = false;
            }
            match kind {
                AttrKind::Group => self.group_methods.push(Method::new(name, arg)),
                _ => self.methods.push(Method::new(name, arg)),
            };
        }
    }

    fn infer_kind(&mut self, attrs: &[ClapAttr]) -> Result<(), syn::Error> {
        for attr in attrs {
            if let Some(AttrValue::Call(_)) = &attr.value {
                continue;
            }

            let actual_attr_kind = *attr.kind.get();
            let kind = match &attr.magic {
                Some(MagicAttrName::FromGlobal) => {
                    if attr.value.is_some() {
                        let expr = attr.value_or_abort()?;
                        abort!(expr, "attribute `{}` does not accept a value", attr.name);
                    }
                    let ty = self
                        .kind()
                        .ty()
                        .cloned()
                        .unwrap_or_else(|| Sp::new(Ty::Other, self.kind.span()));
                    let kind = Sp::new(Kind::FromGlobal(ty), attr.name.span());
                    Some(kind)
                }
                Some(MagicAttrName::Subcommand) if attr.value.is_none() => {
                    if attr.value.is_some() {
                        let expr = attr.value_or_abort()?;
                        abort!(expr, "attribute `{}` does not accept a value", attr.name);
                    }
                    let ty = self
                        .kind()
                        .ty()
                        .cloned()
                        .unwrap_or_else(|| Sp::new(Ty::Other, self.kind.span()));
                    let kind = Sp::new(Kind::Subcommand(ty), attr.name.span());
                    Some(kind)
                }
                Some(MagicAttrName::ExternalSubcommand) if attr.value.is_none() => {
                    if attr.value.is_some() {
                        let expr = attr.value_or_abort()?;
                        abort!(expr, "attribute `{}` does not accept a value", attr.name);
                    }
                    let kind = Sp::new(Kind::ExternalSubcommand, attr.name.span());
                    Some(kind)
                }
                Some(MagicAttrName::Flatten) if attr.value.is_none() => {
                    if attr.value.is_some() {
                        let expr = attr.value_or_abort()?;
                        abort!(expr, "attribute `{}` does not accept a value", attr.name);
                    }
                    let ty = self
                        .kind()
                        .ty()
                        .cloned()
                        .unwrap_or_else(|| Sp::new(Ty::Other, self.kind.span()));
                    let kind = Sp::new(Kind::Flatten(ty), attr.name.span());
                    Some(kind)
                }
                Some(MagicAttrName::Skip) if actual_attr_kind != AttrKind::Group => {
                    let expr = attr.value.clone();
                    let kind = Sp::new(Kind::Skip(expr, self.kind.attr_kind()), attr.name.span());
                    Some(kind)
                }
                _ => None,
            };

            if let Some(kind) = kind {
                self.set_kind(kind)?;
            }
        }

        Ok(())
    }

    fn push_attrs(&mut self, attrs: &[ClapAttr]) -> Result<(), syn::Error> {
        for attr in attrs {
            let actual_attr_kind = *attr.kind.get();
            let expected_attr_kind = self.kind.attr_kind();
            match (actual_attr_kind, expected_attr_kind) {
                (AttrKind::Clap, _) | (AttrKind::StructOpt, _) => {
                    self.deprecations.push(Deprecation::attribute(
                        "4.0.0",
                        actual_attr_kind,
                        expected_attr_kind,
                        attr.kind.span(),
                    ));
                }

                (AttrKind::Group, AttrKind::Command) => {}

                _ if attr.kind != expected_attr_kind => {
                    abort!(
                        attr.kind.span(),
                        "Expected `{}` attribute instead of `{}`",
                        expected_attr_kind.as_str(),
                        actual_attr_kind.as_str()
                    );
                }

                _ => {}
            }

            if let Some(AttrValue::Call(tokens)) = &attr.value {
                // Force raw mode with method call syntax
                self.push_method(*attr.kind.get(), attr.name.clone(), quote!(#(#tokens),*));
                continue;
            }

            match &attr.magic {
                Some(MagicAttrName::Short) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    self.push_method(
                        *attr.kind.get(),
                        attr.name.clone(),
                        self.name.clone().translate_char(*self.casing),
                    );
                }

                Some(MagicAttrName::Long) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    self.push_method(*attr.kind.get(), attr.name.clone(), self.name.clone().translate(*self.casing));
                }

                Some(MagicAttrName::ValueParser) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    self.deprecations.push(Deprecation {
                        span: attr.name.span(),
                        id: "bare_value_parser",
                        version: "4.0.0",
                        description: "`#[arg(value_parser)]` is now the default and is no longer needed`".to_owned(),
                    });
                    self.value_parser = Some(ValueParser::Implicit(attr.name.clone()));
                }

                Some(MagicAttrName::Action) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    self.deprecations.push(Deprecation {
                        span: attr.name.span(),
                        id: "bare_action",
                        version: "4.0.0",
                        description: "`#[arg(action)]` is now the default and is no longer needed`".to_owned(),
                    });
                    self.action = Some(Action::Implicit(attr.name.clone()));
                }

                Some(MagicAttrName::Env) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    self.push_method(
                        *attr.kind.get(),
                        attr.name.clone(),
                        self.name.clone().translate(*self.env_casing),
                    );
                }

                Some(MagicAttrName::ValueEnum) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    self.is_enum = true;
                }

                Some(MagicAttrName::VerbatimDocComment) if attr.value.is_none() => {
                    self.verbatim_doc_comment = true;
                }

                Some(MagicAttrName::About) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Command])?;

                    if let Some(method) =
                        Method::from_env(attr.name.clone(), "CARGO_PKG_DESCRIPTION")?
                    {
                        self.methods.push(method);
                    }
                }

                Some(MagicAttrName::LongAbout) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Command])?;

                    self.force_long_help = true;
                }

                Some(MagicAttrName::LongHelp) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    self.force_long_help = true;
                }

                Some(MagicAttrName::Author) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Command])?;

                    if let Some(method) = Method::from_env(attr.name.clone(), "CARGO_PKG_AUTHORS")? {
                        self.methods.push(method);
                    }
                }

                Some(MagicAttrName::Version) if attr.value.is_none() => {
                    assert_attr_kind(attr, &[AttrKind::Command])?;

                    if let Some(method) = Method::from_env(attr.name.clone(), "CARGO_PKG_VERSION")? {
                        self.methods.push(method);
                    }
                }

                Some(MagicAttrName::DefaultValueT) => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    let ty = if let Some(ty) = self.ty.as_ref() {
                        ty
                    } else {
                        abort!(
                            attr.name.clone(),
                            "#[arg(default_value_t)] (without an argument) can be used \
                            only on field level\n\n= note: {note}\n\n",

                            note = "see \
                                https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                    };

                    let val = if let Some(expr) = &attr.value {
                        quote!(#expr)
                    } else {
                        quote!(<#ty as ::std::default::Default>::default())
                    };

                    let val = if attrs
                        .iter()
                        .any(|a| a.magic == Some(MagicAttrName::ValueEnum))
                    {
                        quote_spanned!(attr.name.span()=> {
                            static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                            let s = DEFAULT_VALUE.get_or_init(|| {
                                let val: #ty = #val;
                                clap::ValueEnum::to_possible_value(&val).unwrap().get_name().to_owned()
                            });
                            let s: &'static str = &*s;
                            s
                        })
                    } else {
                        quote_spanned!(attr.name.span()=> {
                            static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                            let s = DEFAULT_VALUE.get_or_init(|| {
                                let val: #ty = #val;
                                ::std::string::ToString::to_string(&val)
                            });
                            let s: &'static str = &*s;
                            s
                        })
                    };

                    let raw_ident = Ident::new("default_value", attr.name.span());
                    self.methods.push(Method::new(raw_ident, val));
                }

                Some(MagicAttrName::DefaultValuesT) => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    let ty = if let Some(ty) = self.ty.as_ref() {
                        ty
                    } else {
                        abort!(
                            attr.name.clone(),
                            "#[arg(default_values_t)] (without an argument) can be used \
                            only on field level\n\n= note: {note}\n\n",

                            note = "see \
                                https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                    };
                    let expr = attr.value_or_abort()?;

                    let container_type = Ty::from_syn_ty(ty);
                    if *container_type != Ty::Vec {
                        abort!(
                            attr.name.clone(),
                            "#[arg(default_values_t)] can be used only on Vec types\n\n= note: {note}\n\n",

                            note = "see \
                                https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                    }
                    let inner_type = inner_type(ty);

                    // Use `Borrow<#inner_type>` so we accept `&Vec<#inner_type>` and
                    // `Vec<#inner_type>`.
                    let val = if attrs
                        .iter()
                        .any(|a| a.magic == Some(MagicAttrName::ValueEnum))
                    {
                        quote_spanned!(attr.name.span()=> {
                            {
                                fn iter_to_vals<T>(iterable: impl IntoIterator<Item = T>) -> impl Iterator<Item=String>
                                where
                                    T: ::std::borrow::Borrow<#inner_type>
                                {
                                    iterable
                                        .into_iter()
                                        .map(|val| {
                                            clap::ValueEnum::to_possible_value(val.borrow()).unwrap().get_name().to_owned()
                                        })
                                }

                                static DEFAULT_STRINGS: ::std::sync::OnceLock<Vec<String>> = ::std::sync::OnceLock::new();
                                static DEFAULT_VALUES: ::std::sync::OnceLock<Vec<&str>> = ::std::sync::OnceLock::new();
                                DEFAULT_VALUES.get_or_init(|| {
                                    DEFAULT_STRINGS.get_or_init(|| iter_to_vals(#expr).collect()).iter().map(::std::string::String::as_str).collect()
                                }).iter().copied()
                            }
                        })
                    } else {
                        quote_spanned!(attr.name.span()=> {
                            {
                                fn iter_to_vals<T>(iterable: impl IntoIterator<Item = T>) -> impl Iterator<Item=String>
                                where
                                    T: ::std::borrow::Borrow<#inner_type>
                                {
                                    iterable.into_iter().map(|val| val.borrow().to_string())
                                }

                                static DEFAULT_STRINGS: ::std::sync::OnceLock<Vec<String>> = ::std::sync::OnceLock::new();
                                static DEFAULT_VALUES: ::std::sync::OnceLock<Vec<&str>> = ::std::sync::OnceLock::new();
                                DEFAULT_VALUES.get_or_init(|| {
                                    DEFAULT_STRINGS.get_or_init(|| iter_to_vals(#expr).collect()).iter().map(::std::string::String::as_str).collect()
                                }).iter().copied()
                            }
                        })
                    };

                    self.methods.push(Method::new(
                        Ident::new("default_values", attr.name.span()),
                        val,
                    ));
                }

                Some(MagicAttrName::DefaultValueOsT) => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    let ty = if let Some(ty) = self.ty.as_ref() {
                        ty
                    } else {
                        abort!(
                            attr.name.clone(),
                            "#[arg(default_value_os_t)] (without an argument) can be used \
                            only on field level\n\n= note: {note}\n\n",

                            note = "see \
                                https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                    };

                    let val = if let Some(expr) = &attr.value {
                        quote!(#expr)
                    } else {
                        quote!(<#ty as ::std::default::Default>::default())
                    };

                    let val = if attrs
                        .iter()
                        .any(|a| a.magic == Some(MagicAttrName::ValueEnum))
                    {
                        quote_spanned!(attr.name.span()=> {
                            static DEFAULT_VALUE: ::std::sync::OnceLock<String> = ::std::sync::OnceLock::new();
                            let s = DEFAULT_VALUE.get_or_init(|| {
                                let val: #ty = #val;
                                clap::ValueEnum::to_possible_value(&val).unwrap().get_name().to_owned()
                            });
                            let s: &'static str = &*s;
                            s
                        })
                    } else {
                        quote_spanned!(attr.name.span()=> {
                            static DEFAULT_VALUE: ::std::sync::OnceLock<::std::ffi::OsString> = ::std::sync::OnceLock::new();
                            let s = DEFAULT_VALUE.get_or_init(|| {
                                let val: #ty = #val;
                                ::std::ffi::OsString::from(val)
                            });
                            let s: &'static ::std::ffi::OsStr = &*s;
                            s
                        })
                    };

                    let raw_ident = Ident::new("default_value", attr.name.span());
                    self.methods.push(Method::new(raw_ident, val));
                }

                Some(MagicAttrName::DefaultValuesOsT) => {
                    assert_attr_kind(attr, &[AttrKind::Arg])?;

                    let ty = if let Some(ty) = self.ty.as_ref() {
                        ty
                    } else {
                        abort!(
                            attr.name.clone(),
                            "#[arg(default_values_os_t)] (without an argument) can be used \
                            only on field level\n\n= note: {note}\n\n",

                            note = "see \
                                https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                    };
                    let expr = attr.value_or_abort()?;

                    let container_type = Ty::from_syn_ty(ty);
                    if *container_type != Ty::Vec {
                        abort!(
                            attr.name.clone(),
                            "#[arg(default_values_os_t)] can be used only on Vec types\n\n= note: {note}\n\n",

                            note = "see \
                                https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes")
                    }
                    let inner_type = inner_type(ty);

                    // Use `Borrow<#inner_type>` so we accept `&Vec<#inner_type>` and
                    // `Vec<#inner_type>`.
                    let val = if attrs
                        .iter()
                        .any(|a| a.magic == Some(MagicAttrName::ValueEnum))
                    {
                        quote_spanned!(attr.name.span()=> {
                            {
                                fn iter_to_vals<T>(iterable: impl IntoIterator<Item = T>) -> impl Iterator<Item=::std::ffi::OsString>
                                where
                                    T: ::std::borrow::Borrow<#inner_type>
                                {
                                    iterable
                                        .into_iter()
                                        .map(|val| {
                                            clap::ValueEnum::to_possible_value(val.borrow()).unwrap().get_name().to_owned().into()
                                        })
                                }

                                static DEFAULT_STRINGS: ::std::sync::OnceLock<Vec<::std::ffi::OsString>> = ::std::sync::OnceLock::new();
                                static DEFAULT_VALUES: ::std::sync::OnceLock<Vec<&::std::ffi::OsStr>> = ::std::sync::OnceLock::new();
                                DEFAULT_VALUES.get_or_init(|| {
                                    DEFAULT_STRINGS.get_or_init(|| iter_to_vals(#expr).collect()).iter().map(::std::ffi::OsString::as_os_str).collect()
                                }).iter().copied()
                            }
                        })
                    } else {
                        quote_spanned!(attr.name.span()=> {
                            {
                                fn iter_to_vals<T>(iterable: impl IntoIterator<Item = T>) -> impl Iterator<Item=::std::ffi::OsString>
                                where
                                    T: ::std::borrow::Borrow<#inner_type>
                                {
                                    iterable.into_iter().map(|val| val.borrow().into())
                                }

                                static DEFAULT_STRINGS: ::std::sync::OnceLock<Vec<::std::ffi::OsString>> = ::std::sync::OnceLock::new();
                                static DEFAULT_VALUES: ::std::sync::OnceLock<Vec<&::std::ffi::OsStr>> = ::std::sync::OnceLock::new();
                                DEFAULT_VALUES.get_or_init(|| {
                                    DEFAULT_STRINGS.get_or_init(|| iter_to_vals(#expr).collect()).iter().map(::std::ffi::OsString::as_os_str).collect()
                                }).iter().copied()
                            }
                        })
                    };

                    self.methods.push(Method::new(
                        Ident::new("default_values", attr.name.span()),
                        val,
                    ));
                }

                Some(MagicAttrName::NextDisplayOrder) => {
                    assert_attr_kind(attr, &[AttrKind::Command])?;

                    let expr = attr.value_or_abort()?;
                    self.next_display_order = Some(Method::new(attr.name.clone(), quote!(#expr)));
                }

                Some(MagicAttrName::NextHelpHeading) => {
                    assert_attr_kind(attr, &[AttrKind::Command])?;

                    let expr = attr.value_or_abort()?;
                    self.next_help_heading = Some(Method::new(attr.name.clone(), quote!(#expr)));
                }

                Some(MagicAttrName::RenameAll) => {
                    let lit = attr.lit_str_or_abort()?;
                    self.casing = CasingStyle::from_lit(lit)?;
                }

                Some(MagicAttrName::RenameAllEnv) => {
                    assert_attr_kind(attr, &[AttrKind::Command, AttrKind::Arg])?;

                    let lit = attr.lit_str_or_abort()?;
                    self.env_casing = CasingStyle::from_lit(lit)?;
                }

                Some(MagicAttrName::Skip) if actual_attr_kind == AttrKind::Group => {
                    self.skip_group = true;
                }

                None
                // Magic only for the default, otherwise just forward to the builder
                | Some(MagicAttrName::Short)
                | Some(MagicAttrName::Long)
                | Some(MagicAttrName::Env)
                | Some(MagicAttrName::About)
                | Some(MagicAttrName::LongAbout)
                | Some(MagicAttrName::LongHelp)
                | Some(MagicAttrName::Author)
                | Some(MagicAttrName::Version)
                 => {
                    let expr = attr.value_or_abort()?;
                    self.push_method(*attr.kind.get(), attr.name.clone(), expr);
                }

                // Magic only for the default, otherwise just forward to the builder
                Some(MagicAttrName::ValueParser) | Some(MagicAttrName::Action) => {
                    let expr = attr.value_or_abort()?;
                    self.push_method(*attr.kind.get(), attr.name.clone(), expr);
                }

                // Directives that never receive a value
                Some(MagicAttrName::ValueEnum)
                | Some(MagicAttrName::VerbatimDocComment) => {
                    let expr = attr.value_or_abort()?;
                    abort!(expr, "attribute `{}` does not accept a value", attr.name);
                }

                // Kinds
                Some(MagicAttrName::FromGlobal)
                | Some(MagicAttrName::Subcommand)
                | Some(MagicAttrName::ExternalSubcommand)
                | Some(MagicAttrName::Flatten)
                | Some(MagicAttrName::Skip) => {
                }
            }
        }

        if self.has_explicit_methods() {
            if let Kind::Skip(_, attr) = &*self.kind {
                abort!(
                    self.methods[0].name.span(),
                    "`{}` cannot be used with `#[{}(skip)]",
                    self.methods[0].name,
                    attr.as_str(),
                );
            }
            if let Kind::FromGlobal(_) = &*self.kind {
                abort!(
                    self.methods[0].name.span(),
                    "`{}` cannot be used with `#[arg(from_global)]",
                    self.methods[0].name,
                );
            }
        }

        Ok(())
    }

    fn push_doc_comment(&mut self, attrs: &[Attribute], short_name: &str, long_name: Option<&str>) {
        let lines = extract_doc_comment(attrs);

        if !lines.is_empty() {
            let (short_help, long_help) =
                format_doc_comment(&lines, !self.verbatim_doc_comment, self.force_long_help);
            let short_name = format_ident!("{short_name}");
            let short = Method::new(
                short_name,
                short_help
                    .map(|h| quote!(#h))
                    .unwrap_or_else(|| quote!(None)),
            );
            self.doc_comment.push(short);
            if let Some(long_name) = long_name {
                let long_name = format_ident!("{long_name}");
                let long = Method::new(
                    long_name,
                    long_help
                        .map(|h| quote!(#h))
                        .unwrap_or_else(|| quote!(None)),
                );
                self.doc_comment.push(long);
            }
        }
    }

    fn set_kind(&mut self, kind: Sp<Kind>) -> Result<(), syn::Error> {
        match (self.kind.get(), kind.get()) {
            (Kind::Arg(_), Kind::FromGlobal(_))
            | (Kind::Arg(_), Kind::Subcommand(_))
            | (Kind::Arg(_), Kind::Flatten(_))
            | (Kind::Arg(_), Kind::Skip(_, _))
            | (Kind::Command(_), Kind::Subcommand(_))
            | (Kind::Command(_), Kind::Flatten(_))
            | (Kind::Command(_), Kind::Skip(_, _))
            | (Kind::Command(_), Kind::ExternalSubcommand)
            | (Kind::Value, Kind::Skip(_, _)) => {
                self.kind = kind;
            }

            (_, _) => {
                let old = self.kind.name();
                let new = kind.name();
                abort!(kind.span(), "`{new}` cannot be used with `{old}`");
            }
        }
        Ok(())
    }

    pub(crate) fn find_default_method(&self) -> Option<&Method> {
        self.methods
            .iter()
            .find(|m| m.name == "default_value" || m.name == "default_value_os")
    }

    /// generate methods from attributes on top of struct or enum
    pub(crate) fn initial_top_level_methods(&self) -> TokenStream {
        let next_display_order = self.next_display_order.as_ref().into_iter();
        let next_help_heading = self.next_help_heading.as_ref().into_iter();
        quote!(
            #(#next_display_order)*
            #(#next_help_heading)*
        )
    }

    pub(crate) fn final_top_level_methods(&self) -> TokenStream {
        let methods = &self.methods;
        let doc_comment = &self.doc_comment;

        quote!( #(#doc_comment)* #(#methods)*)
    }

    /// generate methods on top of a field
    pub(crate) fn field_methods(&self) -> TokenStream {
        let methods = &self.methods;
        let doc_comment = &self.doc_comment;
        quote!( #(#doc_comment)* #(#methods)* )
    }

    pub(crate) fn group_id(&self) -> &Name {
        &self.group_id
    }

    pub(crate) fn group_methods(&self) -> TokenStream {
        let group_methods = &self.group_methods;
        quote!( #(#group_methods)* )
    }

    pub(crate) fn deprecations(&self) -> TokenStream {
        let deprecations = &self.deprecations;
        quote!( #(#deprecations)* )
    }

    pub(crate) fn next_display_order(&self) -> TokenStream {
        let next_display_order = self.next_display_order.as_ref().into_iter();
        quote!( #(#next_display_order)* )
    }

    pub(crate) fn next_help_heading(&self) -> TokenStream {
        let next_help_heading = self.next_help_heading.as_ref().into_iter();
        quote!( #(#next_help_heading)* )
    }

    pub(crate) fn id(&self) -> &Name {
        &self.name
    }

    pub(crate) fn cased_name(&self) -> TokenStream {
        self.name.clone().translate(*self.casing)
    }

    pub(crate) fn value_name(&self) -> TokenStream {
        self.name.clone().translate(CasingStyle::ScreamingSnake)
    }

    pub(crate) fn value_parser(&self, field_type: &Type) -> Method {
        self.value_parser
            .clone()
            .map(|p| {
                let inner_type = inner_type(field_type);
                p.resolve(inner_type)
            })
            .unwrap_or_else(|| {
                let inner_type = inner_type(field_type);
                if let Some(action) = self.action.as_ref() {
                    let span = action.span();
                    default_value_parser(inner_type, span)
                } else {
                    let span = self
                        .action
                        .as_ref()
                        .map(|a| a.span())
                        .unwrap_or_else(|| self.kind.span());
                    default_value_parser(inner_type, span)
                }
            })
    }

    pub(crate) fn action(&self, field_type: &Type) -> Method {
        self.action
            .clone()
            .map(|p| p.resolve(field_type))
            .unwrap_or_else(|| {
                if let Some(value_parser) = self.value_parser.as_ref() {
                    let span = value_parser.span();
                    default_action(field_type, span)
                } else {
                    let span = self
                        .value_parser
                        .as_ref()
                        .map(|a| a.span())
                        .unwrap_or_else(|| self.kind.span());
                    default_action(field_type, span)
                }
            })
    }

    pub(crate) fn kind(&self) -> Sp<Kind> {
        self.kind.clone()
    }

    pub(crate) fn is_positional(&self) -> bool {
        self.is_positional
    }

    pub(crate) fn casing(&self) -> Sp<CasingStyle> {
        self.casing
    }

    pub(crate) fn env_casing(&self) -> Sp<CasingStyle> {
        self.env_casing
    }

    pub(crate) fn has_explicit_methods(&self) -> bool {
        self.methods
            .iter()
            .any(|m| m.name != "help" && m.name != "long_help")
    }

    pub(crate) fn skip_group(&self) -> bool {
        self.skip_group
    }
}

#[derive(Clone)]
enum ValueParser {
    Explicit(Method),
    Implicit(Ident),
}

impl ValueParser {
    fn resolve(self, _inner_type: &Type) -> Method {
        match self {
            Self::Explicit(method) => method,
            Self::Implicit(ident) => default_value_parser(_inner_type, ident.span()),
        }
    }

    fn span(&self) -> Span {
        match self {
            Self::Explicit(method) => method.name.span(),
            Self::Implicit(ident) => ident.span(),
        }
    }
}

fn default_value_parser(inner_type: &Type, span: Span) -> Method {
    let func = Ident::new("value_parser", span);
    Method::new(
        func,
        quote_spanned! { span=>
            clap::value_parser!(#inner_type)
        },
    )
}

#[derive(Clone)]
pub(crate) enum Action {
    Explicit(Method),
    Implicit(Ident),
}

impl Action {
    pub(crate) fn resolve(self, _field_type: &Type) -> Method {
        match self {
            Self::Explicit(method) => method,
            Self::Implicit(ident) => default_action(_field_type, ident.span()),
        }
    }

    pub(crate) fn span(&self) -> Span {
        match self {
            Self::Explicit(method) => method.name.span(),
            Self::Implicit(ident) => ident.span(),
        }
    }
}

fn default_action(field_type: &Type, span: Span) -> Method {
    let ty = Ty::from_syn_ty(field_type);
    let args = match *ty {
        Ty::Vec | Ty::OptionVec | Ty::VecVec | Ty::OptionVecVec => {
            quote_spanned! { span=>
                clap::ArgAction::Append
            }
        }
        Ty::Option | Ty::OptionOption => {
            quote_spanned! { span=>
                clap::ArgAction::Set
            }
        }
        _ => {
            if is_simple_ty(field_type, "bool") {
                quote_spanned! { span=>
                    clap::ArgAction::SetTrue
                }
            } else {
                quote_spanned! { span=>
                    clap::ArgAction::Set
                }
            }
        }
    };

    let func = Ident::new("action", span);
    Method::new(func, args)
}

#[allow(clippy::large_enum_variant)]
#[derive(Clone)]
pub(crate) enum Kind {
    Arg(Sp<Ty>),
    Command(Sp<Ty>),
    Value,
    FromGlobal(Sp<Ty>),
    Subcommand(Sp<Ty>),
    Flatten(Sp<Ty>),
    Skip(Option<AttrValue>, AttrKind),
    ExternalSubcommand,
}

impl Kind {
    pub(crate) fn name(&self) -> &'static str {
        match self {
            Self::Arg(_) => "arg",
            Self::Command(_) => "command",
            Self::Value => "value",
            Self::FromGlobal(_) => "from_global",
            Self::Subcommand(_) => "subcommand",
            Self::Flatten(_) => "flatten",
            Self::Skip(_, _) => "skip",
            Self::ExternalSubcommand => "external_subcommand",
        }
    }

    pub(crate) fn attr_kind(&self) -> AttrKind {
        match self {
            Self::Arg(_) => AttrKind::Arg,
            Self::Command(_) => AttrKind::Command,
            Self::Value => AttrKind::Value,
            Self::FromGlobal(_) => AttrKind::Arg,
            Self::Subcommand(_) => AttrKind::Command,
            Self::Flatten(_) => AttrKind::Command,
            Self::Skip(_, kind) => *kind,
            Self::ExternalSubcommand => AttrKind::Command,
        }
    }

    pub(crate) fn ty(&self) -> Option<&Sp<Ty>> {
        match self {
            Self::Arg(ty)
            | Self::Command(ty)
            | Self::Flatten(ty)
            | Self::FromGlobal(ty)
            | Self::Subcommand(ty) => Some(ty),
            Self::Value | Self::Skip(_, _) | Self::ExternalSubcommand => None,
        }
    }
}

#[derive(Clone)]
pub(crate) struct Method {
    name: Ident,
    args: TokenStream,
}

impl Method {
    pub(crate) fn new(name: Ident, args: TokenStream) -> Self {
        Method { name, args }
    }

    fn from_env(ident: Ident, env_var: &str) -> Result<Option<Self>, syn::Error> {
        let mut lit = match env::var(env_var) {
            Ok(val) => {
                if val.is_empty() {
                    return Ok(None);
                }
                LitStr::new(&val, ident.span())
            }
            Err(_) => {
                abort!(
                    ident,
                    "cannot derive `{}` from Cargo.toml\n\n= note: {note}\n\n= help: {help}\n\n",
                    ident,
                    note = format_args!("`{env_var}` environment variable is not set"),
                    help = format_args!("use `{ident} = \"...\"` to set {ident} manually")
                );
            }
        };

        if ident == "author" {
            let edited = process_author_str(&lit.value());
            lit = LitStr::new(&edited, lit.span());
        }

        Ok(Some(Method::new(ident, quote!(#lit))))
    }

    pub(crate) fn args(&self) -> &TokenStream {
        &self.args
    }
}

impl ToTokens for Method {
    fn to_tokens(&self, ts: &mut TokenStream) {
        let Method { ref name, ref args } = self;

        let tokens = quote!( .#name(#args) );

        tokens.to_tokens(ts);
    }
}

#[derive(Clone)]
pub(crate) struct Deprecation {
    pub(crate) span: Span,
    pub(crate) id: &'static str,
    pub(crate) version: &'static str,
    pub(crate) description: String,
}

impl Deprecation {
    fn attribute(version: &'static str, old: AttrKind, new: AttrKind, span: Span) -> Self {
        Self {
            span,
            id: "old_attribute",
            version,
            description: format!(
                "Attribute `#[{}(...)]` has been deprecated in favor of `#[{}(...)]`",
                old.as_str(),
                new.as_str()
            ),
        }
    }
}

impl ToTokens for Deprecation {
    fn to_tokens(&self, ts: &mut TokenStream) {
        let tokens = if cfg!(feature = "deprecated") {
            let Deprecation {
                span,
                id,
                version,
                description,
            } = self;
            let span = *span;
            let id = Ident::new(id, span);

            quote_spanned!(span=> {
                #[deprecated(since = #version, note = #description)]
                fn #id() {}
                #id();
            })
        } else {
            quote!()
        };

        tokens.to_tokens(ts);
    }
}

fn assert_attr_kind(attr: &ClapAttr, possible_kind: &[AttrKind]) -> Result<(), syn::Error> {
    if *attr.kind.get() == AttrKind::Clap || *attr.kind.get() == AttrKind::StructOpt {
        // deprecated
    } else if !possible_kind.contains(attr.kind.get()) {
        let options = possible_kind
            .iter()
            .map(|k| format!("`#[{}({})]`", k.as_str(), attr.name))
            .collect::<Vec<_>>();
        abort!(
            attr.name,
            "Unknown `#[{}({})]` attribute ({} exists)",
            attr.kind.as_str(),
            attr.name,
            options.join(", ")
        );
    }
    Ok(())
}

/// replace all `:` with `, ` when not inside the `<>`
///
/// `"author1:author2:author3" => "author1, author2, author3"`
/// `"author1 <http://website1.com>:author2" => "author1 <http://website1.com>, author2"`
fn process_author_str(author: &str) -> String {
    let mut res = String::with_capacity(author.len());
    let mut inside_angle_braces = 0usize;

    for ch in author.chars() {
        if inside_angle_braces > 0 && ch == '>' {
            inside_angle_braces -= 1;
            res.push(ch);
        } else if ch == '<' {
            inside_angle_braces += 1;
            res.push(ch);
        } else if inside_angle_braces == 0 && ch == ':' {
            res.push_str(", ");
        } else {
            res.push(ch);
        }
    }

    res
}

/// Defines the casing for the attributes long representation.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub(crate) enum CasingStyle {
    /// Indicate word boundaries with uppercase letter, excluding the first word.
    Camel,
    /// Keep all letters lowercase and indicate word boundaries with hyphens.
    Kebab,
    /// Indicate word boundaries with uppercase letter, including the first word.
    Pascal,
    /// Keep all letters uppercase and indicate word boundaries with underscores.
    ScreamingSnake,
    /// Keep all letters lowercase and indicate word boundaries with underscores.
    Snake,
    /// Keep all letters lowercase and remove word boundaries.
    Lower,
    /// Keep all letters uppercase and remove word boundaries.
    Upper,
    /// Use the original attribute name defined in the code.
    Verbatim,
}

impl CasingStyle {
    fn from_lit(name: &LitStr) -> Result<Sp<Self>, syn::Error> {
        use self::CasingStyle::{
            Camel, Kebab, Lower, Pascal, ScreamingSnake, Snake, Upper, Verbatim,
        };

        let normalized = name.value().to_upper_camel_case().to_lowercase();
        let cs = |kind| Sp::new(kind, name.span());

        let s = match normalized.as_ref() {
            "camel" | "camelcase" => cs(Camel),
            "kebab" | "kebabcase" => cs(Kebab),
            "pascal" | "pascalcase" => cs(Pascal),
            "screamingsnake" | "screamingsnakecase" => cs(ScreamingSnake),
            "snake" | "snakecase" => cs(Snake),
            "lower" | "lowercase" => cs(Lower),
            "upper" | "uppercase" => cs(Upper),
            "verbatim" | "verbatimcase" => cs(Verbatim),
            s => abort!(name, "unsupported casing: `{s}`"),
        };
        Ok(s)
    }
}

#[derive(Clone)]
pub(crate) enum Name {
    Derived(Ident),
    Assigned(TokenStream),
}

impl Name {
    pub(crate) fn translate(self, style: CasingStyle) -> TokenStream {
        use CasingStyle::{Camel, Kebab, Lower, Pascal, ScreamingSnake, Snake, Upper, Verbatim};

        match self {
            Name::Assigned(tokens) => tokens,
            Name::Derived(ident) => {
                let s = ident.unraw().to_string();
                let s = match style {
                    Pascal => s.to_upper_camel_case(),
                    Kebab => s.to_kebab_case(),
                    Camel => s.to_lower_camel_case(),
                    ScreamingSnake => s.to_shouty_snake_case(),
                    Snake => s.to_snake_case(),
                    Lower => s.to_snake_case().replace('_', ""),
                    Upper => s.to_shouty_snake_case().replace('_', ""),
                    Verbatim => s,
                };
                quote_spanned!(ident.span()=> #s)
            }
        }
    }

    pub(crate) fn translate_char(self, style: CasingStyle) -> TokenStream {
        use CasingStyle::{Camel, Kebab, Lower, Pascal, ScreamingSnake, Snake, Upper, Verbatim};

        match self {
            Name::Assigned(tokens) => quote!( (#tokens).chars().next().unwrap() ),
            Name::Derived(ident) => {
                let s = ident.unraw().to_string();
                let s = match style {
                    Pascal => s.to_upper_camel_case(),
                    Kebab => s.to_kebab_case(),
                    Camel => s.to_lower_camel_case(),
                    ScreamingSnake => s.to_shouty_snake_case(),
                    Snake => s.to_snake_case(),
                    Lower => s.to_snake_case(),
                    Upper => s.to_shouty_snake_case(),
                    Verbatim => s,
                };

                let s = s.chars().next().unwrap();
                quote_spanned!(ident.span()=> #s)
            }
        }
    }
}

impl ToTokens for Name {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        match self {
            Name::Assigned(t) => t.to_tokens(tokens),
            Name::Derived(ident) => {
                let s = ident.unraw().to_string();
                quote_spanned!(ident.span()=> #s).to_tokens(tokens);
            }
        }
    }
}

```

`clap/clap_derive/src/lib.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

#![doc = include_str!("../README.md")]
#![doc(html_logo_url = "https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png")]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![forbid(unsafe_code)]
#![warn(missing_docs)]
#![warn(clippy::print_stderr)]
#![warn(clippy::print_stdout)]

use proc_macro::TokenStream;
use syn::{parse_macro_input, DeriveInput};
use syn::{Data, DataStruct, Fields};

#[macro_use]
mod macros;

mod attr;
mod derives;
mod dummies;
mod item;
mod utils;

/// Generates the `ValueEnum` impl.
#[proc_macro_derive(ValueEnum, attributes(clap, value))]
pub fn value_enum(input: TokenStream) -> TokenStream {
    let input: DeriveInput = parse_macro_input!(input);
    derives::derive_value_enum(&input)
        .unwrap_or_else(|err| {
            let dummy = dummies::value_enum(&input.ident);
            to_compile_error(err, dummy)
        })
        .into()
}

/// Generates the `Parser` implementation.
///
/// This is far less verbose than defining the `clap::Command` struct manually,
/// receiving an instance of `clap::ArgMatches` from conducting parsing, and then
/// implementing a conversion code to instantiate an instance of the user
/// context struct.
#[proc_macro_derive(Parser, attributes(clap, structopt, command, arg, group))]
pub fn parser(input: TokenStream) -> TokenStream {
    let input: DeriveInput = parse_macro_input!(input);
    derives::derive_parser(&input)
        .unwrap_or_else(|err| {
            let specific_dummy = match input.data {
                Data::Struct(DataStruct {
                    fields: Fields::Named(ref _fields),
                    ..
                }) => Some(dummies::args(&input.ident)),
                Data::Struct(DataStruct {
                    fields: Fields::Unit,
                    ..
                }) => Some(dummies::args(&input.ident)),
                Data::Enum(_) => Some(dummies::subcommand(&input.ident)),
                _ => None,
            };
            let dummy = specific_dummy
                .map(|specific_dummy| {
                    let parser_dummy = dummies::parser(&input.ident);
                    quote::quote! {
                        #parser_dummy
                        #specific_dummy
                    }
                })
                .unwrap_or_else(|| quote::quote!());
            to_compile_error(err, dummy)
        })
        .into()
}

/// Generates the `Subcommand` impl.
#[proc_macro_derive(Subcommand, attributes(clap, command, arg, group))]
pub fn subcommand(input: TokenStream) -> TokenStream {
    let input: DeriveInput = parse_macro_input!(input);
    derives::derive_subcommand(&input)
        .unwrap_or_else(|err| {
            let dummy = dummies::subcommand(&input.ident);
            to_compile_error(err, dummy)
        })
        .into()
}

/// Generates the `Args` impl.
#[proc_macro_derive(Args, attributes(clap, command, arg, group))]
pub fn args(input: TokenStream) -> TokenStream {
    let input: DeriveInput = parse_macro_input!(input);
    derives::derive_args(&input)
        .unwrap_or_else(|err| {
            let dummy = dummies::args(&input.ident);
            to_compile_error(err, dummy)
        })
        .into()
}

fn to_compile_error(
    error: syn::Error,
    dummy: proc_macro2::TokenStream,
) -> proc_macro2::TokenStream {
    let compile_errors = error.to_compile_error();
    quote::quote!(
        #dummy
        #compile_errors
    )
}

```

`clap/clap_derive/src/macros.rs`:

```rs
macro_rules! format_err {
    ($obj:expr, $($format:tt)+) => {{
        #[allow(unused_imports)]
        use $crate::utils::error::*;
        let msg = format!($($format)+);
        $obj.EXPECTED_Span_OR_ToTokens(msg)
    }};
}

macro_rules! abort {
    ($obj:expr, $($format:tt)+) => {{
        return Err(format_err!($obj, $($format)+));
    }};
}

macro_rules! abort_call_site {
    ($($format:tt)+) => {{
        let span = proc_macro2::Span::call_site();
        abort!(span, $($format)+)
    }};
}

```

`clap/clap_derive/src/utils/doc_comments.rs`:

```rs
//! The preprocessing we apply to doc comments.
//!
//! #[derive(Parser)] works in terms of "paragraphs". Paragraph is a sequence of
//! non-empty adjacent lines, delimited by sequences of blank (whitespace only) lines.

#[cfg(feature = "unstable-markdown")]
use markdown::parse_markdown;

pub(crate) fn extract_doc_comment(attrs: &[syn::Attribute]) -> Vec<String> {
    // multiline comments (`/** ... */`) may have LFs (`\n`) in them,
    // we need to split so we could handle the lines correctly
    //
    // we also need to remove leading and trailing blank lines
    let mut lines: Vec<_> = attrs
        .iter()
        .filter(|attr| attr.path().is_ident("doc"))
        .filter_map(|attr| {
            // non #[doc = "..."] attributes are not our concern
            // we leave them for rustc to handle
            match &attr.meta {
                syn::Meta::NameValue(syn::MetaNameValue {
                    value:
                        syn::Expr::Lit(syn::ExprLit {
                            lit: syn::Lit::Str(s),
                            ..
                        }),
                    ..
                }) => Some(s.value()),
                _ => None,
            }
        })
        .skip_while(|s| is_blank(s))
        .flat_map(|s| {
            let lines = s
                .split('\n')
                .map(|s| {
                    // remove one leading space no matter what
                    let s = s.strip_prefix(' ').unwrap_or(s);
                    s.to_owned()
                })
                .collect::<Vec<_>>();
            lines
        })
        .collect();

    while let Some(true) = lines.last().map(|s| is_blank(s)) {
        lines.pop();
    }

    lines
}

pub(crate) fn format_doc_comment(
    lines: &[String],
    preprocess: bool,
    force_long: bool,
) -> (Option<String>, Option<String>) {
    if preprocess {
        let (short, long) = parse_markdown(lines);
        let long = long.or_else(|| force_long.then(|| short.clone()));

        (Some(remove_period(short)), long)
    } else if let Some(first_blank) = lines.iter().position(|s| is_blank(s)) {
        let short = lines[..first_blank].join("\n");
        let long = lines.join("\n");

        (Some(short), Some(long))
    } else {
        let short = lines.join("\n");
        let long = force_long.then(|| short.clone());

        (Some(short), long)
    }
}

#[cfg(not(feature = "unstable-markdown"))]
fn split_paragraphs(lines: &[String]) -> Vec<String> {
    use std::iter;

    let mut last_line = 0;
    iter::from_fn(|| {
        let slice = &lines[last_line..];
        let start = slice.iter().position(|s| !is_blank(s)).unwrap_or(0);

        let slice = &slice[start..];
        let len = slice
            .iter()
            .position(|s| is_blank(s))
            .unwrap_or(slice.len());

        last_line += start + len;

        if len != 0 {
            Some(merge_lines(&slice[..len]))
        } else {
            None
        }
    })
    .collect()
}

fn remove_period(mut s: String) -> String {
    if s.ends_with('.') && !s.ends_with("..") {
        s.pop();
    }
    s
}

fn is_blank(s: &str) -> bool {
    s.trim().is_empty()
}

#[cfg(not(feature = "unstable-markdown"))]
fn merge_lines(lines: impl IntoIterator<Item = impl AsRef<str>>) -> String {
    lines
        .into_iter()
        .map(|s| s.as_ref().trim().to_owned())
        .collect::<Vec<_>>()
        .join(" ")
}

#[cfg(not(feature = "unstable-markdown"))]
fn parse_markdown(lines: &[String]) -> (String, Option<String>) {
    if lines.iter().any(|s| is_blank(s)) {
        let paragraphs = split_paragraphs(lines);
        let short = paragraphs[0].clone();
        let long = paragraphs.join("\n\n");
        (short, Some(long))
    } else {
        let short = merge_lines(lines);
        (short, None)
    }
}

#[cfg(feature = "unstable-markdown")]
mod markdown {
    use anstyle::{Reset, Style};
    use pulldown_cmark::{Event, Options, Parser, Tag, TagEnd};
    use std::fmt;
    use std::fmt::Write;
    use std::ops::AddAssign;

    #[derive(Default)]
    struct MarkdownWriter {
        output: String,
        /// Prefix inserted for each line.
        prefix: String,
        /// Should an empty line be inserted before the next anything.
        hanging_paragraph: bool,
        /// Are we in an empty line
        dirty_line: bool,
        styles: Vec<Style>,
    }

    impl MarkdownWriter {
        fn newline(&mut self) {
            self.reset();
            self.output.push('\n');
            self.dirty_line = false;
        }
        fn endline(&mut self) {
            if self.dirty_line {
                self.newline();
            }
        }
        fn new_paragraph(&mut self) {
            self.endline();
            self.hanging_paragraph = true;
        }

        fn write_fmt(&mut self, arguments: fmt::Arguments<'_>) {
            if self.hanging_paragraph {
                self.hanging_paragraph = false;
                self.newline();
            }
            if !self.dirty_line {
                self.output.push_str(&self.prefix);
                self.apply_styles();
                self.dirty_line = true;
            }
            self.output.write_fmt(arguments).unwrap();
        }

        fn start_link(&mut self, dest_url: pulldown_cmark::CowStr<'_>) {
            write!(self, "\x1B]8;;{dest_url}\x1B\\");
        }
        fn end_link(&mut self) {
            write!(self, "\x1B]8;;\x1B\\");
        }

        fn start_style(&mut self, style: Style) {
            self.styles.push(style);
            write!(self, "{style}");
        }
        fn end_style(&mut self, style: Style) {
            let last_style = self.styles.pop();
            debug_assert_eq!(last_style.unwrap(), style);

            write!(self, "{Reset}");
            self.apply_styles();
        }

        fn reset(&mut self) {
            write!(self, "{Reset}");
        }

        fn apply_styles(&mut self) {
            // Reapplying all, because anstyle doesn't support merging styles
            // (probably because the ambiguity around colors)
            // TODO If we decide not to support any colors, we can replace this with
            // anstyle::Effects and remove the need for applying them all individually.
            for style in &self.styles {
                write!(self.output, "{style}").unwrap();
            }
        }

        fn remove_prefix(&mut self, quote_prefix: &str) {
            debug_assert!(self.prefix.ends_with(quote_prefix));
            let new_len = self.prefix.len() - quote_prefix.len();
            self.prefix.truncate(new_len);
        }

        fn add_prefix(&mut self, quote_prefix: &str) {
            if self.hanging_paragraph {
                self.hanging_paragraph = false;
                self.newline();
            }
            self.prefix += quote_prefix;
        }
    }

    pub(super) fn parse_markdown(input: &[String]) -> (String, Option<String>) {
        // Markdown Configuration
        let parsing_options = Options::ENABLE_STRIKETHROUGH;
        // Minimal Styling for now, because we cannot configure it
        let style_heading = Style::new().bold().underline();
        let style_emphasis = Style::new().italic();
        let style_strong = Style::new().bold();
        let style_strike_through = Style::new().strikethrough();
        let style_link = Style::new().underline();
        let style_code = Style::new().bold();
        let list_symbol = '-';
        let quote_prefix = "| ";
        let indentation = "  ";

        let input = input.join("\n");
        let input = Parser::new_ext(&input, parsing_options);

        let mut short = None;
        let mut has_details = false;

        let mut writer = MarkdownWriter::default();

        let mut list_indices = Vec::new();

        for event in input {
            if short.is_some() {
                has_details = true;
            }
            match event {
                Event::Start(Tag::Paragraph) => { /* nothing to do */ }
                Event::End(TagEnd::Paragraph) => {
                    if short.is_none() {
                        short = Some(writer.output.trim().to_owned());
                    }
                    writer.new_paragraph();
                }

                Event::Start(Tag::Heading { .. }) => writer.start_style(style_heading),
                Event::End(TagEnd::Heading(..)) => {
                    writer.end_style(style_heading);
                    writer.new_paragraph();
                }

                Event::Start(Tag::Image { .. } | Tag::HtmlBlock) => { /* IGNORED */ }
                Event::End(TagEnd::Image) => { /* IGNORED */ }
                Event::End(TagEnd::HtmlBlock) => writer.new_paragraph(),

                Event::Start(Tag::BlockQuote(_)) => writer.add_prefix(quote_prefix),
                Event::End(TagEnd::BlockQuote(_)) => {
                    writer.remove_prefix(quote_prefix);
                    writer.new_paragraph();
                }

                Event::Start(Tag::CodeBlock(_)) => {
                    writer.add_prefix(indentation);
                    writer.start_style(style_code);
                }
                Event::End(TagEnd::CodeBlock) => {
                    writer.remove_prefix(indentation);
                    writer.end_style(style_code);
                    writer.dirty_line = false;
                    writer.hanging_paragraph = true;
                }

                Event::Start(Tag::List(list_start)) => {
                    list_indices.push(list_start);
                    writer.endline();
                }
                Event::End(TagEnd::List(_)) => {
                    let list = list_indices.pop();
                    debug_assert!(list.is_some());
                    if list_indices.is_empty() {
                        writer.new_paragraph();
                    }
                }
                Event::Start(Tag::Item) => {
                    if let Some(Some(index)) = list_indices.last_mut() {
                        write!(writer, "{index}. ");
                        index.add_assign(1);
                    } else {
                        write!(writer, "{list_symbol} ");
                    }
                    writer.add_prefix(indentation);
                }
                Event::End(TagEnd::Item) => {
                    writer.remove_prefix(indentation);
                    writer.endline();
                }

                Event::Start(Tag::Emphasis) => writer.start_style(style_emphasis),
                Event::End(TagEnd::Emphasis) => writer.end_style(style_emphasis),
                Event::Start(Tag::Strong) => writer.start_style(style_strong),
                Event::End(TagEnd::Strong) => writer.end_style(style_strong),
                Event::Start(Tag::Strikethrough) => writer.start_style(style_strike_through),
                Event::End(TagEnd::Strikethrough) => writer.end_style(style_strike_through),

                Event::Start(Tag::Link { dest_url, .. }) => {
                    writer.start_link(dest_url);
                    writer.start_style(style_link);
                }
                Event::End(TagEnd::Link) => {
                    writer.end_link();
                    writer.end_style(style_link);
                }

                Event::Text(segment) => {
                    // split into lines to support code blocks
                    let mut lines = segment.lines();
                    // `.lines()`  always returns at least one
                    write!(writer, "{}", lines.next().unwrap());
                    for line in lines {
                        writer.endline();
                        write!(writer, "{line}");
                    }
                    if segment.ends_with('\n') {
                        writer.endline();
                    }
                }

                Event::Code(code) => {
                    writer.start_style(style_code);
                    write!(writer, "{code}");
                    writer.end_style(style_code);
                }

                // There is not really anything useful to do with block level html.
                Event::Html(html) => write!(writer, "{html}"),
                // At some point we could support custom tags like `<red>`
                Event::InlineHtml(html) => write!(writer, "{html}"),
                Event::SoftBreak => write!(writer, " "),
                Event::HardBreak => writer.endline(),

                Event::Rule => {
                    writer.new_paragraph();
                    write!(writer, "---");
                    writer.new_paragraph();
                }

                // Markdown features currently not supported
                Event::Start(
                    Tag::FootnoteDefinition(_)
                    | Tag::DefinitionList
                    | Tag::DefinitionListTitle
                    | Tag::DefinitionListDefinition
                    | Tag::Table(_)
                    | Tag::TableHead
                    | Tag::TableRow
                    | Tag::TableCell
                    | Tag::MetadataBlock(_)
                    | Tag::Superscript
                    | Tag::Subscript,
                )
                | Event::End(
                    TagEnd::FootnoteDefinition
                    | TagEnd::DefinitionList
                    | TagEnd::DefinitionListTitle
                    | TagEnd::DefinitionListDefinition
                    | TagEnd::Table
                    | TagEnd::TableHead
                    | TagEnd::TableRow
                    | TagEnd::TableCell
                    | TagEnd::MetadataBlock(_)
                    | TagEnd::Superscript
                    | TagEnd::Subscript,
                )
                | Event::InlineMath(_)
                | Event::DisplayMath(_)
                | Event::FootnoteReference(_)
                | Event::TaskListMarker(_) => {
                    unimplemented!("feature not enabled {event:?}")
                }
            }
        }
        let short = short.unwrap_or_else(|| writer.output.trim_end().to_owned());
        let long = writer.output.trim_end();
        let long = has_details.then(|| long.to_owned());
        (short, long)
    }
}

```

`clap/clap_derive/src/utils/error.rs`:

```rs
pub(crate) trait SpanError {
    #[allow(non_snake_case)]
    fn EXPECTED_Span_OR_ToTokens<D: std::fmt::Display>(&self, msg: D) -> syn::Error;
}

pub(crate) trait ToTokensError {
    #[allow(non_snake_case)]
    fn EXPECTED_Span_OR_ToTokens<D: std::fmt::Display>(&self, msg: D) -> syn::Error;
}

impl<T: quote::ToTokens> ToTokensError for T {
    fn EXPECTED_Span_OR_ToTokens<D: std::fmt::Display>(&self, msg: D) -> syn::Error {
        // Curb monomorphization from generating too many identical `new_spanned`.
        syn::Error::new_spanned(self.to_token_stream(), msg)
    }
}

impl SpanError for proc_macro2::Span {
    fn EXPECTED_Span_OR_ToTokens<D: std::fmt::Display>(&self, msg: D) -> syn::Error {
        syn::Error::new(*self, msg)
    }
}

```

`clap/clap_derive/src/utils/mod.rs`:

```rs
pub(crate) mod error;

mod doc_comments;
mod spanned;
mod ty;

pub(crate) use doc_comments::extract_doc_comment;
pub(crate) use doc_comments::format_doc_comment;

pub(crate) use self::{
    spanned::Sp,
    ty::{inner_type, is_simple_ty, sub_type, subty_if_name, Ty},
};

```

`clap/clap_derive/src/utils/spanned.rs`:

```rs
use proc_macro2::{Ident, Span, TokenStream};
use quote::ToTokens;
use syn::LitStr;

use std::ops::{Deref, DerefMut};

/// An entity with a span attached.
#[derive(Debug, Copy, Clone)]
pub(crate) struct Sp<T> {
    val: T,
    span: Span,
}

impl<T> Sp<T> {
    pub(crate) fn new(val: T, span: Span) -> Self {
        Sp { val, span }
    }

    pub(crate) fn get(&self) -> &T {
        &self.val
    }

    pub(crate) fn span(&self) -> Span {
        self.span
    }
}

impl<T> Deref for Sp<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.val
    }
}

impl<T> DerefMut for Sp<T> {
    fn deref_mut(&mut self) -> &mut T {
        &mut self.val
    }
}

impl From<Ident> for Sp<String> {
    fn from(ident: Ident) -> Self {
        Sp {
            val: ident.to_string(),
            span: ident.span(),
        }
    }
}

impl From<LitStr> for Sp<String> {
    fn from(lit: LitStr) -> Self {
        Sp {
            val: lit.value(),
            span: lit.span(),
        }
    }
}

impl<'a> From<Sp<&'a str>> for Sp<String> {
    fn from(sp: Sp<&'a str>) -> Self {
        Sp::new(sp.val.into(), sp.span)
    }
}

impl<U, T: PartialEq<U>> PartialEq<U> for Sp<T> {
    fn eq(&self, other: &U) -> bool {
        self.val == *other
    }
}

impl<T: AsRef<str>> AsRef<str> for Sp<T> {
    fn as_ref(&self) -> &str {
        self.val.as_ref()
    }
}

impl<T: ToTokens> ToTokens for Sp<T> {
    fn to_tokens(&self, stream: &mut TokenStream) {
        // this is the simplest way out of correct ones to change span on
        // arbitrary token tree I could come up with
        let tt = self.val.to_token_stream().into_iter().map(|mut tt| {
            tt.set_span(self.span);
            tt
        });

        stream.extend(tt);
    }
}

```

`clap/clap_derive/src/utils/ty.rs`:

```rs
//! Special types handling

use super::spanned::Sp;

use syn::{
    spanned::Spanned, GenericArgument, Path, PathArguments, PathArguments::AngleBracketed,
    PathSegment, Type, TypePath,
};

#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub(crate) enum Ty {
    Unit,
    Vec,
    VecVec,
    Option,
    OptionOption,
    OptionVec,
    OptionVecVec,
    Other,
}

impl Ty {
    pub(crate) fn from_syn_ty(ty: &Type) -> Sp<Self> {
        use self::Ty::{Option, OptionOption, OptionVec, OptionVecVec, Other, Unit, Vec, VecVec};
        let t = |kind| Sp::new(kind, ty.span());

        if is_unit_ty(ty) {
            t(Unit)
        } else if let Some(vt) = get_vec_ty(ty, Vec, VecVec) {
            t(vt)
        } else if let Some(subty) = subty_if_name(ty, "Option") {
            if is_generic_ty(subty, "Option") {
                t(OptionOption)
            } else if let Some(vt) = get_vec_ty(subty, OptionVec, OptionVecVec) {
                t(vt)
            } else {
                t(Option)
            }
        } else {
            t(Other)
        }
    }

    pub(crate) fn as_str(&self) -> &'static str {
        match self {
            Self::Unit => "()",
            Self::Vec => "Vec<T>",
            Self::Option => "Option<T>",
            Self::OptionOption => "Option<Option<T>>",
            Self::OptionVec => "Option<Vec<T>>",
            Self::VecVec => "Vec<Vec<T>>",
            Self::OptionVecVec => "Option<Vec<Vec<T>>>",
            Self::Other => "...other...",
        }
    }
}

pub(crate) fn inner_type(field_ty: &Type) -> &Type {
    let ty = Ty::from_syn_ty(field_ty);
    match *ty {
        Ty::Vec | Ty::Option => sub_type(field_ty).unwrap_or(field_ty),
        Ty::OptionOption | Ty::OptionVec | Ty::VecVec => {
            sub_type(field_ty).and_then(sub_type).unwrap_or(field_ty)
        }
        Ty::OptionVecVec => sub_type(field_ty)
            .and_then(sub_type)
            .and_then(sub_type)
            .unwrap_or(field_ty),
        _ => field_ty,
    }
}

pub(crate) fn sub_type(ty: &Type) -> Option<&Type> {
    subty_if(ty, |_| true)
}

fn only_last_segment(mut ty: &Type) -> Option<&PathSegment> {
    while let Type::Group(syn::TypeGroup { elem, .. }) = ty {
        ty = elem;
    }
    match ty {
        Type::Path(TypePath {
            qself: None,
            path:
                Path {
                    leading_colon: None,
                    segments,
                },
        }) => only_one(segments.iter()),

        _ => None,
    }
}

fn subty_if<F>(ty: &Type, f: F) -> Option<&Type>
where
    F: FnOnce(&PathSegment) -> bool,
{
    only_last_segment(ty)
        .filter(|segment| f(segment))
        .and_then(|segment| {
            if let AngleBracketed(args) = &segment.arguments {
                only_one(args.args.iter()).and_then(|genneric| {
                    if let GenericArgument::Type(ty) = genneric {
                        Some(ty)
                    } else {
                        None
                    }
                })
            } else {
                None
            }
        })
}

pub(crate) fn subty_if_name<'a>(ty: &'a Type, name: &str) -> Option<&'a Type> {
    subty_if(ty, |seg| seg.ident == name)
}

pub(crate) fn is_simple_ty(ty: &Type, name: &str) -> bool {
    only_last_segment(ty)
        .map(|segment| {
            if let PathArguments::None = segment.arguments {
                segment.ident == name
            } else {
                false
            }
        })
        .unwrap_or(false)
}

fn is_generic_ty(ty: &Type, name: &str) -> bool {
    subty_if_name(ty, name).is_some()
}

fn is_unit_ty(ty: &Type) -> bool {
    if let Type::Tuple(tuple) = ty {
        tuple.elems.is_empty()
    } else {
        false
    }
}

fn only_one<I, T>(mut iter: I) -> Option<T>
where
    I: Iterator<Item = T>,
{
    iter.next().filter(|_| iter.next().is_none())
}

#[cfg(feature = "unstable-v5")]
fn get_vec_ty(ty: &Type, vec_ty: Ty, vecvec_ty: Ty) -> Option<Ty> {
    subty_if_name(ty, "Vec").map(|subty| {
        if is_generic_ty(subty, "Vec") {
            vecvec_ty
        } else {
            vec_ty
        }
    })
}

#[cfg(not(feature = "unstable-v5"))]
fn get_vec_ty(ty: &Type, vec_ty: Ty, _vecvec_ty: Ty) -> Option<Ty> {
    is_generic_ty(ty, "Vec").then_some(vec_ty)
}

```

`clap/clap_lex/CHANGELOG.md`:

```md
# Change Log
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/)
and this project adheres to [Semantic Versioning](http://semver.org/).

<!-- next-header -->
## [Unreleased] - ReleaseDate

## [0.7.4] - 2024-12-05

### Fixes

- Support `E` in numbers, not just `e`

## [0.7.3] - 2024-11-13

## [0.7.2] - 2024-07-25

## [0.7.1] - 2024-06-06

## [0.7.0] - 2024-02-08

### Compatibility

- Update MSRV to 1.74

### Fixes

- Improve `unsafe` code by using new `OsStr` API

## [0.6.0] - 2023-10-24

### Breaking Change

- Renamed `is_number` to more focused `is_negative_number`

### Performance

- Reduced code size

## [0.5.1] - 2023-08-24

### Compatibility

- Update MSRV to 1.70.0

## [0.5.0] - 2023-05-19

### Breaking Change

- Removed `OsStrExt::split_at`

## [0.4.1] - 2023-03-28

### Compatibility

- Deprecated `OsStrExt::split_at` as its unsound

## [0.4.0] - 2023-03-25

### Breaking Change

- `RawOsStr` and `RawOsString` are no long exported
- Return types were changed from `RawOsStr` to `OsStr`

### Features

- `OsStrExt` trait added to help with processing `OsStr`s

### Performance

- `os_str_bytes` dependency was dropped to improve build times and reduce binary size

## [0.3.3] - 2023-03-16

## [0.3.2] - 2023-02-23

## [0.3.1] - 2023-01-13

### Compatibility

MSRV changed to 1.64.0

## [0.3.0] - 2022-09-20

### Breaking Changes

- `RawArgs::insert` now takes owned values

### Compatibility

- MSRV changed from 1.56.1 to 1.60.0

## [0.2.4] - 2022-06-28

## [0.2.3] - 2022-06-21

## [0.2.2] - 2022-06-13

## [0.2.1] - 2022-06-13

### Features

- Allow checking if at end of input

## [0.2.0] - 2022-04-30

### Breaking Changes

- Don't do prefix matching by default

## [0.1.1] - 2022-04-15

- Drop `memchr` dependency

<!-- next-url -->
[Unreleased]: https://github.com/clap-rs/clap/compare/clap_lex-v0.7.4...HEAD
[0.7.4]: https://github.com/clap-rs/clap/compare/clap_lex-v0.7.3...clap_lex-v0.7.4
[0.7.3]: https://github.com/clap-rs/clap/compare/clap_lex-v0.7.2...clap_lex-v0.7.3
[0.7.2]: https://github.com/clap-rs/clap/compare/clap_lex-v0.7.1...clap_lex-v0.7.2
[0.7.1]: https://github.com/clap-rs/clap/compare/clap_lex-v0.7.0...clap_lex-v0.7.1
[0.7.0]: https://github.com/clap-rs/clap/compare/clap_lex-v0.6.0...clap_lex-v0.7.0
[0.6.0]: https://github.com/clap-rs/clap/compare/clap_lex-v0.5.1...clap_lex-v0.6.0
[0.5.1]: https://github.com/clap-rs/clap/compare/clap_lex-v0.5.0...clap_lex-v0.5.1
[0.5.0]: https://github.com/clap-rs/clap/compare/clap_lex-v0.4.1...clap_lex-v0.5.0
[0.4.1]: https://github.com/clap-rs/clap/compare/clap_lex-v0.4.0...clap_lex-v0.4.1
[0.4.0]: https://github.com/clap-rs/clap/compare/clap_lex-v0.3.3...clap_lex-v0.4.0
[0.3.3]: https://github.com/clap-rs/clap/compare/clap_lex-v0.3.2...clap_lex-v0.3.3
[0.3.2]: https://github.com/clap-rs/clap/compare/clap_lex-v0.3.1...clap_lex-v0.3.2
[0.3.1]: https://github.com/clap-rs/clap/compare/clap_lex-v0.3.0...clap_lex-v0.3.1
[0.3.0]: https://github.com/clap-rs/clap/compare/clap_lex-v0.2.4...clap_lex-v0.3.0
[0.2.4]: https://github.com/clap-rs/clap/compare/clap_lex-v0.2.3...clap_lex-v0.2.4
[0.2.3]: https://github.com/clap-rs/clap/compare/clap_lex-v0.2.2...clap_lex-v0.2.3
[0.2.2]: https://github.com/clap-rs/clap/compare/clap_lex-v0.2.1...clap_lex-v0.2.2
[0.2.1]: https://github.com/clap-rs/clap/compare/clap_lex-v0.2.0...clap_lex-v0.2.1
[0.2.0]: https://github.com/clap-rs/clap/compare/clap_lex-v0.1.1...clap_lex-v0.2.0
[0.1.1]: https://github.com/clap-rs/clap/compare/ce71b08a3fe28c640dc6e17f6f5bb1452bd6d6d8...clap_lex-v0.1.1

```

`clap/clap_lex/CONTRIBUTING.md`:

```md
# How to Contribute

See the [clap-wide CONTRIBUTING.md](../CONTRIBUTING.md).  This will contain `clap_lex` specific notes.

```

`clap/clap_lex/Cargo.toml`:

```toml
[package]
name = "clap_lex"
version = "0.7.4"
description = "Minimal, flexible command line parser"
categories = ["command-line-interface"]
keywords = [
  "argument",
  "cli",
  "arg",
  "parser",
  "parse"
]
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
include.workspace = true

[package.metadata.release]
pre-release-replacements = [
  {file="CHANGELOG.md", search="Unreleased", replace="{{version}}", min=1},
  {file="CHANGELOG.md", search="\\.\\.\\.HEAD", replace="...{{tag_name}}", exactly=1},
  {file="CHANGELOG.md", search="ReleaseDate", replace="{{date}}", min=1},
  {file="CHANGELOG.md", search="<!-- next-header -->", replace="<!-- next-header -->\n## [Unreleased] - ReleaseDate\n", exactly=1},
  {file="CHANGELOG.md", search="<!-- next-url -->", replace="<!-- next-url -->\n[Unreleased]: https://github.com/clap-rs/clap/compare/{{tag_name}}...HEAD", exactly=1},
  {file="README.md", search="github.com/clap-rs/clap/blob/[^/]+/", replace="github.com/clap-rs/clap/blob/{{tag_name}}/", exactly=4, prerelease = true},
]

[dev-dependencies]
automod = "1.0.14"

[lib]
bench = false

[lints]
workspace = true

```

`clap/clap_lex/LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`clap/clap_lex/LICENSE-MIT`:

```
The MIT License (MIT)

Copyright (c) 2015-2022 Kevin B. Knapp and Clap Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`clap/clap_lex/README.md`:

```md
<!-- omit in TOC -->
# clap_lex

> **Minimal, flexible command line parser**

[![Crates.io](https://img.shields.io/crates/v/clap_lex?style=flat-square)](https://crates.io/crates/clap_lex)
[![Crates.io](https://img.shields.io/crates/d/clap_lex?style=flat-square)](https://crates.io/crates/clap_lex)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue?style=flat-square)](https://github.com/clap-rs/clap/blob/clap_lex-v0.7.4/LICENSE-APACHE)
[![License](https://img.shields.io/badge/license-MIT-blue?style=flat-square)](https://github.com/clap-rs/clap/blob/clap_lex-v0.7.4/LICENSE-MIT)

Dual-licensed under [Apache 2.0](LICENSE-APACHE) or [MIT](LICENSE-MIT).

1. [About](#about)
2. [API Reference](https://docs.rs/clap_lex)
3. [Questions & Discussions](https://github.com/clap-rs/clap/discussions)
4. [CONTRIBUTING](https://github.com/clap-rs/clap/blob/clap_lex-v0.7.4/clap_lex/CONTRIBUTING.md)
5. [Sponsors](https://github.com/clap-rs/clap/blob/clap_lex-v0.7.4/README.md#sponsors)

## About

```

`clap/clap_lex/src/ext.rs`:

```rs
use std::ffi::OsStr;

/// String-like methods for [`OsStr`]
pub trait OsStrExt: private::Sealed {
    /// Converts to a string slice.
    ///
    /// The `Utf8Error` is guaranteed to have a valid UTF8 boundary
    /// in its `valid_up_to()`
    fn try_str(&self) -> Result<&str, std::str::Utf8Error>;
    /// Returns `true` if the given pattern matches a sub-slice of
    /// this string slice.
    ///
    /// Returns `false` if it does not.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use clap_lex::OsStrExt as _;
    /// let bananas = std::ffi::OsStr::new("bananas");
    ///
    /// assert!(bananas.contains("nana"));
    /// assert!(!bananas.contains("apples"));
    /// ```
    fn contains(&self, needle: &str) -> bool;
    /// Returns the byte index of the first character of this string slice that
    /// matches the pattern.
    ///
    /// Returns [`None`] if the pattern doesn't match.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use clap_lex::OsStrExt as _;
    /// let s = std::ffi::OsStr::new("Löwe 老虎 Léopard Gepardi");
    ///
    /// assert_eq!(s.find("L"), Some(0));
    /// assert_eq!(s.find("é"), Some(14));
    /// assert_eq!(s.find("par"), Some(17));
    /// ```
    ///
    /// Not finding the pattern:
    ///
    /// ```rust
    /// use clap_lex::OsStrExt as _;
    /// let s = std::ffi::OsStr::new("Löwe 老虎 Léopard");
    ///
    /// assert_eq!(s.find("1"), None);
    /// ```
    fn find(&self, needle: &str) -> Option<usize>;
    /// Returns a string slice with the prefix removed.
    ///
    /// If the string starts with the pattern `prefix`, returns substring after the prefix, wrapped
    /// in `Some`.
    ///
    /// If the string does not start with `prefix`, returns `None`.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::ffi::OsStr;
    /// use clap_lex::OsStrExt as _;
    /// assert_eq!(OsStr::new("foo:bar").strip_prefix("foo:"), Some(OsStr::new("bar")));
    /// assert_eq!(OsStr::new("foo:bar").strip_prefix("bar"), None);
    /// assert_eq!(OsStr::new("foofoo").strip_prefix("foo"), Some(OsStr::new("foo")));
    /// ```
    fn strip_prefix(&self, prefix: &str) -> Option<&OsStr>;
    /// Returns `true` if the given pattern matches a prefix of this
    /// string slice.
    ///
    /// Returns `false` if it does not.
    ///
    /// # Examples
    ///
    /// ```
    /// use clap_lex::OsStrExt as _;
    /// let bananas = std::ffi::OsStr::new("bananas");
    ///
    /// assert!(bananas.starts_with("bana"));
    /// assert!(!bananas.starts_with("nana"));
    /// ```
    fn starts_with(&self, prefix: &str) -> bool;
    /// An iterator over substrings of this string slice, separated by
    /// characters matched by a pattern.
    ///
    /// # Examples
    ///
    /// Simple patterns:
    ///
    /// ```
    /// use std::ffi::OsStr;
    /// use clap_lex::OsStrExt as _;
    /// let v: Vec<_> = OsStr::new("Mary had a little lamb").split(" ").collect();
    /// assert_eq!(v, [OsStr::new("Mary"), OsStr::new("had"), OsStr::new("a"), OsStr::new("little"), OsStr::new("lamb")]);
    ///
    /// let v: Vec<_> = OsStr::new("").split("X").collect();
    /// assert_eq!(v, [OsStr::new("")]);
    ///
    /// let v: Vec<_> = OsStr::new("lionXXtigerXleopard").split("X").collect();
    /// assert_eq!(v, [OsStr::new("lion"), OsStr::new(""), OsStr::new("tiger"), OsStr::new("leopard")]);
    ///
    /// let v: Vec<_> = OsStr::new("lion::tiger::leopard").split("::").collect();
    /// assert_eq!(v, [OsStr::new("lion"), OsStr::new("tiger"), OsStr::new("leopard")]);
    /// ```
    ///
    /// If a string contains multiple contiguous separators, you will end up
    /// with empty strings in the output:
    ///
    /// ```
    /// use std::ffi::OsStr;
    /// use clap_lex::OsStrExt as _;
    /// let x = OsStr::new("||||a||b|c");
    /// let d: Vec<_> = x.split("|").collect();
    ///
    /// assert_eq!(d, &[OsStr::new(""), OsStr::new(""), OsStr::new(""), OsStr::new(""), OsStr::new("a"), OsStr::new(""), OsStr::new("b"), OsStr::new("c")]);
    /// ```
    ///
    /// Contiguous separators are separated by the empty string.
    ///
    /// ```
    /// use std::ffi::OsStr;
    /// use clap_lex::OsStrExt as _;
    /// let x = OsStr::new("(///)");
    /// let d: Vec<_> = x.split("/").collect();
    ///
    /// assert_eq!(d, &[OsStr::new("("), OsStr::new(""), OsStr::new(""), OsStr::new(")")]);
    /// ```
    ///
    /// Separators at the start or end of a string are neighbored
    /// by empty strings.
    ///
    /// ```
    /// use std::ffi::OsStr;
    /// use clap_lex::OsStrExt as _;
    /// let d: Vec<_> = OsStr::new("010").split("0").collect();
    /// assert_eq!(d, &[OsStr::new(""), OsStr::new("1"), OsStr::new("")]);
    /// ```
    ///
    /// When the empty string is used as a separator, it panics
    ///
    /// ```should_panic
    /// use std::ffi::OsStr;
    /// use clap_lex::OsStrExt as _;
    /// let f: Vec<_> = OsStr::new("rust").split("").collect();
    /// assert_eq!(f, &[OsStr::new(""), OsStr::new("r"), OsStr::new("u"), OsStr::new("s"), OsStr::new("t"), OsStr::new("")]);
    /// ```
    ///
    /// Contiguous separators can lead to possibly surprising behavior
    /// when whitespace is used as the separator. This code is correct:
    ///
    /// ```
    /// use std::ffi::OsStr;
    /// use clap_lex::OsStrExt as _;
    /// let x = OsStr::new("    a  b c");
    /// let d: Vec<_> = x.split(" ").collect();
    ///
    /// assert_eq!(d, &[OsStr::new(""), OsStr::new(""), OsStr::new(""), OsStr::new(""), OsStr::new("a"), OsStr::new(""), OsStr::new("b"), OsStr::new("c")]);
    /// ```
    ///
    /// It does _not_ give you:
    ///
    /// ```,ignore
    /// assert_eq!(d, &[OsStr::new("a"), OsStr::new("b"), OsStr::new("c")]);
    /// ```
    ///
    /// Use [`split_whitespace`] for this behavior.
    ///
    /// [`split_whitespace`]: str::split_whitespace
    fn split<'s, 'n>(&'s self, needle: &'n str) -> Split<'s, 'n>;
    /// Splits the string on the first occurrence of the specified delimiter and
    /// returns prefix before delimiter and suffix after delimiter.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::ffi::OsStr;
    /// use clap_lex::OsStrExt as _;
    /// assert_eq!(OsStr::new("cfg").split_once("="), None);
    /// assert_eq!(OsStr::new("cfg=").split_once("="), Some((OsStr::new("cfg"), OsStr::new(""))));
    /// assert_eq!(OsStr::new("cfg=foo").split_once("="), Some((OsStr::new("cfg"), OsStr::new("foo"))));
    /// assert_eq!(OsStr::new("cfg=foo=bar").split_once("="), Some((OsStr::new("cfg"), OsStr::new("foo=bar"))));
    /// ```
    fn split_once(&self, needle: &'_ str) -> Option<(&OsStr, &OsStr)>;
}

impl OsStrExt for OsStr {
    fn try_str(&self) -> Result<&str, std::str::Utf8Error> {
        let bytes = self.as_encoded_bytes();
        std::str::from_utf8(bytes)
    }

    fn contains(&self, needle: &str) -> bool {
        self.find(needle).is_some()
    }

    fn find(&self, needle: &str) -> Option<usize> {
        let bytes = self.as_encoded_bytes();
        (0..=self.len().checked_sub(needle.len())?)
            .find(|&x| bytes[x..].starts_with(needle.as_bytes()))
    }

    fn strip_prefix(&self, prefix: &str) -> Option<&OsStr> {
        let bytes = self.as_encoded_bytes();
        bytes.strip_prefix(prefix.as_bytes()).map(|s| {
            // SAFETY:
            // - This came from `as_encoded_bytes`
            // - Since `prefix` is `&str`, any split will be along UTF-8 boundary
            unsafe { OsStr::from_encoded_bytes_unchecked(s) }
        })
    }
    fn starts_with(&self, prefix: &str) -> bool {
        let bytes = self.as_encoded_bytes();
        bytes.starts_with(prefix.as_bytes())
    }

    fn split<'s, 'n>(&'s self, needle: &'n str) -> Split<'s, 'n> {
        assert_ne!(needle, "");
        Split {
            haystack: Some(self),
            needle,
        }
    }

    fn split_once(&self, needle: &'_ str) -> Option<(&OsStr, &OsStr)> {
        let start = self.find(needle)?;
        let end = start + needle.len();
        let haystack = self.as_encoded_bytes();
        let first = &haystack[0..start];
        let second = &haystack[end..];
        // SAFETY:
        // - This came from `as_encoded_bytes`
        // - Since `needle` is `&str`, any split will be along UTF-8 boundary
        unsafe {
            Some((
                OsStr::from_encoded_bytes_unchecked(first),
                OsStr::from_encoded_bytes_unchecked(second),
            ))
        }
    }
}

mod private {
    pub trait Sealed {}

    impl Sealed for std::ffi::OsStr {}
}

pub struct Split<'s, 'n> {
    haystack: Option<&'s OsStr>,
    needle: &'n str,
}

impl<'s> Iterator for Split<'s, '_> {
    type Item = &'s OsStr;

    fn next(&mut self) -> Option<Self::Item> {
        let haystack = self.haystack?;
        if let Some((first, second)) = haystack.split_once(self.needle) {
            if !haystack.is_empty() {
                debug_assert_ne!(haystack, second);
            }
            self.haystack = Some(second);
            Some(first)
        } else {
            self.haystack = None;
            Some(haystack)
        }
    }
}

/// Split an `OsStr`
///
/// # Safety
///
/// `index` must be at a valid UTF-8 boundary
pub(crate) unsafe fn split_at(os: &OsStr, index: usize) -> (&OsStr, &OsStr) {
    unsafe {
        let bytes = os.as_encoded_bytes();
        let (first, second) = bytes.split_at(index);
        (
            OsStr::from_encoded_bytes_unchecked(first),
            OsStr::from_encoded_bytes_unchecked(second),
        )
    }
}

```

`clap/clap_lex/src/lib.rs`:

```rs
//! Minimal, flexible command-line parser
//!
//! As opposed to a declarative parser, this processes arguments as a stream of tokens.  As lexing
//! a command-line is not context-free, we rely on the caller to decide how to interpret the
//! arguments.
//!
//! # Examples
//!
//! ```rust
//! use std::path::PathBuf;
//! use std::ffi::OsStr;
//!
//! type BoxedError = Box<dyn std::error::Error + Send + Sync>;
//!
//! #[derive(Debug)]
//! struct Args {
//!     paths: Vec<PathBuf>,
//!     color: Color,
//!     verbosity: usize,
//! }
//!
//! #[derive(Debug)]
//! enum Color {
//!     Always,
//!     Auto,
//!     Never,
//! }
//!
//! impl Color {
//!     fn parse(s: Option<&OsStr>) -> Result<Self, BoxedError> {
//!         let s = s.map(|s| s.to_str().ok_or(s));
//!         match s {
//!             Some(Ok("always")) | Some(Ok("")) | None => {
//!                 Ok(Color::Always)
//!             }
//!             Some(Ok("auto")) => {
//!                 Ok(Color::Auto)
//!             }
//!             Some(Ok("never")) => {
//!                 Ok(Color::Never)
//!             }
//!             Some(invalid) => {
//!                 Err(format!("Invalid value for `--color`, {invalid:?}").into())
//!             }
//!         }
//!     }
//! }
//!
//! fn parse_args(
//!     raw: impl IntoIterator<Item=impl Into<std::ffi::OsString>>
//! ) -> Result<Args, BoxedError> {
//!     let mut args = Args {
//!         paths: Vec::new(),
//!         color: Color::Auto,
//!         verbosity: 0,
//!     };
//!
//!     let raw = clap_lex::RawArgs::new(raw);
//!     let mut cursor = raw.cursor();
//!     raw.next(&mut cursor);  // Skip the bin
//!     while let Some(arg) = raw.next(&mut cursor) {
//!         if arg.is_escape() {
//!             args.paths.extend(raw.remaining(&mut cursor).map(PathBuf::from));
//!         } else if arg.is_stdio() {
//!             args.paths.push(PathBuf::from("-"));
//!         } else if let Some((long, value)) = arg.to_long() {
//!             match long {
//!                 Ok("verbose") => {
//!                     if let Some(value) = value {
//!                         return Err(format!("`--verbose` does not take a value, got `{value:?}`").into());
//!                     }
//!                     args.verbosity += 1;
//!                 }
//!                 Ok("color") => {
//!                     args.color = Color::parse(value)?;
//!                 }
//!                 _ => {
//!                     return Err(
//!                         format!("Unexpected flag: --{}", arg.display()).into()
//!                     );
//!                 }
//!             }
//!         } else if let Some(mut shorts) = arg.to_short() {
//!             while let Some(short) = shorts.next_flag() {
//!                 match short {
//!                     Ok('v') => {
//!                         args.verbosity += 1;
//!                     }
//!                     Ok('c') => {
//!                         let value = shorts.next_value_os();
//!                         args.color = Color::parse(value)?;
//!                     }
//!                     Ok(c) => {
//!                         return Err(format!("Unexpected flag: -{c}").into());
//!                     }
//!                     Err(e) => {
//!                         return Err(format!("Unexpected flag: -{}", e.to_string_lossy()).into());
//!                     }
//!                 }
//!             }
//!         } else {
//!             args.paths.push(PathBuf::from(arg.to_value_os().to_owned()));
//!         }
//!     }
//!
//!     Ok(args)
//! }
//!
//! let args = parse_args(["bin", "--hello", "world"]);
//! println!("{args:?}");
//! ```

#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![warn(missing_docs)]
#![warn(clippy::print_stderr)]
#![warn(clippy::print_stdout)]

mod ext;

use std::ffi::OsStr;
use std::ffi::OsString;

pub use std::io::SeekFrom;

pub use ext::OsStrExt;

/// Command-line arguments
#[derive(Default, Clone, Debug, PartialEq, Eq)]
pub struct RawArgs {
    items: Vec<OsString>,
}

impl RawArgs {
    //// Create an argument list to parse
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** The argument returned will be the current binary.
    ///
    /// </div>
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// # use std::path::PathBuf;
    /// let raw = clap_lex::RawArgs::from_args();
    /// let mut cursor = raw.cursor();
    /// let _bin = raw.next_os(&mut cursor);
    ///
    /// let mut paths = raw.remaining(&mut cursor).map(PathBuf::from).collect::<Vec<_>>();
    /// println!("{paths:?}");
    /// ```
    pub fn from_args() -> Self {
        Self::new(std::env::args_os())
    }

    //// Create an argument list to parse
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// # use std::path::PathBuf;
    /// let raw = clap_lex::RawArgs::new(["bin", "foo.txt"]);
    /// let mut cursor = raw.cursor();
    /// let _bin = raw.next_os(&mut cursor);
    ///
    /// let mut paths = raw.remaining(&mut cursor).map(PathBuf::from).collect::<Vec<_>>();
    /// println!("{paths:?}");
    /// ```
    pub fn new(iter: impl IntoIterator<Item = impl Into<OsString>>) -> Self {
        let iter = iter.into_iter();
        Self::from(iter)
    }

    /// Create a cursor for walking the arguments
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// # use std::path::PathBuf;
    /// let raw = clap_lex::RawArgs::new(["bin", "foo.txt"]);
    /// let mut cursor = raw.cursor();
    /// let _bin = raw.next_os(&mut cursor);
    ///
    /// let mut paths = raw.remaining(&mut cursor).map(PathBuf::from).collect::<Vec<_>>();
    /// println!("{paths:?}");
    /// ```
    pub fn cursor(&self) -> ArgCursor {
        ArgCursor::new()
    }

    /// Advance the cursor, returning the next [`ParsedArg`]
    pub fn next(&self, cursor: &mut ArgCursor) -> Option<ParsedArg<'_>> {
        self.next_os(cursor).map(ParsedArg::new)
    }

    /// Advance the cursor, returning a raw argument value.
    pub fn next_os(&self, cursor: &mut ArgCursor) -> Option<&OsStr> {
        let next = self.items.get(cursor.cursor).map(|s| s.as_os_str());
        cursor.cursor = cursor.cursor.saturating_add(1);
        next
    }

    /// Return the next [`ParsedArg`]
    pub fn peek(&self, cursor: &ArgCursor) -> Option<ParsedArg<'_>> {
        self.peek_os(cursor).map(ParsedArg::new)
    }

    /// Return a raw argument value.
    pub fn peek_os(&self, cursor: &ArgCursor) -> Option<&OsStr> {
        self.items.get(cursor.cursor).map(|s| s.as_os_str())
    }

    /// Return all remaining raw arguments, advancing the cursor to the end
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// # use std::path::PathBuf;
    /// let raw = clap_lex::RawArgs::new(["bin", "foo.txt"]);
    /// let mut cursor = raw.cursor();
    /// let _bin = raw.next_os(&mut cursor);
    ///
    /// let mut paths = raw.remaining(&mut cursor).map(PathBuf::from).collect::<Vec<_>>();
    /// println!("{paths:?}");
    /// ```
    pub fn remaining(&self, cursor: &mut ArgCursor) -> impl Iterator<Item = &OsStr> {
        let remaining = self.items[cursor.cursor..].iter().map(|s| s.as_os_str());
        cursor.cursor = self.items.len();
        remaining
    }

    /// Adjust the cursor's position
    pub fn seek(&self, cursor: &mut ArgCursor, pos: SeekFrom) {
        let pos = match pos {
            SeekFrom::Start(pos) => pos,
            SeekFrom::End(pos) => (self.items.len() as i64).saturating_add(pos).max(0) as u64,
            SeekFrom::Current(pos) => (cursor.cursor as i64).saturating_add(pos).max(0) as u64,
        };
        let pos = (pos as usize).min(self.items.len());
        cursor.cursor = pos;
    }

    /// Inject arguments before the [`RawArgs::next`]
    pub fn insert(
        &mut self,
        cursor: &ArgCursor,
        insert_items: impl IntoIterator<Item = impl Into<OsString>>,
    ) {
        self.items.splice(
            cursor.cursor..cursor.cursor,
            insert_items.into_iter().map(Into::into),
        );
    }

    /// Any remaining args?
    pub fn is_end(&self, cursor: &ArgCursor) -> bool {
        self.peek_os(cursor).is_none()
    }
}

impl<I, T> From<I> for RawArgs
where
    I: Iterator<Item = T>,
    T: Into<OsString>,
{
    fn from(val: I) -> Self {
        Self {
            items: val.map(|x| x.into()).collect(),
        }
    }
}

/// Position within [`RawArgs`]
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ArgCursor {
    cursor: usize,
}

impl ArgCursor {
    fn new() -> Self {
        Self { cursor: 0 }
    }
}

/// Command-line Argument
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ParsedArg<'s> {
    inner: &'s OsStr,
}

impl<'s> ParsedArg<'s> {
    fn new(inner: &'s OsStr) -> Self {
        Self { inner }
    }

    /// Argument is length of 0
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }

    /// Does the argument look like a stdio argument (`-`)
    pub fn is_stdio(&self) -> bool {
        self.inner == "-"
    }

    /// Does the argument look like an argument escape (`--`)
    pub fn is_escape(&self) -> bool {
        self.inner == "--"
    }

    /// Does the argument look like a negative number?
    ///
    /// This won't parse the number in full but attempts to see if this looks
    /// like something along the lines of `-3`, `-0.3`, or `-33.03`
    pub fn is_negative_number(&self) -> bool {
        self.to_value()
            .ok()
            .and_then(|s| Some(is_number(s.strip_prefix('-')?)))
            .unwrap_or_default()
    }

    /// Treat as a long-flag
    pub fn to_long(&self) -> Option<(Result<&str, &OsStr>, Option<&OsStr>)> {
        let raw = self.inner;
        let remainder = raw.strip_prefix("--")?;
        if remainder.is_empty() {
            debug_assert!(self.is_escape());
            return None;
        }

        let (flag, value) = if let Some((p0, p1)) = remainder.split_once("=") {
            (p0, Some(p1))
        } else {
            (remainder, None)
        };
        let flag = flag.to_str().ok_or(flag);
        Some((flag, value))
    }

    /// Can treat as a long-flag
    pub fn is_long(&self) -> bool {
        self.inner.starts_with("--") && !self.is_escape()
    }

    /// Treat as a short-flag
    pub fn to_short(&self) -> Option<ShortFlags<'_>> {
        if let Some(remainder_os) = self.inner.strip_prefix("-") {
            if remainder_os.starts_with("-") {
                None
            } else if remainder_os.is_empty() {
                debug_assert!(self.is_stdio());
                None
            } else {
                Some(ShortFlags::new(remainder_os))
            }
        } else {
            None
        }
    }

    /// Can treat as a short-flag
    pub fn is_short(&self) -> bool {
        self.inner.starts_with("-") && !self.is_stdio() && !self.inner.starts_with("--")
    }

    /// Treat as a value
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** May return a flag or an escape.
    ///
    /// </div>
    pub fn to_value_os(&self) -> &OsStr {
        self.inner
    }

    /// Treat as a value
    ///
    /// <div class="warning">
    ///
    /// **NOTE:** May return a flag or an escape.
    ///
    /// </div>
    pub fn to_value(&self) -> Result<&str, &OsStr> {
        self.inner.to_str().ok_or(self.inner)
    }

    /// Safely print an argument that may contain non-UTF8 content
    ///
    /// This may perform lossy conversion, depending on the platform. If you would like an implementation which escapes the path please use Debug instead.
    pub fn display(&self) -> impl std::fmt::Display + '_ {
        self.inner.to_string_lossy()
    }
}

/// Walk through short flags within a [`ParsedArg`]
#[derive(Clone, Debug)]
pub struct ShortFlags<'s> {
    inner: &'s OsStr,
    utf8_prefix: std::str::CharIndices<'s>,
    invalid_suffix: Option<&'s OsStr>,
}

impl<'s> ShortFlags<'s> {
    fn new(inner: &'s OsStr) -> Self {
        let (utf8_prefix, invalid_suffix) = split_nonutf8_once(inner);
        let utf8_prefix = utf8_prefix.char_indices();
        Self {
            inner,
            utf8_prefix,
            invalid_suffix,
        }
    }

    /// Move the iterator forward by `n` short flags
    pub fn advance_by(&mut self, n: usize) -> Result<(), usize> {
        for i in 0..n {
            self.next().ok_or(i)?.map_err(|_| i)?;
        }
        Ok(())
    }

    /// No short flags left
    pub fn is_empty(&self) -> bool {
        self.invalid_suffix.is_none() && self.utf8_prefix.as_str().is_empty()
    }

    /// Does the short flag look like a number
    ///
    /// Ideally call this before doing any iterator
    pub fn is_negative_number(&self) -> bool {
        self.invalid_suffix.is_none() && is_number(self.utf8_prefix.as_str())
    }

    /// Advance the iterator, returning the next short flag on success
    ///
    /// On error, returns the invalid-UTF8 value
    pub fn next_flag(&mut self) -> Option<Result<char, &'s OsStr>> {
        if let Some((_, flag)) = self.utf8_prefix.next() {
            return Some(Ok(flag));
        }

        if let Some(suffix) = self.invalid_suffix {
            self.invalid_suffix = None;
            return Some(Err(suffix));
        }

        None
    }

    /// Advance the iterator, returning everything left as a value
    pub fn next_value_os(&mut self) -> Option<&'s OsStr> {
        if let Some((index, _)) = self.utf8_prefix.next() {
            self.utf8_prefix = "".char_indices();
            self.invalid_suffix = None;
            // SAFETY: `char_indices` ensures `index` is at a valid UTF-8 boundary
            let remainder = unsafe { ext::split_at(self.inner, index).1 };
            return Some(remainder);
        }

        if let Some(suffix) = self.invalid_suffix {
            self.invalid_suffix = None;
            return Some(suffix);
        }

        None
    }
}

impl<'s> Iterator for ShortFlags<'s> {
    type Item = Result<char, &'s OsStr>;

    fn next(&mut self) -> Option<Self::Item> {
        self.next_flag()
    }
}

fn split_nonutf8_once(b: &OsStr) -> (&str, Option<&OsStr>) {
    match b.try_str() {
        Ok(s) => (s, None),
        Err(err) => {
            // SAFETY: `err.valid_up_to()`, which came from str::from_utf8(), is guaranteed
            // to be a valid UTF8 boundary
            let (valid, after_valid) = unsafe { ext::split_at(b, err.valid_up_to()) };
            let valid = valid.try_str().unwrap();
            (valid, Some(after_valid))
        }
    }
}

fn is_number(arg: &str) -> bool {
    // Return true if this looks like an integer or a float where it's all
    // digits plus an optional single dot after some digits.
    //
    // For floats allow forms such as `1.`, `1.2`, `1.2e10`, etc.
    let mut seen_dot = false;
    let mut position_of_e = None;
    for (i, c) in arg.as_bytes().iter().enumerate() {
        match c {
            // Digits are always valid
            b'0'..=b'9' => {}

            // Allow a `.`, but only one, only if it comes before an
            // optional exponent, and only if it's not the first character.
            b'.' if !seen_dot && position_of_e.is_none() && i > 0 => seen_dot = true,

            // Allow an exponent `e`/`E` but only at most one after the first
            // character.
            b'e' | b'E' if position_of_e.is_none() && i > 0 => position_of_e = Some(i),

            _ => return false,
        }
    }

    // Disallow `-1e` which isn't a valid float since it doesn't actually have
    // an exponent.
    match position_of_e {
        Some(i) => i != arg.len() - 1,
        None => true,
    }
}

```

`clap/clap_lex/tests/testsuite/lexer.rs`:

```rs
#[test]
fn insert() {
    let mut raw = clap_lex::RawArgs::new(["bin", "a", "b", "c"]);
    let mut cursor = raw.cursor();

    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("a")));
    raw.insert(&cursor, ["1", "2", "3"]);
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("1")));
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("2")));
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("3")));
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("b")));
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("c")));

    let mut cursor = raw.cursor();
    let rest = raw
        .remaining(&mut cursor)
        .map(|s| s.to_string_lossy())
        .collect::<Vec<_>>();
    assert_eq!(rest, vec!["bin", "a", "1", "2", "3", "b", "c"]);
}

```

`clap/clap_lex/tests/testsuite/main.rs`:

```rs
automod::dir!("tests/testsuite");

```

`clap/clap_lex/tests/testsuite/parsed.rs`:

```rs
use std::ffi::OsStr;

// Despite our design philosophy being to support completion generation, we aren't considering `-`
// the start of a long because there is no valid value to return.
#[test]
fn to_long_stdio() {
    let raw = clap_lex::RawArgs::new(["bin", "-"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(!next.is_long());

    assert_eq!(next.to_long(), None);
}

#[test]
fn to_long_no_escape() {
    let raw = clap_lex::RawArgs::new(["bin", "--"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(!next.is_long());

    assert_eq!(next.to_long(), None);
}

#[test]
fn to_long_no_value() {
    let raw = clap_lex::RawArgs::new(["bin", "--long"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(next.is_long());

    let (key, value) = next.to_long().unwrap();
    assert_eq!(key, Ok("long"));
    assert_eq!(value, None);
}

#[test]
fn to_long_with_empty_value() {
    let raw = clap_lex::RawArgs::new(["bin", "--long="]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(next.is_long());

    let (key, value) = next.to_long().unwrap();
    assert_eq!(key, Ok("long"));
    assert_eq!(value, Some(OsStr::new("")));
}

#[test]
fn to_long_with_value() {
    let raw = clap_lex::RawArgs::new(["bin", "--long=hello"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(next.is_long());

    let (key, value) = next.to_long().unwrap();
    assert_eq!(key, Ok("long"));
    assert_eq!(value, Some(OsStr::new("hello")));
}

#[test]
fn to_short_stdio() {
    let raw = clap_lex::RawArgs::new(["bin", "-"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(!next.is_short());

    assert!(next.to_short().is_none());
}

#[test]
fn to_short_escape() {
    let raw = clap_lex::RawArgs::new(["bin", "--"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(!next.is_short());

    assert!(next.to_short().is_none());
}

#[test]
fn to_short_long() {
    let raw = clap_lex::RawArgs::new(["bin", "--long"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(!next.is_short());

    assert!(next.to_short().is_none());
}

#[test]
fn to_short() {
    let raw = clap_lex::RawArgs::new(["bin", "-short"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(next.is_short());

    let shorts = next.to_short().unwrap();
    let actual: String = shorts.map(|s| s.unwrap()).collect();
    assert_eq!(actual, "short");
}

#[test]
fn is_negative_number() {
    for number in ["-10.0", "-1", "-100", "-3.5", "-1e10", "-1.3e10", "-1E10"] {
        let raw = clap_lex::RawArgs::new(["bin", number]);
        let mut cursor = raw.cursor();
        assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
        let next = raw.next(&mut cursor).unwrap();

        assert!(next.is_negative_number());
    }
}

#[test]
fn is_positive_number() {
    let raw = clap_lex::RawArgs::new(["bin", "10.0"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(!next.is_negative_number());
}

#[test]
fn is_not_number() {
    for number in [
        "--10.0", "-..", "-2..", "-e", "-1e", "-1e10.2", "-.2", "-E", "-1E", "-1E10.2",
    ] {
        let raw = clap_lex::RawArgs::new(["bin", number]);
        let mut cursor = raw.cursor();
        assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
        let next = raw.next(&mut cursor).unwrap();

        assert!(
            !next.is_negative_number(),
            "`{number}` is mistakenly classified as a number"
        );
    }
}

#[test]
fn is_stdio() {
    let raw = clap_lex::RawArgs::new(["bin", "-"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(next.is_stdio());
}

#[test]
fn is_not_stdio() {
    let raw = clap_lex::RawArgs::new(["bin", "--"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(!next.is_stdio());
}

#[test]
fn is_escape() {
    let raw = clap_lex::RawArgs::new(["bin", "--"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(next.is_escape());
}

#[test]
fn is_not_escape() {
    let raw = clap_lex::RawArgs::new(["bin", "-"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();

    assert!(!next.is_escape());
}

```

`clap/clap_lex/tests/testsuite/shorts.rs`:

```rs
#[test]
fn iter() {
    let raw = clap_lex::RawArgs::new(["bin", "-short"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let shorts = next.to_short().unwrap();

    let actual: String = shorts.map(|s| s.unwrap()).collect();
    assert_eq!(actual, "short");
}

#[test]
fn next_flag() {
    let raw = clap_lex::RawArgs::new(["bin", "-short"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let mut shorts = next.to_short().unwrap();

    let mut actual = String::new();
    actual.push(shorts.next_flag().unwrap().unwrap());
    actual.push(shorts.next_flag().unwrap().unwrap());
    actual.push(shorts.next_flag().unwrap().unwrap());
    actual.push(shorts.next_flag().unwrap().unwrap());
    actual.push(shorts.next_flag().unwrap().unwrap());
    assert_eq!(shorts.next_flag(), None);

    assert_eq!(actual, "short");
}

#[test]
fn next_value_os() {
    let raw = clap_lex::RawArgs::new(["bin", "-short"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let mut shorts = next.to_short().unwrap();

    let actual = shorts.next_value_os().unwrap().to_string_lossy();

    assert_eq!(actual, "short");
}

#[test]
fn next_flag_with_value() {
    let raw = clap_lex::RawArgs::new(["bin", "-short"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let mut shorts = next.to_short().unwrap();

    assert_eq!(shorts.next_flag().unwrap().unwrap(), 's');
    let actual = shorts.next_value_os().unwrap().to_string_lossy();

    assert_eq!(actual, "hort");
}

#[test]
fn next_flag_with_no_value() {
    let raw = clap_lex::RawArgs::new(["bin", "-short"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let mut shorts = next.to_short().unwrap();

    assert_eq!(shorts.next_flag().unwrap().unwrap(), 's');
    assert_eq!(shorts.next_flag().unwrap().unwrap(), 'h');
    assert_eq!(shorts.next_flag().unwrap().unwrap(), 'o');
    assert_eq!(shorts.next_flag().unwrap().unwrap(), 'r');
    assert_eq!(shorts.next_flag().unwrap().unwrap(), 't');

    assert_eq!(shorts.next_value_os(), None);
}

#[test]
fn advance_by_nothing() {
    let raw = clap_lex::RawArgs::new(["bin", "-short"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let mut shorts = next.to_short().unwrap();

    assert_eq!(shorts.advance_by(0), Ok(()));

    let actual: String = shorts.map(|s| s.unwrap()).collect();
    assert_eq!(actual, "short");
}

#[test]
fn advance_by_something() {
    let raw = clap_lex::RawArgs::new(["bin", "-short"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let mut shorts = next.to_short().unwrap();

    assert_eq!(shorts.advance_by(2), Ok(()));

    let actual: String = shorts.map(|s| s.unwrap()).collect();
    assert_eq!(actual, "ort");
}

#[test]
fn advance_by_out_of_bounds() {
    let raw = clap_lex::RawArgs::new(["bin", "-short"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let mut shorts = next.to_short().unwrap();

    assert_eq!(shorts.advance_by(2000), Err(5));

    let actual: String = shorts.map(|s| s.unwrap()).collect();
    assert_eq!(actual, "");
}

#[test]
fn is_not_empty() {
    let raw = clap_lex::RawArgs::new(["bin", "-hello"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let shorts = next.to_short().unwrap();

    assert!(!shorts.is_empty());
}

#[test]
fn is_partial_not_empty() {
    let raw = clap_lex::RawArgs::new(["bin", "-hello"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let mut shorts = next.to_short().unwrap();
    shorts.advance_by(1).unwrap();

    assert!(!shorts.is_empty());
}

#[test]
fn is_exhausted_empty() {
    let raw = clap_lex::RawArgs::new(["bin", "-hello"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let mut shorts = next.to_short().unwrap();
    shorts.advance_by(20000).unwrap_err();

    assert!(shorts.is_empty());
}

#[test]
fn is_negative_number() {
    let raw = clap_lex::RawArgs::new(["bin", "-1.0"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let shorts = next.to_short().unwrap();

    assert!(shorts.is_negative_number());
}

#[test]
fn is_not_negaitve_number() {
    let raw = clap_lex::RawArgs::new(["bin", "-hello"]);
    let mut cursor = raw.cursor();
    assert_eq!(raw.next_os(&mut cursor), Some(std::ffi::OsStr::new("bin")));
    let next = raw.next(&mut cursor).unwrap();
    let shorts = next.to_short().unwrap();

    assert!(!shorts.is_negative_number());
}

```

`clap/clap_mangen/CHANGELOG.md`:

```md
# Change Log
All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](http://keepachangelog.com/)
and this project adheres to [Semantic Versioning](http://semver.org/).

<!-- next-header -->
## [Unreleased] - ReleaseDate

## [0.2.26] - 2025-01-10

### Features

- Respect `help_heading`

## [0.2.25] - 2025-01-07

### Fixes

- Do not generate man pages for hidden subcommands

## [0.2.24] - 2024-10-08

## [0.2.23] - 2024-07-25

## [0.2.22] - 2024-06-28

## [0.2.21] - 2024-06-06

## [0.2.20] - 2024-02-08

### Compatibility

- Update MSRV to 1.74

## [0.2.19] - 2024-02-02

### Features

- Support generating files for man pages

## [0.2.18] - 2024-01-29

### Fixes

- Print full subcommand name in title (ie include parent commands)
- Print full subcommand in usage (ie include parent commands

## [0.2.17] - 2024-01-11

### Fixes

- Correctly show help for fake flags

## [0.2.16] - 2023-12-28

### Performance

- Only ask `TypedValueParser` for possible values if needed

## [0.2.15] - 2023-10-24

## [0.2.14] - 2023-09-18

## [0.2.13] - 2023-08-24

### Compatibility

- Update MSRV to 1.70.0

## [0.2.12] - 2023-06-02

## [0.2.11] - 2023-05-19

## [0.2.10] - 2023-03-16

## [0.2.9] - 2023-02-22

### Fixes

- Only show value names if a value is taken

## [0.2.8] - 2023-02-15

## [0.2.7] - 2023-01-13

### Compatibility

MSRV changed to 1.64.0

## [0.2.6] - 2022-12-22

## [0.2.5] - 2022-11-24

## [0.2.4] - 2022-10-31

### Fixes

- Don't show defaults for flags

## [0.2.3] - 2022-10-18

## [0.2.2] - 2022-09-29

### Fixes

- Reference to subcommand man pages now lists the correct name

## [0.2.1] - 2022-09-28

### Fixes

- Respect hide attributes in more cases

## [0.2.0] - 2022-09-28

## [0.1.10] - 2022-06-28

## [0.1.9] - 2022-06-21

## [0.1.8] - 2022-06-13

## [0.1.7] - 2022-06-13

## [0.1.6] - 2022-04-20

### Fixes

- Split environment variables into separate paragraph

## [0.1.5] - 2022-04-19

## [0.1.4] - 2022-04-19

## [0.1.3] - 2022-04-15

- Use value names for positionals
- Hide hidden flags in synopsis
- Use italics for replaceable args

## [0.1.2] - 2022-02-16

## [0.1.1] - 2022-02-08

### Fixes

- Expanded the documentation

<!-- next-url -->
[Unreleased]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.26...HEAD
[0.2.26]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.25...clap_mangen-v0.2.26
[0.2.25]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.24...clap_mangen-v0.2.25
[0.2.24]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.23...clap_mangen-v0.2.24
[0.2.23]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.22...clap_mangen-v0.2.23
[0.2.22]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.21...clap_mangen-v0.2.22
[0.2.21]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.20...clap_mangen-v0.2.21
[0.2.20]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.19...clap_mangen-v0.2.20
[0.2.19]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.18...clap_mangen-v0.2.19
[0.2.18]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.17...clap_mangen-v0.2.18
[0.2.17]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.16...clap_mangen-v0.2.17
[0.2.16]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.15...clap_mangen-v0.2.16
[0.2.15]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.14...clap_mangen-v0.2.15
[0.2.14]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.13...clap_mangen-v0.2.14
[0.2.13]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.12...clap_mangen-v0.2.13
[0.2.12]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.11...clap_mangen-v0.2.12
[0.2.11]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.10...clap_mangen-v0.2.11
[0.2.10]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.9...clap_mangen-v0.2.10
[0.2.9]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.8...clap_mangen-v0.2.9
[0.2.8]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.7...clap_mangen-v0.2.8
[0.2.7]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.6...clap_mangen-v0.2.7
[0.2.6]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.5...clap_mangen-v0.2.6
[0.2.5]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.4...clap_mangen-v0.2.5
[0.2.4]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.3...clap_mangen-v0.2.4
[0.2.3]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.2...clap_mangen-v0.2.3
[0.2.2]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.1...clap_mangen-v0.2.2
[0.2.1]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.2.0...clap_mangen-v0.2.1
[0.2.0]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.10...clap_mangen-v0.2.0
[0.1.10]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.9...clap_mangen-v0.1.10
[0.1.9]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.8...clap_mangen-v0.1.9
[0.1.8]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.7...clap_mangen-v0.1.8
[0.1.7]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.6...clap_mangen-v0.1.7
[0.1.6]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.5...clap_mangen-v0.1.6
[0.1.5]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.4...clap_mangen-v0.1.5
[0.1.4]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.3...clap_mangen-v0.1.4
[0.1.3]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.2...clap_mangen-v0.1.3
[0.1.2]: https://github.com/clap-rs/clap/compare/clap_mangen-v0.1.1...clap_mangen-v0.1.2
[0.1.1]: https://github.com/clap-rs/clap/compare/0b045f5d0de9f6c97607be3276f529a14510e94e...clap_mangen-v0.1.1

```

`clap/clap_mangen/CONTRIBUTING.md`:

```md
# How to Contribute

See the [clap-wide CONTRIBUTING.md](../CONTRIBUTING.md). This will contain `clap_mangen` specific notes.

```

`clap/clap_mangen/Cargo.toml`:

```toml
[package]
name = "clap_mangen"
version = "0.2.26"
description = "A manpage generator for clap"
categories = ["command-line-interface"]
keywords = [
  "clap",
  "cli",
  "generate",
  "manpage",
]
repository.workspace = true
license.workspace = true
edition.workspace = true
rust-version.workspace = true
include.workspace = true

[package.metadata.docs.rs]
targets = ["x86_64-unknown-linux-gnu"]

[package.metadata.release]
pre-release-replacements = [
  {file="CHANGELOG.md", search="Unreleased", replace="{{version}}", min=1},
  {file="CHANGELOG.md", search="\\.\\.\\.HEAD", replace="...{{tag_name}}", exactly=1},
  {file="CHANGELOG.md", search="ReleaseDate", replace="{{date}}", min=1},
  {file="CHANGELOG.md", search="<!-- next-header -->", replace="<!-- next-header -->\n## [Unreleased] - ReleaseDate\n", exactly=1},
  {file="CHANGELOG.md", search="<!-- next-url -->", replace="<!-- next-url -->\n[Unreleased]: https://github.com/clap-rs/clap/compare/{{tag_name}}...HEAD", exactly=1},
  {file="README.md", search="github.com/clap-rs/clap/blob/[^/]+/", replace="github.com/clap-rs/clap/blob/{{tag_name}}/", exactly=4, prerelease = true},
]

[lib]
bench = false

[dependencies]
roff = "0.2.1"
clap = { path = "../", version = "4.0.0", default-features = false, features = ["std", "env"] }

[dev-dependencies]
snapbox = { version = "0.6.0", features = ["diff"] }
clap = { path = "../", version = "4.0.0", default-features = false, features = ["std", "help"] }
automod = "1.0.14"

[features]
default = []
debug = ["clap/debug"]

[lints]
workspace = true

```

`clap/clap_mangen/LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`clap/clap_mangen/LICENSE-MIT`:

```
The MIT License (MIT)

Copyright (c) 2021-2022 Kevin B. Knapp and Clap Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`clap/clap_mangen/README.md`:

```md
<!-- omit in TOC -->
# `clap_mangen`

> **Manpage generation for `clap`**

[![Crates.io](https://img.shields.io/crates/v/clap_mangen?style=flat-square)](https://crates.io/crates/clap_mangen)
[![Crates.io](https://img.shields.io/crates/d/clap_mangen?style=flat-square)](https://crates.io/crates/clap_mangen)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue?style=flat-square)](https://github.com/clap-rs/clap/blob/clap_mangen-v0.2.26/LICENSE-APACHE)
[![License](https://img.shields.io/badge/license-MIT-blue?style=flat-square)](https://github.com/clap-rs/clap/blob/clap_mangen-v0.2.26/LICENSE-MIT)

Dual-licensed under [Apache 2.0](LICENSE-APACHE) or [MIT](LICENSE-MIT).

1. [About](#about)
2. [API Reference](https://docs.rs/clap_mangen)
3. [Questions & Discussions](https://github.com/clap-rs/clap/discussions)
4. [CONTRIBUTING](https://github.com/clap-rs/clap/blob/clap_mangen-v0.2.26/clap_mangen/CONTRIBUTING.md)
5. [Sponsors](https://github.com/clap-rs/clap/blob/clap_mangen-v0.2.26/README.md#sponsors)

## About

Generate [ROFF](https://en.wikipedia.org/wiki/Roff_(software)) from a `clap::Command`.

### Example

We're going to assume you want to generate your man page as part of your
development rather than your shipped program having a flag to generate it.

Run
```console
$ cargo add --build clap_mangen
```

In your `build.rs`:
```rust,no_run
fn main() -> std::io::Result<()> {
    let out_dir = std::path::PathBuf::from(std::env::var_os("OUT_DIR").ok_or(std::io::ErrorKind::NotFound)?);

    let cmd = clap::Command::new("mybin")
        .arg(clap::arg!(-n --name <NAME>))
        .arg(clap::arg!(-c --count <NUM>));

    let man = clap_mangen::Man::new(cmd);
    let mut buffer: Vec<u8> = Default::default();
    man.render(&mut buffer)?;

    std::fs::write(out_dir.join("mybin.1"), buffer)?;

    Ok(())
}
```

Tip: Consider a [cargo xtask](https://github.com/matklad/cargo-xtask) instead of a `build.rs` to reduce build costs.

```

`clap/clap_mangen/examples/man.rs`:

```rs
use clap::{arg, Command};
use clap_mangen::Man;
use std::io;

// Run this example as `cargo run --example man | man -l -`.

fn main() -> Result<(), io::Error> {
    let cmd = Command::new("myapp")
        .version("1.0")
        .author("Kevin K. <kbknapp@gmail.com>:Ola Nordmann <old@nordmann.no>")
        .about("Does awesome things")
        .long_about(
            "With a longer description to help clarify some things.

And a few newlines.",
        )
        .after_help("This is an extra section added to the end of the manpage.")
        .after_long_help("With even more text added.")
        .arg(
            arg!(-c --config <FILE> "Sets a custom config file")
                .long_help("Some more text about how to set a custom config file")
                .default_value("config.toml")
                .env("CONFIG_FILE"),
        )
        .arg(arg!([output] "Sets an output file").default_value("result.txt"))
        .arg(
            arg!(-d --debug ... "Turn debugging information on")
                .env("DEBUG_ON")
                .hide_env(true),
        )
        .subcommand(
            Command::new("test")
                .about("does testing things")
                .arg(arg!(-l --list "Lists test values")),
        );

    Man::new(cmd).render(&mut io::stdout())
}

```

`clap/clap_mangen/src/lib.rs`:

```rs
#![doc = include_str!("../README.md")]
#![doc(html_logo_url = "https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png")]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![forbid(unsafe_code)]
#![warn(missing_docs)]
#![warn(clippy::print_stderr)]
#![warn(clippy::print_stdout)]

mod render;

pub use roff;

use render::subcommand_heading;
use roff::{roman, Roff};
use std::io::Write;

/// A manpage writer
pub struct Man {
    cmd: clap::Command,
    title: String,
    section: String,
    date: String,
    source: String,
    manual: String,
}

/// Build a [`Man`]
impl Man {
    /// Create a new manual page.
    pub fn new(mut cmd: clap::Command) -> Self {
        cmd.build();
        let title = cmd
            .get_display_name()
            .unwrap_or_else(|| cmd.get_name())
            .to_owned();
        let section = "1".to_owned();
        let date = "".to_owned();
        let source = format!(
            "{} {}",
            cmd.get_name(),
            cmd.get_version().unwrap_or_default()
        );
        let manual = "".to_owned();
        Self {
            cmd,
            title,
            section,
            date,
            source,
            manual,
        }
    }

    /// Override the default man page title, written in all caps
    pub fn title(mut self, title: impl Into<String>) -> Self {
        self.title = title.into();
        self
    }

    /// Override the default section this man page is placed in
    ///
    /// Common values:
    ///
    /// - `"1"`: User Commands
    /// - `"2"`: System Calls
    /// - `"3"`: C Library Functions
    /// - `"4"`: Devices and Special Files
    /// - `"5"`: File Formats and Conventions
    /// - `"6"`: Games et. al.
    /// - `"7"`: Miscellanea
    /// - `"8"`: System Administration tools and Daemons
    pub fn section(mut self, section: impl Into<String>) -> Self {
        self.section = section.into();
        self
    }

    /// Override the default date for the last non-trivial change to this man page
    ///
    /// Dates should be written in the form `YYYY-MM-DD`.
    pub fn date(mut self, date: impl Into<String>) -> Self {
        self.date = date.into();
        self
    }

    /// Override the default source your command
    ///
    /// For those few man-pages pages in Sections 1 and 8, probably you just want to write GNU.
    pub fn source(mut self, source: impl Into<String>) -> Self {
        self.source = source.into();
        self
    }

    /// Override the default manual this page is a member of
    pub fn manual(mut self, manual: impl Into<String>) -> Self {
        self.manual = manual.into();
        self
    }
}

/// Handle [`Man`] in relation to files
impl Man {
    /// Generate the filename of the manual page
    #[must_use]
    pub fn get_filename(&self) -> String {
        format!(
            "{}.{}",
            self.cmd
                .get_display_name()
                .unwrap_or_else(|| self.cmd.get_name()),
            self.section
        )
    }

    /// [Renders](Man::render) the manual page and writes it to a file
    pub fn generate_to(
        &self,
        out_dir: impl AsRef<std::path::Path>,
    ) -> Result<std::path::PathBuf, std::io::Error> {
        let filepath = out_dir.as_ref().join(self.get_filename());
        let mut file = std::fs::File::create(&filepath)?;
        self.render(&mut file)?;
        file.flush()?;
        Ok(filepath)
    }
}

/// Generate manual page files for the command with all subcommands
pub fn generate_to(
    cmd: clap::Command,
    out_dir: impl AsRef<std::path::Path>,
) -> Result<(), std::io::Error> {
    fn generate(cmd: clap::Command, out_dir: &std::path::Path) -> Result<(), std::io::Error> {
        for cmd in cmd.get_subcommands().filter(|s| !s.is_hide_set()).cloned() {
            generate(cmd, out_dir)?;
        }
        Man::new(cmd).generate_to(out_dir)?;
        Ok(())
    }

    let mut cmd = cmd.disable_help_subcommand(true);
    cmd.build();
    generate(cmd, out_dir.as_ref())
}

/// Generate ROFF output
impl Man {
    /// Render a full manual page into the writer.
    ///
    /// If customization is needed, you can call the individual sections you want and mix them into
    /// your own ROFF content.
    pub fn render(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_title(&mut roff);
        self._render_name_section(&mut roff);
        self._render_synopsis_section(&mut roff);
        self._render_description_section(&mut roff);

        if app_has_arguments(&self.cmd) {
            self._render_options_section(&mut roff);
        }

        if app_has_subcommands(&self.cmd) {
            self._render_subcommands_section(&mut roff);
        }

        if self.cmd.get_after_long_help().is_some() || self.cmd.get_after_help().is_some() {
            self._render_extra_section(&mut roff);
        }

        if app_has_version(&self.cmd) {
            self._render_version_section(&mut roff);
        }

        if self.cmd.get_author().is_some() {
            self._render_authors_section(&mut roff);
        }

        roff.to_writer(w)
    }

    /// Render the title into the writer.
    pub fn render_title(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_title(&mut roff);
        roff.to_writer(w)
    }

    fn _render_title(&self, roff: &mut Roff) {
        roff.control("TH", self.title_args());
    }

    // Turn metadata into arguments for a .TH macro.
    fn title_args(&self) -> Vec<&str> {
        vec![
            &self.title,
            &self.section,
            &self.date,
            &self.source,
            &self.manual,
        ]
    }

    /// Render the NAME section into the writer.
    pub fn render_name_section(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_name_section(&mut roff);
        roff.to_writer(w)
    }

    fn _render_name_section(&self, roff: &mut Roff) {
        roff.control("SH", ["NAME"]);
        render::about(roff, &self.cmd);
    }

    /// Render the SYNOPSIS section into the writer.
    pub fn render_synopsis_section(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_synopsis_section(&mut roff);
        roff.to_writer(w)
    }

    fn _render_synopsis_section(&self, roff: &mut Roff) {
        roff.control("SH", ["SYNOPSIS"]);
        render::synopsis(roff, &self.cmd);
    }

    /// Render the DESCRIPTION section into the writer.
    pub fn render_description_section(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_description_section(&mut roff);
        roff.to_writer(w)
    }

    fn _render_description_section(&self, roff: &mut Roff) {
        roff.control("SH", ["DESCRIPTION"]);
        render::description(roff, &self.cmd);
    }

    /// Render the OPTIONS section into the writer.
    pub fn render_options_section(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_options_section(&mut roff);
        roff.to_writer(w)
    }

    fn _render_options_section(&self, roff: &mut Roff) {
        let help_headings = self
            .cmd
            .get_arguments()
            .filter(|a| !a.is_hide_set())
            .filter_map(|arg| arg.get_help_heading())
            .fold(vec![], |mut acc, header| {
                if !acc.contains(&header) {
                    acc.push(header);
                }

                acc
            });

        let (args, mut args_with_heading) =
            self.cmd
                .get_arguments()
                .filter(|a| !a.is_hide_set())
                .partition::<Vec<_>, _>(|a| a.get_help_heading().is_none());

        if !args.is_empty() {
            roff.control("SH", ["OPTIONS"]);
            render::options(roff, &args);
        }

        for heading in help_headings {
            let args;
            (args, args_with_heading) = args_with_heading
                .into_iter()
                .partition(|&a| a.get_help_heading() == Some(heading));

            roff.control("SH", [heading.to_uppercase().as_str()]);
            render::options(roff, &args);
        }
    }

    /// Render the SUBCOMMANDS section into the writer.
    pub fn render_subcommands_section(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_subcommands_section(&mut roff);
        roff.to_writer(w)
    }

    fn _render_subcommands_section(&self, roff: &mut Roff) {
        let heading = subcommand_heading(&self.cmd);
        roff.control("SH", [heading]);
        render::subcommands(roff, &self.cmd, &self.section);
    }

    /// Render the EXTRA section into the writer.
    pub fn render_extra_section(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_extra_section(&mut roff);
        roff.to_writer(w)
    }

    fn _render_extra_section(&self, roff: &mut Roff) {
        roff.control("SH", ["EXTRA"]);
        render::after_help(roff, &self.cmd);
    }

    /// Render the VERSION section into the writer.
    pub fn render_version_section(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_version_section(&mut roff);
        roff.to_writer(w)
    }

    fn _render_version_section(&self, roff: &mut Roff) {
        let version = roman(render::version(&self.cmd));
        roff.control("SH", ["VERSION"]);
        roff.text([version]);
    }

    /// Render the AUTHORS section into the writer.
    pub fn render_authors_section(&self, w: &mut dyn Write) -> Result<(), std::io::Error> {
        let mut roff = Roff::default();
        self._render_authors_section(&mut roff);
        roff.to_writer(w)
    }

    fn _render_authors_section(&self, roff: &mut Roff) {
        let author = roman(self.cmd.get_author().unwrap_or_default());
        roff.control("SH", ["AUTHORS"]);
        roff.text([author]);
    }
}

// Does the application have a version?
fn app_has_version(cmd: &clap::Command) -> bool {
    cmd.get_version()
        .or_else(|| cmd.get_long_version())
        .is_some()
}

// Does the application have any command line arguments?
fn app_has_arguments(cmd: &clap::Command) -> bool {
    cmd.get_arguments().any(|i| !i.is_hide_set())
}

// Does the application have any subcommands?
fn app_has_subcommands(cmd: &clap::Command) -> bool {
    cmd.get_subcommands().any(|i| !i.is_hide_set())
}

```

`clap/clap_mangen/src/render.rs`:

```rs
use clap::{Arg, ArgAction};
use roff::{bold, italic, roman, Inline, Roff};

pub(crate) fn subcommand_heading(cmd: &clap::Command) -> &str {
    match cmd.get_subcommand_help_heading() {
        Some(title) => title,
        None => "SUBCOMMANDS",
    }
}

pub(crate) fn about(roff: &mut Roff, cmd: &clap::Command) {
    let name = cmd.get_display_name().unwrap_or_else(|| cmd.get_name());
    let s = match cmd.get_about().or_else(|| cmd.get_long_about()) {
        Some(about) => format!("{name} - {about}"),
        None => name.to_owned(),
    };
    roff.text([roman(s)]);
}

pub(crate) fn description(roff: &mut Roff, cmd: &clap::Command) {
    if let Some(about) = cmd.get_long_about().or_else(|| cmd.get_about()) {
        for line in about.to_string().lines() {
            if line.trim().is_empty() {
                roff.control("PP", []);
            } else {
                roff.text([roman(line)]);
            }
        }
    }
}

pub(crate) fn synopsis(roff: &mut Roff, cmd: &clap::Command) {
    let name = cmd.get_bin_name().unwrap_or_else(|| cmd.get_name());
    let mut line = vec![bold(name), roman(" ")];

    for opt in cmd.get_arguments().filter(|i| !i.is_hide_set()) {
        let (lhs, rhs) = option_markers(opt);
        match (opt.get_short(), opt.get_long()) {
            (Some(short), Some(long)) => {
                line.push(roman(lhs));
                line.push(bold(format!("-{short}")));
                line.push(roman("|"));
                line.push(bold(format!("--{long}",)));
                line.push(roman(rhs));
            }
            (Some(short), None) => {
                line.push(roman(lhs));
                line.push(bold(format!("-{short} ")));
                line.push(roman(rhs));
            }
            (None, Some(long)) => {
                line.push(roman(lhs));
                line.push(bold(format!("--{long}")));
                line.push(roman(rhs));
            }
            (None, None) => continue,
        };

        if matches!(opt.get_action(), ArgAction::Count) {
            line.push(roman("..."));
        }
        line.push(roman(" "));
    }

    for arg in cmd.get_positionals() {
        let (lhs, rhs) = option_markers(arg);
        line.push(roman(lhs));
        if let Some(value) = arg.get_value_names() {
            line.push(italic(value.join(" ")));
        } else {
            line.push(italic(arg.get_id().as_str()));
        }
        line.push(roman(rhs));
        line.push(roman(" "));
    }

    if cmd.has_subcommands() {
        let (lhs, rhs) = subcommand_markers(cmd);
        line.push(roman(lhs));
        line.push(italic(
            cmd.get_subcommand_value_name()
                .unwrap_or_else(|| subcommand_heading(cmd))
                .to_lowercase(),
        ));
        line.push(roman(rhs));
    }

    roff.text(line);
}

pub(crate) fn options(roff: &mut Roff, items: &[&Arg]) {
    for opt in items.iter().filter(|a| !a.is_positional()) {
        let mut header = match (opt.get_short(), opt.get_long()) {
            (Some(short), Some(long)) => {
                vec![short_option(short), roman(", "), long_option(long)]
            }
            (Some(short), None) => vec![short_option(short)],
            (None, Some(long)) => vec![long_option(long)],
            (None, None) => vec![],
        };

        if opt.get_num_args().expect("built").takes_values() {
            if let Some(value) = &opt.get_value_names() {
                header.push(roman("="));
                header.push(italic(value.join(" ")));
            }
        }

        if let Some(defs) = option_default_values(opt) {
            header.push(roman(" "));
            header.push(roman(defs));
        }

        let mut body = vec![];
        let mut arg_help_written = false;
        if let Some(help) = option_help(opt) {
            arg_help_written = true;
            body.push(roman(help.to_string()));
        }

        roff.control("TP", []);
        roff.text(header);
        roff.text(body);

        possible_options(roff, opt, arg_help_written);

        if let Some(env) = option_environment(opt) {
            roff.control("RS", []);
            roff.text(env);
            roff.control("RE", []);
        }
    }

    for pos in items.iter().filter(|a| a.is_positional()) {
        let mut header = vec![];
        let (lhs, rhs) = option_markers(pos);
        header.push(roman(lhs));
        if let Some(value) = pos.get_value_names() {
            header.push(italic(value.join(" ")));
        } else {
            header.push(italic(pos.get_id().as_str()));
        };
        header.push(roman(rhs));

        if let Some(defs) = option_default_values(pos) {
            header.push(roman(format!(" {defs}")));
        }

        let mut body = vec![];
        let mut arg_help_written = false;
        if let Some(help) = option_help(pos) {
            body.push(roman(help.to_string()));
            arg_help_written = true;
        }

        roff.control("TP", []);
        roff.text(header);
        roff.text(body);

        if let Some(env) = option_environment(pos) {
            roff.control("RS", []);
            roff.text(env);
            roff.control("RE", []);
        }

        possible_options(roff, pos, arg_help_written);
    }
}

fn possible_options(roff: &mut Roff, arg: &Arg, arg_help_written: bool) {
    if let Some((possible_values_text, with_help)) = get_possible_values(arg) {
        if arg_help_written {
            // It looks nice to have a separation between the help and the values
            roff.text([Inline::LineBreak]);
        }
        if with_help {
            roff.text([Inline::LineBreak, italic("Possible values:")]);

            // Need to indent twice to get it to look right, because .TP heading indents, but
            // that indent doesn't Carry over to the .IP for the bullets. The standard shift
            // size is 7 for terminal devices
            roff.control("RS", ["14"]);
            for line in possible_values_text {
                roff.control("IP", ["\\(bu", "2"]);
                roff.text([roman(line)]);
            }
            roff.control("RE", []);
        } else {
            let possible_value_text: Vec<Inline> = vec![
                Inline::LineBreak,
                roman("["),
                italic("possible values: "),
                roman(possible_values_text.join(", ")),
                roman("]"),
            ];
            roff.text(possible_value_text);
        }
    }
}

pub(crate) fn subcommands(roff: &mut Roff, cmd: &clap::Command, section: &str) {
    for sub in cmd.get_subcommands().filter(|s| !s.is_hide_set()) {
        roff.control("TP", []);

        let name = format!(
            "{}-{}({})",
            cmd.get_display_name().unwrap_or_else(|| cmd.get_name()),
            sub.get_name(),
            section
        );
        roff.text([roman(name)]);

        if let Some(about) = sub.get_about().or_else(|| sub.get_long_about()) {
            for line in about.to_string().lines() {
                roff.text([roman(line)]);
            }
        }
    }
}

pub(crate) fn version(cmd: &clap::Command) -> String {
    format!(
        "v{}",
        cmd.get_long_version()
            .or_else(|| cmd.get_version())
            .unwrap()
    )
}

pub(crate) fn after_help(roff: &mut Roff, cmd: &clap::Command) {
    if let Some(about) = cmd.get_after_long_help().or_else(|| cmd.get_after_help()) {
        for line in about.to_string().lines() {
            roff.text([roman(line)]);
        }
    }
}

fn subcommand_markers(cmd: &clap::Command) -> (&'static str, &'static str) {
    markers(cmd.is_subcommand_required_set())
}

fn option_markers(opt: &Arg) -> (&'static str, &'static str) {
    markers(opt.is_required_set())
}

fn markers(required: bool) -> (&'static str, &'static str) {
    if required {
        ("<", ">")
    } else {
        ("[", "]")
    }
}

fn short_option(opt: char) -> Inline {
    bold(format!("-{opt}"))
}

fn long_option(opt: &str) -> Inline {
    bold(format!("--{opt}"))
}

fn option_help(opt: &Arg) -> Option<&clap::builder::StyledStr> {
    if !opt.is_hide_long_help_set() {
        let long_help = opt.get_long_help();
        if long_help.is_some() {
            return long_help;
        }
    }
    if !opt.is_hide_short_help_set() {
        return opt.get_help();
    }

    None
}

fn option_environment(opt: &Arg) -> Option<Vec<Inline>> {
    if opt.is_hide_env_set() {
        return None;
    } else if let Some(env) = opt.get_env() {
        return Some(vec![
            roman("May also be specified with the "),
            bold(env.to_string_lossy().into_owned()),
            roman(" environment variable. "),
        ]);
    }

    None
}

fn option_default_values(opt: &Arg) -> Option<String> {
    if opt.is_hide_default_value_set() || !opt.get_num_args().expect("built").takes_values() {
        return None;
    } else if !opt.get_default_values().is_empty() {
        let values = opt
            .get_default_values()
            .iter()
            .map(|s| s.to_string_lossy())
            .collect::<Vec<_>>()
            .join(",");

        return Some(format!("[default: {values}]"));
    }

    None
}

fn get_possible_values(arg: &Arg) -> Option<(Vec<String>, bool)> {
    if arg.is_hide_possible_values_set() {
        return None;
    }

    let possibles = &arg.get_possible_values();
    let possibles: Vec<&clap::builder::PossibleValue> =
        possibles.iter().filter(|pos| !pos.is_hide_set()).collect();

    if !possibles.is_empty() {
        return Some(format_possible_values(&possibles));
    }
    None
}

fn format_possible_values(possibles: &Vec<&clap::builder::PossibleValue>) -> (Vec<String>, bool) {
    let mut lines = vec![];
    let with_help = possibles.iter().any(|p| p.get_help().is_some());
    if with_help {
        for value in possibles {
            let val_name = value.get_name();
            match value.get_help() {
                Some(help) => lines.push(format!("{val_name}: {help}")),
                None => lines.push(val_name.to_string()),
            }
        }
    } else {
        lines.append(&mut possibles.iter().map(|p| p.get_name().to_string()).collect());
    }
    (lines, with_help)
}

```

`clap/clap_mangen/tests/snapshots/aliases.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app 3.0" 
.SH NAME
my\-app \- testing bash completions
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-f\fR|\fB\-\-flag\fR] [\fB\-o\fR|\fB\-\-option\fR] [\fB\-h\fR|\fB\-\-help\fR] [\fB\-V\fR|\fB\-\-version\fR] [\fIpositional\fR] 
.SH DESCRIPTION
testing bash completions
.SH OPTIONS
.TP
\fB\-f\fR, \fB\-\-flag\fR
cmd flag
.TP
\fB\-o\fR, \fB\-\-option\fR
cmd option
.TP
\fB\-h\fR, \fB\-\-help\fR
Print help
.TP
\fB\-V\fR, \fB\-\-version\fR
Print version
.TP
[\fIpositional\fR]

.SH VERSION
v3.0

```

`clap/clap_mangen/tests/snapshots/basic.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app " 
.SH NAME
my\-app
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-c \fR] [\fB\-v \fR] [\fB\-h\fR|\fB\-\-help\fR] [\fIsubcommands\fR]
.SH DESCRIPTION
.SH OPTIONS
.TP
\fB\-c\fR

.TP
\fB\-v\fR

.TP
\fB\-h\fR, \fB\-\-help\fR
Print help
.SH SUBCOMMANDS
.TP
my\-app\-test(1)
Subcommand
with a second line
.TP
my\-app\-help(1)
Print this message or the help of the given subcommand(s)

```

`clap/clap_mangen/tests/snapshots/feature_sample.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app 3.0" 
.SH NAME
my\-app \- Tests completions
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-c\fR|\fB\-\-config\fR]... [\fB\-h\fR|\fB\-\-help\fR] [\fB\-V\fR|\fB\-\-version\fR] [\fIfile\fR] [\fIchoice\fR] [\fIsubcommands\fR]
.SH DESCRIPTION
Tests completions
.SH OPTIONS
.TP
\fB\-c\fR, \fB\-\-config\fR
some config file
.TP
\fB\-h\fR, \fB\-\-help\fR
Print help
.TP
\fB\-V\fR, \fB\-\-version\fR
Print version
.TP
[\fIfile\fR]
some input file
.TP
[\fIchoice\fR]

.br
[\fIpossible values: \fRfirst, second]
.SH SUBCOMMANDS
.TP
my\-app\-test(1)
tests things
.TP
my\-app\-help(1)
Print this message or the help of the given subcommand(s)
.SH VERSION
v3.0

```

`clap/clap_mangen/tests/snapshots/help_headings.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app " 
.SH NAME
my\-app
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-r\fR|\fB\-\-recursive\fR] [\fB\-f\fR|\fB\-\-force\fR] [\fB\-h\fR|\fB\-\-help\fR] [\fIcolor\fR] 
.SH DESCRIPTION
.SH OPTIONS
.TP
\fB\-r\fR, \fB\-\-recursive\fR

.TP
\fB\-h\fR, \fB\-\-help\fR
Print help
.SH "CONFLICT OPTIONS"
.TP
\fB\-f\fR, \fB\-\-force\fR

.SH "GLOBAL OPTIONS"
.TP
[\fIcolor\fR]

.br
[\fIpossible values: \fRalways, never, auto]

```

`clap/clap_mangen/tests/snapshots/hidden_option.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app " 
.SH NAME
my\-app
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-\-config\fR] [\fB\-h\fR|\fB\-\-help\fR] 
.SH DESCRIPTION
.SH OPTIONS
.TP
\fB\-\-config\fR

.TP
\fB\-h\fR, \fB\-\-help\fR
Print help

```

`clap/clap_mangen/tests/snapshots/possible_values.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app " 
.SH NAME
my\-app
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-\-choice\fR] [\fB\-\-method\fR] [\fB\-h\fR|\fB\-\-help\fR] [\fIpositional_choice\fR] 
.SH DESCRIPTION
.SH OPTIONS
.TP
\fB\-\-choice\fR

.br
[\fIpossible values: \fRbash, fish, zsh]
.TP
\fB\-\-method\fR

.br
\fIPossible values:\fR
.RS 14
.IP \(bu 2
fast: use the Fast method
.IP \(bu 2
slow: use the slow method
.RE
.TP
\fB\-h\fR, \fB\-\-help\fR
Print help (see a summary with \*(Aq\-h\*(Aq)
.TP
[\fIpositional_choice\fR]
Pick the Position you want the command to run in
.br

.br
\fIPossible values:\fR
.RS 14
.IP \(bu 2
left: run left adjusted
.IP \(bu 2
right
.RE

```

`clap/clap_mangen/tests/snapshots/quoting.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app 3.0" 
.SH NAME
my\-app
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-\-single\-quotes\fR] [\fB\-\-double\-quotes\fR] [\fB\-\-backticks\fR] [\fB\-\-backslash\fR] [\fB\-\-brackets\fR] [\fB\-\-expansions\fR] [\fB\-h\fR|\fB\-\-help\fR] [\fB\-V\fR|\fB\-\-version\fR] [\fIsubcommands\fR]
.SH DESCRIPTION
.SH OPTIONS
.TP
\fB\-\-single\-quotes\fR
Can be \*(Aqalways\*(Aq, \*(Aqauto\*(Aq, or \*(Aqnever\*(Aq
.TP
\fB\-\-double\-quotes\fR
Can be "always", "auto", or "never"
.TP
\fB\-\-backticks\fR
For more information see `echo test`
.TP
\fB\-\-backslash\fR
Avoid \*(Aq\\n\*(Aq
.TP
\fB\-\-brackets\fR
List packages [filter]
.TP
\fB\-\-expansions\fR
Execute the shell command with $SHELL
.TP
\fB\-h\fR, \fB\-\-help\fR
Print help
.TP
\fB\-V\fR, \fB\-\-version\fR
Print version
.SH SUBCOMMANDS
.TP
my\-app\-cmd\-single\-quotes(1)
Can be \*(Aqalways\*(Aq, \*(Aqauto\*(Aq, or \*(Aqnever\*(Aq
.TP
my\-app\-cmd\-double\-quotes(1)
Can be "always", "auto", or "never"
.TP
my\-app\-cmd\-backticks(1)
For more information see `echo test`
.TP
my\-app\-cmd\-backslash(1)
Avoid \*(Aq\\n\*(Aq
.TP
my\-app\-cmd\-brackets(1)
List packages [filter]
.TP
my\-app\-cmd\-expansions(1)
Execute the shell command with $SHELL
.TP
my\-app\-help(1)
Print this message or the help of the given subcommand(s)
.SH VERSION
v3.0

```

`clap/clap_mangen/tests/snapshots/special_commands.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app 3.0" 
.SH NAME
my\-app \- Tests completions
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-c\fR|\fB\-\-config\fR]... [\fB\-h\fR|\fB\-\-help\fR] [\fB\-V\fR|\fB\-\-version\fR] [\fIfile\fR] [\fIchoice\fR] [\fIsubcommands\fR]
.SH DESCRIPTION
Tests completions
.SH OPTIONS
.TP
\fB\-c\fR, \fB\-\-config\fR
some config file
.TP
\fB\-h\fR, \fB\-\-help\fR
Print help
.TP
\fB\-V\fR, \fB\-\-version\fR
Print version
.TP
[\fIfile\fR]
some input file
.TP
[\fIchoice\fR]

.br
[\fIpossible values: \fRfirst, second]
.SH SUBCOMMANDS
.TP
my\-app\-test(1)
tests things
.TP
my\-app\-some_cmd(1)
tests other things
.TP
my\-app\-some\-cmd\-with\-hyphens(1)
.TP
my\-app\-help(1)
Print this message or the help of the given subcommand(s)
.SH VERSION
v3.0

```

`clap/clap_mangen/tests/snapshots/sub_subcommand_help.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app-help 1  "help " 
.SH NAME
my\-app\-help \- Print this message or the help of the given subcommand(s)
.SH SYNOPSIS
\fBmy\-app help\fR [\fIsubcommands\fR]
.SH DESCRIPTION
Print this message or the help of the given subcommand(s)
.SH SUBCOMMANDS
.TP
my\-app\-help\-test(1)
tests things
.TP
my\-app\-help\-some_cmd(1)
top level subcommand
.TP
my\-app\-help\-help(1)
Print this message or the help of the given subcommand(s)

```

`clap/clap_mangen/tests/snapshots/sub_subcommands.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app 3.0" 
.SH NAME
my\-app \- Tests completions
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-c\fR|\fB\-\-config\fR]... [\fB\-h\fR|\fB\-\-help\fR] [\fB\-V\fR|\fB\-\-version\fR] [\fIfile\fR] [\fIchoice\fR] [\fIsubcommands\fR]
.SH DESCRIPTION
Tests completions
.SH OPTIONS
.TP
\fB\-c\fR, \fB\-\-config\fR
some config file
.TP
\fB\-h\fR, \fB\-\-help\fR
Print help
.TP
\fB\-V\fR, \fB\-\-version\fR
Print version
.TP
[\fIfile\fR]
some input file
.TP
[\fIchoice\fR]

.br
[\fIpossible values: \fRfirst, second]
.SH SUBCOMMANDS
.TP
my\-app\-test(1)
tests things
.TP
my\-app\-some_cmd(1)
top level subcommand
.TP
my\-app\-help(1)
Print this message or the help of the given subcommand(s)
.SH VERSION
v3.0

```

`clap/clap_mangen/tests/snapshots/value_env.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app " 
.SH NAME
my\-app
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-c \fR] [\fB\-h\fR|\fB\-\-help\fR] 
.SH DESCRIPTION
.SH OPTIONS
.TP
\fB\-c\fR [default: config.toml]
Set configuration file path
.RS
May also be specified with the \fBCONFIG_FILE\fR environment variable. 
.RE
.TP
\fB\-h\fR, \fB\-\-help\fR
Print help (see a summary with \*(Aq\-h\*(Aq)

```

`clap/clap_mangen/tests/snapshots/value_hint.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app " 
.SH NAME
my\-app
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-\-choice\fR] [\fB\-\-unknown\fR] [\fB\-\-other\fR] [\fB\-p\fR|\fB\-\-path\fR] [\fB\-f\fR|\fB\-\-file\fR] [\fB\-d\fR|\fB\-\-dir\fR] [\fB\-e\fR|\fB\-\-exe\fR] [\fB\-\-cmd\-name\fR] [\fB\-c\fR|\fB\-\-cmd\fR] [\fB\-u\fR|\fB\-\-user\fR] [\fB\-H\fR|\fB\-\-host\fR] [\fB\-\-url\fR] [\fB\-\-email\fR] [\fB\-h\fR|\fB\-\-help\fR] [\fIcommand_with_args\fR] 
.SH DESCRIPTION
.SH OPTIONS
.TP
\fB\-\-choice\fR

.br
[\fIpossible values: \fRbash, fish, zsh]
.TP
\fB\-\-unknown\fR

.TP
\fB\-\-other\fR

.TP
\fB\-p\fR, \fB\-\-path\fR

.TP
\fB\-f\fR, \fB\-\-file\fR

.TP
\fB\-d\fR, \fB\-\-dir\fR

.TP
\fB\-e\fR, \fB\-\-exe\fR

.TP
\fB\-\-cmd\-name\fR

.TP
\fB\-c\fR, \fB\-\-cmd\fR

.TP
\fB\-u\fR, \fB\-\-user\fR

.TP
\fB\-H\fR, \fB\-\-host\fR

.TP
\fB\-\-url\fR

.TP
\fB\-\-email\fR

.TP
\fB\-h\fR, \fB\-\-help\fR
Print help
.TP
[\fIcommand_with_args\fR]


```

`clap/clap_mangen/tests/snapshots/value_name_without_arg.bash.roff`:

```roff
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH my-app 1  "my-app " 
.SH NAME
my\-app
.SH SYNOPSIS
\fBmy\-app\fR [\fB\-\-flag\fR] [\fB\-h\fR|\fB\-\-help\fR] 
.SH DESCRIPTION
.SH OPTIONS
.TP
\fB\-\-flag\fR

.TP
\fB\-h\fR, \fB\-\-help\fR
Print help

```

`clap/clap_mangen/tests/testsuite/common.rs`:

```rs
use clap::builder::PossibleValue;
use snapbox::prelude::*;

pub(crate) fn basic_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .arg(
            clap::Arg::new("config")
                .short('c')
                .global(true)
                .action(clap::ArgAction::SetTrue),
        )
        .arg(
            clap::Arg::new("v")
                .short('v')
                .conflicts_with("config")
                .action(clap::ArgAction::SetTrue),
        )
        .subcommand(
            clap::Command::new("test")
                .about("Subcommand\nwith a second line")
                .arg(
                    clap::Arg::new("debug")
                        .short('d')
                        .action(clap::ArgAction::Count),
                ),
        )
}

pub(crate) fn feature_sample_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .version("3.0")
        .propagate_version(true)
        .about("Tests completions")
        .arg(
            clap::Arg::new("file")
                .value_hint(clap::ValueHint::FilePath)
                .help("some input file"),
        )
        .arg(
            clap::Arg::new("config")
                .action(clap::ArgAction::Count)
                .help("some config file")
                .short('c')
                .visible_short_alias('C')
                .long("config")
                .visible_alias("conf"),
        )
        .arg(clap::Arg::new("choice").value_parser(["first", "second"]))
        .subcommand(
            clap::Command::new("test").about("tests things").arg(
                clap::Arg::new("case")
                    .long("case")
                    .action(clap::ArgAction::Set)
                    .help("the case to test"),
            ),
        )
}

pub(crate) fn special_commands_command(name: &'static str) -> clap::Command {
    feature_sample_command(name)
        .subcommand(
            clap::Command::new("some_cmd")
                .about("tests other things")
                .arg(
                    clap::Arg::new("config")
                        .long("config")
                        .action(clap::ArgAction::Set)
                        .help("the other case to test"),
                ),
        )
        .subcommand(clap::Command::new("some-cmd-with-hyphens").alias("hyphen"))
}

pub(crate) fn quoting_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .version("3.0")
        .arg(
            clap::Arg::new("single-quotes")
                .long("single-quotes")
                .action(clap::ArgAction::SetTrue)
                .help("Can be 'always', 'auto', or 'never'"),
        )
        .arg(
            clap::Arg::new("double-quotes")
                .long("double-quotes")
                .action(clap::ArgAction::SetTrue)
                .help("Can be \"always\", \"auto\", or \"never\""),
        )
        .arg(
            clap::Arg::new("backticks")
                .long("backticks")
                .action(clap::ArgAction::SetTrue)
                .help("For more information see `echo test`"),
        )
        .arg(
            clap::Arg::new("backslash")
                .long("backslash")
                .action(clap::ArgAction::SetTrue)
                .help("Avoid '\\n'"),
        )
        .arg(
            clap::Arg::new("brackets")
                .long("brackets")
                .action(clap::ArgAction::SetTrue)
                .help("List packages [filter]"),
        )
        .arg(
            clap::Arg::new("expansions")
                .long("expansions")
                .action(clap::ArgAction::SetTrue)
                .help("Execute the shell command with $SHELL"),
        )
        .subcommands([
            clap::Command::new("cmd-single-quotes").about("Can be 'always', 'auto', or 'never'"),
            clap::Command::new("cmd-double-quotes")
                .about("Can be \"always\", \"auto\", or \"never\""),
            clap::Command::new("cmd-backticks").about("For more information see `echo test`"),
            clap::Command::new("cmd-backslash").about("Avoid '\\n'"),
            clap::Command::new("cmd-brackets").about("List packages [filter]"),
            clap::Command::new("cmd-expansions").about("Execute the shell command with $SHELL"),
        ])
}

pub(crate) fn aliases_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .version("3.0")
        .about("testing bash completions")
        .arg(
            clap::Arg::new("flag")
                .short('f')
                .visible_short_alias('F')
                .long("flag")
                .action(clap::ArgAction::SetTrue)
                .visible_alias("flg")
                .help("cmd flag"),
        )
        .arg(
            clap::Arg::new("option")
                .short('o')
                .visible_short_alias('O')
                .long("option")
                .visible_alias("opt")
                .help("cmd option")
                .action(clap::ArgAction::Set),
        )
        .arg(clap::Arg::new("positional"))
}

pub(crate) fn sub_subcommands_command(name: &'static str) -> clap::Command {
    feature_sample_command(name).subcommand(
        clap::Command::new("some_cmd")
            .about("top level subcommand")
            .subcommand(
                clap::Command::new("sub_cmd").about("sub-subcommand").arg(
                    clap::Arg::new("config")
                        .long("config")
                        .action(clap::ArgAction::Set)
                        .value_parser([PossibleValue::new("Lest quotes aren't escaped.")])
                        .help("the other case to test"),
                ),
            ),
    )
}

pub(crate) fn value_hint_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .arg(
            clap::Arg::new("choice")
                .long("choice")
                .action(clap::ArgAction::Set)
                .value_parser(["bash", "fish", "zsh"]),
        )
        .arg(
            clap::Arg::new("unknown")
                .long("unknown")
                .value_hint(clap::ValueHint::Unknown),
        )
        .arg(
            clap::Arg::new("other")
                .long("other")
                .value_hint(clap::ValueHint::Other),
        )
        .arg(
            clap::Arg::new("path")
                .long("path")
                .short('p')
                .value_hint(clap::ValueHint::AnyPath),
        )
        .arg(
            clap::Arg::new("file")
                .long("file")
                .short('f')
                .value_hint(clap::ValueHint::FilePath),
        )
        .arg(
            clap::Arg::new("dir")
                .long("dir")
                .short('d')
                .value_hint(clap::ValueHint::DirPath),
        )
        .arg(
            clap::Arg::new("exe")
                .long("exe")
                .short('e')
                .value_hint(clap::ValueHint::ExecutablePath),
        )
        .arg(
            clap::Arg::new("cmd_name")
                .long("cmd-name")
                .value_hint(clap::ValueHint::CommandName),
        )
        .arg(
            clap::Arg::new("cmd")
                .long("cmd")
                .short('c')
                .value_hint(clap::ValueHint::CommandString),
        )
        .arg(
            clap::Arg::new("command_with_args")
                .action(clap::ArgAction::Set)
                .num_args(1..)
                .trailing_var_arg(true)
                .value_hint(clap::ValueHint::CommandWithArguments),
        )
        .arg(
            clap::Arg::new("user")
                .short('u')
                .long("user")
                .value_hint(clap::ValueHint::Username),
        )
        .arg(
            clap::Arg::new("host")
                .short('H')
                .long("host")
                .value_hint(clap::ValueHint::Hostname),
        )
        .arg(
            clap::Arg::new("url")
                .long("url")
                .value_hint(clap::ValueHint::Url),
        )
        .arg(
            clap::Arg::new("email")
                .long("email")
                .value_hint(clap::ValueHint::EmailAddress),
        )
}

pub(crate) fn hidden_option_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .arg(
            clap::Arg::new("config")
                .long("config")
                .action(clap::ArgAction::Set),
        )
        .arg(
            clap::Arg::new("no-config")
                .long("no-config")
                .hide(true)
                .overrides_with("config"),
        )
}

pub(crate) fn env_value_command(name: &'static str) -> clap::Command {
    clap::Command::new(name).arg(
        clap::Arg::new("config")
            .short('c')
            .long_help("Set configuration file path")
            .required(false)
            .action(clap::ArgAction::Set)
            .default_value("config.toml")
            .env("CONFIG_FILE"),
    )
}

pub(crate) fn assert_matches(expected: impl IntoData, cmd: clap::Command) {
    let mut buf = vec![];
    clap_mangen::Man::new(cmd).render(&mut buf).unwrap();

    snapbox::Assert::new()
        .action_env(snapbox::assert::DEFAULT_ACTION_ENV)
        .normalize_paths(false)
        .eq(buf, expected);
}

pub(crate) fn possible_values_command(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .arg(
            clap::Arg::new("choice")
                .long("choice")
                .action(clap::ArgAction::Set)
                .value_parser(["bash", "fish", "zsh"]),
        )
        .arg(
            clap::Arg::new("method")
                .long("method")
                .action(clap::ArgAction::Set)
                .value_parser([
                    PossibleValue::new("fast").help("use the Fast method"),
                    PossibleValue::new("slow").help("use the slow method"),
                    PossibleValue::new("normal")
                        .help("use normal mode")
                        .hide(true),
                ]),
        )
        .arg(
            clap::Arg::new("positional_choice")
                .action(clap::ArgAction::Set)
                .help("Pick the Position you want the command to run in")
                .value_parser([
                    PossibleValue::new("left").help("run left adjusted"),
                    PossibleValue::new("right"),
                    PossibleValue::new("center").hide(true),
                ]),
        )
}

pub(crate) fn value_name_without_arg(name: &'static str) -> clap::Command {
    clap::Command::new(name).arg(
        clap::Arg::new("flag")
            .long("flag")
            .value_name("SPURIOUS")
            .action(clap::ArgAction::SetTrue),
    )
}

pub(crate) fn help_headings(name: &'static str) -> clap::Command {
    clap::Command::new(name)
        .arg(
            clap::Arg::new("recursive")
                .long("recursive")
                .short('r')
                .action(clap::ArgAction::SetTrue),
        )
        .next_help_heading("Conflict Options")
        .arg(
            clap::Arg::new("force")
                .long("force")
                .short('f')
                .action(clap::ArgAction::SetTrue),
        )
        .next_help_heading("Hidden Options")
        .arg(
            clap::Arg::new("debug")
                .long("debug")
                .short('d')
                .hide(true)
                .action(clap::ArgAction::SetTrue),
        )
        .next_help_heading("Global Options")
        .arg(
            clap::Arg::new("color")
                .global(true)
                .value_parser(["always", "never", "auto"]),
        )
}

```

`clap/clap_mangen/tests/testsuite/main.rs`:

```rs
automod::dir!("tests/testsuite");

```

`clap/clap_mangen/tests/testsuite/roff.rs`:

```rs
use crate::common;

#[test]
fn basic() {
    let name = "my-app";
    let cmd = common::basic_command(name);
    common::assert_matches(snapbox::file!["../snapshots/basic.bash.roff"], cmd);
}

#[test]
fn feature_sample() {
    let name = "my-app";
    let cmd = common::feature_sample_command(name);
    common::assert_matches(snapbox::file!["../snapshots/feature_sample.bash.roff"], cmd);
}

#[test]
fn special_commands() {
    let name = "my-app";
    let cmd = common::special_commands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/special_commands.bash.roff"],
        cmd,
    );
}

#[test]
fn quoting() {
    let name = "my-app";
    let cmd = common::quoting_command(name);
    common::assert_matches(snapbox::file!["../snapshots/quoting.bash.roff"], cmd);
}

#[test]
fn aliases() {
    let name = "my-app";
    let cmd = common::aliases_command(name);
    common::assert_matches(snapbox::file!["../snapshots/aliases.bash.roff"], cmd);
}

#[test]
fn sub_subcommands() {
    let name = "my-app";
    let cmd = common::sub_subcommands_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/sub_subcommands.bash.roff"],
        cmd,
    );
}

#[test]
fn value_hint() {
    let name = "my-app";
    let cmd = common::value_hint_command(name);
    common::assert_matches(snapbox::file!["../snapshots/value_hint.bash.roff"], cmd);
}

#[test]
fn hidden_options() {
    let name = "my-app";
    let cmd = common::hidden_option_command(name);
    common::assert_matches(snapbox::file!["../snapshots/hidden_option.bash.roff"], cmd);
}

#[test]
fn value_env() {
    let name = "my-app";
    let cmd = common::env_value_command(name);
    common::assert_matches(snapbox::file!["../snapshots/value_env.bash.roff"], cmd);
}

#[test]
fn possible_values() {
    let name = "my-app";
    let cmd = common::possible_values_command(name);
    common::assert_matches(
        snapbox::file!["../snapshots/possible_values.bash.roff"],
        cmd,
    );
}

#[test]
fn sub_subcommands_help() {
    let name = "my-app";
    let mut cmd = common::sub_subcommands_command(name);
    cmd.build();
    let cmd = cmd
        .get_subcommands()
        .find(|cmd| cmd.get_display_name() == Some("my-app-help"));
    assert!(cmd.is_some(), "help subcommand not found in command");
    if let Some(cmd) = cmd {
        common::assert_matches(
            snapbox::file!["../snapshots/sub_subcommand_help.roff"],
            cmd.clone(),
        );
    }
}

#[test]
fn help_headings() {
    let name = "my-app";
    let cmd = common::help_headings(name);
    common::assert_matches(snapbox::file!["../snapshots/help_headings.bash.roff"], cmd);
}

#[test]
fn value_name_without_arg() {
    let name = "my-app";
    let cmd = common::value_name_without_arg(name);
    common::assert_matches(
        snapbox::file!["../snapshots/value_name_without_arg.bash.roff"],
        cmd,
    );
}

```

`clap/committed.toml`:

```toml
style="conventional"
ignore_author_re="(dependabot|renovate)"
merge_commit = false

```

`clap/deny.toml`:

```toml
# Note that all fields that take a lint level have these possible values:
# * deny - An error will be produced and the check will fail
# * warn - A warning will be produced, but the check will not fail
# * allow - No warning or error will be produced, though in some cases a note
# will be

# Root options

# The graph table configures how the dependency graph is constructed and thus
# which crates the checks are performed against
[graph]
# If 1 or more target triples (and optionally, target_features) are specified,
# only the specified targets will be checked when running `cargo deny check`.
# This means, if a particular package is only ever used as a target specific
# dependency, such as, for example, the `nix` crate only being used via the
# `target_family = "unix"` configuration, that only having windows targets in
# this list would mean the nix crate, as well as any of its exclusive
# dependencies not shared by any other crates, would be ignored, as the target
# list here is effectively saying which targets you are building for.
targets = [
    # The triple can be any string, but only the target triples built in to
    # rustc (as of 1.40) can be checked against actual config expressions
    #"x86_64-unknown-linux-musl",
    # You can also specify which target_features you promise are enabled for a
    # particular target. target_features are currently not validated against
    # the actual valid features supported by the target architecture.
    #{ triple = "wasm32-unknown-unknown", features = ["atomics"] },
]
# When creating the dependency graph used as the source of truth when checks are
# executed, this field can be used to prune crates from the graph, removing them
# from the view of cargo-deny. This is an extremely heavy hammer, as if a crate
# is pruned from the graph, all of its dependencies will also be pruned unless
# they are connected to another crate in the graph that hasn't been pruned,
# so it should be used with care. The identifiers are [Package ID Specifications]
# (https://doc.rust-lang.org/cargo/reference/pkgid-spec.html)
#exclude = []
# If true, metadata will be collected with `--all-features`. Note that this can't
# be toggled off if true, if you want to conditionally enable `--all-features` it
# is recommended to pass `--all-features` on the cmd line instead
all-features = false
# If true, metadata will be collected with `--no-default-features`. The same
# caveat with `all-features` applies
no-default-features = false
# If set, these feature will be enabled when collecting metadata. If `--features`
# is specified on the cmd line they will take precedence over this option.
#features = []

# The output table provides options for how/if diagnostics are outputted
[output]
# When outputting inclusion graphs in diagnostics that include features, this
# option can be used to specify the depth at which feature edges will be added.
# This option is included since the graphs can be quite large and the addition
# of features from the crate(s) to all of the graph roots can be far too verbose.
# This option can be overridden via `--feature-depth` on the cmd line
feature-depth = 1

# This section is considered when running `cargo deny check advisories`
# More documentation for the advisories section can be found here:
# https://embarkstudios.github.io/cargo-deny/checks/advisories/cfg.html
[advisories]
# The path where the advisory databases are cloned/fetched into
#db-path = "$CARGO_HOME/advisory-dbs"
# The url(s) of the advisory databases to use
#db-urls = ["https://github.com/rustsec/advisory-db"]
# A list of advisory IDs to ignore. Note that ignored advisories will still
# output a note when they are encountered.
ignore = [
    #"RUSTSEC-0000-0000",
    #{ id = "RUSTSEC-0000-0000", reason = "you can specify a reason the advisory is ignored" },
    #"a-crate-that-is-yanked@0.1.1", # you can also ignore yanked crate versions if you wish
    #{ crate = "a-crate-that-is-yanked@0.1.1", reason = "you can specify why you are ignoring the yanked crate" },
]
# If this is true, then cargo deny will use the git executable to fetch advisory database.
# If this is false, then it uses a built-in git library.
# Setting this to true can be helpful if you have special authentication requirements that cargo-deny does not support.
# See Git Authentication for more information about setting up git authentication.
#git-fetch-with-cli = true

# This section is considered when running `cargo deny check licenses`
# More documentation for the licenses section can be found here:
# https://embarkstudios.github.io/cargo-deny/checks/licenses/cfg.html
[licenses]
# List of explicitly allowed licenses
# See https://spdx.org/licenses/ for list of possible licenses
# [possible values: any SPDX 3.11 short identifier (+ optional exception)].
allow = [
    "MIT",
    "MIT-0",
    "Apache-2.0",
    "BSD-3-Clause",
    "MPL-2.0",
    "Unicode-DFS-2016",
    "CC0-1.0",
    "ISC",
    "OpenSSL",
]
# The confidence threshold for detecting a license from license text.
# The higher the value, the more closely the license text must be to the
# canonical license text of a valid SPDX license file.
# [possible values: any between 0.0 and 1.0].
confidence-threshold = 0.8
# Allow 1 or more licenses on a per-crate basis, so that particular licenses
# aren't accepted for every possible crate as with the normal allow list
exceptions = [
    # Each entry is the crate and version constraint, and its specific allow
    # list
    #{ allow = ["Zlib"], crate = "adler32" },
]

# Some crates don't have (easily) machine readable licensing information,
# adding a clarification entry for it allows you to manually specify the
# licensing information
[[licenses.clarify]]
# The package spec the clarification applies to
crate = "ring"
# The SPDX expression for the license requirements of the crate
expression = "MIT AND ISC AND OpenSSL"
# One or more files in the crate's source used as the "source of truth" for
# the license expression. If the contents match, the clarification will be used
# when running the license check, otherwise the clarification will be ignored
# and the crate will be checked normally, which may produce warnings or errors
# depending on the rest of your configuration
license-files = [
# Each entry is a crate relative path, and the (opaque) hash of its contents
{ path = "LICENSE", hash = 0xbd0eed23 }
]

[licenses.private]
# If true, ignores workspace crates that aren't published, or are only
# published to private registries.
# To see how to mark a crate as unpublished (to the official registry),
# visit https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish-field.
ignore = true
# One or more private registries that you might publish crates to, if a crate
# is only published to private registries, and ignore is true, the crate will
# not have its license(s) checked
registries = [
    #"https://sekretz.com/registry
]

# This section is considered when running `cargo deny check bans`.
# More documentation about the 'bans' section can be found here:
# https://embarkstudios.github.io/cargo-deny/checks/bans/cfg.html
[bans]
# Lint level for when multiple versions of the same crate are detected
multiple-versions = "warn"
# Lint level for when a crate version requirement is `*`
wildcards = "allow"
# The graph highlighting used when creating dotgraphs for crates
# with multiple versions
# * lowest-version - The path to the lowest versioned duplicate is highlighted
# * simplest-path - The path to the version with the fewest edges is highlighted
# * all - Both lowest-version and simplest-path are used
highlight = "all"
# The default lint level for `default` features for crates that are members of
# the workspace that is being checked. This can be overridden by allowing/denying
# `default` on a crate-by-crate basis if desired.
workspace-default-features = "allow"
# The default lint level for `default` features for external crates that are not
# members of the workspace. This can be overridden by allowing/denying `default`
# on a crate-by-crate basis if desired.
external-default-features = "allow"
# List of crates that are allowed. Use with care!
allow = [
    #"ansi_term@0.11.0",
    #{ crate = "ansi_term@0.11.0", reason = "you can specify a reason it is allowed" },
]
# List of crates to deny
deny = [
    #"ansi_term@0.11.0",
    #{ crate = "ansi_term@0.11.0", reason = "you can specify a reason it is banned" },
    # Wrapper crates can optionally be specified to allow the crate when it
    # is a direct dependency of the otherwise banned crate
    #{ crate = "ansi_term@0.11.0", wrappers = ["this-crate-directly-depends-on-ansi_term"] },
]

# List of features to allow/deny
# Each entry the name of a crate and a version range. If version is
# not specified, all versions will be matched.
#[[bans.features]]
#crate = "reqwest"
# Features to not allow
#deny = ["json"]
# Features to allow
#allow = [
#    "rustls",
#    "__rustls",
#    "__tls",
#    "hyper-rustls",
#    "rustls",
#    "rustls-pemfile",
#    "rustls-tls-webpki-roots",
#    "tokio-rustls",
#    "webpki-roots",
#]
# If true, the allowed features must exactly match the enabled feature set. If
# this is set there is no point setting `deny`
#exact = true

# Certain crates/versions that will be skipped when doing duplicate detection.
skip = [
    #"ansi_term@0.11.0",
    #{ crate = "ansi_term@0.11.0", reason = "you can specify a reason why it can't be updated/removed" },
]
# Similarly to `skip` allows you to skip certain crates during duplicate
# detection. Unlike skip, it also includes the entire tree of transitive
# dependencies starting at the specified crate, up to a certain depth, which is
# by default infinite.
skip-tree = [
    #"ansi_term@0.11.0", # will be skipped along with _all_ of its direct and transitive dependencies
    #{ crate = "ansi_term@0.11.0", depth = 20 },
]

# This section is considered when running `cargo deny check sources`.
# More documentation about the 'sources' section can be found here:
# https://embarkstudios.github.io/cargo-deny/checks/sources/cfg.html
[sources]
# Lint level for what to happen when a crate from a crate registry that is not
# in the allow list is encountered
unknown-registry = "deny"
# Lint level for what to happen when a crate from a git repository that is not
# in the allow list is encountered
unknown-git = "deny"
# List of URLs for allowed crate registries. Defaults to the crates.io index
# if not specified. If it is specified but empty, no registries are allowed.
allow-registry = ["https://github.com/rust-lang/crates.io-index"]
# List of URLs for allowed Git repositories
allow-git = []

[sources.allow-org]
# 1 or more github.com organizations to allow git sources for
github = []
# 1 or more gitlab.com organizations to allow git sources for
gitlab = []
# 1 or more bitbucket.org organizations to allow git sources for
bitbucket = []

```

`clap/examples/README.md`:

```md
# Examples

We try to focus our documentation on the [four types of
documentation](https://documentation.divio.com/).  Examples fit into this by
providing:
- [Cookbook / How-To Guides](https://docs.rs/clap/latest/clap/_cookbook/index.html)
- Tutorials ([derive](https://docs.rs/clap/latest/clap/_derive/_tutorial/index.html), [builder](https://docs.rs/clap/latest/clap/_tutorial/index.html))

This directory contains the source for the above.

## Contributing

New examples should fit within the above structure and support their narrative
- Add the example to [Cargo.toml](../Cargo.toml) for any `required-features`
- Document how the example works with a `.md` file which will be verified using [trycmd](https://docs.rs/trycmd)
- Pull the `.rs` and `.md` file into the appropriate module doc comment to be accessible on docs.rs

```

`clap/examples/cargo-example-derive.md`:

```md
For more on creating a custom subcommand, see [the cargo
book](https://doc.rust-lang.org/cargo/reference/external-tools.html#custom-subcommands).
The crate [`clap-cargo`](https://github.com/crate-ci/clap-cargo) can help in
mimicking cargo's interface.

The help looks like:
```console
$ cargo-example-derive --help
Usage: cargo <COMMAND>

Commands:
  example-derive  A simple to use, efficient, and full-featured Command Line Argument Parser
  help            Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help

$ cargo-example-derive example-derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: cargo example-derive [OPTIONS]

Options:
      --manifest-path <MANIFEST_PATH>  
  -h, --help                           Print help
  -V, --version                        Print version

```

Then to directly invoke the command, run:
```console
$ cargo-example-derive example-derive
None

$ cargo-example-derive example-derive --manifest-path Cargo.toml
Some("Cargo.toml")

```

```

`clap/examples/cargo-example-derive.rs`:

```rs
use clap::Parser;

#[derive(Parser)] // requires `derive` feature
#[command(name = "cargo")]
#[command(bin_name = "cargo")]
#[command(styles = CLAP_STYLING)]
enum CargoCli {
    ExampleDerive(ExampleDeriveArgs),
}

// See also `clap_cargo::style::CLAP_STYLING`
pub const CLAP_STYLING: clap::builder::styling::Styles = clap::builder::styling::Styles::styled()
    .header(clap_cargo::style::HEADER)
    .usage(clap_cargo::style::USAGE)
    .literal(clap_cargo::style::LITERAL)
    .placeholder(clap_cargo::style::PLACEHOLDER)
    .error(clap_cargo::style::ERROR)
    .valid(clap_cargo::style::VALID)
    .invalid(clap_cargo::style::INVALID);

#[derive(clap::Args)]
#[command(version, about, long_about = None)]
struct ExampleDeriveArgs {
    #[arg(long)]
    manifest_path: Option<std::path::PathBuf>,
}

fn main() {
    let CargoCli::ExampleDerive(args) = CargoCli::parse();
    println!("{:?}", args.manifest_path);
}

```

`clap/examples/cargo-example.md`:

```md
For more on creating a custom subcommand, see [the cargo
book](https://doc.rust-lang.org/cargo/reference/external-tools.html#custom-subcommands).
The crate [`clap-cargo`](https://github.com/crate-ci/clap-cargo) can help in
mimicking cargo's interface.

The help looks like:
```console
$ cargo-example --help
Usage: cargo <COMMAND>

Commands:
  example  A simple to use, efficient, and full-featured Command Line Argument Parser
  help     Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help

$ cargo-example example --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: cargo example [OPTIONS]

Options:
      --manifest-path <PATH>  
  -h, --help                  Print help
  -V, --version               Print version

```

Then to directly invoke the command, run:
```console
$ cargo-example example
None

$ cargo-example example --manifest-path Cargo.toml
Some("Cargo.toml")

```

```

`clap/examples/cargo-example.rs`:

```rs
fn main() {
    let cmd = clap::Command::new("cargo")
        .bin_name("cargo")
        .styles(CLAP_STYLING)
        .subcommand_required(true)
        .subcommand(
            clap::command!("example").arg(
                clap::arg!(--"manifest-path" <PATH>)
                    .value_parser(clap::value_parser!(std::path::PathBuf)),
            ),
        );
    let matches = cmd.get_matches();
    let matches = match matches.subcommand() {
        Some(("example", matches)) => matches,
        _ => unreachable!("clap should ensure we don't get here"),
    };
    let manifest_path = matches.get_one::<std::path::PathBuf>("manifest-path");
    println!("{manifest_path:?}");
}

// See also `clap_cargo::style::CLAP_STYLING`
pub const CLAP_STYLING: clap::builder::styling::Styles = clap::builder::styling::Styles::styled()
    .header(clap_cargo::style::HEADER)
    .usage(clap_cargo::style::USAGE)
    .literal(clap_cargo::style::LITERAL)
    .placeholder(clap_cargo::style::PLACEHOLDER)
    .error(clap_cargo::style::ERROR)
    .valid(clap_cargo::style::VALID)
    .invalid(clap_cargo::style::INVALID);

```

`clap/examples/demo.md`:

```md
```console
$ demo --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: demo[EXE] [OPTIONS] --name <NAME>

Options:
  -n, --name <NAME>    Name of the person to greet
  -c, --count <COUNT>  Number of times to greet [default: 1]
  -h, --help           Print help
  -V, --version        Print version

$ demo --name Me
Hello Me!

```
*(version number and `.exe` extension on windows replaced by placeholders)*

```

`clap/examples/demo.rs`:

```rs
use clap::Parser;

/// Simple program to greet a person
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// Name of the person to greet
    #[arg(short, long)]
    name: String,

    /// Number of times to greet
    #[arg(short, long, default_value_t = 1)]
    count: u8,
}

fn main() {
    let args = Args::parse();

    for _ in 0..args.count {
        println!("Hello {}!", args.name);
    }
}

```

`clap/examples/derive_ref/augment_args.rs`:

```rs
use clap::{arg, Args, Command, FromArgMatches as _};

#[derive(Args, Debug)]
struct DerivedArgs {
    #[arg(short, long)]
    derived: bool,
}

fn main() {
    let cli = Command::new("CLI").arg(arg!(-b - -built).action(clap::ArgAction::SetTrue));
    // Augment built args with derived args
    let cli = DerivedArgs::augment_args(cli);

    let matches = cli.get_matches();
    println!("Value of built: {:?}", matches.get_flag("built"));
    println!(
        "Value of derived via ArgMatches: {:?}",
        matches.get_flag("derived")
    );

    // Since DerivedArgs implements FromArgMatches, we can extract it from the unstructured ArgMatches.
    // This is the main benefit of using derived arguments.
    let derived_matches = DerivedArgs::from_arg_matches(&matches)
        .map_err(|err| err.exit())
        .unwrap();
    println!("Value of derived: {derived_matches:#?}");
}

```

`clap/examples/derive_ref/augment_subcommands.rs`:

```rs
use clap::{Command, FromArgMatches as _, Parser, Subcommand as _};

#[derive(Parser, Debug)]
enum Subcommands {
    Derived {
        #[arg(short, long)]
        derived_flag: bool,
    },
}

fn main() {
    let cli = Command::new("Built CLI");
    // Augment with derived subcommands
    let cli = Subcommands::augment_subcommands(cli);

    let matches = cli.get_matches();
    let derived_subcommands = Subcommands::from_arg_matches(&matches)
        .map_err(|err| err.exit())
        .unwrap();
    println!("Derived subcommands: {derived_subcommands:#?}");
}

```

`clap/examples/derive_ref/flatten_hand_args.rs`:

```rs
use clap::error::Error;
use clap::{Arg, ArgAction, ArgMatches, Args, Command, FromArgMatches, Parser};

#[derive(Debug)]
struct CliArgs {
    foo: bool,
    bar: bool,
    quuz: Option<String>,
}

impl FromArgMatches for CliArgs {
    fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error> {
        let mut matches = matches.clone();
        Self::from_arg_matches_mut(&mut matches)
    }
    fn from_arg_matches_mut(matches: &mut ArgMatches) -> Result<Self, Error> {
        Ok(Self {
            foo: matches.get_flag("foo"),
            bar: matches.get_flag("bar"),
            quuz: matches.remove_one::<String>("quuz"),
        })
    }
    fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error> {
        let mut matches = matches.clone();
        self.update_from_arg_matches_mut(&mut matches)
    }
    fn update_from_arg_matches_mut(&mut self, matches: &mut ArgMatches) -> Result<(), Error> {
        self.foo |= matches.get_flag("foo");
        self.bar |= matches.get_flag("bar");
        if let Some(quuz) = matches.remove_one::<String>("quuz") {
            self.quuz = Some(quuz);
        }
        Ok(())
    }
}

impl Args for CliArgs {
    fn augment_args(cmd: Command) -> Command {
        cmd.arg(
            Arg::new("foo")
                .short('f')
                .long("foo")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("bar")
                .short('b')
                .long("bar")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("quuz")
                .short('q')
                .long("quuz")
                .action(ArgAction::Set),
        )
    }
    fn augment_args_for_update(cmd: Command) -> Command {
        cmd.arg(
            Arg::new("foo")
                .short('f')
                .long("foo")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("bar")
                .short('b')
                .long("bar")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("quuz")
                .short('q')
                .long("quuz")
                .action(ArgAction::Set),
        )
    }
}

#[derive(Parser, Debug)]
struct Cli {
    #[arg(short, long)]
    top_level: bool,
    #[command(flatten)]
    more_args: CliArgs,
}

fn main() {
    let args = Cli::parse();
    println!("{args:#?}");
}

```

`clap/examples/derive_ref/hand_subcommand.rs`:

```rs
#![allow(dead_code)]
use clap::error::{Error, ErrorKind};
use clap::{ArgMatches, Args as _, Command, FromArgMatches, Parser, Subcommand};

#[derive(Parser, Debug)]
struct AddArgs {
    name: Vec<String>,
}
#[derive(Parser, Debug)]
struct RemoveArgs {
    #[arg(short, long)]
    force: bool,
    name: Vec<String>,
}

#[derive(Debug)]
enum CliSub {
    Add(AddArgs),
    Remove(RemoveArgs),
}

impl FromArgMatches for CliSub {
    fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error> {
        match matches.subcommand() {
            Some(("add", args)) => Ok(Self::Add(AddArgs::from_arg_matches(args)?)),
            Some(("remove", args)) => Ok(Self::Remove(RemoveArgs::from_arg_matches(args)?)),
            Some((_, _)) => Err(Error::raw(
                ErrorKind::InvalidSubcommand,
                "Valid subcommands are `add` and `remove`",
            )),
            None => Err(Error::raw(
                ErrorKind::MissingSubcommand,
                "Valid subcommands are `add` and `remove`",
            )),
        }
    }
    fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error> {
        match matches.subcommand() {
            Some(("add", args)) => *self = Self::Add(AddArgs::from_arg_matches(args)?),
            Some(("remove", args)) => *self = Self::Remove(RemoveArgs::from_arg_matches(args)?),
            Some((_, _)) => {
                return Err(Error::raw(
                    ErrorKind::InvalidSubcommand,
                    "Valid subcommands are `add` and `remove`",
                ))
            }
            None => (),
        };
        Ok(())
    }
}

impl Subcommand for CliSub {
    fn augment_subcommands(cmd: Command) -> Command {
        cmd.subcommand(AddArgs::augment_args(Command::new("add")))
            .subcommand(RemoveArgs::augment_args(Command::new("remove")))
            .subcommand_required(true)
    }
    fn augment_subcommands_for_update(cmd: Command) -> Command {
        cmd.subcommand(AddArgs::augment_args(Command::new("add")))
            .subcommand(RemoveArgs::augment_args(Command::new("remove")))
            .subcommand_required(true)
    }
    fn has_subcommand(name: &str) -> bool {
        matches!(name, "add" | "remove")
    }
}

#[derive(Parser, Debug)]
struct Cli {
    #[arg(short, long)]
    top_level: bool,
    #[command(subcommand)]
    subcommand: CliSub,
}

fn main() {
    let args = Cli::parse();
    println!("{args:#?}");
}

```

`clap/examples/derive_ref/interop_tests.md`:

```md
Following are tests for the interop examples in this directory.

## Augment Args

```console
$ interop_augment_args
Value of built: false
Value of derived via ArgMatches: false
Value of derived: DerivedArgs {
    derived: false,
}

```

```console
$ interop_augment_args -b --derived
Value of built: true
Value of derived via ArgMatches: true
Value of derived: DerivedArgs {
    derived: true,
}

```

```console
$ interop_augment_args -d --built
Value of built: true
Value of derived via ArgMatches: true
Value of derived: DerivedArgs {
    derived: true,
}

```

```console
$ interop_augment_args --unknown
? failed
error: unexpected argument '--unknown' found

Usage: interop_augment_args[EXE] [OPTIONS]

For more information, try '--help'.

```

## Augment Subcommands

```console
$ interop_augment_subcommands
? failed
error: A subcommand is required but one was not provided.
```

```console
$ interop_augment_subcommands derived
Derived subcommands: Derived {
    derived_flag: false,
}

```

```console
$ interop_augment_subcommands derived --derived-flag
Derived subcommands: Derived {
    derived_flag: true,
}

```

```console
$ interop_augment_subcommands derived --unknown
? failed
error: unexpected argument '--unknown' found

Usage: interop_augment_subcommands[EXE] derived [OPTIONS]

For more information, try '--help'.

```

```console
$ interop_augment_subcommands unknown
? failed
error: unrecognized subcommand 'unknown'

Usage: interop_augment_subcommands[EXE] [COMMAND]

For more information, try '--help'.

```

## Hand-Implemented Subcommand

```console
$ interop_hand_subcommand
? failed
Usage: interop_hand_subcommand[EXE] [OPTIONS] <COMMAND>

Commands:
  add     
  remove  
  help    Print this message or the help of the given subcommand(s)

Options:
  -t, --top-level  
  -h, --help       Print help

```

```console
$ interop_hand_subcommand add
Cli {
    top_level: false,
    subcommand: Add(
        AddArgs {
            name: [],
        },
    ),
}

```

```console
$ interop_hand_subcommand add a b c
Cli {
    top_level: false,
    subcommand: Add(
        AddArgs {
            name: [
                "a",
                "b",
                "c",
            ],
        },
    ),
}

```

```console
$ interop_hand_subcommand add --unknown
? failed
error: unexpected argument '--unknown' found

  tip: to pass '--unknown' as a value, use '-- --unknown'

Usage: interop_hand_subcommand[EXE] add [NAME]...

For more information, try '--help'.

```

```console
$ interop_hand_subcommand remove
Cli {
    top_level: false,
    subcommand: Remove(
        RemoveArgs {
            force: false,
            name: [],
        },
    ),
}

```

```console
$ interop_hand_subcommand remove --force a b c
Cli {
    top_level: false,
    subcommand: Remove(
        RemoveArgs {
            force: true,
            name: [
                "a",
                "b",
                "c",
            ],
        },
    ),
}

```

```console
$ interop_hand_subcommand unknown
? failed
error: unrecognized subcommand 'unknown'

Usage: interop_hand_subcommand[EXE] [OPTIONS] <COMMAND>

For more information, try '--help'.

```

## Flatten Hand-Implemented Args

```console
$ interop_flatten_hand_args
Cli {
    top_level: false,
    more_args: CliArgs {
        foo: false,
        bar: false,
        quuz: None,
    },
}

```

```console
$ interop_flatten_hand_args -f --bar
Cli {
    top_level: false,
    more_args: CliArgs {
        foo: true,
        bar: true,
        quuz: None,
    },
}

```

```console
$ interop_flatten_hand_args --quuz abc
Cli {
    top_level: false,
    more_args: CliArgs {
        foo: false,
        bar: false,
        quuz: Some(
            "abc",
        ),
    },
}

```

```console
$ interop_flatten_hand_args --unknown
? failed
error: unexpected argument '--unknown' found

Usage: interop_flatten_hand_args[EXE] [OPTIONS]

For more information, try '--help'.

```

```

`clap/examples/escaped-positional-derive.md`:

```md
**This requires enabling the [`derive` feature flag][crate::_features].**

You can use `--` to escape further arguments.

Let's see what this looks like in the help:
```console
$ escaped-positional-derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: escaped-positional-derive[EXE] [OPTIONS] [-- <SLOP>...]

Arguments:
  [SLOP]...  

Options:
  -f             
  -p <PEAR>      
  -h, --help     Print help
  -V, --version  Print version

```

Here is a baseline without any arguments:
```console
$ escaped-positional-derive
-f used: false
-p's value: None
'slops' values: []

```

Notice that we can't pass positional arguments before `--`:
```console
$ escaped-positional-derive foo bar
? failed
error: unexpected argument 'foo' found

Usage: escaped-positional-derive[EXE] [OPTIONS] [-- <SLOP>...]

For more information, try '--help'.

```

But you can after:
```console
$ escaped-positional-derive -f -p=bob -- sloppy slop slop
-f used: true
-p's value: Some("bob")
'slops' values: ["sloppy", "slop", "slop"]

```

As mentioned, the parser will directly pass everything through:
```console
$ escaped-positional-derive -- -f -p=bob sloppy slop slop
-f used: false
-p's value: None
'slops' values: ["-f", "-p=bob", "sloppy", "slop", "slop"]

```

```

`clap/examples/escaped-positional-derive.rs`:

```rs
use clap::Parser;

#[derive(Parser)] // requires `derive` feature
#[command(version, about, long_about = None)]
struct Cli {
    #[arg(short = 'f')]
    eff: bool,

    #[arg(short = 'p', value_name = "PEAR")]
    pea: Option<String>,

    #[arg(last = true)]
    slop: Vec<String>,
}

fn main() {
    let args = Cli::parse();

    // This is what will happen with `myprog -f -p=bob -- sloppy slop slop`...
    println!("-f used: {:?}", args.eff); // -f used: true
    println!("-p's value: {:?}", args.pea); // -p's value: Some("bob")
    println!("'slops' values: {:?}", args.slop); // 'slops' values: Some(["sloppy", "slop", "slop"])

    // Continued program logic goes here...
}

```

`clap/examples/escaped-positional.md`:

```md
**This requires enabling the [`cargo` feature flag][crate::_features].**

You can use `--` to escape further arguments.

Let's see what this looks like in the help:
```console
$ escaped-positional --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: escaped-positional[EXE] [OPTIONS] [-- <SLOP>...]

Arguments:
  [SLOP]...  

Options:
  -f             
  -p <PEAR>      
  -h, --help     Print help
  -V, --version  Print version

```

Here is a baseline without any arguments:
```console
$ escaped-positional
-f used: false
-p's value: None
'slops' values: []

```

Notice that we can't pass positional arguments before `--`:
```console
$ escaped-positional foo bar
? failed
error: unexpected argument 'foo' found

Usage: escaped-positional[EXE] [OPTIONS] [-- <SLOP>...]

For more information, try '--help'.

```

But you can after:
```console
$ escaped-positional -f -p=bob -- sloppy slop slop
-f used: true
-p's value: Some("bob")
'slops' values: ["sloppy", "slop", "slop"]

```

As mentioned, the parser will directly pass everything through:
```console
$ escaped-positional -- -f -p=bob sloppy slop slop
-f used: false
-p's value: None
'slops' values: ["-f", "-p=bob", "sloppy", "slop", "slop"]

```

```

`clap/examples/escaped-positional.rs`:

```rs
use clap::{arg, command, value_parser, ArgAction};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(arg!(eff: -f).action(ArgAction::SetTrue))
        .arg(arg!(pea: -p <PEAR>).value_parser(value_parser!(String)))
        .arg(
            // Indicates that `slop` is only accessible after `--`.
            arg!(slop: [SLOP])
                .num_args(1..)
                .last(true)
                .value_parser(value_parser!(String)),
        )
        .get_matches();

    // This is what will happen with `myprog -f -p=bob -- sloppy slop slop`...

    // -f used: true
    println!("-f used: {:?}", matches.get_flag("eff"));
    // -p's value: Some("bob")
    println!("-p's value: {:?}", matches.get_one::<String>("pea"));
    // 'slops' values: Some(["sloppy", "slop", "slop"])
    println!(
        "'slops' values: {:?}",
        matches
            .get_many::<String>("slop")
            .map(|vals| vals.collect::<Vec<_>>())
            .unwrap_or_default()
    );

    // Continued program logic goes here...
}

```

`clap/examples/find.md`:

```md
`find` is an example of position-sensitive flags

```console
$ find --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: find[EXE] [OPTIONS]

Options:
  -h, --help     Print help
  -V, --version  Print version

TESTS:
      --empty        File is empty and is either a regular file or a directory
      --name <name>  Base of file name (the path with the leading directories removed) matches shell
                     pattern pattern

OPERATORS:
  -o, --or   expr2 is not evaluate if exp1 is true
  -a, --and  Same as `expr1 expr1`

$ find --empty -o --name .keep
[
    (
        "empty",
        Bool(
            true,
        ),
    ),
    (
        "or",
        Bool(
            true,
        ),
    ),
    (
        "name",
        String(
            ".keep",
        ),
    ),
]

$ find --empty -o --name .keep -o --name foo
[
    (
        "empty",
        Bool(
            true,
        ),
    ),
    (
        "or",
        Bool(
            true,
        ),
    ),
    (
        "name",
        String(
            ".keep",
        ),
    ),
    (
        "or",
        Bool(
            true,
        ),
    ),
    (
        "name",
        String(
            "foo",
        ),
    ),
]

```


```

`clap/examples/find.rs`:

```rs
use std::collections::BTreeMap;

use clap::{command, value_parser, Arg, ArgAction, ArgGroup, ArgMatches, Command};

fn main() {
    let matches = cli().get_matches();
    let values = Value::from_matches(&matches);
    println!("{values:#?}");
}

fn cli() -> Command {
    command!()
        .group(ArgGroup::new("tests").multiple(true))
        .next_help_heading("TESTS")
        .args([
            position_sensitive_flag(Arg::new("empty"))
                .long("empty")
                .action(ArgAction::Append)
                .help("File is empty and is either a regular file or a directory")
                .group("tests"),
            Arg::new("name")
                .long("name")
                .action(ArgAction::Append)
                .help("Base of file name (the path with the leading directories removed) matches shell pattern pattern")
                .group("tests")
        ])
        .group(ArgGroup::new("operators").multiple(true))
        .next_help_heading("OPERATORS")
        .args([
            position_sensitive_flag(Arg::new("or"))
                .short('o')
                .long("or")
                .action(ArgAction::Append)
                .help("expr2 is not evaluate if exp1 is true")
                .group("operators"),
            position_sensitive_flag(Arg::new("and"))
                .short('a')
                .long("and")
                .action(ArgAction::Append)
                .help("Same as `expr1 expr1`")
                .group("operators"),
        ])
}

fn position_sensitive_flag(arg: Arg) -> Arg {
    // Flags don't track the position of each occurrence, so we need to emulate flags with
    // value-less options to get the same result
    arg.num_args(0)
        .value_parser(value_parser!(bool))
        .default_missing_value("true")
        .default_value("false")
}

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub enum Value {
    Bool(bool),
    String(String),
}

impl Value {
    pub fn from_matches(matches: &ArgMatches) -> Vec<(clap::Id, Self)> {
        let mut values = BTreeMap::new();
        for id in matches.ids() {
            if matches.try_get_many::<clap::Id>(id.as_str()).is_ok() {
                // ignore groups
                continue;
            }
            let value_source = matches
                .value_source(id.as_str())
                .expect("id came from matches");
            if value_source != clap::parser::ValueSource::CommandLine {
                // Any other source just gets tacked on at the end (like default values)
                continue;
            }
            if Self::extract::<String>(matches, id, &mut values) {
                continue;
            }
            if Self::extract::<bool>(matches, id, &mut values) {
                continue;
            }
            unimplemented!("unknown type for {id}: {matches:?}");
        }
        values.into_values().collect::<Vec<_>>()
    }

    fn extract<T: Clone + Into<Value> + Send + Sync + 'static>(
        matches: &ArgMatches,
        id: &clap::Id,
        output: &mut BTreeMap<usize, (clap::Id, Self)>,
    ) -> bool {
        match matches.try_get_many::<T>(id.as_str()) {
            Ok(Some(values)) => {
                for (value, index) in values.zip(
                    matches
                        .indices_of(id.as_str())
                        .expect("id came from matches"),
                ) {
                    output.insert(index, (id.clone(), value.clone().into()));
                }
                true
            }
            Ok(None) => {
                unreachable!("`ids` only reports what is present")
            }
            Err(clap::parser::MatchesError::UnknownArgument { .. }) => {
                unreachable!("id came from matches")
            }
            Err(clap::parser::MatchesError::Downcast { .. }) => false,
            Err(_) => {
                unreachable!("id came from matches")
            }
        }
    }
}

impl From<String> for Value {
    fn from(other: String) -> Self {
        Self::String(other)
    }
}

impl From<bool> for Value {
    fn from(other: bool) -> Self {
        Self::Bool(other)
    }
}

```

`clap/examples/git-derive.md`:

```md
**This requires enabling the [`derive` feature flag][crate::_features].**

Git is an example of several common subcommand patterns.

Help:
```console
$ git-derive
? failed
A fictional versioning CLI

Usage: git-derive[EXE] <COMMAND>

Commands:
  clone  Clones repos
  diff   Compare two commits
  push   pushes things
  add    adds things
  stash  
  help   Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help

$ git-derive help
A fictional versioning CLI

Usage: git-derive[EXE] <COMMAND>

Commands:
  clone  Clones repos
  diff   Compare two commits
  push   pushes things
  add    adds things
  stash  
  help   Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help

$ git-derive help add
adds things

Usage: git-derive[EXE] add <PATH>...

Arguments:
  <PATH>...  Stuff to add

Options:
  -h, --help  Print help

```

A basic argument:
```console
$ git-derive add
? failed
adds things

Usage: git-derive[EXE] add <PATH>...

Arguments:
  <PATH>...  Stuff to add

Options:
  -h, --help  Print help

$ git-derive add Cargo.toml Cargo.lock
Adding ["Cargo.toml", "Cargo.lock"]

```

Default subcommand:
```console
$ git-derive stash -h
Usage: git-derive[EXE] stash [OPTIONS]
       git-derive[EXE] stash push [OPTIONS]
       git-derive[EXE] stash pop [STASH]
       git-derive[EXE] stash apply [STASH]
       git-derive[EXE] stash help [COMMAND]...

Options:
  -m, --message <MESSAGE>  
  -h, --help               Print help

git-derive[EXE] stash push:
  -m, --message <MESSAGE>  
  -h, --help               Print help

git-derive[EXE] stash pop:
  -h, --help  Print help
  [STASH]     

git-derive[EXE] stash apply:
  -h, --help  Print help
  [STASH]     

git-derive[EXE] stash help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

$ git-derive stash push -h
Usage: git-derive[EXE] stash push [OPTIONS]

Options:
  -m, --message <MESSAGE>  
  -h, --help               Print help

$ git-derive stash pop -h
Usage: git-derive[EXE] stash pop [STASH]

Arguments:
  [STASH]  

Options:
  -h, --help  Print help

$ git-derive stash -m "Prototype"
Pushing StashPushArgs { message: Some("Prototype") }

$ git-derive stash pop
Popping None

$ git-derive stash push -m "Prototype"
Pushing StashPushArgs { message: Some("Prototype") }

$ git-derive stash pop
Popping None

```

External subcommands:
```console
$ git-derive custom-tool arg1 --foo bar
Calling out to "custom-tool" with ["arg1", "--foo", "bar"]

```

Last argument:
```console
$ git-derive diff --help
Compare two commits

Usage: git-derive[EXE] diff [OPTIONS] [COMMIT] [COMMIT] [-- <PATH>]

Arguments:
  [COMMIT]  
  [COMMIT]  
  [PATH]    

Options:
      --color[=<WHEN>]  [default: auto] [possible values: always, auto, never]
  -h, --help            Print help

$ git-derive diff
Diffing stage..worktree  (color=auto)

$ git-derive diff ./src
Diffing stage..worktree ./src (color=auto)

$ git-derive diff HEAD ./src
Diffing HEAD..worktree ./src (color=auto)

$ git-derive diff HEAD~~ -- HEAD
Diffing HEAD~~..worktree HEAD (color=auto)

$ git-derive diff --color
Diffing stage..worktree  (color=always)

$ git-derive diff --color=never
Diffing stage..worktree  (color=never)

```

```

`clap/examples/git-derive.rs`:

```rs
use std::ffi::OsStr;
use std::ffi::OsString;
use std::path::PathBuf;

use clap::{Args, Parser, Subcommand, ValueEnum};

/// A fictional versioning CLI
#[derive(Debug, Parser)] // requires `derive` feature
#[command(name = "git")]
#[command(about = "A fictional versioning CLI", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Debug, Subcommand)]
enum Commands {
    /// Clones repos
    #[command(arg_required_else_help = true)]
    Clone {
        /// The remote to clone
        remote: String,
    },
    /// Compare two commits
    Diff {
        #[arg(value_name = "COMMIT")]
        base: Option<OsString>,
        #[arg(value_name = "COMMIT")]
        head: Option<OsString>,
        #[arg(last = true)]
        path: Option<OsString>,
        #[arg(
            long,
            require_equals = true,
            value_name = "WHEN",
            num_args = 0..=1,
            default_value_t = ColorWhen::Auto,
            default_missing_value = "always",
            value_enum
        )]
        color: ColorWhen,
    },
    /// pushes things
    #[command(arg_required_else_help = true)]
    Push {
        /// The remote to target
        remote: String,
    },
    /// adds things
    #[command(arg_required_else_help = true)]
    Add {
        /// Stuff to add
        #[arg(required = true)]
        path: Vec<PathBuf>,
    },
    Stash(StashArgs),
    #[command(external_subcommand)]
    External(Vec<OsString>),
}

#[derive(ValueEnum, Copy, Clone, Debug, PartialEq, Eq)]
enum ColorWhen {
    Always,
    Auto,
    Never,
}

impl std::fmt::Display for ColorWhen {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.to_possible_value()
            .expect("no values are skipped")
            .get_name()
            .fmt(f)
    }
}

#[derive(Debug, Args)]
#[command(args_conflicts_with_subcommands = true)]
#[command(flatten_help = true)]
struct StashArgs {
    #[command(subcommand)]
    command: Option<StashCommands>,

    #[command(flatten)]
    push: StashPushArgs,
}

#[derive(Debug, Subcommand)]
enum StashCommands {
    Push(StashPushArgs),
    Pop { stash: Option<String> },
    Apply { stash: Option<String> },
}

#[derive(Debug, Args)]
struct StashPushArgs {
    #[arg(short, long)]
    message: Option<String>,
}

fn main() {
    let args = Cli::parse();

    match args.command {
        Commands::Clone { remote } => {
            println!("Cloning {remote}");
        }
        Commands::Diff {
            mut base,
            mut head,
            mut path,
            color,
        } => {
            if path.is_none() {
                path = head;
                head = None;
                if path.is_none() {
                    path = base;
                    base = None;
                }
            }
            let base = base
                .as_deref()
                .map(|s| s.to_str().unwrap())
                .unwrap_or("stage");
            let head = head
                .as_deref()
                .map(|s| s.to_str().unwrap())
                .unwrap_or("worktree");
            let path = path.as_deref().unwrap_or_else(|| OsStr::new(""));
            println!(
                "Diffing {}..{} {} (color={})",
                base,
                head,
                path.to_string_lossy(),
                color
            );
        }
        Commands::Push { remote } => {
            println!("Pushing to {remote}");
        }
        Commands::Add { path } => {
            println!("Adding {path:?}");
        }
        Commands::Stash(stash) => {
            let stash_cmd = stash.command.unwrap_or(StashCommands::Push(stash.push));
            match stash_cmd {
                StashCommands::Push(push) => {
                    println!("Pushing {push:?}");
                }
                StashCommands::Pop { stash } => {
                    println!("Popping {stash:?}");
                }
                StashCommands::Apply { stash } => {
                    println!("Applying {stash:?}");
                }
            }
        }
        Commands::External(args) => {
            println!("Calling out to {:?} with {:?}", &args[0], &args[1..]);
        }
    }

    // Continued program logic goes here...
}

```

`clap/examples/git.md`:

```md
Git is an example of several common subcommand patterns.

Help:
```console
$ git
? failed
A fictional versioning CLI

Usage: git[EXE] <COMMAND>

Commands:
  clone  Clones repos
  diff   Compare two commits
  push   pushes things
  add    adds things
  stash  
  help   Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help

$ git help
A fictional versioning CLI

Usage: git[EXE] <COMMAND>

Commands:
  clone  Clones repos
  diff   Compare two commits
  push   pushes things
  add    adds things
  stash  
  help   Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help

$ git help add
adds things

Usage: git[EXE] add <PATH>...

Arguments:
  <PATH>...  Stuff to add

Options:
  -h, --help  Print help

```

A basic argument:
```console
$ git add
? failed
adds things

Usage: git[EXE] add <PATH>...

Arguments:
  <PATH>...  Stuff to add

Options:
  -h, --help  Print help

$ git add Cargo.toml Cargo.lock
Adding ["Cargo.toml", "Cargo.lock"]

```

Default subcommand:
```console
$ git stash -h
Usage: git[EXE] stash [OPTIONS]
       git[EXE] stash push [OPTIONS]
       git[EXE] stash pop [STASH]
       git[EXE] stash apply [STASH]
       git[EXE] stash help [COMMAND]...

Options:
  -m, --message <MESSAGE>  
  -h, --help               Print help

git[EXE] stash push:
  -m, --message <MESSAGE>  
  -h, --help               Print help

git[EXE] stash pop:
  -h, --help  Print help
  [STASH]     

git[EXE] stash apply:
  -h, --help  Print help
  [STASH]     

git[EXE] stash help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

$ git stash push -h
Usage: git[EXE] stash push [OPTIONS]

Options:
  -m, --message <MESSAGE>  
  -h, --help               Print help

$ git stash pop -h
Usage: git[EXE] stash pop [STASH]

Arguments:
  [STASH]  

Options:
  -h, --help  Print help

$ git stash -m "Prototype"
Pushing Some("Prototype")

$ git stash pop
Popping None

$ git stash push -m "Prototype"
Pushing Some("Prototype")

$ git stash pop
Popping None

```

External subcommands:
```console
$ git custom-tool arg1 --foo bar
Calling out to "custom-tool" with ["arg1", "--foo", "bar"]

```

Last argument:
```console
$ git diff --help
Compare two commits

Usage: git[EXE] diff [OPTIONS] [COMMIT] [COMMIT] [-- <PATH>]

Arguments:
  [COMMIT]  
  [COMMIT]  
  [PATH]    

Options:
      --color[=<WHEN>]  [default: auto] [possible values: always, auto, never]
  -h, --help            Print help

$ git diff
Diffing stage..worktree  (color=auto)

$ git diff ./src
Diffing stage..worktree ./src (color=auto)

$ git diff HEAD ./src
Diffing HEAD..worktree ./src (color=auto)

$ git diff HEAD~~ -- HEAD
Diffing HEAD~~..worktree HEAD (color=auto)

$ git diff --color
Diffing stage..worktree  (color=always)

$ git diff --color=never
Diffing stage..worktree  (color=never)

```

```

`clap/examples/git.rs`:

```rs
use std::ffi::OsString;
use std::path::PathBuf;

use clap::{arg, Command};

fn cli() -> Command {
    Command::new("git")
        .about("A fictional versioning CLI")
        .subcommand_required(true)
        .arg_required_else_help(true)
        .allow_external_subcommands(true)
        .subcommand(
            Command::new("clone")
                .about("Clones repos")
                .arg(arg!(<REMOTE> "The remote to clone"))
                .arg_required_else_help(true),
        )
        .subcommand(
            Command::new("diff")
                .about("Compare two commits")
                .arg(arg!(base: [COMMIT]))
                .arg(arg!(head: [COMMIT]))
                .arg(arg!(path: [PATH]).last(true))
                .arg(
                    arg!(--color <WHEN>)
                        .value_parser(["always", "auto", "never"])
                        .num_args(0..=1)
                        .require_equals(true)
                        .default_value("auto")
                        .default_missing_value("always"),
                ),
        )
        .subcommand(
            Command::new("push")
                .about("pushes things")
                .arg(arg!(<REMOTE> "The remote to target"))
                .arg_required_else_help(true),
        )
        .subcommand(
            Command::new("add")
                .about("adds things")
                .arg_required_else_help(true)
                .arg(arg!(<PATH> ... "Stuff to add").value_parser(clap::value_parser!(PathBuf))),
        )
        .subcommand(
            Command::new("stash")
                .args_conflicts_with_subcommands(true)
                .flatten_help(true)
                .args(push_args())
                .subcommand(Command::new("push").args(push_args()))
                .subcommand(Command::new("pop").arg(arg!([STASH])))
                .subcommand(Command::new("apply").arg(arg!([STASH]))),
        )
}

fn push_args() -> Vec<clap::Arg> {
    vec![arg!(-m --message <MESSAGE>)]
}

fn main() {
    let matches = cli().get_matches();

    match matches.subcommand() {
        Some(("clone", sub_matches)) => {
            println!(
                "Cloning {}",
                sub_matches.get_one::<String>("REMOTE").expect("required")
            );
        }
        Some(("diff", sub_matches)) => {
            let color = sub_matches
                .get_one::<String>("color")
                .map(|s| s.as_str())
                .expect("defaulted in clap");

            let mut base = sub_matches.get_one::<String>("base").map(|s| s.as_str());
            let mut head = sub_matches.get_one::<String>("head").map(|s| s.as_str());
            let mut path = sub_matches.get_one::<String>("path").map(|s| s.as_str());
            if path.is_none() {
                path = head;
                head = None;
                if path.is_none() {
                    path = base;
                    base = None;
                }
            }
            let base = base.unwrap_or("stage");
            let head = head.unwrap_or("worktree");
            let path = path.unwrap_or("");
            println!("Diffing {base}..{head} {path} (color={color})");
        }
        Some(("push", sub_matches)) => {
            println!(
                "Pushing to {}",
                sub_matches.get_one::<String>("REMOTE").expect("required")
            );
        }
        Some(("add", sub_matches)) => {
            let paths = sub_matches
                .get_many::<PathBuf>("PATH")
                .into_iter()
                .flatten()
                .collect::<Vec<_>>();
            println!("Adding {paths:?}");
        }
        Some(("stash", sub_matches)) => {
            let stash_command = sub_matches.subcommand().unwrap_or(("push", sub_matches));
            match stash_command {
                ("apply", sub_matches) => {
                    let stash = sub_matches.get_one::<String>("STASH");
                    println!("Applying {stash:?}");
                }
                ("pop", sub_matches) => {
                    let stash = sub_matches.get_one::<String>("STASH");
                    println!("Popping {stash:?}");
                }
                ("push", sub_matches) => {
                    let message = sub_matches.get_one::<String>("message");
                    println!("Pushing {message:?}");
                }
                (name, _) => {
                    unreachable!("Unsupported subcommand `{name}`")
                }
            }
        }
        Some((ext, sub_matches)) => {
            let args = sub_matches
                .get_many::<OsString>("")
                .into_iter()
                .flatten()
                .collect::<Vec<_>>();
            println!("Calling out to {ext:?} with {args:?}");
        }
        _ => unreachable!(), // If all subcommands are defined above, anything else is unreachable!()
    }

    // Continued program logic goes here...
}

```

`clap/examples/multicall-busybox.md`:

```md
See the documentation for [`Command::multicall`][crate::Command::multicall] for rationale.

This example omits every command except true and false,
which are the most trivial to implement,
```console
$ busybox true
? 0

$ busybox false
? 1

```
*Note: without the links setup, we can't demonstrate the multicall behavior*

But includes the `--install` option as an example of why it can be useful
for the main program to take arguments that aren't applet subcommands.
```console
$ busybox --install
? failed
...

```

Though users must pass something:
```console
$ busybox
? failed
Usage: busybox [OPTIONS] [APPLET]

APPLETS:
  true   does nothing successfully
  false  does nothing unsuccessfully
  help   Print this message or the help of the given subcommand(s)

Options:
      --install <install>  Install hardlinks for all subcommands in path
  -h, --help               Print help

```

```

`clap/examples/multicall-busybox.rs`:

```rs
use std::path::PathBuf;
use std::process::exit;

use clap::{value_parser, Arg, ArgAction, Command};

fn applet_commands() -> [Command; 2] {
    [
        Command::new("true").about("does nothing successfully"),
        Command::new("false").about("does nothing unsuccessfully"),
    ]
}

fn main() {
    let cmd = Command::new(env!("CARGO_CRATE_NAME"))
        .multicall(true)
        .subcommand(
            Command::new("busybox")
                .arg_required_else_help(true)
                .subcommand_value_name("APPLET")
                .subcommand_help_heading("APPLETS")
                .arg(
                    Arg::new("install")
                        .long("install")
                        .help("Install hardlinks for all subcommands in path")
                        .exclusive(true)
                        .action(ArgAction::Set)
                        .default_missing_value("/usr/local/bin")
                        .value_parser(value_parser!(PathBuf)),
                )
                .subcommands(applet_commands()),
        )
        .subcommands(applet_commands());

    let matches = cmd.get_matches();
    let mut subcommand = matches.subcommand();
    if let Some(("busybox", cmd)) = subcommand {
        if cmd.contains_id("install") {
            unimplemented!("Make hardlinks to the executable here");
        }
        subcommand = cmd.subcommand();
    }
    match subcommand {
        Some(("false", _)) => exit(1),
        Some(("true", _)) => exit(0),
        _ => unreachable!("parser should ensure only valid subcommand names are used"),
    }
}

```

`clap/examples/multicall-hostname.md`:

```md
See the documentation for [`Command::multicall`][crate::Command::multicall] for rationale.

This example omits the implementation of displaying address config

```console
$ hostname
www

```
*Note: without the links setup, we can't demonstrate the multicall behavior*

```

`clap/examples/multicall-hostname.rs`:

```rs
use clap::Command;

fn main() {
    let cmd = Command::new(env!("CARGO_CRATE_NAME"))
        .multicall(true)
        .arg_required_else_help(true)
        .subcommand_value_name("APPLET")
        .subcommand_help_heading("APPLETS")
        .subcommand(Command::new("hostname").about("show hostname part of FQDN"))
        .subcommand(Command::new("dnsdomainname").about("show domain name part of FQDN"));

    match cmd.get_matches().subcommand_name() {
        Some("hostname") => println!("www"),
        Some("dnsdomainname") => println!("example.com"),
        _ => unreachable!("parser should ensure only valid subcommand names are used"),
    }
}

```

`clap/examples/pacman.md`:

```md
[`pacman`](https://wiki.archlinux.org/index.php/pacman) defines subcommands via flags.

Here, `-S` is a short flag subcommand:
```console
$ pacman -S package
Installing package...

```

Here `--sync` is a long flag subcommand:
```console
$ pacman --sync package
Installing package...

```

Now the short flag subcommand (`-S`) with a long flag:
```console
$ pacman -S --search name
Searching for name...

```

And the various forms of short flags that work:
```console
$ pacman -S -s name
Searching for name...

$ pacman -Ss name
Searching for name...

```
*(users can "stack" short subcommands with short flags or with other short flag subcommands)*

In the help, this looks like:
```console
$ pacman -h
package manager utility

Usage: pacman[EXE] <COMMAND>

Commands:
  query, -Q, --query  Query the package database.
  sync, -S, --sync    Synchronize packages.
  help                Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

$ pacman -S -h
Synchronize packages.

Usage: pacman[EXE] {sync|--sync|-S} [OPTIONS] [package]...

Arguments:
  [package]...  packages

Options:
  -s, --search <search>...  search remote repositories for matching strings
  -i, --info                view package information
  -h, --help                Print help

```

And errors:
```console
$ pacman -S -s foo -i bar
? failed
error: the argument '--search <search>...' cannot be used with '--info'

Usage: pacman[EXE] {sync|--sync|-S} --search <search>... <package>...

For more information, try '--help'.

```

<div class="warning">

**NOTE:** Keep in mind that subcommands, flags, and long flags are *case sensitive*: `-Q` and `-q` are different flags/subcommands. For example, you can have both `-Q` subcommand and `-q` flag, and they will be properly disambiguated.
Let's make a quick program to illustrate.

</div>

```

`clap/examples/pacman.rs`:

```rs
use clap::{Arg, ArgAction, Command};

fn main() {
    let matches = Command::new("pacman")
        .about("package manager utility")
        .version("5.2.1")
        .subcommand_required(true)
        .arg_required_else_help(true)
        // Query subcommand
        //
        // Only a few of its arguments are implemented below.
        .subcommand(
            Command::new("query")
                .short_flag('Q')
                .long_flag("query")
                .about("Query the package database.")
                .arg(
                    Arg::new("search")
                        .short('s')
                        .long("search")
                        .help("search locally installed packages for matching strings")
                        .conflicts_with("info")
                        .action(ArgAction::Set)
                        .num_args(1..),
                )
                .arg(
                    Arg::new("info")
                        .long("info")
                        .short('i')
                        .conflicts_with("search")
                        .help("view package information")
                        .action(ArgAction::Set)
                        .num_args(1..),
                ),
        )
        // Sync subcommand
        //
        // Only a few of its arguments are implemented below.
        .subcommand(
            Command::new("sync")
                .short_flag('S')
                .long_flag("sync")
                .about("Synchronize packages.")
                .arg(
                    Arg::new("search")
                        .short('s')
                        .long("search")
                        .conflicts_with("info")
                        .action(ArgAction::Set)
                        .num_args(1..)
                        .help("search remote repositories for matching strings"),
                )
                .arg(
                    Arg::new("info")
                        .long("info")
                        .conflicts_with("search")
                        .short('i')
                        .action(ArgAction::SetTrue)
                        .help("view package information"),
                )
                .arg(
                    Arg::new("package")
                        .help("packages")
                        .required_unless_present("search")
                        .action(ArgAction::Set)
                        .num_args(1..),
                ),
        )
        .get_matches();

    match matches.subcommand() {
        Some(("sync", sync_matches)) => {
            if sync_matches.contains_id("search") {
                let packages: Vec<_> = sync_matches
                    .get_many::<String>("search")
                    .expect("contains_id")
                    .map(|s| s.as_str())
                    .collect();
                let values = packages.join(", ");
                println!("Searching for {values}...");
                return;
            }

            let packages: Vec<_> = sync_matches
                .get_many::<String>("package")
                .expect("is present")
                .map(|s| s.as_str())
                .collect();
            let values = packages.join(", ");

            if sync_matches.get_flag("info") {
                println!("Retrieving info for {values}...");
            } else {
                println!("Installing {values}...");
            }
        }
        Some(("query", query_matches)) => {
            if let Some(packages) = query_matches.get_many::<String>("info") {
                let comma_sep = packages.map(|s| s.as_str()).collect::<Vec<_>>().join(", ");
                println!("Retrieving info for {comma_sep}...");
            } else if let Some(queries) = query_matches.get_many::<String>("search") {
                let comma_sep = queries.map(|s| s.as_str()).collect::<Vec<_>>().join(", ");
                println!("Searching Locally for {comma_sep}...");
            } else {
                println!("Displaying all locally installed packages...");
            }
        }
        _ => unreachable!(), // If all subcommands are defined above, anything else is unreachable
    }
}

```

`clap/examples/repl-derive.rs`:

```rs
use std::io::Write;

use clap::{Parser, Subcommand};

fn main() -> Result<(), String> {
    loop {
        let line = readline()?;
        let line = line.trim();
        if line.is_empty() {
            continue;
        }

        match respond(line) {
            Ok(quit) => {
                if quit {
                    break;
                }
            }
            Err(err) => {
                write!(std::io::stdout(), "{err}").map_err(|e| e.to_string())?;
                std::io::stdout().flush().map_err(|e| e.to_string())?;
            }
        }
    }

    Ok(())
}

fn respond(line: &str) -> Result<bool, String> {
    let args = shlex::split(line).ok_or("error: Invalid quoting")?;
    let cli = Cli::try_parse_from(args).map_err(|e| e.to_string())?;
    match cli.command {
        Commands::Ping => {
            write!(std::io::stdout(), "Pong").map_err(|e| e.to_string())?;
            std::io::stdout().flush().map_err(|e| e.to_string())?;
        }
        Commands::Exit => {
            write!(std::io::stdout(), "Exiting ...").map_err(|e| e.to_string())?;
            std::io::stdout().flush().map_err(|e| e.to_string())?;
            return Ok(true);
        }
    }
    Ok(false)
}

#[derive(Debug, Parser)]
#[command(multicall = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Debug, Subcommand)]
enum Commands {
    Ping,
    Exit,
}

fn readline() -> Result<String, String> {
    write!(std::io::stdout(), "$ ").map_err(|e| e.to_string())?;
    std::io::stdout().flush().map_err(|e| e.to_string())?;
    let mut buffer = String::new();
    std::io::stdin()
        .read_line(&mut buffer)
        .map_err(|e| e.to_string())?;
    Ok(buffer)
}

```

`clap/examples/repl.rs`:

```rs
use std::io::Write;

use clap::Command;

fn main() -> Result<(), String> {
    loop {
        let line = readline()?;
        let line = line.trim();
        if line.is_empty() {
            continue;
        }

        match respond(line) {
            Ok(quit) => {
                if quit {
                    break;
                }
            }
            Err(err) => {
                write!(std::io::stdout(), "{err}").map_err(|e| e.to_string())?;
                std::io::stdout().flush().map_err(|e| e.to_string())?;
            }
        }
    }

    Ok(())
}

fn respond(line: &str) -> Result<bool, String> {
    let args = shlex::split(line).ok_or("error: Invalid quoting")?;
    let matches = cli()
        .try_get_matches_from(args)
        .map_err(|e| e.to_string())?;
    match matches.subcommand() {
        Some(("ping", _matches)) => {
            write!(std::io::stdout(), "Pong").map_err(|e| e.to_string())?;
            std::io::stdout().flush().map_err(|e| e.to_string())?;
        }
        Some(("quit", _matches)) => {
            write!(std::io::stdout(), "Exiting ...").map_err(|e| e.to_string())?;
            std::io::stdout().flush().map_err(|e| e.to_string())?;
            return Ok(true);
        }
        Some((name, _matches)) => unimplemented!("{name}"),
        None => unreachable!("subcommand required"),
    }

    Ok(false)
}

fn cli() -> Command {
    // strip out usage
    const PARSER_TEMPLATE: &str = "\
        {all-args}
    ";
    // strip out name/version
    const APPLET_TEMPLATE: &str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    ";

    Command::new("repl")
        .multicall(true)
        .arg_required_else_help(true)
        .subcommand_required(true)
        .subcommand_value_name("APPLET")
        .subcommand_help_heading("APPLETS")
        .help_template(PARSER_TEMPLATE)
        .subcommand(
            Command::new("ping")
                .about("Get a response")
                .help_template(APPLET_TEMPLATE),
        )
        .subcommand(
            Command::new("quit")
                .alias("exit")
                .about("Quit the REPL")
                .help_template(APPLET_TEMPLATE),
        )
}

fn readline() -> Result<String, String> {
    write!(std::io::stdout(), "$ ").map_err(|e| e.to_string())?;
    std::io::stdout().flush().map_err(|e| e.to_string())?;
    let mut buffer = String::new();
    std::io::stdin()
        .read_line(&mut buffer)
        .map_err(|e| e.to_string())?;
    Ok(buffer)
}

```

`clap/examples/tutorial_builder/01_quick.md`:

```md
```console
$ 01_quick --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 01_quick[EXE] [OPTIONS] [name] [COMMAND]

Commands:
  test  does testing things
  help  Print this message or the help of the given subcommand(s)

Arguments:
  [name]  Optional name to operate on

Options:
  -c, --config <FILE>  Sets a custom config file
  -d, --debug...       Turn debugging information on
  -h, --help           Print help
  -V, --version        Print version

```

By default, the program does nothing:
```console
$ 01_quick
Debug mode is off

```

But you can mix and match the various features
```console
$ 01_quick -dd test
Debug mode is on
Not printing testing lists...

```

```

`clap/examples/tutorial_builder/01_quick.rs`:

```rs
use std::path::PathBuf;

use clap::{arg, command, value_parser, ArgAction, Command};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(arg!([name] "Optional name to operate on"))
        .arg(
            arg!(
                -c --config <FILE> "Sets a custom config file"
            )
            // We don't have syntax yet for optional options, so manually calling `required`
            .required(false)
            .value_parser(value_parser!(PathBuf)),
        )
        .arg(arg!(
            -d --debug ... "Turn debugging information on"
        ))
        .subcommand(
            Command::new("test")
                .about("does testing things")
                .arg(arg!(-l --list "lists test values").action(ArgAction::SetTrue)),
        )
        .get_matches();

    // You can check the value provided by positional arguments, or option arguments
    if let Some(name) = matches.get_one::<String>("name") {
        println!("Value for name: {name}");
    }

    if let Some(config_path) = matches.get_one::<PathBuf>("config") {
        println!("Value for config: {}", config_path.display());
    }

    // You can see how many times a particular flag or argument occurred
    // Note, only flags can have multiple occurrences
    match matches
        .get_one::<u8>("debug")
        .expect("Counts are defaulted")
    {
        0 => println!("Debug mode is off"),
        1 => println!("Debug mode is kind of on"),
        2 => println!("Debug mode is on"),
        _ => println!("Don't be crazy"),
    }

    // You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    if let Some(matches) = matches.subcommand_matches("test") {
        // "$ myapp test" was run
        if matches.get_flag("list") {
            // "$ myapp test -l" was run
            println!("Printing testing lists...");
        } else {
            println!("Not printing testing lists...");
        }
    }

    // Continued program logic goes here...
}

```

`clap/examples/tutorial_builder/02_app_settings.md`:

```md
```console
$ 02_app_settings --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_app_settings[EXE] --two <VALUE> --one <VALUE>

Options:
      --two <VALUE>
          
      --one <VALUE>
          
  -h, --help
          Print help
  -V, --version
          Print version

```

```

`clap/examples/tutorial_builder/02_app_settings.rs`:

```rs
use clap::{arg, command, ArgAction};

fn main() {
    let matches = command!() // requires `cargo` feature
        .next_line_help(true)
        .arg(arg!(--two <VALUE>).required(true).action(ArgAction::Set))
        .arg(arg!(--one <VALUE>).required(true).action(ArgAction::Set))
        .get_matches();

    println!(
        "two: {:?}",
        matches.get_one::<String>("two").expect("required")
    );
    println!(
        "one: {:?}",
        matches.get_one::<String>("one").expect("required")
    );
}

```

`clap/examples/tutorial_builder/02_apps.md`:

```md
```console
$ 02_apps --help
Does awesome things

Usage: 02_apps[EXE] --two <VALUE> --one <VALUE>

Options:
      --two <VALUE>  
      --one <VALUE>  
  -h, --help         Print help
  -V, --version      Print version

$ 02_apps --version
MyApp 1.0

```

```

`clap/examples/tutorial_builder/02_apps.rs`:

```rs
use clap::{arg, Command};

fn main() {
    let matches = Command::new("MyApp")
        .version("1.0")
        .about("Does awesome things")
        .arg(arg!(--two <VALUE>).required(true))
        .arg(arg!(--one <VALUE>).required(true))
        .get_matches();

    println!(
        "two: {:?}",
        matches.get_one::<String>("two").expect("required")
    );
    println!(
        "one: {:?}",
        matches.get_one::<String>("one").expect("required")
    );
}

```

`clap/examples/tutorial_builder/02_crate.md`:

```md
```console
$ 02_crate --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_crate[EXE] --two <VALUE> --one <VALUE>

Options:
      --two <VALUE>  
      --one <VALUE>  
  -h, --help         Print help
  -V, --version      Print version

$ 02_crate --version
clap [..]

```

```

`clap/examples/tutorial_builder/02_crate.rs`:

```rs
use clap::{arg, command};

fn main() {
    // requires `cargo` feature, reading name, version, author, and description from `Cargo.toml`
    let matches = command!()
        .arg(arg!(--two <VALUE>).required(true))
        .arg(arg!(--one <VALUE>).required(true))
        .get_matches();

    println!(
        "two: {:?}",
        matches.get_one::<String>("two").expect("required")
    );
    println!(
        "one: {:?}",
        matches.get_one::<String>("one").expect("required")
    );
}

```

`clap/examples/tutorial_builder/03_01_flag_bool.md`:

```md
```console
$ 03_01_flag_bool --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_bool[EXE] [OPTIONS]

Options:
  -v, --verbose  
  -h, --help     Print help
  -V, --version  Print version

$ 03_01_flag_bool
verbose: false

$ 03_01_flag_bool --verbose
verbose: true

$ 03_01_flag_bool --verbose --verbose
? failed
error: the argument '--verbose' cannot be used multiple times

Usage: 03_01_flag_bool[EXE] [OPTIONS]

For more information, try '--help'.

```

```

`clap/examples/tutorial_builder/03_01_flag_bool.rs`:

```rs
use clap::{command, Arg, ArgAction};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(
            Arg::new("verbose")
                .short('v')
                .long("verbose")
                .action(ArgAction::SetTrue),
        )
        .get_matches();

    println!("verbose: {:?}", matches.get_flag("verbose"));
}

```

`clap/examples/tutorial_builder/03_01_flag_count.md`:

```md
```console
$ 03_01_flag_count --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_count[EXE] [OPTIONS]

Options:
  -v, --verbose...  
  -h, --help        Print help
  -V, --version     Print version

$ 03_01_flag_count
verbose: 0

$ 03_01_flag_count --verbose
verbose: 1

$ 03_01_flag_count --verbose --verbose
verbose: 2

```

```

`clap/examples/tutorial_builder/03_01_flag_count.rs`:

```rs
use clap::{command, Arg, ArgAction};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(
            Arg::new("verbose")
                .short('v')
                .long("verbose")
                .action(ArgAction::Count),
        )
        .get_matches();

    println!("verbose: {:?}", matches.get_count("verbose"));
}

```

`clap/examples/tutorial_builder/03_02_option.md`:

```md
```console
$ 03_02_option --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option[EXE] [OPTIONS]

Options:
  -n, --name <name>  
  -h, --help         Print help
  -V, --version      Print version

$ 03_02_option
name: None

$ 03_02_option --name bob
name: Some("bob")

$ 03_02_option --name=bob
name: Some("bob")

$ 03_02_option -n bob
name: Some("bob")

$ 03_02_option -n=bob
name: Some("bob")

$ 03_02_option -nbob
name: Some("bob")

```

```

`clap/examples/tutorial_builder/03_02_option.rs`:

```rs
use clap::{command, Arg};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(Arg::new("name").short('n').long("name"))
        .get_matches();

    println!("name: {:?}", matches.get_one::<String>("name"));
}

```

`clap/examples/tutorial_builder/03_02_option_mult.md`:

```md
```console
$ 03_02_option_mult --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option_mult[EXE] [OPTIONS]

Options:
  -n, --name <name>  
  -h, --help         Print help
  -V, --version      Print version

$ 03_02_option_mult
names: []

$ 03_02_option_mult --name bob
names: ["bob"]

$ 03_02_option_mult --name bob --name john
names: ["bob", "john"]

$ 03_02_option_mult_derive --name bob --name=john -n tom -n=chris -nsteve
name: ["bob", "john", "tom", "chris", "steve"]

```

```

`clap/examples/tutorial_builder/03_02_option_mult.rs`:

```rs
use clap::{command, Arg, ArgAction};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(
            Arg::new("name")
                .short('n')
                .long("name")
                .action(ArgAction::Append),
        )
        .get_matches();

    let args = matches
        .get_many::<String>("name")
        .unwrap_or_default()
        .map(|v| v.as_str())
        .collect::<Vec<_>>();

    println!("names: {:?}", &args);
}

```

`clap/examples/tutorial_builder/03_03_positional.md`:

```md
```console
$ 03_03_positional --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional[EXE] [name]

Arguments:
  [name]  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_03_positional
name: None

$ 03_03_positional bob
name: Some("bob")

```

```

`clap/examples/tutorial_builder/03_03_positional.rs`:

```rs
use clap::{command, Arg};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(Arg::new("name"))
        .get_matches();

    println!("name: {:?}", matches.get_one::<String>("name"));
}

```

`clap/examples/tutorial_builder/03_03_positional_mult.md`:

```md
```console
$ 03_03_positional_mult --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional_mult[EXE] [name]...

Arguments:
  [name]...  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_03_positional_mult
names: []

$ 03_03_positional_mult bob
names: ["bob"]

$ 03_03_positional_mult bob john
names: ["bob", "john"]

```

```

`clap/examples/tutorial_builder/03_03_positional_mult.rs`:

```rs
use clap::{command, Arg, ArgAction};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(Arg::new("name").action(ArgAction::Append))
        .get_matches();

    let args = matches
        .get_many::<String>("name")
        .unwrap_or_default()
        .map(|v| v.as_str())
        .collect::<Vec<_>>();

    println!("names: {:?}", &args);
}

```

`clap/examples/tutorial_builder/03_04_subcommands.md`:

```md
```console
$ 03_04_subcommands help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands[EXE] <COMMAND>

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_04_subcommands help add
Adds files to myapp

Usage: 03_04_subcommands[EXE] add [NAME]

Arguments:
  [NAME]  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_04_subcommands add bob
'myapp add' was used, name is: Some("bob")

```

Because we set [`Command::arg_required_else_help`][crate::Command::arg_required_else_help]:
```console
$ 03_04_subcommands
? failed
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands[EXE] <COMMAND>

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

```

Since we specified [`Command::propagate_version`][crate::Command::propagate_version], the `--version` flag
is available in all subcommands:
```console
$ 03_04_subcommands --version
clap [..]

$ 03_04_subcommands add --version
clap-add [..]

```

```

`clap/examples/tutorial_builder/03_04_subcommands.rs`:

```rs
use clap::{arg, command, Command};

fn main() {
    let matches = command!() // requires `cargo` feature
        .propagate_version(true)
        .subcommand_required(true)
        .arg_required_else_help(true)
        .subcommand(
            Command::new("add")
                .about("Adds files to myapp")
                .arg(arg!([NAME])),
        )
        .get_matches();

    match matches.subcommand() {
        Some(("add", sub_matches)) => println!(
            "'myapp add' was used, name is: {:?}",
            sub_matches.get_one::<String>("NAME")
        ),
        _ => unreachable!("Exhausted list of subcommands and subcommand_required prevents `None`"),
    }
}

```

`clap/examples/tutorial_builder/03_05_default_values.md`:

```md
```console
$ 03_05_default_values --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_05_default_values[EXE] [PORT]

Arguments:
  [PORT]  [default: 2020]

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_05_default_values
port: 2020

$ 03_05_default_values 22
port: 22

```

```

`clap/examples/tutorial_builder/03_05_default_values.rs`:

```rs
use clap::{arg, command, value_parser};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(
            arg!([PORT])
                .value_parser(value_parser!(u16))
                .default_value("2020"),
        )
        .get_matches();

    println!(
        "port: {:?}",
        matches
            .get_one::<u16>("PORT")
            .expect("default ensures there is always a value")
    );
}

```

`clap/examples/tutorial_builder/03_06_required.md`:

```md
```console
$ 03_06_required --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_06_required[EXE] <name>

Arguments:
  <name>  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_06_required
? 2
error: the following required arguments were not provided:
  <name>

Usage: 03_06_required[EXE] <name>

For more information, try '--help'.

$ 03_06_required bob
name: "bob"

```

```

`clap/examples/tutorial_builder/03_06_required.rs`:

```rs
use clap::{command, Arg};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(Arg::new("name").required(true))
        .get_matches();

    println!(
        "name: {:?}",
        matches
            .get_one::<String>("name")
            .expect("clap `required` ensures its present")
    );
}

```

`clap/examples/tutorial_builder/04_01_enum.md`:

```md
```console
$ 04_01_enum --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_enum[EXE] <MODE>

Arguments:
  <MODE>
          What mode to run the program in

          Possible values:
          - fast: Run swiftly
          - slow: Crawl slowly but steadily

Options:
  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version

$ 04_01_enum -h
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_enum[EXE] <MODE>

Arguments:
  <MODE>  What mode to run the program in [possible values: fast, slow]

Options:
  -h, --help     Print help (see more with '--help')
  -V, --version  Print version

$ 04_01_enum fast
Hare

$ 04_01_enum slow
Tortoise

$ 04_01_enum medium
? failed
error: invalid value 'medium' for '<MODE>'
  [possible values: fast, slow]

For more information, try '--help'.

```

```

`clap/examples/tutorial_builder/04_01_enum.rs`:

```rs
use clap::{arg, builder::PossibleValue, command, value_parser, ValueEnum};

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
enum Mode {
    Fast,
    Slow,
}

// Can also be derived with feature flag `derive`
impl ValueEnum for Mode {
    fn value_variants<'a>() -> &'a [Self] {
        &[Mode::Fast, Mode::Slow]
    }

    fn to_possible_value(&self) -> Option<PossibleValue> {
        Some(match self {
            Mode::Fast => PossibleValue::new("fast").help("Run swiftly"),
            Mode::Slow => PossibleValue::new("slow").help("Crawl slowly but steadily"),
        })
    }
}

impl std::fmt::Display for Mode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.to_possible_value()
            .expect("no values are skipped")
            .get_name()
            .fmt(f)
    }
}

impl std::str::FromStr for Mode {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        for variant in Self::value_variants() {
            if variant.to_possible_value().unwrap().matches(s, false) {
                return Ok(*variant);
            }
        }
        Err(format!("invalid variant: {s}"))
    }
}

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(
            arg!(<MODE>)
                .help("What mode to run the program in")
                .value_parser(value_parser!(Mode)),
        )
        .get_matches();

    // Note, it's safe to call unwrap() because the arg is required
    match matches
        .get_one::<Mode>("MODE")
        .expect("'MODE' is required and parsing will fail if its missing")
    {
        Mode::Fast => {
            println!("Hare");
        }
        Mode::Slow => {
            println!("Tortoise");
        }
    }
}

```

`clap/examples/tutorial_builder/04_01_possible.md`:

```md
```console
$ 04_01_possible --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_possible[EXE] <MODE>

Arguments:
  <MODE>  What mode to run the program in [possible values: fast, slow]

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 04_01_possible fast
Hare

$ 04_01_possible slow
Tortoise

$ 04_01_possible medium
? failed
error: invalid value 'medium' for '<MODE>'
  [possible values: fast, slow]

For more information, try '--help'.

```

```

`clap/examples/tutorial_builder/04_01_possible.rs`:

```rs
use clap::{arg, command};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(
            arg!(<MODE>)
                .help("What mode to run the program in")
                .value_parser(["fast", "slow"]),
        )
        .get_matches();

    // Note, it's safe to call unwrap() because the arg is required
    match matches
        .get_one::<String>("MODE")
        .expect("'MODE' is required and parsing will fail if its missing")
        .as_str()
    {
        "fast" => {
            println!("Hare");
        }
        "slow" => {
            println!("Tortoise");
        }
        _ => unreachable!(),
    }
}

```

`clap/examples/tutorial_builder/04_02_parse.md`:

```md
```console
$ 04_02_parse --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_parse[EXE] <PORT>

Arguments:
  <PORT>  Network port to use

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 04_02_parse 22
PORT = 22

$ 04_02_parse foobar
? failed
error: invalid value 'foobar' for '<PORT>': invalid digit found in string

For more information, try '--help'.

$ 04_02_parse_derive 0
? failed
error: invalid value '0' for '<PORT>': 0 is not in 1..=65535

For more information, try '--help'.

```

```

`clap/examples/tutorial_builder/04_02_parse.rs`:

```rs
use clap::{arg, command, value_parser};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(
            arg!(<PORT>)
                .help("Network port to use")
                .value_parser(value_parser!(u16).range(1..)),
        )
        .get_matches();

    // Note, it's safe to call unwrap() because the arg is required
    let port: u16 = *matches
        .get_one::<u16>("PORT")
        .expect("'PORT' is required and parsing will fail if its missing");
    println!("PORT = {port}");
}

```

`clap/examples/tutorial_builder/04_02_validate.md`:

```md
```console
$ 04_02_validate --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_validate[EXE] <PORT>

Arguments:
  <PORT>  Network port to use

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 04_02_validate 22
PORT = 22

$ 04_02_validate foobar
? failed
error: invalid value 'foobar' for '<PORT>': `foobar` isn't a port number

For more information, try '--help'.

$ 04_02_validate 0
? failed
error: invalid value '0' for '<PORT>': port not in range 1-65535

For more information, try '--help'.

```

```

`clap/examples/tutorial_builder/04_02_validate.rs`:

```rs
use std::ops::RangeInclusive;

use clap::{arg, command};

fn main() {
    let matches = command!() // requires `cargo` feature
        .arg(
            arg!(<PORT>)
                .help("Network port to use")
                .value_parser(port_in_range),
        )
        .get_matches();

    // Note, it's safe to call unwrap() because the arg is required
    let port: u16 = *matches
        .get_one::<u16>("PORT")
        .expect("'PORT' is required and parsing will fail if its missing");
    println!("PORT = {port}");
}

const PORT_RANGE: RangeInclusive<usize> = 1..=65535;

fn port_in_range(s: &str) -> Result<u16, String> {
    let port: usize = s
        .parse()
        .map_err(|_| format!("`{s}` isn't a port number"))?;
    if PORT_RANGE.contains(&port) {
        Ok(port as u16)
    } else {
        Err(format!(
            "port not in range {}-{}",
            PORT_RANGE.start(),
            PORT_RANGE.end()
        ))
    }
}

```

`clap/examples/tutorial_builder/04_03_relations.md`:

```md
```console
$ 04_03_relations --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_03_relations[EXE] [OPTIONS] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver <VER>      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in <SPEC_IN>  some special input argument
  -c <CONFIG>              
  -h, --help               Print help
  -V, --version            Print version

$ 04_03_relations
? failed
error: the following required arguments were not provided:
  <--set-ver <VER>|--major|--minor|--patch>

Usage: 04_03_relations[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]

For more information, try '--help'.

$ 04_03_relations --major
Version: 2.2.3

$ 04_03_relations --major --minor
? failed
error: the argument '--major' cannot be used with '--minor'

Usage: 04_03_relations[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]

For more information, try '--help'.

$ 04_03_relations --major -c config.toml
? failed
error: the following required arguments were not provided:
  <INPUT_FILE|--spec-in <SPEC_IN>>

Usage: 04_03_relations[EXE] -c <CONFIG> <--set-ver <VER>|--major|--minor|--patch> <INPUT_FILE|--spec-in <SPEC_IN>>

For more information, try '--help'.

$ 04_03_relations --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml

```

```

`clap/examples/tutorial_builder/04_03_relations.rs`:

```rs
use std::path::PathBuf;

use clap::{arg, command, value_parser, ArgAction, ArgGroup};

fn main() {
    // Create application like normal
    let matches = command!() // requires `cargo` feature
        // Add the version arguments
        .arg(arg!(--"set-ver" <VER> "set version manually"))
        .arg(arg!(--major         "auto inc major").action(ArgAction::SetTrue))
        .arg(arg!(--minor         "auto inc minor").action(ArgAction::SetTrue))
        .arg(arg!(--patch         "auto inc patch").action(ArgAction::SetTrue))
        // Create a group, make it required, and add the above arguments
        .group(
            ArgGroup::new("vers")
                .required(true)
                .args(["set-ver", "major", "minor", "patch"]),
        )
        // Arguments can also be added to a group individually, these two arguments
        // are part of the "input" group which is not required
        .arg(
            arg!([INPUT_FILE] "some regular input")
                .value_parser(value_parser!(PathBuf))
                .group("input"),
        )
        .arg(
            arg!(--"spec-in" <SPEC_IN> "some special input argument")
                .value_parser(value_parser!(PathBuf))
                .group("input"),
        )
        // Now let's assume we have a -c [config] argument which requires one of
        // (but **not** both) the "input" arguments
        .arg(
            arg!(config: -c <CONFIG>)
                .value_parser(value_parser!(PathBuf))
                .requires("input"),
        )
        .get_matches();

    // Let's assume the old version 1.2.3
    let mut major = 1;
    let mut minor = 2;
    let mut patch = 3;

    // See if --set-ver was used to set the version manually
    let version = if let Some(ver) = matches.get_one::<String>("set-ver") {
        ver.to_owned()
    } else {
        // Increment the one requested (in a real program, we'd reset the lower numbers)
        let (maj, min, pat) = (
            matches.get_flag("major"),
            matches.get_flag("minor"),
            matches.get_flag("patch"),
        );
        match (maj, min, pat) {
            (true, _, _) => major += 1,
            (_, true, _) => minor += 1,
            (_, _, true) => patch += 1,
            _ => unreachable!(),
        };
        format!("{major}.{minor}.{patch}")
    };

    println!("Version: {version}");

    // Check for usage of -c
    if matches.contains_id("config") {
        let input = matches
            .get_one::<PathBuf>("INPUT_FILE")
            .unwrap_or_else(|| matches.get_one::<PathBuf>("spec-in").unwrap())
            .display();
        println!(
            "Doing work using input {} and config {}",
            input,
            matches.get_one::<PathBuf>("config").unwrap().display()
        );
    }
}

```

`clap/examples/tutorial_builder/04_04_custom.md`:

```md
```console
$ 04_04_custom --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver <VER>      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in <SPEC_IN>  some special input argument
  -c <CONFIG>              
  -h, --help               Print help
  -V, --version            Print version

$ 04_04_custom
? failed
error: Can only modify one version field

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

For more information, try '--help'.

$ 04_04_custom --major
Version: 2.2.3

$ 04_04_custom --major --minor
? failed
error: Can only modify one version field

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

For more information, try '--help'.

$ 04_04_custom --major -c config.toml
? failed
Version: 2.2.3
error: INPUT_FILE or --spec-in is required when using --config

Usage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]

For more information, try '--help'.

$ 04_04_custom --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml

```

```

`clap/examples/tutorial_builder/04_04_custom.rs`:

```rs
use std::path::PathBuf;

use clap::error::ErrorKind;
use clap::{arg, command, value_parser, ArgAction};

fn main() {
    // Create application like normal
    let mut cmd = command!() // requires `cargo` feature
        // Add the version arguments
        .arg(arg!(--"set-ver" <VER> "set version manually"))
        .arg(arg!(--major         "auto inc major").action(ArgAction::SetTrue))
        .arg(arg!(--minor         "auto inc minor").action(ArgAction::SetTrue))
        .arg(arg!(--patch         "auto inc patch").action(ArgAction::SetTrue))
        // Arguments can also be added to a group individually, these two arguments
        // are part of the "input" group which is not required
        .arg(arg!([INPUT_FILE] "some regular input").value_parser(value_parser!(PathBuf)))
        .arg(
            arg!(--"spec-in" <SPEC_IN> "some special input argument")
                .value_parser(value_parser!(PathBuf)),
        )
        // Now let's assume we have a -c [config] argument which requires one of
        // (but **not** both) the "input" arguments
        .arg(arg!(config: -c <CONFIG>).value_parser(value_parser!(PathBuf)));
    let matches = cmd.get_matches_mut();

    // Let's assume the old version 1.2.3
    let mut major = 1;
    let mut minor = 2;
    let mut patch = 3;

    // See if --set-ver was used to set the version manually
    let version = if let Some(ver) = matches.get_one::<String>("set-ver") {
        if matches.get_flag("major") || matches.get_flag("minor") || matches.get_flag("patch") {
            cmd.error(
                ErrorKind::ArgumentConflict,
                "Can't do relative and absolute version change",
            )
            .exit();
        }
        ver.to_string()
    } else {
        // Increment the one requested (in a real program, we'd reset the lower numbers)
        let (maj, min, pat) = (
            matches.get_flag("major"),
            matches.get_flag("minor"),
            matches.get_flag("patch"),
        );
        match (maj, min, pat) {
            (true, false, false) => major += 1,
            (false, true, false) => minor += 1,
            (false, false, true) => patch += 1,
            _ => {
                cmd.error(
                    ErrorKind::ArgumentConflict,
                    "Can only modify one version field",
                )
                .exit();
            }
        };
        format!("{major}.{minor}.{patch}")
    };

    println!("Version: {version}");

    // Check for usage of -c
    if matches.contains_id("config") {
        let input = matches
            .get_one::<PathBuf>("INPUT_FILE")
            .or_else(|| matches.get_one::<PathBuf>("spec-in"))
            .unwrap_or_else(|| {
                cmd.error(
                    ErrorKind::MissingRequiredArgument,
                    "INPUT_FILE or --spec-in is required when using --config",
                )
                .exit()
            })
            .display();
        println!(
            "Doing work using input {} and config {}",
            input,
            matches.get_one::<PathBuf>("config").unwrap().display()
        );
    }
}

```

`clap/examples/tutorial_builder/05_01_assert.rs`:

```rs
use clap::{arg, command, value_parser};

fn main() {
    let matches = cmd().get_matches();

    // Note, it's safe to call unwrap() because the arg is required
    let port: usize = *matches
        .get_one::<usize>("PORT")
        .expect("'PORT' is required and parsing will fail if its missing");
    println!("PORT = {port}");
}

fn cmd() -> clap::Command {
    command!() // requires `cargo` feature
        .arg(
            arg!(<PORT>)
                .help("Network port to use")
                .value_parser(value_parser!(usize)),
        )
}

#[test]
fn verify_cmd() {
    cmd().debug_assert();
}

```

`clap/examples/tutorial_derive/01_quick.md`:

```md
```console
$ 01_quick_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 01_quick_derive[EXE] [OPTIONS] [NAME] [COMMAND]

Commands:
  test  does testing things
  help  Print this message or the help of the given subcommand(s)

Arguments:
  [NAME]  Optional name to operate on

Options:
  -c, --config <FILE>  Sets a custom config file
  -d, --debug...       Turn debugging information on
  -h, --help           Print help
  -V, --version        Print version

```

By default, the program does nothing:
```console
$ 01_quick_derive
Debug mode is off

```

But you can mix and match the various features
```console
$ 01_quick_derive -dd test
Debug mode is on
Not printing testing lists...

```

```

`clap/examples/tutorial_derive/01_quick.rs`:

```rs
use std::path::PathBuf;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Optional name to operate on
    name: Option<String>,

    /// Sets a custom config file
    #[arg(short, long, value_name = "FILE")]
    config: Option<PathBuf>,

    /// Turn debugging information on
    #[arg(short, long, action = clap::ArgAction::Count)]
    debug: u8,

    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// does testing things
    Test {
        /// lists test values
        #[arg(short, long)]
        list: bool,
    },
}

fn main() {
    let cli = Cli::parse();

    // You can check the value provided by positional arguments, or option arguments
    if let Some(name) = cli.name.as_deref() {
        println!("Value for name: {name}");
    }

    if let Some(config_path) = cli.config.as_deref() {
        println!("Value for config: {}", config_path.display());
    }

    // You can see how many times a particular flag or argument occurred
    // Note, only flags can have multiple occurrences
    match cli.debug {
        0 => println!("Debug mode is off"),
        1 => println!("Debug mode is kind of on"),
        2 => println!("Debug mode is on"),
        _ => println!("Don't be crazy"),
    }

    // You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    match &cli.command {
        Some(Commands::Test { list }) => {
            if *list {
                println!("Printing testing lists...");
            } else {
                println!("Not printing testing lists...");
            }
        }
        None => {}
    }

    // Continued program logic goes here...
}

```

`clap/examples/tutorial_derive/02_app_settings.md`:

```md
```console
$ 02_app_settings_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_app_settings_derive[EXE] --two <TWO> --one <ONE>

Options:
      --two <TWO>
          
      --one <ONE>
          
  -h, --help
          Print help
  -V, --version
          Print version

```

```

`clap/examples/tutorial_derive/02_app_settings.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(next_line_help = true)]
struct Cli {
    #[arg(long)]
    two: String,
    #[arg(long)]
    one: String,
}

fn main() {
    let cli = Cli::parse();

    println!("two: {:?}", cli.two);
    println!("one: {:?}", cli.one);
}

```

`clap/examples/tutorial_derive/02_apps.md`:

```md
```console
$ 02_apps_derive --help
Does awesome things

Usage: 02_apps_derive[EXE] --two <TWO> --one <ONE>

Options:
      --two <TWO>  
      --one <ONE>  
  -h, --help       Print help
  -V, --version    Print version

$ 02_apps_derive --version
MyApp 1.0

```

```

`clap/examples/tutorial_derive/02_apps.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(name = "MyApp")]
#[command(version = "1.0")]
#[command(about = "Does awesome things", long_about = None)]
struct Cli {
    #[arg(long)]
    two: String,
    #[arg(long)]
    one: String,
}

fn main() {
    let cli = Cli::parse();

    println!("two: {:?}", cli.two);
    println!("one: {:?}", cli.one);
}

```

`clap/examples/tutorial_derive/02_crate.md`:

```md
```console
$ 02_crate_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 02_crate_derive[EXE] --two <TWO> --one <ONE>

Options:
      --two <TWO>  
      --one <ONE>  
  -h, --help       Print help
  -V, --version    Print version

$ 02_crate_derive --version
clap [..]

```

```

`clap/examples/tutorial_derive/02_crate.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)] // Read from `Cargo.toml`
struct Cli {
    #[arg(long)]
    two: String,
    #[arg(long)]
    one: String,
}

fn main() {
    let cli = Cli::parse();

    println!("two: {:?}", cli.two);
    println!("one: {:?}", cli.one);
}

```

`clap/examples/tutorial_derive/03_01_flag_bool.md`:

```md
```console
$ 03_01_flag_bool_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_bool_derive[EXE] [OPTIONS]

Options:
  -v, --verbose  
  -h, --help     Print help
  -V, --version  Print version

$ 03_01_flag_bool_derive
verbose: false

$ 03_01_flag_bool_derive --verbose
verbose: true

$ 03_01_flag_bool_derive --verbose --verbose
? failed
error: the argument '--verbose' cannot be used multiple times

Usage: 03_01_flag_bool_derive[EXE] [OPTIONS]

For more information, try '--help'.

```

```

`clap/examples/tutorial_derive/03_01_flag_bool.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[arg(short, long)]
    verbose: bool,
}

fn main() {
    let cli = Cli::parse();

    println!("verbose: {:?}", cli.verbose);
}

```

`clap/examples/tutorial_derive/03_01_flag_count.md`:

```md
```console
$ 03_01_flag_count_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_01_flag_count_derive[EXE] [OPTIONS]

Options:
  -v, --verbose...  
  -h, --help        Print help
  -V, --version     Print version

$ 03_01_flag_count_derive
verbose: 0

$ 03_01_flag_count_derive --verbose
verbose: 1

$ 03_01_flag_count_derive --verbose --verbose
verbose: 2

```

```

`clap/examples/tutorial_derive/03_01_flag_count.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[arg(short, long, action = clap::ArgAction::Count)]
    verbose: u8,
}

fn main() {
    let cli = Cli::parse();

    println!("verbose: {:?}", cli.verbose);
}

```

`clap/examples/tutorial_derive/03_02_option.md`:

```md
```console
$ 03_02_option_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option_derive[EXE] --name <NAME>

Options:
  -n, --name <NAME>  
  -h, --help         Print help
  -V, --version      Print version

$ 03_02_option_derive
? 2
error: the following required arguments were not provided:
  --name <NAME>

Usage: 03_02_option_derive[EXE] --name <NAME>

For more information, try '--help'.

$ 03_02_option_derive --name bob
name: "bob"

$ 03_02_option_derive --name=bob
name: "bob"

$ 03_02_option_derive -n bob
name: "bob"

$ 03_02_option_derive -n=bob
name: "bob"

$ 03_02_option_derive -nbob
name: "bob"

```

```

`clap/examples/tutorial_derive/03_02_option.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[arg(short, long)]
    name: String,
}

fn main() {
    let cli = Cli::parse();

    println!("name: {:?}", cli.name);
}

```

`clap/examples/tutorial_derive/03_02_option_mult.md`:

```md
```console
$ 03_02_option_mult_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_02_option_mult_derive[EXE] [OPTIONS]

Options:
  -n, --name <NAME>  
  -h, --help         Print help
  -V, --version      Print version

$ 03_02_option_mult_derive
name: []

$ 03_02_option_mult_derive --name bob
name: ["bob"]

$ 03_02_option_mult_derive --name bob --name john
name: ["bob", "john"]

$ 03_02_option_mult_derive --name bob --name=john -n tom -n=chris -nsteve
name: ["bob", "john", "tom", "chris", "steve"]

```

```

`clap/examples/tutorial_derive/03_02_option_mult.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[arg(short, long)]
    name: Vec<String>,
}

fn main() {
    let cli = Cli::parse();

    println!("name: {:?}", cli.name);
}

```

`clap/examples/tutorial_derive/03_03_positional.md`:

```md
```console
$ 03_03_positional_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional_derive[EXE] <NAME>

Arguments:
  <NAME>  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_03_positional_derive
? 2
error: the following required arguments were not provided:
  <NAME>

Usage: 03_03_positional_derive[EXE] <NAME>

For more information, try '--help'.

$ 03_03_positional_derive bob
name: "bob"

```

```

`clap/examples/tutorial_derive/03_03_positional.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    name: String,
}

fn main() {
    let cli = Cli::parse();

    println!("name: {:?}", cli.name);
}

```

`clap/examples/tutorial_derive/03_03_positional_mult.md`:

```md
```console
$ 03_03_positional_mult_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_03_positional_mult_derive[EXE] [NAME]...

Arguments:
  [NAME]...  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_03_positional_mult_derive
name: []

$ 03_03_positional_mult_derive bob
name: ["bob"]

$ 03_03_positional_mult_derive bob john
name: ["bob", "john"]

```

```

`clap/examples/tutorial_derive/03_03_positional_mult.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    name: Vec<String>,
}

fn main() {
    let cli = Cli::parse();

    println!("name: {:?}", cli.name);
}

```

`clap/examples/tutorial_derive/03_04_subcommands.md`:

```md
```console
$ 03_04_subcommands_derive help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands_derive[EXE] <COMMAND>

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_04_subcommands_derive help add
Adds files to myapp

Usage: 03_04_subcommands_derive[EXE] add [NAME]

Arguments:
  [NAME]  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_04_subcommands_derive add bob
'myapp add' was used, name is: Some("bob")

```

When specifying commands with `command: Commands`, they are required.
Alternatively, you could do `command: Option<Commands>` to make it optional.
```console
$ 03_04_subcommands_derive
? failed
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_04_subcommands_derive[EXE] <COMMAND>

Commands:
  add   Adds files to myapp
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

```

Since we specified [`#[command(propagate_version = true)]`][crate::Command::propagate_version],
the `--version` flag is available in all subcommands:
```console
$ 03_04_subcommands_derive --version
clap [..]

$ 03_04_subcommands_derive add --version
clap-add [..]

```

```

`clap/examples/tutorial_derive/03_04_subcommands.rs`:

```rs
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Adds files to myapp
    Add { name: Option<String> },
}

fn main() {
    let cli = Cli::parse();

    // You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    match &cli.command {
        Commands::Add { name } => {
            println!("'myapp add' was used, name is: {name:?}");
        }
    }
}

```

`clap/examples/tutorial_derive/03_04_subcommands_alt.rs`:

```rs
use clap::{Args, Parser, Subcommand};

#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Adds files to myapp
    Add(AddArgs),
}

#[derive(Args)]
struct AddArgs {
    name: Option<String>,
}

fn main() {
    let cli = Cli::parse();

    // You can check for the existence of subcommands, and if found use their
    // matches just as you would the top level cmd
    match &cli.command {
        Commands::Add(name) => {
            println!("'myapp add' was used, name is: {:?}", name.name);
        }
    }
}

```

`clap/examples/tutorial_derive/03_05_default_values.md`:

```md
```console
$ 03_05_default_values_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_05_default_values_derive[EXE] [PORT]

Arguments:
  [PORT]  [default: 2020]

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_05_default_values_derive
port: 2020

$ 03_05_default_values_derive 22
port: 22

```

```

`clap/examples/tutorial_derive/03_05_default_values.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[arg(default_value_t = 2020)]
    port: u16,
}

fn main() {
    let cli = Cli::parse();

    println!("port: {:?}", cli.port);
}

```

`clap/examples/tutorial_derive/03_06_optional.md`:

```md
```console
$ 03_06_optional_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 03_06_optional_derive[EXE] [NAME]

Arguments:
  [NAME]  

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 03_06_optional_derive
name: None

$ 03_06_optional_derive bob
name: Some("bob")

```

```

`clap/examples/tutorial_derive/03_06_optional.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    name: Option<String>,
}

fn main() {
    let cli = Cli::parse();

    println!("name: {:?}", cli.name);
}

```

`clap/examples/tutorial_derive/04_01_enum.md`:

```md
```console
$ 04_01_enum_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_enum_derive[EXE] <MODE>

Arguments:
  <MODE>
          What mode to run the program in

          Possible values:
          - fast: Run swiftly
          - slow: Crawl slowly but steadily

Options:
  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version

$ 04_01_enum_derive -h
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_01_enum_derive[EXE] <MODE>

Arguments:
  <MODE>  What mode to run the program in [possible values: fast, slow]

Options:
  -h, --help     Print help (see more with '--help')
  -V, --version  Print version

$ 04_01_enum_derive fast
Hare

$ 04_01_enum_derive slow
Tortoise

$ 04_01_enum_derive medium
? failed
error: invalid value 'medium' for '<MODE>'
  [possible values: fast, slow]

For more information, try '--help'.

```

```

`clap/examples/tutorial_derive/04_01_enum.rs`:

```rs
use clap::{Parser, ValueEnum};

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// What mode to run the program in
    #[arg(value_enum)]
    mode: Mode,
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
enum Mode {
    /// Run swiftly
    Fast,
    /// Crawl slowly but steadily
    ///
    /// This paragraph is ignored because there is no long help text for possible values.
    Slow,
}

fn main() {
    let cli = Cli::parse();

    match cli.mode {
        Mode::Fast => {
            println!("Hare");
        }
        Mode::Slow => {
            println!("Tortoise");
        }
    }
}

```

`clap/examples/tutorial_derive/04_02_parse.md`:

```md
```console
$ 04_02_parse_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_parse_derive[EXE] <PORT>

Arguments:
  <PORT>  Network port to use

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 04_02_parse_derive 22
PORT = 22

$ 04_02_parse_derive foobar
? failed
error: invalid value 'foobar' for '<PORT>': invalid digit found in string

For more information, try '--help'.

$ 04_02_parse_derive 0
? failed
error: invalid value '0' for '<PORT>': 0 is not in 1..=65535

For more information, try '--help'.

```

```

`clap/examples/tutorial_derive/04_02_parse.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Network port to use
    #[arg(value_parser = clap::value_parser!(u16).range(1..))]
    port: u16,
}

fn main() {
    let cli = Cli::parse();

    println!("PORT = {}", cli.port);
}

```

`clap/examples/tutorial_derive/04_02_validate.md`:

```md
```console
$ 04_02_validate_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_02_validate_derive[EXE] <PORT>

Arguments:
  <PORT>  Network port to use

Options:
  -h, --help     Print help
  -V, --version  Print version

$ 04_02_validate_derive 22
PORT = 22

$ 04_02_validate_derive foobar
? failed
error: invalid value 'foobar' for '<PORT>': `foobar` isn't a port number

For more information, try '--help'.

$ 04_02_validate_derive 0
? failed
error: invalid value '0' for '<PORT>': port not in range 1-65535

For more information, try '--help'.

```

```

`clap/examples/tutorial_derive/04_02_validate.rs`:

```rs
use std::ops::RangeInclusive;

use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Network port to use
    #[arg(value_parser = port_in_range)]
    port: u16,
}

fn main() {
    let cli = Cli::parse();

    println!("PORT = {}", cli.port);
}

const PORT_RANGE: RangeInclusive<usize> = 1..=65535;

fn port_in_range(s: &str) -> Result<u16, String> {
    let port: usize = s
        .parse()
        .map_err(|_| format!("`{s}` isn't a port number"))?;
    if PORT_RANGE.contains(&port) {
        Ok(port as u16)
    } else {
        Err(format!(
            "port not in range {}-{}",
            PORT_RANGE.start(),
            PORT_RANGE.end()
        ))
    }
}

```

`clap/examples/tutorial_derive/04_03_relations.md`:

```md
```console
$ 04_03_relations_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_03_relations_derive[EXE] [OPTIONS] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver <VER>      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in <SPEC_IN>  some special input argument
  -c <CONFIG>              
  -h, --help               Print help
  -V, --version            Print version

$ 04_03_relations_derive
? failed
error: the following required arguments were not provided:
  <--set-ver <VER>|--major|--minor|--patch>

Usage: 04_03_relations_derive[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]

For more information, try '--help'.

$ 04_03_relations_derive --major
Version: 2.2.3

$ 04_03_relations_derive --major --minor
? failed
error: the argument '--major' cannot be used with '--minor'

Usage: 04_03_relations_derive[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]

For more information, try '--help'.

$ 04_03_relations_derive --major -c config.toml
? failed
error: the following required arguments were not provided:
  <INPUT_FILE|--spec-in <SPEC_IN>>

Usage: 04_03_relations_derive[EXE] -c <CONFIG> <--set-ver <VER>|--major|--minor|--patch> <INPUT_FILE|--spec-in <SPEC_IN>>

For more information, try '--help'.

$ 04_03_relations_derive --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml

```

```

`clap/examples/tutorial_derive/04_03_relations.rs`:

```rs
use clap::{Args, Parser};

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[command(flatten)]
    vers: Vers,

    /// some regular input
    #[arg(group = "input")]
    input_file: Option<String>,

    /// some special input argument
    #[arg(long, group = "input")]
    spec_in: Option<String>,

    #[arg(short, requires = "input")]
    config: Option<String>,
}

#[derive(Args)]
#[group(required = true, multiple = false)]
struct Vers {
    /// set version manually
    #[arg(long, value_name = "VER")]
    set_ver: Option<String>,

    /// auto inc major
    #[arg(long)]
    major: bool,

    /// auto inc minor
    #[arg(long)]
    minor: bool,

    /// auto inc patch
    #[arg(long)]
    patch: bool,
}

fn main() {
    let cli = Cli::parse();

    // Let's assume the old version 1.2.3
    let mut major = 1;
    let mut minor = 2;
    let mut patch = 3;

    // See if --set_ver was used to set the version manually
    let vers = &cli.vers;
    let version = if let Some(ver) = vers.set_ver.as_deref() {
        ver.to_string()
    } else {
        // Increment the one requested (in a real program, we'd reset the lower numbers)
        let (maj, min, pat) = (vers.major, vers.minor, vers.patch);
        match (maj, min, pat) {
            (true, _, _) => major += 1,
            (_, true, _) => minor += 1,
            (_, _, true) => patch += 1,
            _ => unreachable!(),
        };
        format!("{major}.{minor}.{patch}")
    };

    println!("Version: {version}");

    // Check for usage of -c
    if let Some(config) = cli.config.as_deref() {
        let input = cli
            .input_file
            .as_deref()
            .unwrap_or_else(|| cli.spec_in.as_deref().unwrap());
        println!("Doing work using input {input} and config {config}");
    }
}

```

`clap/examples/tutorial_derive/04_04_custom.md`:

```md
```console
$ 04_04_custom_derive --help
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: 04_04_custom_derive[EXE] [OPTIONS] [INPUT_FILE]

Arguments:
  [INPUT_FILE]  some regular input

Options:
      --set-ver <VER>      set version manually
      --major              auto inc major
      --minor              auto inc minor
      --patch              auto inc patch
      --spec-in <SPEC_IN>  some special input argument
  -c <CONFIG>              
  -h, --help               Print help
  -V, --version            Print version

$ 04_04_custom_derive
? failed
error: Can only modify one version field

Usage: clap [OPTIONS] [INPUT_FILE]

For more information, try '--help'.

$ 04_04_custom_derive --major
Version: 2.2.3

$ 04_04_custom_derive --major --minor
? failed
error: Can only modify one version field

Usage: clap [OPTIONS] [INPUT_FILE]

For more information, try '--help'.

$ 04_04_custom_derive --major -c config.toml
? failed
Version: 2.2.3
error: INPUT_FILE or --spec-in is required when using --config

Usage: clap [OPTIONS] [INPUT_FILE]

For more information, try '--help'.

$ 04_04_custom_derive --major -c config.toml --spec-in input.txt
Version: 2.2.3
Doing work using input input.txt and config config.toml

```

```

`clap/examples/tutorial_derive/04_04_custom.rs`:

```rs
use clap::error::ErrorKind;
use clap::{CommandFactory, Parser};

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// set version manually
    #[arg(long, value_name = "VER")]
    set_ver: Option<String>,

    /// auto inc major
    #[arg(long)]
    major: bool,

    /// auto inc minor
    #[arg(long)]
    minor: bool,

    /// auto inc patch
    #[arg(long)]
    patch: bool,

    /// some regular input
    input_file: Option<String>,

    /// some special input argument
    #[arg(long)]
    spec_in: Option<String>,

    #[arg(short)]
    config: Option<String>,
}

fn main() {
    let cli = Cli::parse();

    // Let's assume the old version 1.2.3
    let mut major = 1;
    let mut minor = 2;
    let mut patch = 3;

    // See if --set-ver was used to set the version manually
    let version = if let Some(ver) = cli.set_ver.as_deref() {
        if cli.major || cli.minor || cli.patch {
            let mut cmd = Cli::command();
            cmd.error(
                ErrorKind::ArgumentConflict,
                "Can't do relative and absolute version change",
            )
            .exit();
        }
        ver.to_string()
    } else {
        // Increment the one requested (in a real program, we'd reset the lower numbers)
        let (maj, min, pat) = (cli.major, cli.minor, cli.patch);
        match (maj, min, pat) {
            (true, false, false) => major += 1,
            (false, true, false) => minor += 1,
            (false, false, true) => patch += 1,
            _ => {
                let mut cmd = Cli::command();
                cmd.error(
                    ErrorKind::ArgumentConflict,
                    "Can only modify one version field",
                )
                .exit();
            }
        };
        format!("{major}.{minor}.{patch}")
    };

    println!("Version: {version}");

    // Check for usage of -c
    if let Some(config) = cli.config.as_deref() {
        let input = cli
            .input_file
            .as_deref()
            // 'or' is preferred to 'or_else' here since `Option::as_deref` is 'const'
            .or(cli.spec_in.as_deref())
            .unwrap_or_else(|| {
                let mut cmd = Cli::command();
                cmd.error(
                    ErrorKind::MissingRequiredArgument,
                    "INPUT_FILE or --spec-in is required when using --config",
                )
                .exit()
            });
        println!("Doing work using input {input} and config {config}");
    }
}

```

`clap/examples/tutorial_derive/05_01_assert.rs`:

```rs
use clap::Parser;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Network port to use
    port: u16,
}

fn main() {
    let cli = Cli::parse();

    println!("PORT = {}", cli.port);
}

#[test]
fn verify_cli() {
    use clap::CommandFactory;
    Cli::command().debug_assert();
}

```

`clap/examples/typed-derive.md`:

```md
**This requires enabling the [`derive` feature flag][crate::_features].**

Help:
```console
$ typed-derive --help
Usage: typed-derive[EXE] [OPTIONS]

Options:
  -O <OPTIMIZATION>            Implicitly using `std::str::FromStr`
  -I <DIR>                     Allow invalid UTF-8 paths
      --bind <BIND>            Handle IP addresses
      --sleep <SLEEP>          Allow human-readable durations
  -D <DEFINES>                 Hand-written parser for tuples
      --port <PORT>            Support for discrete numbers [default: 22] [possible values: 22, 80]
      --log-level <LOG_LEVEL>  Support enums from a foreign crate that don't implement `ValueEnum` [default: info] [possible values: trace, debug, info, warn, error]
  -h, --help                   Print help

```

Optimization-level (number)
```console
$ typed-derive -O 1
Args { optimization: Some(1), include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Info }

$ typed-derive -O plaid
? failed
error: invalid value 'plaid' for '-O <OPTIMIZATION>': invalid digit found in string

For more information, try '--help'.

```

Include (path)
```console
$ typed-derive -I../hello
Args { optimization: None, include: Some("../hello"), bind: None, sleep: None, defines: [], port: 22, log_level: Info }

```

IP Address
```console
$ typed-derive --bind 192.0.0.1
Args { optimization: None, include: None, bind: Some(192.0.0.1), sleep: None, defines: [], port: 22, log_level: Info }

$ typed-derive --bind localhost
? failed
error: invalid value 'localhost' for '--bind <BIND>': invalid IP address syntax

For more information, try '--help'.

```

Time
```console
$ typed-derive --sleep 10s
Args { optimization: None, include: None, bind: None, sleep: Some(10s), defines: [], port: 22, log_level: Info }

$ typed-derive --sleep forever
? failed
error: invalid value 'forever' for '--sleep <SLEEP>': failed to parse "forever" in the "friendly" format: parsing a friendly duration requires it to start with a unit value (a decimal integer) after an optional sign, but no integer was found

For more information, try '--help'.

```

Defines (key-value pairs)
```console
$ typed-derive -D Foo=10 -D Alice=30
Args { optimization: None, include: None, bind: None, sleep: None, defines: [("Foo", 10), ("Alice", 30)], port: 22, log_level: Info }

$ typed-derive -D Foo
? failed
error: invalid value 'Foo' for '-D <DEFINES>': invalid KEY=value: no `=` found in `Foo`

For more information, try '--help'.

$ typed-derive -D Foo=Bar
? failed
error: invalid value 'Foo=Bar' for '-D <DEFINES>': invalid digit found in string

For more information, try '--help'.

```

Discrete numbers
```console
$ typed-derive --port 22
Args { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Info }

$ typed-derive --port 80
Args { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 80, log_level: Info }

$ typed-derive --port
? failed
error: a value is required for '--port <PORT>' but none was supplied
  [possible values: 22, 80]

For more information, try '--help'.

$ typed-derive --port 3000
? failed
error: invalid value '3000' for '--port <PORT>'
  [possible values: 22, 80]

For more information, try '--help'.

```

Enums from crates that can't implement `ValueEnum`
```console
$ typed-derive --log-level debug
Args { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Debug }

$ typed-derive --log-level error
Args { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Error }

$ typed-derive --log-level
? failed
error: a value is required for '--log-level <LOG_LEVEL>' but none was supplied
  [possible values: trace, debug, info, warn, error]

For more information, try '--help'.

$ typed-derive --log-level critical
? failed
error: invalid value 'critical' for '--log-level <LOG_LEVEL>'
  [possible values: trace, debug, info, warn, error]

For more information, try '--help'.

```

```

`clap/examples/typed-derive.rs`:

```rs
use clap::builder::TypedValueParser as _;
use clap::Parser;
use std::error::Error;

#[derive(Parser, Debug)] // requires `derive` feature
#[command(term_width = 0)] // Just to make testing across clap features easier
struct Args {
    /// Implicitly using `std::str::FromStr`
    #[arg(short = 'O')]
    optimization: Option<usize>,

    /// Allow invalid UTF-8 paths
    #[arg(short = 'I', value_name = "DIR", value_hint = clap::ValueHint::DirPath)]
    include: Option<std::path::PathBuf>,

    /// Handle IP addresses
    #[arg(long)]
    bind: Option<std::net::IpAddr>,

    /// Allow human-readable durations
    #[arg(long)]
    sleep: Option<jiff::SignedDuration>,

    /// Hand-written parser for tuples
    #[arg(short = 'D', value_parser = parse_key_val::<String, i32>)]
    defines: Vec<(String, i32)>,

    /// Support for discrete numbers
    #[arg(
        long,
        default_value_t = 22,
        value_parser = clap::builder::PossibleValuesParser::new(["22", "80"])
            .map(|s| s.parse::<usize>().unwrap()),
    )]
    port: usize,

    /// Support enums from a foreign crate that don't implement `ValueEnum`
    #[arg(
        long,
        default_value_t = foreign_crate::LogLevel::Info,
        value_parser = clap::builder::PossibleValuesParser::new(["trace", "debug", "info", "warn", "error"])
            .map(|s| s.parse::<foreign_crate::LogLevel>().unwrap()),
    )]
    log_level: foreign_crate::LogLevel,
}

/// Parse a single key-value pair
fn parse_key_val<T, U>(s: &str) -> Result<(T, U), Box<dyn Error + Send + Sync + 'static>>
where
    T: std::str::FromStr,
    T::Err: Error + Send + Sync + 'static,
    U: std::str::FromStr,
    U::Err: Error + Send + Sync + 'static,
{
    let pos = s
        .find('=')
        .ok_or_else(|| format!("invalid KEY=value: no `=` found in `{s}`"))?;
    Ok((s[..pos].parse()?, s[pos + 1..].parse()?))
}

mod foreign_crate {
    #[derive(Copy, Clone, PartialEq, Eq, Debug)]
    pub(crate) enum LogLevel {
        Trace,
        Debug,
        Info,
        Warn,
        Error,
    }

    impl std::fmt::Display for LogLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let s = match self {
                Self::Trace => "trace",
                Self::Debug => "debug",
                Self::Info => "info",
                Self::Warn => "warn",
                Self::Error => "error",
            };
            s.fmt(f)
        }
    }
    impl std::str::FromStr for LogLevel {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            match s {
                "trace" => Ok(Self::Trace),
                "debug" => Ok(Self::Debug),
                "info" => Ok(Self::Info),
                "warn" => Ok(Self::Warn),
                "error" => Ok(Self::Error),
                _ => Err(format!("Unknown log level: {s}")),
            }
        }
    }
}

fn main() {
    let args = Args::parse();
    println!("{args:?}");
}

```

`clap/release.toml`:

```toml
owners = ["github:clap-rs:Admins", "github:rust-cli:Maintainers"]
dependent-version = "fix"
allow-branch = ["master", "v*-master"]

```

`clap/src/_cookbook/cargo_example.rs`:

```rs
//! # Example: cargo subcommand (Builder API)
//!
//! ```rust
#![doc = include_str!("../../examples/cargo-example.rs")]
//! ```
//!
#![doc = include_str!("../../examples/cargo-example.md")]

```

`clap/src/_cookbook/cargo_example_derive.rs`:

```rs
//! # Example: cargo subcommand (Derive API)
//!
//! ```rust
#![doc = include_str!("../../examples/cargo-example-derive.rs")]
//! ```
//!
#![doc = include_str!("../../examples/cargo-example-derive.md")]

```

`clap/src/_cookbook/escaped_positional.rs`:

```rs
//! # Example (Builder API)
//!
//! ```rust
#![doc = include_str!("../../examples/escaped-positional.rs")]
//! ```
//!
#![doc = include_str!("../../examples/escaped-positional.md")]

```

`clap/src/_cookbook/escaped_positional_derive.rs`:

```rs
//! # Example (Derive API)
//!
//! ```rust
#![doc = include_str!("../../examples/escaped-positional-derive.rs")]
//! ```
//!
#![doc = include_str!("../../examples/escaped-positional-derive.md")]

```

`clap/src/_cookbook/find.rs`:

```rs
//! # Example: find-like CLI (Builder API)
//!
//! ```rust
#![doc = include_str!("../../examples/find.rs")]
//! ```
//!
#![doc = include_str!("../../examples/find.md")]

```

`clap/src/_cookbook/git.rs`:

```rs
//! # Example: git-like CLI (Builder API)
//!
//! ```rust
#![doc = include_str!("../../examples/git.rs")]
//! ```
//!
#![doc = include_str!("../../examples/git.md")]

```

`clap/src/_cookbook/git_derive.rs`:

```rs
//! # Example: git-like CLI (Derive API)
//!
//! ```rust
#![doc = include_str!("../../examples/git-derive.rs")]
//! ```
//!
#![doc = include_str!("../../examples/git-derive.md")]

```

`clap/src/_cookbook/mod.rs`:

```rs
// Contributing
//
// New examples:
// - Building: They must be added to `Cargo.toml` with the appropriate `required-features`.
// - Testing: Ensure there is a markdown file with [trycmd](https://docs.rs/trycmd) syntax
// - Link the `.md` file from here

//! # Documentation: Cookbook
//!
//! Typed arguments: [derive][typed_derive]
//! - Topics:
//!   - Custom `parse()`
//!
//! Custom cargo command: [builder][cargo_example], [derive][cargo_example_derive]
//! - Topics:
//!   - Subcommands
//!   - Cargo plugins
//!   - custom terminal [styles][crate::Command::styles] (colors)
//!
//! find-like interface: [builder][find]
//! - Topics:
//!   - Position-sensitive flags
//!
//! git-like interface: [builder][git], [derive][git_derive]
//! - Topics:
//!   - Subcommands
//!   - External subcommands
//!   - Optional subcommands
//!   - Default subcommands
//!   - [`last`][crate::Arg::last]
//!
//! pacman-like interface: [builder][pacman]
//! - Topics:
//!   - Flag subcommands
//!   - Conflicting arguments
//!
//! Escaped positionals with `--`: [builder][escaped_positional], [derive][escaped_positional_derive]
//!
//! Multi-call
//! - busybox: [builder][multicall_busybox]
//!   - Topics:
//!     - Subcommands
//! - hostname: [builder][multicall_hostname]
//!   - Topics:
//!     - Subcommands
//!
//! repl: [builder][repl], [derive][repl_derive]
//! - Topics:
//!   - Read-Eval-Print Loops / Custom command lines

pub mod cargo_example;
pub mod cargo_example_derive;
pub mod escaped_positional;
pub mod escaped_positional_derive;
pub mod find;
pub mod git;
pub mod git_derive;
pub mod multicall_busybox;
pub mod multicall_hostname;
pub mod pacman;
pub mod repl;
pub mod repl_derive;
pub mod typed_derive;

```

`clap/src/_cookbook/multicall_busybox.rs`:

```rs
//! # Example: busybox-like CLI (Builder API)
//!
//! ```rust
#![doc = include_str!("../../examples/multicall-busybox.rs")]
//! ```
//!
#![doc = include_str!("../../examples/multicall-busybox.md")]

```

`clap/src/_cookbook/multicall_hostname.rs`:

```rs
//! # Example: hostname-like CLI (Builder API)
//!
//! ```rust
#![doc = include_str!("../../examples/multicall-hostname.rs")]
//! ```
//!
#![doc = include_str!("../../examples/multicall-hostname.md")]

```

`clap/src/_cookbook/pacman.rs`:

```rs
//! # Example: pacman-like CLI (Builder API)
//!
//! ```rust
#![doc = include_str!("../../examples/pacman.rs")]
//! ```
//!
#![doc = include_str!("../../examples/pacman.md")]

```

`clap/src/_cookbook/repl.rs`:

```rs
//! # Example: Command REPL (Builder API)
//!
//! ```rust
#![doc = include_str!("../../examples/repl.rs")]
//! ```

```

`clap/src/_cookbook/repl_derive.rs`:

```rs
//! # Example: REPL (Derive API)
//!
//! ```rust
#![doc = include_str!("../../examples/repl-derive.rs")]

```

`clap/src/_cookbook/typed_derive.rs`:

```rs
//! # Example: Custom Types (Derive API)
//!
//! ```rust
#![doc = include_str!("../../examples/typed-derive.rs")]
//! ```
//!
#![doc = include_str!("../../examples/typed-derive.md")]

```

`clap/src/_derive/_tutorial.rs`:

```rs
// Contributing
//
// New example code:
// - Please update the corresponding section in the derive tutorial
// - Building: They must be added to `Cargo.toml` with the appropriate `required-features`.
// - Testing: Ensure there is a markdown file with [trycmd](https://docs.rs/trycmd) syntax
//
// See also the general CONTRIBUTING

//! ## Tutorial for the Derive API
//!
//! *See the side bar for the Table of Contents*
//!
//! ## Quick Start
//!
//! You can create an application declaratively with a `struct` and some
//! attributes.
//!
//! First, ensure `clap` is available with the [`derive` feature flag][crate::_features]:
//! ```console
//! $ cargo add clap --features derive
//! ```
//!
//! Here is a preview of the type of application you can make:
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/01_quick.rs")]
//! ```
//!
#![doc = include_str!("../../examples/tutorial_derive/01_quick.md")]
//!
//! See also
//! - [FAQ: When should I use the builder vs derive APIs?][crate::_faq#when-should-i-use-the-builder-vs-derive-apis]
//! - The [cookbook][crate::_cookbook] for more application-focused examples
//!
//! ## Configuring the Parser
//!
//! You use derive [`Parser`][crate::Parser] to start building a parser.
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/02_apps.rs")]
//! ```
//!
#![doc = include_str!("../../examples/tutorial_derive/02_apps.md")]
//!
//! You can use [`#[command(version, about)]` attribute defaults][super#command-attributes] on the struct to fill these fields in from your `Cargo.toml` file.
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/02_crate.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/02_crate.md")]
//!
//! You can use `#[command]` attributes on the struct to change the application level behavior of clap.  Any [`Command`][crate::Command] builder function can be used as an attribute, like [`Command::next_line_help`].
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/02_app_settings.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/02_app_settings.md")]
//!
//! ## Adding Arguments
//!
//! 1. [Positionals](#positionals)
//! 2. [Options](#options)
//! 3. [Flags](#flags)
//! 4. [Optional](#optional)
//! 5. [Defaults](#defaults)
//! 6. [Subcommands](#subcommands)
//!
//! Arguments are inferred from the fields of your struct.
//!
//! ### Positionals
//!
//! By default, struct fields define positional arguments:
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_03_positional.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/03_03_positional.md")]
//!
//! Note that the [default `ArgAction` is `Set`][super#arg-types].  To
//! accept multiple values, override the [action][Arg::action] with [`Append`][crate::ArgAction::Append] via `Vec`:
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_03_positional_mult.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/03_03_positional_mult.md")]
//!
//! ### Options
//!
//! You can name your arguments with a flag:
//! - Intent of the value is clearer
//! - Order doesn't matter
//!
//! To specify the flags for an argument, you can use [`#[arg(short = 'n')]`][Arg::short] and/or
//! [`#[arg(long = "name")]`][Arg::long] attributes on a field.  When no value is given (e.g.
//! `#[arg(short)]`), the flag is inferred from the field's name.
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_02_option.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/03_02_option.md")]
//!
//! Note that the [default `ArgAction` is `Set`][super#arg-types].  To
//! accept multiple occurrences, override the [action][Arg::action] with [`Append`][crate::ArgAction::Append] via `Vec`:
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_02_option_mult.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/03_02_option_mult.md")]
//!
//! ### Flags
//!
//! Flags can also be switches that can be on/off:
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_01_flag_bool.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/03_01_flag_bool.md")]
//!
//! Note that the [default `ArgAction` for a `bool` field is
//! `SetTrue`][super#arg-types].  To accept multiple flags, override the [action][Arg::action] with
//! [`Count`][crate::ArgAction::Count]:
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_01_flag_count.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/03_01_flag_count.md")]
//!
//! This also shows that any[`Arg`][crate::Args] method may be used as an attribute.
//!
//! ### Optional
//!
//! By default, arguments are assumed to be [`required`][crate::Arg::required].
//! To make an argument optional, wrap the field's type in `Option`:
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_06_optional.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/03_06_optional.md")]
//!
//! ### Defaults
//!
//! We've previously showed that arguments can be [`required`][crate::Arg::required] or optional.
//! When optional, you work with a `Option` and can `unwrap_or`.  Alternatively, you can
//! set [`#[arg(default_value_t)]`][super#arg-attributes].
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_05_default_values.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/03_05_default_values.md")]
//!
//! ### Subcommands
//!
//! Subcommands are derived with `#[derive(Subcommand)]` and be added via
//! [`#[command(subcommand)]` attribute][super#command-attributes] on the field using that type.
//! Each instance of a [Subcommand][crate::Subcommand] can have its own version, author(s), Args,
//! and even its own subcommands.
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_04_subcommands.rs")]
//! ```
//! We used a struct-variant to define the `add` subcommand.
//! Alternatively, you can use a struct for your subcommand's arguments:
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/03_04_subcommands_alt.rs")]
//! ```
//!
#![doc = include_str!("../../examples/tutorial_derive/03_04_subcommands.md")]
//!
//! ## Validation
//!
//! 1. [Enumerated values](#enumerated-values)
//! 2. [Validated values](#validated-values)
//! 3. [Argument Relations](#argument-relations)
//! 4. [Custom Validation](#custom-validation)
//!
//! An appropriate default parser/validator will be selected for the field's type.  See
//! [`value_parser!`][crate::value_parser!] for more details.
//!
//! ### Enumerated values
//!
//! For example, if you have arguments of specific values you want to test for, you can derive
//! [`ValueEnum`][super#valueenum-attributes]
//! (any [`PossibleValue`] builder function can be used as a `#[value]` attribute on enum variants).
//!
//! This allows you specify the valid values for that argument. If the user does not use one of
//! those specific values, they will receive a graceful exit with error message informing them
//! of the mistake, and what the possible valid values are
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/04_01_enum.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/04_01_enum.md")]
//!
//! ### Validated values
//!
//! More generally, you can validate and parse into any data type with [`Arg::value_parser`].
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/04_02_parse.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/04_02_parse.md")]
//!
//! A [custom parser][TypedValueParser] can be used to improve the error messages or provide additional validation:
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/04_02_validate.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/04_02_validate.md")]
//!
//! See [`Arg::value_parser`][crate::Arg::value_parser] for more details.
//!
//! ### Argument Relations
//!
//! You can declare dependencies or conflicts between [`Arg`][crate::Arg]s or even
//! [`ArgGroup`][crate::ArgGroup]s.
//!
//! [`ArgGroup`][crate::ArgGroup]s  make it easier to declare relations instead of having to list
//! each individually, or when you want a rule to apply "any but not all" arguments.
//!
//! Perhaps the most common use of [`ArgGroup`][crate::ArgGroup]s is to require one and *only* one
//! argument to be present out of a given set. Imagine that you had multiple arguments, and you
//! want one of them to be required, but making all of them required isn't feasible because perhaps
//! they conflict with each other.
//!
//! [`ArgGroup`][crate::ArgGroup]s are automatically created for a `struct` with its
//! [`ArgGroup::id`][crate::ArgGroup::id] being the struct's name.
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/04_03_relations.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/04_03_relations.md")]
//!
//! ### Custom Validation
//!
//! As a last resort, you can create custom errors with the basics of clap's formatting.
//!
//! ```rust
#![doc = include_str!("../../examples/tutorial_derive/04_04_custom.rs")]
//! ```
#![doc = include_str!("../../examples/tutorial_derive/04_04_custom.md")]
//!
//! ## Testing
//!
//! clap reports most development errors as `debug_assert!`s.  Rather than checking every
//! subcommand, you should have a test that calls
//! [`Command::debug_assert`][crate::Command::debug_assert]:
//! ```rust,no_run
#![doc = include_str!("../../examples/tutorial_derive/05_01_assert.rs")]
//! ```
//!
//! ## Next Steps
//!
//! - [Cookbook][crate::_cookbook] for application-focused examples
//! - Explore more features in the [Derive reference][super]
//!   - See also [`Command`], [`Arg`], [`ArgGroup`], and [`PossibleValue`] builder functions which
//!     can be used as attributes
//!
//! For support, see [Discussions](https://github.com/clap-rs/clap/discussions)
#![allow(unused_imports)]
use crate::builder::*;

```

`clap/src/_derive/mod.rs`:

```rs
//! # Documentation: Derive Reference
//!
//! 1. [Overview](#overview)
//! 2. [Attributes](#attributes)
//!     1. [Terminology](#terminology)
//!     2. [Command Attributes](#command-attributes)
//!     2. [ArgGroup Attributes](#arggroup-attributes)
//!     3. [Arg Attributes](#arg-attributes)
//!     4. [ValueEnum Attributes](#valueenum-attributes)
//!     5. [Possible Value Attributes](#possible-value-attributes)
//! 3. [Arg Types](#arg-types)
//! 4. [Doc Comments](#doc-comments)
//! 5. [Mixing Builder and Derive APIs](#mixing-builder-and-derive-apis)
//! 6. [Tips](#tips)
//!
//! ## Overview
//!
//! To derive `clap` types, you need to enable the [`derive` feature flag][crate::_features].
//!
//! Example:
//! ```rust
#![doc = include_str!("../../examples/demo.rs")]
//! ```
//!
//! Let's start by breaking down the anatomy of the derive attributes:
//! ```rust
//! use clap::{Parser, Args, Subcommand, ValueEnum};
//!
//! /// Doc comment
//! #[derive(Parser)]
//! #[command(CMD ATTRIBUTE)]
//! #[group(GROUP ATTRIBUTE)]
//! struct Cli {
//!     /// Doc comment
//!     #[arg(ARG ATTRIBUTE)]
//!     field: UserType,
//!
//!     #[arg(value_enum, ARG ATTRIBUTE...)]
//!     field: EnumValues,
//!
//!     #[command(flatten)]
//!     delegate: Struct,
//!
//!     #[command(subcommand)]
//!     command: Command,
//! }
//!
//! /// Doc comment
//! #[derive(Args)]
//! #[command(PARENT CMD ATTRIBUTE)]
//! #[group(GROUP ATTRIBUTE)]
//! struct Struct {
//!     /// Doc comment
//!     #[command(ARG ATTRIBUTE)]
//!     field: UserType,
//! }
//!
//! /// Doc comment
//! #[derive(Subcommand)]
//! #[command(PARENT CMD ATTRIBUTE)]
//! enum Command {
//!     /// Doc comment
//!     #[command(CMD ATTRIBUTE)]
//!     Variant1(Struct),
//!
//!     /// Doc comment
//!     #[command(CMD ATTRIBUTE)]
//!     Variant2 {
//!         /// Doc comment
//!         #[arg(ARG ATTRIBUTE)]
//!         field: UserType,
//!     }
//! }
//!
//! /// Doc comment
//! #[derive(ValueEnum)]
//! #[value(VALUE ENUM ATTRIBUTE)]
//! enum EnumValues {
//!     /// Doc comment
//!     #[value(POSSIBLE VALUE ATTRIBUTE)]
//!     Variant1,
//! }
//!
//! fn main() {
//!     let cli = Cli::parse();
//! }
//! ```
//!
//! Traits:
//! - [`Parser`][crate::Parser] parses arguments into a `struct` (arguments) or `enum` (subcommands).
//!   - [`Args`][crate::Args] allows defining a set of re-usable arguments that get merged into their parent container.
//!   - [`Subcommand`][crate::Subcommand] defines available subcommands.
//!   - Subcommand arguments can be defined in a struct-variant or automatically flattened with a tuple-variant.
//! - [`ValueEnum`][crate::ValueEnum] allows parsing a value directly into an `enum`, erroring on unsupported values.
//!   - The derive doesn't work on enums that contain non-unit variants, unless they are skipped
//!
//! *See also the [derive tutorial][crate::_derive::_tutorial] and [cookbook][crate::_cookbook]*
//!
//! ## Attributes
//!
//! ### Terminology
//!
//! **Raw attributes** are forwarded directly to the underlying [`clap` builder][crate::builder].  Any
//! [`Command`][crate::Command], [`Arg`][crate::Arg], or [`PossibleValue`][crate::builder::PossibleValue] method can be used as an attribute.
//!
//! Raw attributes come in two different syntaxes:
//! ```rust,ignore
//! #[arg(
//!     global = true, // name = arg form, neat for one-arg methods
//!     required_if_eq("out", "file") // name(arg1, arg2, ...) form.
//! )]
//! ```
//!
//! - `method = arg` can only be used for methods which take only one argument.
//! - `method(arg1, arg2)` can be used with any method.
//!
//! As long as `method_name` is not one of the magical methods it will be
//! translated into a mere method call.
//!
//! **Magic attributes** have post-processing done to them, whether that is
//! - Providing of defaults
//! - Special behavior is triggered off of it
//!
//! Magic attributes are more constrained in the syntax they support, usually just
//! `<attr> = <value>` though some use `<attr>(<value>)` instead.  See the specific
//! magic attributes documentation for details.  This allows users to access the
//! raw behavior of an attribute via `<attr>(<value>)` syntax.
//!
//! <div class="warning">
//!
//! **NOTE:** Some attributes are inferred from [Arg Types](#arg-types) and [Doc
//! Comments](#doc-comments).  Explicit attributes take precedence over inferred
//! attributes.
//!
//! </div>
//!
//! ### Command Attributes
//!
//! These correspond to a [`Command`][crate::Command] which is used for both top-level parsers and
//! when defining subcommands.
//!
//! **Raw attributes:**  Any [`Command` method][crate::Command] can also be used as an attribute,
//! see [Terminology](#terminology) for syntax.
//! - e.g. `#[command(arg_required_else_help(true))]` would translate to `cmd.arg_required_else_help(true)`
//!
//! **Magic attributes:**
//! - `name  = <expr>`: [`Command::name`][crate::Command::name]
//!   - When not present: [package `name`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-name-field) (if on [`Parser`][crate::Parser] container), variant name (if on [`Subcommand`][crate::Subcommand] variant)
//! - `version [= <expr>]`: [`Command::version`][crate::Command::version]
//!   - When not present: no version set
//!   - Without `<expr>`: defaults to [crate `version`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-version-field)
//! - `author [= <expr>]`: [`Command::author`][crate::Command::author]
//!   - When not present: no author set
//!   - Without `<expr>`: defaults to [crate `authors`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-authors-field)
//!   - **NOTE:** A custom [`help_template`][crate::Command::help_template] is needed for author to show up.
//! - `about [= <expr>]`: [`Command::about`][crate::Command::about]
//!   - When not present: [Doc comment summary](#doc-comments)
//!   - Without `<expr>`: [crate `description`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-description-field) ([`Parser`][crate::Parser] container)
//!     - **TIP:** When a doc comment is also present, you most likely want to add
//!       `#[arg(long_about = None)]` to clear the doc comment so only [`about`][crate::Command::about]
//!       gets shown with both `-h` and `--help`.
//! - `long_about[ = <expr>]`: [`Command::long_about`][crate::Command::long_about]
//!   - When not present: [Doc comment](#doc-comments) if there is a blank line, else nothing
//!   - When present without a value: [Doc comment](#doc-comments)
//! - `verbatim_doc_comment`: Minimizes pre-processing when converting doc comments to [`about`][crate::Command::about] / [`long_about`][crate::Command::long_about]
//! - `next_display_order`: [`Command::next_display_order`][crate::Command::next_display_order]
//! - `next_help_heading`: [`Command::next_help_heading`][crate::Command::next_help_heading]
//!   - When `flatten`ing [`Args`][crate::Args], this is scoped to just the args in this struct and any struct `flatten`ed into it
//! - `rename_all = <string_literal>`: Override default field / variant name case conversion for [`Command::name`][crate::Command::name] / [`Arg::id`][crate::Arg::id]
//!   - When not present: `"kebab-case"`
//!   - Available values: `"camelCase"`, `"kebab-case"`, `"PascalCase"`, `"SCREAMING_SNAKE_CASE"`, `"snake_case"`, `"lower"`, `"UPPER"`, `"verbatim"`
//! - `rename_all_env = <string_literal>`: Override default field name case conversion for env variables for  [`Arg::env`][crate::Arg::env]
//!   - When not present: `"SCREAMING_SNAKE_CASE"`
//!   - Available values: `"camelCase"`, `"kebab-case"`, `"PascalCase"`, `"SCREAMING_SNAKE_CASE"`, `"snake_case"`, `"lower"`, `"UPPER"`, `"verbatim"`
//!
//! And for [`Subcommand`][crate::Subcommand] variants:
//! - `skip`: Ignore this variant
//! - `flatten`: Delegates to the variant for more subcommands (must implement
//!   [`Subcommand`][crate::Subcommand])
//! - `subcommand`: Nest subcommands under the current set of subcommands (must implement
//!   [`Subcommand`][crate::Subcommand])
//! - `external_subcommand`: [`Command::allow_external_subcommand(true)`][crate::Command::allow_external_subcommands]
//!   - Variant must be either `Variant(Vec<String>)` or `Variant(Vec<OsString>)`
//!
//! And for [`Args`][crate::Args] fields:
//! - `flatten`: Delegates to the field for more arguments (must implement [`Args`][crate::Args])
//!   - Only [`next_help_heading`][crate::Command::next_help_heading] can be used with `flatten`.  See
//!     [clap-rs/clap#3269](https://github.com/clap-rs/clap/issues/3269) for why
//!     arg attributes are not generally supported.
//!   - **Tip:** Though we do apply a flattened [`Args`][crate::Args]'s Parent Command Attributes, this
//!     makes reuse harder. Generally prefer putting the cmd attributes on the
//!     [`Parser`][crate::Parser] or on the flattened field.
//! - `subcommand`: Delegates definition of subcommands to the field (must implement
//!   [`Subcommand`][crate::Subcommand])
//!   - When `Option<T>`, the subcommand becomes optional
//!
//! See [Configuring the Parser][_tutorial#configuring-the-parser] and
//! [Subcommands][_tutorial#subcommands] from the tutorial.
//!
//! ### ArgGroup Attributes
//!
//! These correspond to the [`ArgGroup`][crate::ArgGroup] which is implicitly created for each
//! `Args` derive.
//!
//! **Raw attributes:**  Any [`ArgGroup` method][crate::ArgGroup] can also be used as an attribute, see [Terminology](#terminology) for syntax.
//! - e.g. `#[group(required = true)]` would translate to `arg_group.required(true)`
//!
//! **Magic attributes**:
//! - `id = <expr>`: [`ArgGroup::id`][crate::ArgGroup::id]
//!   - When not present: struct's name is used
//! - `skip [= <expr>]`: Ignore this field, filling in with `<expr>`
//!   - Without `<expr>`: fills the field with `Default::default()`
//!
//! Note:
//! - For `struct`s, [`multiple = true`][crate::ArgGroup::multiple] is implied
//! - `enum` support is tracked at [#2621](https://github.com/clap-rs/clap/issues/2621)
//!
//! See [Argument Relations][_tutorial#argument-relations] from the tutorial.
//!
//! ### Arg Attributes
//!
//! These correspond to a [`Arg`][crate::Arg].
//! The default state for a field without attributes is to be a positional argument with [behavior
//! inferred from the field type](#arg-types).
//! `#[arg(...)]` attributes allow overriding or extending those defaults.
//!
//! **Raw attributes:**  Any [`Arg` method][crate::Arg] can also be used as an attribute, see [Terminology](#terminology) for syntax.
//! - e.g. `#[arg(num_args(..=3))]` would translate to `arg.num_args(..=3)`
//!
//! **Magic attributes**:
//! - `id = <expr>`: [`Arg::id`][crate::Arg::id]
//!   - When not present: field's name is used
//! - `value_parser [= <expr>]`: [`Arg::value_parser`][crate::Arg::value_parser]
//!   - When not present: will auto-select an implementation based on the field type using
//!     [`value_parser!`][crate::value_parser!]
//! - `action [= <expr>]`: [`Arg::action`][crate::Arg::action]
//!   - When not present: will auto-select an action based on the field type
//! - `help = <expr>`: [`Arg::help`][crate::Arg::help]
//!   - When not present: [Doc comment summary](#doc-comments)
//! - `long_help[ = <expr>]`: [`Arg::long_help`][crate::Arg::long_help]
//!   - When not present: [Doc comment](#doc-comments) if there is a blank line, else nothing
//!   - When present without a value: [Doc comment](#doc-comments)
//! - `verbatim_doc_comment`: Minimizes pre-processing when converting doc comments to [`help`][crate::Arg::help] / [`long_help`][crate::Arg::long_help]
//! - `short [= <char>]`: [`Arg::short`][crate::Arg::short]
//!   - When not present: no short set
//!   - Without `<char>`: defaults to first character in the case-converted field name
//! - `long [= <str>]`: [`Arg::long`][crate::Arg::long]
//!   - When not present: no long set
//!   - Without `<str>`: defaults to the case-converted field name
//! - `env [= <str>]`: [`Arg::env`][crate::Arg::env] (needs [`env` feature][crate::_features] enabled)
//!   - When not present: no env set
//!   - Without `<str>`: defaults to the case-converted field name
//! - `from_global`: Read a [`Arg::global`][crate::Arg::global] argument (raw attribute), regardless of what subcommand you are in
//! - `value_enum`: Parse the value using the [`ValueEnum`][crate::ValueEnum]
//! - `skip [= <expr>]`: Ignore this field, filling in with `<expr>`
//!   - Without `<expr>`: fills the field with `Default::default()`
//! - `default_value = <str>`: [`Arg::default_value`][crate::Arg::default_value] and [`Arg::required(false)`][crate::Arg::required]
//! - `default_value_t [= <expr>]`: [`Arg::default_value`][crate::Arg::default_value] and [`Arg::required(false)`][crate::Arg::required]
//!   - Requires `std::fmt::Display` that roundtrips correctly with the
//!     [`Arg::value_parser`][crate::Arg::value_parser] or `#[arg(value_enum)]`
//!   - Without `<expr>`, relies on `Default::default()`
//! - `default_values_t = <expr>`: [`Arg::default_values`][crate::Arg::default_values] and [`Arg::required(false)`][crate::Arg::required]
//!   - Requires field arg to be of type `Vec<T>` and `T` to implement `std::fmt::Display` or `#[arg(value_enum)]`
//!   - `<expr>` must implement `IntoIterator<T>`
//! - `default_value_os_t [= <expr>]`: [`Arg::default_value_os`][crate::Arg::default_value_os] and [`Arg::required(false)`][crate::Arg::required]
//!   - Requires `std::convert::Into<OsString>` or `#[arg(value_enum)]`
//!   - Without `<expr>`, relies on `Default::default()`
//! - `default_values_os_t = <expr>`: [`Arg::default_values_os`][crate::Arg::default_values_os] and [`Arg::required(false)`][crate::Arg::required]
//!   - Requires field arg to be of type `Vec<T>` and `T` to implement `std::convert::Into<OsString>` or `#[arg(value_enum)]`
//!   - `<expr>` must implement `IntoIterator<T>`
//!
//! See [Adding Arguments][_tutorial#adding-arguments] and [Validation][_tutorial#validation] from the
//! tutorial.
//!
//! ### ValueEnum Attributes
//!
//! - `rename_all = <string_literal>`: Override default field / variant name case conversion for [`PossibleValue::new`][crate::builder::PossibleValue]
//!   - When not present: `"kebab-case"`
//!   - Available values: `"camelCase"`, `"kebab-case"`, `"PascalCase"`, `"SCREAMING_SNAKE_CASE"`, `"snake_case"`, `"lower"`, `"UPPER"`, `"verbatim"`
//!
//! See [Enumerated values][_tutorial#enumerated-values] from the tutorial.
//!
//! ### Possible Value Attributes
//!
//! These correspond to a [`PossibleValue`][crate::builder::PossibleValue].
//!
//! **Raw attributes:**  Any [`PossibleValue` method][crate::builder::PossibleValue] can also be used as an attribute, see [Terminology](#terminology) for syntax.
//! - e.g. `#[value(alias("foo"))]` would translate to `pv.alias("foo")`
//!
//! **Magic attributes**:
//! - `name = <expr>`: [`PossibleValue::new`][crate::builder::PossibleValue::new]
//!   - When not present: case-converted field name is used
//! - `help = <expr>`: [`PossibleValue::help`][crate::builder::PossibleValue::help]
//!   - When not present: [Doc comment summary](#doc-comments)
//! - `skip`: Ignore this variant
//!
//! ## Arg Types
//!
//! `clap` assumes some intent based on the type used:
//!
//! | Type                  | Effect                                               | Implies                                                     | Notes |
//! |-----------------------|------------------------------------------------------|-------------------------------------------------------------|-------|
//! | `()`                  | user-defined                                         | `.action(ArgAction::Set).required(false)`                   |       |
//! | `bool`                | flag                                                 | `.action(ArgAction::SetTrue)`                               |       |
//! | `Option<T>`           | optional argument                                    | `.action(ArgAction::Set).required(false)`                   |       |
//! | `Option<Option<T>>`   | optional value for optional argument                 | `.action(ArgAction::Set).required(false).num_args(0..=1)`   |       |
//! | `T`                   | required argument                                    | `.action(ArgAction::Set).required(!has_default)`            |       |
//! | `Vec<T>`              | `0..` occurrences of argument                        | `.action(ArgAction::Append).required(false)`  |       |
//! | `Option<Vec<T>>`      | `0..` occurrences of argument                        | `.action(ArgAction::Append).required(false)`  |       |
//! | `Vec<Vec<T>>`         | `0..` occurrences of argument, grouped by occurrence | `.action(ArgAction::Append).required(false)`  | requires `unstable-v5` |
//! | `Option<Vec<Vec<T>>>` | `0..` occurrences of argument, grouped by occurrence | `.action(ArgAction::Append).required(false)`  | requires `unstable-v5` |
//!
//! In addition, [`.value_parser(value_parser!(T))`][crate::value_parser!] is called for each
//! field.
//!
//! Notes:
//! - For custom type behavior, you can override the implied attributes/settings and/or set additional ones
//!   - To force any inferred type (like `Vec<T>`) to be treated as `T`, you can refer to the type
//!     by another means, like using `std::vec::Vec` instead of `Vec`.  For improving this, see
//!     [#4626](https://github.com/clap-rs/clap/issues/4626).
//! - `Option<Vec<T>>` and `Option<Vec<Vec<T>>` will be `None` instead of `vec![]` if no arguments are provided.
//!   - This gives the user some flexibility in designing their argument, like with `num_args(0..)`
//! - `Vec<Vec<T>>` will need [`Arg::num_args`][crate::Arg::num_args] set to be meaningful
//!
//! ## Doc Comments
//!
//! In clap, help messages for the whole binary can be specified
//! via [`Command::about`][crate::Command::about] and [`Command::long_about`][crate::Command::long_about] while help messages
//! for individual arguments can be specified via [`Arg::help`][crate::Arg::help] and [`Arg::long_help`][crate::Arg::long_help].
//!
//! `long_*` variants are used when user calls the program with
//! `--help` and "short" variants are used with `-h` flag.
//!
//! ```rust
//! # use clap::Parser;
//!
//! #[derive(Parser)]
//! #[command(about = "I am a program and I work, just pass `-h`", long_about = None)]
//! struct Foo {
//!     #[arg(short, help = "Pass `-h` and you'll see me!")]
//!     bar: String,
//! }
//! ```
//!
//! For convenience, doc comments can be used instead of raw methods
//! (this example works exactly like the one above):
//!
//! ```rust
//! # use clap::Parser;
//!
//! #[derive(Parser)]
//! /// I am a program and I work, just pass `-h`
//! struct Foo {
//!     /// Pass `-h` and you'll see me!
//!     bar: String,
//! }
//! ```
//!
//! <div class="warning">
//!
//! **NOTE:** Attributes have priority over doc comments!
//!
//! **Top level doc comments always generate `Command::about/long_about` calls!**
//! If you really want to use the `Command::about/long_about` methods (you likely don't),
//! use the `about` / `long_about` attributes to override the calls generated from
//! the doc comment.  To clear `long_about`, you can use
//! `#[command(long_about = None)]`.
//!
//! </div>
//!
//! ### Pre-processing
//!
//! ```rust
//! # use clap::Parser;
//! #[derive(Parser)]
//! /// Hi there, I'm Robo!
//! ///
//! /// I like beeping, stumbling, eating your electricity,
//! /// and making records of you singing in a shower.
//! /// Pay up, or I'll upload it to youtube!
//! struct Robo {
//!     /// Call my brother SkyNet.
//!     ///
//!     /// I am artificial superintelligence. I won't rest
//!     /// until I'll have destroyed humanity. Enjoy your
//!     /// pathetic existence, you mere mortals.
//!     #[arg(long, action)]
//!     kill_all_humans: bool,
//! }
//! ```
//!
//! A doc comment consists of three parts:
//! - Short summary
//! - A blank line (whitespace only)
//! - Detailed description, all the rest
//!
//! The summary corresponds with `Command::about` / `Arg::help`.  When a blank line is
//! present, the whole doc comment will be passed to `Command::long_about` /
//! `Arg::long_help`.  Or in other words, a doc may result in just a `Command::about` /
//! `Arg::help` or `Command::about` / `Arg::help` and `Command::long_about` /
//! `Arg::long_help`
//!
//! In addition, when `verbatim_doc_comment` is not present, `clap` applies some preprocessing, including:
//!
//! - Strip leading and trailing whitespace from every line, if present.
//!
//! - Strip leading and trailing blank lines, if present.
//!
//! - Interpret each group of non-empty lines as a word-wrapped paragraph.
//!
//!   We replace newlines within paragraphs with spaces to allow the output
//!   to be re-wrapped to the terminal width.
//!
//! - Strip any excess blank lines so that there is exactly one per paragraph break.
//!
//! - If the first paragraph ends in exactly one period,
//!   remove the trailing period (i.e. strip trailing periods but not trailing ellipses).
//!
//! Sometimes you don't want this preprocessing to apply, for example the comment contains
//! some ASCII art or markdown tables, you would need to preserve LFs along with
//! blank lines and the leading/trailing whitespace. When you pass use the
//! `verbatim_doc_comment` magic attribute, you  preserve
//! them.
//!
//! **Note:** Keep in mind that `verbatim_doc_comment` will *still*
//! - Remove one leading space from each line, even if this attribute is present,
//!   to allow for a space between `///` and the content.
//! - Remove leading and trailing blank lines
//!
//! ## Mixing Builder and Derive APIs
//!
//! The builder and derive APIs do not live in isolation. They can work together, which is
//! especially helpful if some arguments can be specified at compile-time while others must be
//! specified at runtime.
//!
//! ### Using derived arguments in a builder application
//!
//! When using the derive API, you can `#[command(flatten)]` a struct deriving `Args` into a struct
//! deriving `Args` or `Parser`. This example shows how you can augment a `Command` instance
//! created using the builder API with `Args` created using the derive API.
//!
//! It uses the [`Args::augment_args`][crate::Args::augment_args] method to add the arguments to
//! the `Command` instance.
//!
//! Crates such as [clap-verbosity-flag](https://github.com/rust-cli/clap-verbosity-flag) provide
//! structs that implement `Args`. Without the technique shown in this example, it would not be
//! possible to use such crates with the builder API.
//!
//! For example:
//! ```rust
#![doc = include_str!("../../examples/derive_ref/augment_args.rs")]
//! ```
//!
//! ### Using derived subcommands in a builder application
//!
//! When using the derive API, you can use `#[command(subcommand)]` inside the struct to add
//! subcommands. The type of the field is usually an enum that derived `Parser`. However, you can
//! also add the subcommands in that enum to a `Command` instance created with the builder API.
//!
//! It uses the [`Subcommand::augment_subcommands`][crate::Subcommand::augment_subcommands] method
//! to add the subcommands to the `Command` instance.
//!
//! For example:
//! ```rust
#![doc = include_str!("../../examples/derive_ref/augment_subcommands.rs")]
//! ```
//!
//! ### Adding hand-implemented subcommands to a derived application
//!
//! When using the derive API, you can use `#[command(subcommand)]` inside the struct to add
//! subcommands. The type of the field is usually an enum that derived `Parser`. However, you can
//! also implement the `Subcommand` trait manually on this enum (or any other type) and it can
//! still be used inside the struct created with the derive API. The implementation of the
//! `Subcommand` trait will use the builder API to add the subcommands to the `Command` instance
//! created behind the scenes for you by the derive API.
//!
//! Notice how in the previous example we used
//! [`augment_subcommands`][crate::Subcommand::augment_subcommands] on an enum that derived
//! `Parser`, whereas now we implement
//! [`augment_subcommands`][crate::Subcommand::augment_subcommands] ourselves, but the derive API
//! calls it automatically since we used the `#[command(subcommand)]` attribute.
//!
//! For example:
//! ```rust
#![doc = include_str!("../../examples/derive_ref/hand_subcommand.rs")]
//! ```
//!
//! ### Flattening hand-implemented args into a derived application
//!
//! When using the derive API, you can use `#[command(flatten)]` inside the struct to add arguments as
//! if they were added directly to the containing struct. The type of the field is usually an
//! struct that derived `Args`. However, you can also implement the `Args` trait manually on this
//! struct (or any other type) and it can still be used inside the struct created with the derive
//! API. The implementation of the `Args` trait will use the builder API to add the arguments to
//! the `Command` instance created behind the scenes for you by the derive API.
//!
//! Notice how in the previous example we used [`augment_args`][crate::Args::augment_args] on the
//! struct that derived `Parser`, whereas now we implement
//! [`augment_args`][crate::Args::augment_args] ourselves, but the derive API calls it
//! automatically since we used the `#[command(flatten)]` attribute.
//!
//! For example:
//! ```rust
#![doc = include_str!("../../examples/derive_ref/flatten_hand_args.rs")]
//! ```
//!
//! ## Tips
//!
//! - To get access to a [`Command`][crate::Command] call
//!   [`CommandFactory::command`][crate::CommandFactory::command] (implemented when deriving
//!   [`Parser`][crate::Parser])
//! - Proactively check for bad [`Command`][crate::Command] configurations by calling
//!   [`Command::debug_assert`][crate::Command::debug_assert] in a test
//!   ([example][_tutorial#testing])
//! - Always remember to [document](#doc-comments) args and commands with `#![deny(missing_docs)]`

// Point people here that search for attributes that don't exist in the derive (a subset of magic
// attributes)
#![doc(alias = "skip")]
#![doc(alias = "verbatim_doc_comment")]
#![doc(alias = "flatten")]
#![doc(alias = "external_subcommand")]
#![doc(alias = "subcommand")]
#![doc(alias = "rename_all")]
#![doc(alias = "rename_all_env")]
#![doc(alias = "default_value_t")]
#![doc(alias = "default_values_t")]
#![doc(alias = "default_value_os_t")]
#![doc(alias = "default_values_os_t")]

pub mod _tutorial;
#[doc(inline)]
pub use crate::_cookbook;

```

`clap/src/_faq.rs`:

```rs
//! # Documentation: FAQ
//!
//! 1. [Comparisons](#comparisons)
//!    1. [How does `clap` compare to structopt?](#how-does-clap-compare-to-structopt)
//!    2. [What are some reasons to use `clap`? (The Pitch)](#what-are-some-reasons-to-use-clap-the-pitch)
//!    3. [What are some reasons *not* to use `clap`? (The Anti Pitch)](#what-are-some-reasons-not-to-use-clap-the-anti-pitch)
//!    4. [Reasons to use `clap`](#reasons-to-use-clap)
//! 2. [How many approaches are there to create a parser?](#how-many-approaches-are-there-to-create-a-parser)
//! 3. [When should I use the builder vs derive APIs?](#when-should-i-use-the-builder-vs-derive-apis)
//! 4. [Why is there a default subcommand of help?](#why-is-there-a-default-subcommand-of-help)
//!
//! ### Comparisons
//!
//! First, let me say that these comparisons are highly subjective, and not meant
//! in a critical or harsh manner. All the argument parsing libraries out there (to
//! include `clap`) have their own strengths and weaknesses. Sometimes it just
//! comes down to personal taste when all other factors are equal. When in doubt,
//! try them all and pick one that you enjoy :). There's plenty of room in the Rust
//! community for multiple implementations!
//!
//! For less detailed but more broad comparisons, see
//! [argparse-benchmarks](https://github.com/rust-cli/argparse-benchmarks-rs).
//!
//! #### How does `clap` compare to [structopt](https://github.com/TeXitoi/structopt)?
//!
//! Simple! `clap` *is* `structopt`.  `structopt` started as a derive API built on
//! top of clap v2.  With clap v3, we've forked structopt and integrated it
//! directly into clap.  structopt is in
//! [maintenance mode](https://github.com/TeXitoi/structopt/issues/516#issuecomment-989566094)
//! with the release of `clap_derive`.
//!
//! The benefits of integrating `structopt` and `clap` are:
//! - Easier cross-linking in documentation
//! - Documentation parity
//! - Tighter design feedback loop, ensuring all new features are designed with
//!   derives in mind and easier to change `clap` in response to `structopt` bugs.
//! - Clearer endorsement of `structopt`
//!
//! See also
//! - [`clap` v3 CHANGELOG](https://github.com/clap-rs/clap/blob/v3-master/CHANGELOG.md#300---2021-12-31)
//! - [`structopt` migration guide](https://github.com/clap-rs/clap/blob/v3-master/CHANGELOG.md#migrate-structopt)
//!
//! #### What are some reasons to use `clap`? (The Pitch)
//!
//! `clap` is as fast, and as lightweight as possible while still giving all the features you'd expect from a modern argument parser. In fact, for the amount and type of features `clap` offers it remains about as fast as `getopts`. If you use `clap`, when you just need some simple arguments parsed, you'll find it's a walk in the park. `clap` also makes it possible to represent extremely complex and advanced requirements without too much thought. `clap` aims to be intuitive, easy to use, and fully capable for wide variety use cases and needs.
//!
//! #### What are some reasons *not* to use `clap`? (The Anti Pitch)
//!
//! Depending on the style in which you choose to define the valid arguments, `clap` can be very verbose. `clap` also offers so many finetuning knobs and dials, that learning everything can seem overwhelming. I strive to keep the simple cases simple, but when turning all those custom dials it can get complex. `clap` is also opinionated about parsing. Even though so much can be tweaked and tuned with `clap` (and I'm adding more all the time), there are still certain features which `clap` implements in specific ways that may be contrary to some users' use-cases.
//!
//! #### Reasons to use `clap`
//!
//!  * You want all the nice CLI features your users may expect, yet you don't want to implement them all yourself. You'd like to focus on your application, not argument parsing.
//!  * In addition to the point above, you don't want to sacrifice performance to get all those nice features.
//!  * You have complex requirements/conflicts between your various valid args.
//!  * You want to use subcommands (although other libraries also support subcommands, they are not nearly as feature rich as those provided by `clap`).
//!  * You want some sort of custom validation built into the argument parsing process, instead of as part of your application (which allows for earlier failures, better error messages, more cohesive experience, etc.).
//!
//! ### How many approaches are there to create a parser?
//!
//! The following APIs are supported:
//! - [Derive][crate::_derive::_tutorial]
//! - [Builder][crate::_tutorial]
//!
//! Previously, we supported:
//! - [YAML](https://github.com/clap-rs/clap/issues/3087)
//! - [docopt](http://docopt.org/)-inspired [usage parser](https://github.com/clap-rs/clap/issues/3086)
//! - [`clap_app!`](https://github.com/clap-rs/clap/issues/2835)
//!
//! There are also experiments with other APIs:
//! - [fncmd](https://github.com/yuhr/fncmd): function attribute
//! - [clap-serde](https://github.com/aobatact/clap-serde): create an `Command` from a deserializer
//!
//! ### When should I use the builder vs derive APIs?
//!
//! Our default answer is to use the [Derive API][crate::_derive::_tutorial]:
//! - Easier to read, write, and modify
//! - Easier to keep the argument declaration and reading of argument in sync
//! - Easier to reuse, e.g. [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag)
//!
//! The [Builder API][crate::_tutorial] is a lower-level API that someone might want to use for
//! - Faster compile times if you aren't already using other procedural macros
//! - More flexibility, e.g. you can look up an [arguments values][crate::ArgMatches::get_many],
//!   their [ordering with other arguments][crate::ArgMatches::indices_of], and [what set
//!   them][crate::ArgMatches::value_source].  The Derive API can only report values and not
//!   indices of or other data.
//!
//! You can [interop between Derive and Builder APIs][crate::_derive#mixing-builder-and-derive-apis].
//!
//! ### Why is there a default subcommand of help?
//!
//! There is only a default subcommand of `help` when other subcommands have been defined manually. So it's opt-in(ish), being that you only get a `help` subcommand if you're actually using subcommands.
//!
//! Also, if the user defined a `help` subcommand themselves, the auto-generated one wouldn't be added (meaning it's only generated if the user hasn't defined one themselves).
//!

```

`clap/src/_features.rs`:

```rs
//! ## Documentation: Feature Flags
//!
//! Available [compile-time feature flags](https://doc.rust-lang.org/cargo/reference/features.html#dependency-features)
//!
//! #### Default Features
//!
//! * `std`: _Not Currently Used._ Placeholder for supporting `no_std` environments in a backwards compatible manner.
//! * `color`: Turns on terminal styling of help and error messages.  See
//!   [`Command::styles`][crate::Command::styles] to customize this.
//! * `help`: Auto-generate help output
//! * `usage`: Auto-generate usage
//! * `error-context`: Include contextual information for errors (which arg failed, etc)
//! * `suggestions`: Turns on the `Did you mean '--myoption'?` feature for when users make typos.
//!
//! #### Optional features
//!
//! * `deprecated`: Guided experience to prepare for next breaking release (at different stages of development, this may become default)
//! * `derive`: Enables the custom derive (i.e. `#[derive(Parser)]`). Without this you must use one of the other methods of creating a `clap` CLI listed above.
//! * `cargo`: Turns on macros that read values from [`CARGO_*` environment variables](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates).
//! * `env`: Turns on the usage of environment variables during parsing.
//! * `unicode`: Turns on support for unicode characters (including emoji) in arguments and help messages.
//! * ``wrap_help``: Turns on the help text wrapping feature, based on the terminal size.
//! * `string`: Allow runtime generated strings (e.g. with [`Str`][crate::builder::Str]).
//!
//! #### Experimental features
//!
//! **Warning:** These may contain breaking changes between minor releases.
//!
//! * `unstable-v5`: Preview features which will be stable on the v5.0 release

```

`clap/src/_tutorial.rs`:

```rs
// Contributing
//
// New example code:
// - Please update the corresponding section in the derive tutorial
// - Building: They must be added to `Cargo.toml` with the appropriate `required-features`.
// - Testing: Ensure there is a markdown file with [trycmd](https://docs.rs/trycmd) syntax
//
// See also the general CONTRIBUTING

//! ## Tutorial for the Builder API
//!
//! *See the side bar for the Table of Contents*
//!
//! ## Quick Start
//!
//! You can create an application with several arguments using usage strings.
//!
//! First, ensure `clap` is available:
//! ```console
//! $ cargo add clap
//! ```
//!
//! Here is a preview of the type of application you can make:
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/01_quick.rs")]
//! ```
//!
#![doc = include_str!("../examples/tutorial_builder/01_quick.md")]
//!
//! See also
//! - [FAQ: When should I use the builder vs derive APIs?][crate::_faq#when-should-i-use-the-builder-vs-derive-apis]
//! - The [cookbook][crate::_cookbook] for more application-focused examples
//!
//! ## Configuring the Parser
//!
//! You use [`Command`][crate::Command] to start building a parser.
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/02_apps.rs")]
//! ```
//!
#![doc = include_str!("../examples/tutorial_builder/02_apps.md")]
//!
//! You can use [`command!()`][crate::command!] to fill these fields in from your `Cargo.toml`
//! file.  **This requires the [`cargo` feature flag][crate::_features].**
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/02_crate.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/02_crate.md")]
//!
//! You can use [`Command`][crate::Command] methods to change the application level behavior of
//! clap, like [`Command::next_line_help`].
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/02_app_settings.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/02_app_settings.md")]
//!
//! ## Adding Arguments
//!
//! 1. [Positionals](#positionals)
//! 2. [Options](#options)
//! 3. [Flags](#flags)
//! 4. [Required](#required)
//! 5. [Defaults](#defaults)
//! 6. [Subcommands](#subcommands)
//!
//!
//! ### Positionals
//!
//! By default, an [`Arg`] defines a positional argument:
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/03_03_positional.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/03_03_positional.md")]
//!
//! Note that the default [`ArgAction`][crate::ArgAction] is [`Set`][crate::ArgAction::Set].  To
//! accept multiple values, override the [action][Arg::action] with [`Append`][crate::ArgAction::Append]:
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/03_03_positional_mult.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/03_03_positional_mult.md")]
//!
//! ### Options
//!
//! You can name your arguments with a flag:
//! - Intent of the value is clearer
//! - Order doesn't matter
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/03_02_option.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/03_02_option.md")]
//!
//! Note that the default [`ArgAction`][crate::ArgAction] is [`Set`][crate::ArgAction::Set].  To
//! accept multiple occurrences, override the [action][Arg::action] with [`Append`][crate::ArgAction::Append]:
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/03_02_option_mult.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/03_02_option_mult.md")]
//!
//! ### Flags
//!
//! Flags can also be switches that can be on/off:
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/03_01_flag_bool.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/03_01_flag_bool.md")]
//!
//! To accept multiple flags, use [`Count`][crate::ArgAction::Count]:
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/03_01_flag_count.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/03_01_flag_count.md")]
//!
//! ### Required
//!
//! By default, an [`Arg`] is optional which can be changed with
//! [`required`][crate::Arg::required].
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/03_06_required.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/03_06_required.md")]
//!
//! ### Defaults
//!
//! We've previously showed that arguments can be [`required`][crate::Arg::required] or optional.
//! When optional, you work with a `Option` and can `unwrap_or`.  Alternatively, you can set
//! [`Arg::default_value`][crate::Arg::default_value].
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/03_05_default_values.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/03_05_default_values.md")]
//!
//! ### Subcommands
//!
//! Subcommands are defined as [`Command`][crate::Command]s that get added via
//! [`Command::subcommand`][crate::Command::subcommand]. Each instance of a Subcommand can have its
//! own version, author(s), Args, and even its own subcommands.
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/03_04_subcommands.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/03_04_subcommands.md")]
//!
//! ## Validation
//!
//! 1. [Enumerated values](#enumerated-values)
//! 2. [Validated values](#validated-values)
//! 3. [Argument Relations](#argument-relations)
//! 4. [Custom Validation](#custom-validation)
//!
//! An appropriate default parser/validator will be selected for the field's type.  See
//! [`value_parser!`][crate::value_parser!] for more details.
//!
//! ### Enumerated values
//!
//! If you have arguments of specific values you want to test for, you can use the
//! [`PossibleValuesParser`][crate::builder::PossibleValuesParser] or [`Arg::value_parser(["val1",
//! ...])`][crate::Arg::value_parser] for short.
//!
//! This allows you to specify the valid values for that argument. If the user does not use one of
//! those specific values, they will receive a graceful exit with error message informing them
//! of the mistake, and what the possible valid values are
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/04_01_possible.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/04_01_possible.md")]
//!
//! When enabling the [`derive` feature][crate::_features], you can use
//! [`ValueEnum`][crate::ValueEnum] to take care of the boiler plate for you, giving the same
//! results.
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/04_01_enum.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/04_01_enum.md")]
//!
//! ### Validated values
//!
//! More generally, you can validate and parse into any data type with [`Arg::value_parser`].
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/04_02_parse.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/04_02_parse.md")]
//!
//! A [custom parser][TypedValueParser] can be used to improve the error messages or provide additional validation:
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/04_02_validate.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/04_02_validate.md")]
//!
//! See [`Arg::value_parser`][crate::Arg::value_parser] for more details.
//!
//! ### Argument Relations
//!
//! You can declare dependencies or conflicts between [`Arg`][crate::Arg]s or even
//! [`ArgGroup`][crate::ArgGroup]s.
//!
//! [`ArgGroup`][crate::ArgGroup]s  make it easier to declare relations instead of having to list
//! each individually, or when you want a rule to apply "any but not all" arguments.
//!
//! Perhaps the most common use of [`ArgGroup`][crate::ArgGroup]s is to require one and *only* one
//! argument to be present out of a given set. Imagine that you had multiple arguments, and you
//! want one of them to be required, but making all of them required isn't feasible because perhaps
//! they conflict with each other.
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/04_03_relations.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/04_03_relations.md")]
//!
//! ### Custom Validation
//!
//! As a last resort, you can create custom errors with the basics of clap's formatting.
//!
//! ```rust
#![doc = include_str!("../examples/tutorial_builder/04_04_custom.rs")]
//! ```
#![doc = include_str!("../examples/tutorial_builder/04_04_custom.md")]
//!
//! ## Testing
//!
//! clap reports most development errors as `debug_assert!`s.  Rather than checking every
//! subcommand, you should have a test that calls
//! [`Command::debug_assert`][crate::Command::debug_assert]:
//! ```rust,no_run
#![doc = include_str!("../examples/tutorial_builder/05_01_assert.rs")]
//! ```
//!
//! ## Next Steps
//!
//! - [Cookbook][crate::_cookbook] for application-focused examples
//! - Explore more features in the [API reference][super]
//!
//! For support, see [Discussions](https://github.com/clap-rs/clap/discussions)
#![allow(unused_imports)]
use crate::builder::*;

```

`clap/src/bin/stdio-fixture.rs`:

```rs
fn main() {
    #[allow(unused_mut)]
    let mut cmd = clap::Command::new("stdio-fixture")
        .version("1.0")
        .long_version("1.0 - a2132c")
        .arg_required_else_help(true)
        .subcommand(clap::Command::new("more"))
        .arg(
            clap::Arg::new("verbose")
                .long("verbose")
                .help("log")
                .action(clap::ArgAction::SetTrue)
                .long_help("more log"),
        );
    #[cfg(feature = "color")]
    {
        use clap::builder::styling;
        const STYLES: styling::Styles = styling::Styles::styled()
            .header(styling::AnsiColor::Green.on_default().bold())
            .usage(styling::AnsiColor::Green.on_default().bold())
            .literal(styling::AnsiColor::Blue.on_default().bold())
            .placeholder(styling::AnsiColor::Cyan.on_default());
        cmd = cmd.styles(STYLES);
    }
    cmd.get_matches();
}

```

`clap/src/lib.rs`:

```rs
// Copyright ⓒ 2015-2016 Kevin B. Knapp and [`clap-rs` contributors](https://github.com/clap-rs/clap/graphs/contributors).
// Licensed under the MIT license
// (see LICENSE or <http://opensource.org/licenses/MIT>) All files in the project carrying such
// notice may not be copied, modified, or distributed except according to those terms.

//! > **Command Line Argument Parser for Rust**
//!
//! Quick Links:
//! - Derive [tutorial][_derive::_tutorial] and [reference][_derive]
//! - Builder [tutorial][_tutorial] and [reference](index.html)
//! - [Cookbook][_cookbook]
//! - [FAQ][_faq]
//! - [Discussions](https://github.com/clap-rs/clap/discussions)
//! - [CHANGELOG](https://github.com/clap-rs/clap/blob/v4.5.36/CHANGELOG.md) (includes major version migration
//!   guides)
//!
//! ## Aspirations
//!
//! - Out of the box, users get a polished CLI experience
//!   - Including common argument behavior, help generation, suggested fixes for users, colored output, [shell completions](https://github.com/clap-rs/clap/tree/master/clap_complete), etc
//! - Flexible enough to port your existing CLI interface
//!   - However, we won't necessarily streamline support for each use case
//! - Reasonable parse performance
//! - Resilient maintainership, including
//!   - Willing to break compatibility rather than batching up breaking changes in large releases
//!   - Leverage feature flags to keep to one active branch
//!   - Being under [WG-CLI](https://github.com/rust-cli/team/) to increase the bus factor
//! - We follow semver and will wait about 6-9 months between major breaking changes
//! - We will support the last two minor Rust releases (MSRV, currently 1.74)
//!
//! While these aspirations can be at odds with fast build times and low binary
//! size, we will still strive to keep these reasonable for the flexibility you
//! get.  Check out the
//! [argparse-benchmarks](https://github.com/rust-cli/argparse-benchmarks-rs) for
//! CLI parsers optimized for other use cases.
//!
//! ## Example
//!
//! Run
//! ```console
//! $ cargo add clap --features derive
//! ```
//! *(See also [feature flag reference][_features])*
//!
//! Then define your CLI in `main.rs`:
//! ```rust
//! # #[cfg(feature = "derive")] {
#![doc = include_str!("../examples/demo.rs")]
//! # }
//! ```
//!
//! And try it out:
#![doc = include_str!("../examples/demo.md")]
//!
//! See also the derive [tutorial][_derive::_tutorial] and [reference][_derive]
//!
//! ### Related Projects
//!
//! Augment clap:
//! - [wild](https://crates.io/crates/wild) for supporting wildcards (`*`) on Windows like you do Linux
//! - [argfile](https://crates.io/crates/argfile) for loading additional arguments from a file (aka response files)
//! - [shadow-rs](https://crates.io/crates/shadow-rs) for generating `Command::long_version`
//! - [clap_mangen](https://crates.io/crates/clap_mangen) for generating man page source (roff)
//! - [clap_complete](https://crates.io/crates/clap_complete) for shell completion support
//!
//! CLI Helpers
//! - [clio](https://crates.io/crates/clio) for reading/writing to files specified as arguments
//! - [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag)
//! - [clap-cargo](https://crates.io/crates/clap-cargo)
//! - [colorchoice-clap](https://crates.io/crates/colorchoice-clap)
//!
//! Testing
//! - [`trycmd`](https://crates.io/crates/trycmd):  Bulk snapshot testing
//! - [`snapbox`](https://crates.io/crates/snapbox):  Specialized snapshot testing
//! - [`assert_cmd`](https://crates.io/crates/assert_cmd) and [`assert_fs`](https://crates.io/crates/assert_fs): Customized testing
//!
//! Documentation:
//! - [Command-line Apps for Rust](https://rust-cli.github.io/book/index.html) book
//!

#![doc(html_logo_url = "https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png")]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![forbid(unsafe_code)]
#![warn(missing_docs)]
#![warn(clippy::print_stderr)]
#![warn(clippy::print_stdout)]

pub use clap_builder::*;
#[cfg(feature = "derive")]
#[doc(hidden)]
pub use clap_derive::{self, Args, Parser, Subcommand, ValueEnum};

#[cfg(feature = "unstable-doc")]
pub mod _cookbook;
#[cfg(feature = "unstable-doc")]
pub mod _derive;
#[cfg(feature = "unstable-doc")]
pub mod _faq;
#[cfg(feature = "unstable-doc")]
pub mod _features;
#[cfg(feature = "unstable-doc")]
pub mod _tutorial;

```

`clap/tests/builder/action.rs`:

```rs
#![allow(clippy::bool_assert_comparison)]

use clap::builder::ArgPredicate;
use clap::error::ErrorKind;
use clap::Arg;
use clap::ArgAction;
use clap::Command;

#[test]
fn set() {
    let cmd = Command::new("test").arg(Arg::new("mammal").long("mammal").action(ArgAction::Set));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_one::<String>("mammal"), None);
    assert_eq!(matches.contains_id("mammal"), false);
    assert_eq!(matches.index_of("mammal"), None);

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal", "dog"])
        .unwrap();
    assert_eq!(matches.get_one::<String>("mammal").unwrap(), "dog");
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(2));

    let result = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal", "dog", "--mammal", "cat"]);
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let matches = cmd
        .clone()
        .args_override_self(true)
        .try_get_matches_from(["test", "--mammal", "dog", "--mammal", "cat"])
        .unwrap();
    assert_eq!(matches.get_one::<String>("mammal").unwrap(), "cat");
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(4));
}

#[test]
fn append() {
    let cmd = Command::new("test").arg(Arg::new("mammal").long("mammal").action(ArgAction::Append));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_one::<String>("mammal"), None);
    assert_eq!(matches.contains_id("mammal"), false);
    assert_eq!(matches.index_of("mammal"), None);

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal", "dog"])
        .unwrap();
    assert_eq!(matches.get_one::<String>("mammal").unwrap(), "dog");
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(
        matches.indices_of("mammal").unwrap().collect::<Vec<_>>(),
        vec![2]
    );

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal", "dog", "--mammal", "cat"])
        .unwrap();
    assert_eq!(
        matches
            .get_many::<String>("mammal")
            .unwrap()
            .map(|s| s.as_str())
            .collect::<Vec<_>>(),
        vec!["dog", "cat"]
    );
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(
        matches.indices_of("mammal").unwrap().collect::<Vec<_>>(),
        vec![2, 4]
    );
}

#[test]
fn set_true() {
    let cmd =
        Command::new("test").arg(Arg::new("mammal").long("mammal").action(ArgAction::SetTrue));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_flag("mammal"), false);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("mammal"), true);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));

    let result = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal", "--mammal"]);
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let matches = cmd
        .clone()
        .args_override_self(true)
        .try_get_matches_from(["test", "--mammal", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("mammal"), true);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(2));
}

#[test]
fn set_true_with_explicit_default_value() {
    let cmd = Command::new("test").arg(
        Arg::new("mammal")
            .long("mammal")
            .action(ArgAction::SetTrue)
            .default_value("false"),
    );

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("mammal"), true);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_flag("mammal"), false);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));
}

#[test]
fn set_true_with_default_value_if_present() {
    let cmd = Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::SetTrue)
                .default_value_if("dog", ArgPredicate::IsPresent, Some("true")),
        )
        .arg(Arg::new("dog").long("dog").action(ArgAction::SetTrue));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_flag("dog"), false);
    assert_eq!(matches.get_flag("mammal"), false);

    let matches = cmd.clone().try_get_matches_from(["test", "--dog"]).unwrap();
    assert_eq!(matches.get_flag("dog"), true);
    assert_eq!(matches.get_flag("mammal"), true);

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("dog"), false);
    assert_eq!(matches.get_flag("mammal"), true);
}

#[test]
fn set_true_with_default_value_if_value() {
    let cmd = Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::SetTrue)
                .default_value_if("dog", "true", Some("true")),
        )
        .arg(Arg::new("dog").long("dog").action(ArgAction::SetTrue));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_flag("dog"), false);
    assert_eq!(matches.get_flag("mammal"), false);

    let matches = cmd.clone().try_get_matches_from(["test", "--dog"]).unwrap();
    assert_eq!(matches.get_flag("dog"), true);
    assert_eq!(matches.get_flag("mammal"), true);

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("dog"), false);
    assert_eq!(matches.get_flag("mammal"), true);
}

#[test]
fn set_true_with_required_if_eq() {
    let cmd = Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::SetTrue)
                .required_if_eq("dog", "true"),
        )
        .arg(Arg::new("dog").long("dog").action(ArgAction::SetTrue));

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("dog"), false);
    assert_eq!(matches.get_flag("mammal"), true);

    cmd.clone()
        .try_get_matches_from(["test", "--dog"])
        .unwrap_err();

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--dog", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("dog"), true);
    assert_eq!(matches.get_flag("mammal"), true);
}

#[test]
#[should_panic = "Argument `mammal`'s action SetTrue is incompatible with `num_args(1..)`"]
fn set_true_with_incompatible_num_args() {
    Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::SetTrue)
                .num_args(1..),
        )
        .build();
}

#[test]
fn set_false() {
    let cmd = Command::new("test").arg(
        Arg::new("mammal")
            .long("mammal")
            .action(ArgAction::SetFalse),
    );

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_flag("mammal"), true);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("mammal"), false);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));

    let result = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal", "--mammal"]);
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let matches = cmd
        .clone()
        .args_override_self(true)
        .try_get_matches_from(["test", "--mammal", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("mammal"), false);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(2));
}

#[test]
fn set_false_with_explicit_default_value() {
    let cmd = Command::new("test").arg(
        Arg::new("mammal")
            .long("mammal")
            .action(ArgAction::SetFalse)
            .default_value("true"),
    );

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("mammal"), false);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_flag("mammal"), true);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));
}

#[test]
fn set_false_with_default_value_if_present() {
    let cmd = Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::SetFalse)
                .default_value_if("dog", ArgPredicate::IsPresent, Some("false")),
        )
        .arg(Arg::new("dog").long("dog").action(ArgAction::SetFalse));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_flag("dog"), true);
    assert_eq!(matches.get_flag("mammal"), true);

    let matches = cmd.clone().try_get_matches_from(["test", "--dog"]).unwrap();
    assert_eq!(matches.get_flag("dog"), false);
    assert_eq!(matches.get_flag("mammal"), false);

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("dog"), true);
    assert_eq!(matches.get_flag("mammal"), false);
}

#[test]
fn set_false_with_default_value_if_value() {
    let cmd = Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::SetFalse)
                .default_value_if("dog", "false", Some("false")),
        )
        .arg(Arg::new("dog").long("dog").action(ArgAction::SetFalse));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(matches.get_flag("dog"), true);
    assert_eq!(matches.get_flag("mammal"), true);

    let matches = cmd.clone().try_get_matches_from(["test", "--dog"]).unwrap();
    assert_eq!(matches.get_flag("dog"), false);
    assert_eq!(matches.get_flag("mammal"), false);

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(matches.get_flag("dog"), true);
    assert_eq!(matches.get_flag("mammal"), false);
}

#[test]
#[should_panic = "Argument `mammal`'s action SetFalse is incompatible with `num_args(1..)`"]
fn set_false_with_incompatible_num_args() {
    Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::SetFalse)
                .num_args(1..),
        )
        .build();
}

#[test]
fn count() {
    let cmd = Command::new("test").arg(Arg::new("mammal").long("mammal").action(ArgAction::Count));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 0);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 1);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal", "--mammal"])
        .unwrap();
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 2);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(2));
}

#[test]
fn count_with_explicit_default_value() {
    let cmd = Command::new("test").arg(
        Arg::new("mammal")
            .long("mammal")
            .action(ArgAction::Count)
            .default_value("10"),
    );

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 1);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 10);
    assert_eq!(matches.contains_id("mammal"), true);
    assert_eq!(matches.index_of("mammal"), Some(1));
}

#[test]
fn count_with_default_value_if_present() {
    let cmd = Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::Count)
                .default_value_if("dog", ArgPredicate::IsPresent, Some("10")),
        )
        .arg(Arg::new("dog").long("dog").action(ArgAction::Count));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(*matches.get_one::<u8>("dog").unwrap(), 0);
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 0);

    let matches = cmd.clone().try_get_matches_from(["test", "--dog"]).unwrap();
    assert_eq!(*matches.get_one::<u8>("dog").unwrap(), 1);
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 10);

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(*matches.get_one::<u8>("dog").unwrap(), 0);
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 1);
}

#[test]
fn count_with_default_value_if_value() {
    let cmd = Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::Count)
                .default_value_if("dog", "2", Some("10")),
        )
        .arg(Arg::new("dog").long("dog").action(ArgAction::Count));

    let matches = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(*matches.get_one::<u8>("dog").unwrap(), 0);
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 0);

    let matches = cmd.clone().try_get_matches_from(["test", "--dog"]).unwrap();
    assert_eq!(*matches.get_one::<u8>("dog").unwrap(), 1);
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 0);

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--dog", "--dog"])
        .unwrap();
    assert_eq!(*matches.get_one::<u8>("dog").unwrap(), 2);
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 10);

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--mammal"])
        .unwrap();
    assert_eq!(*matches.get_one::<u8>("dog").unwrap(), 0);
    assert_eq!(*matches.get_one::<u8>("mammal").unwrap(), 1);
}

#[test]
#[should_panic = "Argument `mammal`'s action Count is incompatible with `num_args(1..)`"]
fn count_with_incompatible_num_args() {
    Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::Count)
                .num_args(1..),
        )
        .build();
}

#[test]
#[should_panic = "Argument `mammal`'s action Help is incompatible with `num_args(1..)`"]
fn help_with_incompatible_num_args() {
    Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::Help)
                .num_args(1..),
        )
        .build();
}

#[test]
#[should_panic = "Argument `mammal`'s action HelpShort is incompatible with `num_args(1..)`"]
fn help_short_with_incompatible_num_args() {
    Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::HelpShort)
                .num_args(1..),
        )
        .build();
}

#[test]
#[should_panic = "Argument `mammal`'s action HelpLong is incompatible with `num_args(1..)`"]
fn help_long_with_incompatible_num_args() {
    Command::new("test")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::HelpLong)
                .num_args(1..),
        )
        .build();
}

#[test]
#[should_panic = "Argument `mammal`'s action Version is incompatible with `num_args(1..)`"]
fn version_with_incompatible_num_args() {
    Command::new("test")
        .version("1.0.0")
        .arg(
            Arg::new("mammal")
                .long("mammal")
                .action(ArgAction::Version)
                .num_args(1..),
        )
        .build();
}

```

`clap/tests/builder/app_settings.rs`:

```rs
use std::ffi::OsString;

use clap::{arg, error::ErrorKind, Arg, ArgAction, Command};

use super::utils;

static ALLOW_EXT_SC: &str = "\
Usage: clap-test [COMMAND]

Options:
  -h, --help     Print help
  -V, --version  Print version
";

static DONT_COLLAPSE_ARGS: &str = "\
Usage: clap-test [arg1] [arg2] [arg3]

Arguments:
  [arg1]  some
  [arg2]  some
  [arg3]  some

Options:
  -h, --help     Print help
  -V, --version  Print version
";

#[test]
fn sub_command_negate_required() {
    Command::new("sub_command_negate")
        .subcommand_negates_reqs(true)
        .arg(Arg::new("test").required(true).index(1))
        .subcommand(Command::new("sub1"))
        .try_get_matches_from(vec!["myprog", "sub1"])
        .unwrap();
}

#[test]
fn sub_command_negate_required_2() {
    let result = Command::new("sub_command_negate")
        .subcommand_negates_reqs(true)
        .arg(Arg::new("test").required(true).index(1))
        .subcommand(Command::new("sub1"))
        .try_get_matches_from(vec![""]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn sub_command_required() {
    let result = Command::new("sc_required")
        .subcommand_required(true)
        .subcommand(Command::new("sub1"))
        .try_get_matches_from(vec![""]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingSubcommand);
}

#[test]
#[cfg(feature = "error-context")]
fn sub_command_required_error() {
    static ERROR: &str = "\
error: 'sc_required' requires a subcommand but one was not provided
  [subcommands: sub1, help]

Usage: sc_required <COMMAND>

For more information, try '--help'.
";

    let cmd = Command::new("sc_required")
        .subcommand_required(true)
        .subcommand(Command::new("sub1"));
    utils::assert_output(cmd, "sc_required", ERROR, true);
}

#[test]
fn arg_required_else_help() {
    let result = Command::new("arg_required")
        .arg_required_else_help(true)
        .arg(Arg::new("test").index(1))
        .try_get_matches_from(vec![""]);

    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(
        err.kind(),
        ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand
    );
}

#[test]
fn arg_required_else_help_over_req_arg() {
    let result = Command::new("arg_required")
        .arg_required_else_help(true)
        .arg(Arg::new("test").index(1).required(true))
        .try_get_matches_from(vec![""]);

    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(
        err.kind(),
        ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand
    );
}

#[test]
fn arg_required_else_help_over_req_subcommand() {
    let result = Command::new("sub_required")
        .arg_required_else_help(true)
        .subcommand_required(true)
        .subcommand(Command::new("sub1"))
        .try_get_matches_from(vec![""]);

    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(
        err.kind(),
        ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand
    );
}

#[test]
fn arg_required_else_help_with_default() {
    let result = Command::new("arg_required")
        .arg_required_else_help(true)
        .arg(arg!(--input <PATH>).default_value("-"))
        .try_get_matches_from(vec![""]);

    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(
        err.kind(),
        ErrorKind::DisplayHelpOnMissingArgumentOrSubcommand
    );
}

#[test]
fn arg_required_else_help_error_message() {
    static ARG_REQUIRED_ELSE_HELP: &str = "\
Usage: test [OPTIONS]

Options:
  -i, --info     Provides more info
  -h, --help     Print help
  -V, --version  Print version
";

    let cmd = Command::new("test")
        .arg_required_else_help(true)
        .version("1.0")
        .arg(
            Arg::new("info")
                .help("Provides more info")
                .short('i')
                .long("info")
                .action(ArgAction::SetTrue),
        );
    utils::assert_output(
        cmd,
        "test",
        ARG_REQUIRED_ELSE_HELP,
        true, // Unlike normal displaying of help, we should provide a fatal exit code
    );
}

#[cfg(not(feature = "suggestions"))]
#[test]
fn infer_subcommands_fail_no_args() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test"))
        .subcommand(Command::new("temp"))
        .try_get_matches_from(vec!["prog", "te"]);
    assert!(m.is_err(), "{:#?}", m.unwrap());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidSubcommand);
}

#[cfg(feature = "suggestions")]
#[test]
fn infer_subcommands_fail_no_args() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test"))
        .subcommand(Command::new("temp"))
        .try_get_matches_from(vec!["prog", "te"]);
    assert!(m.is_err(), "{:#?}", m.unwrap());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidSubcommand);
}

#[test]
fn infer_subcommands_fail_with_args() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .arg(Arg::new("some"))
        .subcommand(Command::new("test"))
        .subcommand(Command::new("temp"))
        .try_get_matches_from(vec!["prog", "t"]);
    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    assert_eq!(
        m.unwrap().get_one::<String>("some").map(|v| v.as_str()),
        Some("t")
    );
}

#[test]
fn infer_subcommands_fail_with_args2() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .arg(Arg::new("some"))
        .subcommand(Command::new("test"))
        .subcommand(Command::new("temp"))
        .try_get_matches_from(vec!["prog", "te"]);
    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    assert_eq!(
        m.unwrap().get_one::<String>("some").map(|v| v.as_str()),
        Some("te")
    );
}

#[test]
fn infer_subcommands_pass() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test"))
        .try_get_matches_from(vec!["prog", "te"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

#[test]
fn infer_subcommands_pass_close() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test"))
        .subcommand(Command::new("temp"))
        .try_get_matches_from(vec!["prog", "tes"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

#[test]
fn infer_subcommands_pass_exact_match() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test"))
        .subcommand(Command::new("testa"))
        .subcommand(Command::new("testb"))
        .try_get_matches_from(vec!["prog", "test"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

#[test]
fn infer_subcommands_pass_conflicting_aliases() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test").aliases(["testa", "t", "testb"]))
        .try_get_matches_from(vec!["prog", "te"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

#[test]
fn infer_long_flag_pass_conflicting_aliases() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(
            Command::new("c")
                .long_flag("test")
                .long_flag_aliases(["testa", "t", "testb"]),
        )
        .try_get_matches_from(vec!["prog", "--te"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("c"));
}

#[test]
fn infer_long_flag() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test").long_flag("testa"))
        .try_get_matches_from(vec!["prog", "--te"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

#[test]
fn infer_subcommands_long_flag_fail_with_args2() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("a").long_flag("test"))
        .subcommand(Command::new("b").long_flag("temp"))
        .try_get_matches_from(vec!["prog", "--te"]);
    assert!(m.is_err(), "{:#?}", m.unwrap());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[cfg(feature = "suggestions")]
#[test]
fn infer_subcommands_fail_suggestions() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test"))
        .subcommand(Command::new("temp"))
        .try_get_matches_from(vec!["prog", "temps"]);
    assert!(m.is_err(), "{:#?}", m.unwrap());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidSubcommand);
}

#[cfg(not(feature = "suggestions"))]
#[test]
fn infer_subcommands_fail_suggestions() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test"))
        .subcommand(Command::new("temp"))
        .try_get_matches_from(vec!["prog", "temps"]);
    assert!(m.is_err(), "{:#?}", m.unwrap());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidSubcommand);
}

#[test]
fn no_bin_name() {
    let result = Command::new("arg_required")
        .no_binary_name(true)
        .arg(Arg::new("test").required(true).index(1))
        .try_get_matches_from(vec!["testing"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
    let matches = result.unwrap();
    assert_eq!(
        matches
            .get_one::<String>("test")
            .map(|v| v.as_str())
            .unwrap(),
        "testing"
    );
}

#[test]
fn skip_possible_values() {
    static SKIP_POS_VALS: &str = "\
tests stuff

Usage: test [OPTIONS] [arg1]

Arguments:
  [arg1]  some pos arg

Options:
  -o, --opt <opt>  some option
  -h, --help       Print help
  -V, --version    Print version
";

    let cmd = Command::new("test")
        .author("Kevin K.")
        .about("tests stuff")
        .version("1.3")
        .hide_possible_values(true)
        .args([
            arg!(-o --opt <opt> "some option").value_parser(["one", "two"]),
            arg!([arg1] "some pos arg").value_parser(["three", "four"]),
        ]);

    utils::assert_output(cmd, "test --help", SKIP_POS_VALS, false);
}

#[test]
fn stop_delim_values_only_pos_follows() {
    let r = Command::new("onlypos")
        .dont_delimit_trailing_values(true)
        .args([arg!(f: -f <flag> "some opt"), arg!([arg] ... "some arg")])
        .try_get_matches_from(vec!["", "--", "-f", "-g,x"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert!(!m.contains_id("f"));
    assert_eq!(
        m.get_many::<String>("arg")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["-f", "-g,x"]
    );
}

#[test]
fn dont_delim_values_trailingvararg() {
    let m = Command::new("positional")
        .dont_delimit_trailing_values(true)
        .arg(arg!([opt] ... "some pos").trailing_var_arg(true))
        .try_get_matches_from(vec!["", "test", "--foo", "-Wl,-bar"])
        .unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(
        m.get_many::<String>("opt")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["test", "--foo", "-Wl,-bar"]
    );
}

#[test]
fn delim_values_only_pos_follows() {
    let r = Command::new("onlypos")
        .args([arg!(f: -f [flag] "some opt"), arg!([arg] ... "some arg")])
        .try_get_matches_from(vec!["", "--", "-f", "-g,x"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert!(!m.contains_id("f"));
    assert_eq!(
        m.get_many::<String>("arg")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["-f", "-g,x"]
    );
}

#[test]
fn delim_values_trailingvararg() {
    let m = Command::new("positional")
        .arg(arg!([opt] ... "some pos").trailing_var_arg(true))
        .try_get_matches_from(vec!["", "test", "--foo", "-Wl,-bar"])
        .unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(
        m.get_many::<String>("opt")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["test", "--foo", "-Wl,-bar"]
    );
}

#[test]
fn delim_values_only_pos_follows_with_delim() {
    let r = Command::new("onlypos")
        .args([
            arg!(f: -f [flag] "some opt"),
            arg!([arg] ... "some arg").value_delimiter(','),
        ])
        .try_get_matches_from(vec!["", "--", "-f", "-g,x"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert!(!m.contains_id("f"));
    assert_eq!(
        m.get_many::<String>("arg")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["-f", "-g", "x"]
    );
}

#[test]
fn delim_values_trailingvararg_with_delim() {
    let m = Command::new("positional")
        .arg(
            arg!([opt] ... "some pos")
                .value_delimiter(',')
                .trailing_var_arg(true),
        )
        .try_get_matches_from(vec!["", "test", "--foo", "-Wl,-bar"])
        .unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(
        m.get_many::<String>("opt")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["test", "--foo", "-Wl", "-bar"]
    );
}

#[test]
fn leading_hyphen_short() {
    let res = Command::new("leadhy")
        .arg(Arg::new("some").allow_hyphen_values(true))
        .arg(Arg::new("other").short('o').action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-bar", "-o"]);
    assert!(res.is_ok(), "Error: {:?}", res.unwrap_err().kind());
    let m = res.unwrap();
    assert!(m.contains_id("some"));
    assert!(m.contains_id("other"));
    assert_eq!(
        m.get_one::<String>("some").map(|v| v.as_str()).unwrap(),
        "-bar"
    );
    assert_eq!(
        *m.get_one::<bool>("other").expect("defaulted by clap"),
        true
    );
}

#[test]
fn leading_hyphen_long() {
    let res = Command::new("leadhy")
        .arg(Arg::new("some").allow_hyphen_values(true))
        .arg(Arg::new("other").short('o').action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "--bar", "-o"]);
    assert!(res.is_ok(), "Error: {:?}", res.unwrap_err().kind());
    let m = res.unwrap();
    assert!(m.contains_id("some"));
    assert!(m.contains_id("other"));
    assert_eq!(
        m.get_one::<String>("some").map(|v| v.as_str()).unwrap(),
        "--bar"
    );
    assert_eq!(
        *m.get_one::<bool>("other").expect("defaulted by clap"),
        true
    );
}

#[test]
fn leading_hyphen_opt() {
    let res = Command::new("leadhy")
        .arg(
            Arg::new("some")
                .action(ArgAction::Set)
                .long("opt")
                .allow_hyphen_values(true),
        )
        .arg(Arg::new("other").short('o').action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "--opt", "--bar", "-o"]);
    assert!(res.is_ok(), "Error: {:?}", res.unwrap_err().kind());
    let m = res.unwrap();
    assert!(m.contains_id("some"));
    assert!(m.contains_id("other"));
    assert_eq!(
        m.get_one::<String>("some").map(|v| v.as_str()).unwrap(),
        "--bar"
    );
    assert_eq!(
        *m.get_one::<bool>("other").expect("defaulted by clap"),
        true
    );
}

#[test]
fn allow_negative_numbers_success() {
    let res = Command::new("negnum")
        .arg(Arg::new("panum").allow_negative_numbers(true))
        .arg(
            Arg::new("onum")
                .short('o')
                .action(ArgAction::Set)
                .allow_negative_numbers(true),
        )
        .try_get_matches_from(vec!["negnum", "-20", "-o", "-1.2"]);
    assert!(res.is_ok(), "Error: {:?}", res.unwrap_err().kind());
    let m = res.unwrap();
    assert_eq!(
        m.get_one::<String>("panum").map(|v| v.as_str()).unwrap(),
        "-20"
    );
    assert_eq!(
        m.get_one::<String>("onum").map(|v| v.as_str()).unwrap(),
        "-1.2"
    );
}

#[test]
fn allow_negative_numbers_fail() {
    let res = Command::new("negnum")
        .arg(Arg::new("panum").allow_negative_numbers(true))
        .arg(
            Arg::new("onum")
                .short('o')
                .action(ArgAction::Set)
                .allow_negative_numbers(true),
        )
        .try_get_matches_from(vec!["negnum", "--foo", "-o", "-1.2"]);
    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[test]
fn trailing_var_arg_with_hyphen_values_escape_first() {
    assert_trailing_var_args(&["test", "--", "foo", "bar"], Some(&["foo", "bar"]), false);
}

#[test]
fn trailing_var_arg_with_hyphen_values_escape_middle() {
    assert_trailing_var_args(
        &["test", "foo", "--", "bar"],
        Some(&["foo", "--", "bar"]),
        false,
    );
}

#[test]
fn trailing_var_arg_with_hyphen_values_short_first() {
    assert_trailing_var_args(&["test", "-p", "foo", "bar"], Some(&["foo", "bar"]), true);
}

#[test]
fn trailing_var_arg_with_hyphen_values_short_middle() {
    assert_trailing_var_args(
        &["test", "foo", "-p", "bar"],
        Some(&["foo", "-p", "bar"]),
        false,
    );
}

#[test]
fn trailing_var_arg_with_hyphen_values_long_first() {
    assert_trailing_var_args(
        &["test", "--prog", "foo", "bar"],
        Some(&["foo", "bar"]),
        true,
    );
}

#[test]
fn trailing_var_arg_with_hyphen_values_long_middle() {
    assert_trailing_var_args(
        &["test", "foo", "--prog", "bar"],
        Some(&["foo", "--prog", "bar"]),
        false,
    );
}

#[track_caller]
fn assert_trailing_var_args(
    input: &[&str],
    expected_var_arg: Option<&[&str]>,
    expected_flag: bool,
) {
    let cmd = Command::new("test").arg(arg!(-p - -prog)).arg(
        arg!([opt] ... "some pos")
            .trailing_var_arg(true)
            .allow_hyphen_values(true),
    );
    let m = cmd.try_get_matches_from(input);
    assert!(
        m.is_ok(),
        "failed with args {:?}: {}",
        input,
        m.unwrap_err()
    );
    let m = m.unwrap();

    let actual_var_args = m
        .get_many::<String>("opt")
        .map(|v| v.map(|s| s.as_str()).collect::<Vec<_>>());
    assert_eq!(actual_var_args.as_deref(), expected_var_arg);
    assert_eq!(m.get_flag("prog"), expected_flag);
}

#[test]
fn disable_help_subcommand() {
    let result = Command::new("disablehelp")
        .disable_help_subcommand(true)
        .subcommand(Command::new("sub1"))
        .try_get_matches_from(vec!["", "help"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::InvalidSubcommand);
}

#[test]
fn dont_collapse_args() {
    let cmd = Command::new("clap-test").version("v1.4.8").args([
        Arg::new("arg1").help("some"),
        Arg::new("arg2").help("some"),
        Arg::new("arg3").help("some"),
    ]);
    utils::assert_output(cmd, "clap-test --help", DONT_COLLAPSE_ARGS, false);
}

#[test]
fn require_eq() {
    static REQUIRE_EQUALS: &str = "\
Usage: clap-test --opt=<FILE>

Options:
  -o, --opt=<FILE>  some
  -h, --help        Print help
  -V, --version     Print version
";

    let cmd = Command::new("clap-test").version("v1.4.8").arg(
        Arg::new("opt")
            .long("opt")
            .short('o')
            .required(true)
            .require_equals(true)
            .value_name("FILE")
            .help("some"),
    );
    utils::assert_output(cmd, "clap-test --help", REQUIRE_EQUALS, false);
}

#[test]
fn propagate_vals_down() {
    let m = Command::new("myprog")
        .arg(arg!([cmd] "command to run").global(true))
        .subcommand(Command::new("foo"))
        .try_get_matches_from(vec!["myprog", "set", "foo"]);
    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();
    assert_eq!(m.get_one::<String>("cmd").map(|v| v.as_str()), Some("set"));
    let sub_m = m.subcommand_matches("foo").unwrap();
    assert_eq!(
        sub_m.get_one::<String>("cmd").map(|v| v.as_str()),
        Some("set")
    );
}

#[test]
fn allow_missing_positional() {
    let m = Command::new("test")
        .allow_missing_positional(true)
        .arg(arg!([src] "some file").default_value("src"))
        .arg(arg!(<dest> "some file"))
        .try_get_matches_from(vec!["test", "file"]);
    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();
    assert_eq!(m.get_one::<String>("src").map(|v| v.as_str()), Some("src"));
    assert_eq!(
        m.get_one::<String>("dest").map(|v| v.as_str()),
        Some("file")
    );
}

#[test]
fn allow_missing_positional_no_default() {
    let m = Command::new("test")
        .allow_missing_positional(true)
        .arg(arg!([src] "some file"))
        .arg(arg!(<dest> "some file"))
        .try_get_matches_from(vec!["test", "file"]);
    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();
    assert_eq!(m.get_one::<String>("src").map(|v| v.as_str()), None);
    assert_eq!(
        m.get_one::<String>("dest").map(|v| v.as_str()),
        Some("file")
    );
}

#[test]
fn missing_positional_no_hyphen() {
    let r = Command::new("bench")
        .allow_missing_positional(true)
        .arg(arg!([BENCH] "some bench"))
        .arg(arg!([ARGS] ... "some args"))
        .try_get_matches_from(vec!["bench", "foo", "arg1", "arg2", "arg3"]);
    assert!(r.is_ok(), "{:?}", r.unwrap_err().kind());

    let m = r.unwrap();

    let expected_bench = Some("foo");
    let expected_args = vec!["arg1", "arg2", "arg3"];

    assert_eq!(
        m.get_one::<String>("BENCH").map(|v| v.as_str()),
        expected_bench
    );
    assert_eq!(
        m.get_many::<String>("ARGS")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        &*expected_args
    );
}

#[test]
fn missing_positional_hyphen() {
    let r = Command::new("bench")
        .allow_missing_positional(true)
        .arg(arg!([BENCH] "some bench"))
        .arg(arg!([ARGS] ... "some args"))
        .try_get_matches_from(vec!["bench", "--", "arg1", "arg2", "arg3"]);
    assert!(r.is_ok(), "{:?}", r.unwrap_err().kind());

    let m = r.unwrap();

    let expected_bench = None;
    let expected_args = vec!["arg1", "arg2", "arg3"];

    assert_eq!(
        m.get_one::<String>("BENCH").map(|v| v.as_str()),
        expected_bench
    );
    assert_eq!(
        m.get_many::<String>("ARGS")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        &*expected_args
    );
}

#[test]
fn missing_positional_hyphen_far_back() {
    let r = Command::new("bench")
        .allow_missing_positional(true)
        .arg(arg!([BENCH1] "some bench"))
        .arg(arg!([BENCH2] "some bench"))
        .arg(arg!([BENCH3] "some bench"))
        .arg(arg!([ARGS] ... "some args"))
        .try_get_matches_from(vec!["bench", "foo", "--", "arg1", "arg2", "arg3"]);
    assert!(r.is_ok(), "{:?}", r.unwrap_err().kind());

    let m = r.unwrap();

    let expected_bench1 = Some("foo");
    let expected_bench2 = None;
    let expected_bench3 = None;
    let expected_args = vec!["arg1", "arg2", "arg3"];

    assert_eq!(
        m.get_one::<String>("BENCH1").map(|v| v.as_str()),
        expected_bench1
    );
    assert_eq!(
        m.get_one::<String>("BENCH2").map(|v| v.as_str()),
        expected_bench2
    );
    assert_eq!(
        m.get_one::<String>("BENCH3").map(|v| v.as_str()),
        expected_bench3
    );
    assert_eq!(
        m.get_many::<String>("ARGS")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        &*expected_args
    );
}

#[test]
fn missing_positional_hyphen_req_error() {
    let r = Command::new("bench")
        .allow_missing_positional(true)
        .arg(arg!([BENCH1] "some bench"))
        .arg(arg!(<BENCH2> "some bench"))
        .arg(arg!([ARGS] ... "some args"))
        .try_get_matches_from(vec!["bench", "foo", "--", "arg1", "arg2", "arg3"]);
    assert!(r.is_err());
    assert_eq!(r.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn issue_1066_allow_leading_hyphen_and_unknown_args_option() {
    let res = Command::new("prog")
        .arg(
            arg!(--"some-argument" <val>)
                .required(true)
                .allow_hyphen_values(true),
        )
        .try_get_matches_from(vec!["prog", "-fish"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[test]
fn issue_1437_allow_hyphen_values_for_positional_arg() {
    let m = Command::new("tmp")
        .arg(
            Arg::new("pat")
                .allow_hyphen_values(true)
                .required(true)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(["tmp", "-file"])
        .unwrap();
    assert_eq!(
        m.get_one::<String>("pat").map(|v| v.as_str()),
        Some("-file")
    );
}

#[test]
fn issue_3880_allow_long_flag_hyphen_value_for_positional_arg() {
    let m = Command::new("prog")
        .arg(
            Arg::new("pat")
                .allow_hyphen_values(true)
                .required(true)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(["", "--file"])
        .unwrap();

    assert_eq!(
        m.get_one::<String>("pat").map(|v| v.as_str()),
        Some("--file")
    );
}

#[test]
fn issue_1093_allow_ext_sc() {
    let cmd = Command::new("clap-test")
        .version("v1.4.8")
        .allow_external_subcommands(true);
    utils::assert_output(cmd, "clap-test --help", ALLOW_EXT_SC, false);
}

#[test]
fn allow_ext_sc_empty_args() {
    let res = Command::new("clap-test")
        .version("v1.4.8")
        .allow_external_subcommands(true)
        .try_get_matches_from(vec!["clap-test", "external-cmd"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());

    match res.unwrap().subcommand() {
        Some((name, args)) => {
            assert_eq!(name, "external-cmd");
            assert_eq!(
                args.get_many::<OsString>("").unwrap().collect::<Vec<_>>(),
                Vec::<&OsString>::new(),
            );
        }
        _ => unreachable!(),
    }
}

#[test]
fn allow_ext_sc_when_sc_required() {
    let res = Command::new("clap-test")
        .version("v1.4.8")
        .allow_external_subcommands(true)
        .subcommand_required(true)
        .try_get_matches_from(vec!["clap-test", "external-cmd", "foo"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());

    match res.unwrap().subcommand() {
        Some((name, args)) => {
            assert_eq!(name, "external-cmd");
            assert_eq!(
                args.get_many::<OsString>("")
                    .unwrap()
                    .cloned()
                    .collect::<Vec<_>>(),
                vec![OsString::from("foo")]
            );
        }
        _ => unreachable!(),
    }
}

#[test]
fn external_subcommand_looks_like_built_in() {
    let res = Command::new("cargo")
        .version("1.26.0")
        .allow_external_subcommands(true)
        .subcommand(Command::new("install"))
        .try_get_matches_from(vec!["cargo", "install-update", "foo"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    match m.subcommand() {
        Some((name, args)) => {
            assert_eq!(name, "install-update");
            assert_eq!(
                args.get_many::<OsString>("")
                    .unwrap()
                    .cloned()
                    .collect::<Vec<_>>(),
                vec![OsString::from("foo")]
            );
        }
        _ => panic!("external_subcommand didn't work"),
    }
}

#[test]
fn built_in_subcommand_escaped() {
    let res = Command::new("cargo")
        .version("1.26.0")
        .allow_external_subcommands(true)
        .subcommand(Command::new("install"))
        .try_get_matches_from(vec!["cargo", "--", "install", "foo"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    match m.subcommand() {
        Some((name, args)) => {
            assert_eq!(name, "install");
            assert_eq!(
                args.get_many::<OsString>("")
                    .unwrap()
                    .cloned()
                    .collect::<Vec<_>>(),
                vec![OsString::from("foo")]
            );
        }
        _ => panic!("external_subcommand didn't work"),
    }
}

#[test]
fn aaos_opts_w_other_overrides() {
    // opts with other overrides
    let res = Command::new("posix")
        .args_override_self(true)
        .arg(arg!(--opt <val> "some option").action(ArgAction::Set))
        .arg(
            arg!(--other <val> "some other option")
                .overrides_with("opt")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "--opt=some", "--other=test", "--opt=other"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(m.contains_id("opt"));
    assert!(!m.contains_id("other"));
    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("other")
    );
}

#[test]
fn aaos_opts_w_other_overrides_rev() {
    // opts with other overrides, rev
    let res = Command::new("posix")
        .args_override_self(true)
        .arg(
            arg!(--opt <val> "some option")
                .required(true)
                .action(ArgAction::Set),
        )
        .arg(
            arg!(--other <val> "some other option")
                .required(true)
                .overrides_with("opt")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "--opt=some", "--opt=other", "--other=val"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(!m.contains_id("opt"));
    assert!(m.contains_id("other"));
    assert_eq!(
        m.get_one::<String>("other").map(|v| v.as_str()),
        Some("val")
    );
}

#[test]
fn aaos_opts_w_other_overrides_2() {
    // opts with other overrides
    let res = Command::new("posix")
        .args_override_self(true)
        .arg(
            arg!(--opt <val> "some option")
                .overrides_with("other")
                .action(ArgAction::Set),
        )
        .arg(arg!(--other <val> "some other option").action(ArgAction::Set))
        .try_get_matches_from(vec!["", "--opt=some", "--other=test", "--opt=other"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(m.contains_id("opt"));
    assert!(!m.contains_id("other"));
    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("other")
    );
}

#[test]
fn aaos_opts_w_other_overrides_rev_2() {
    // opts with other overrides, rev
    let res = Command::new("posix")
        .args_override_self(true)
        .arg(
            arg!(--opt <val> "some option")
                .required(true)
                .overrides_with("other")
                .action(ArgAction::Set),
        )
        .arg(
            arg!(--other <val> "some other option")
                .required(true)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "--opt=some", "--opt=other", "--other=val"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(!m.contains_id("opt"));
    assert!(m.contains_id("other"));
    assert_eq!(
        m.get_one::<String>("other").map(|v| v.as_str()),
        Some("val")
    );
}

#[test]
fn aaos_opts_w_override_as_conflict_1() {
    // opts with other overrides, rev
    let res = Command::new("posix")
        .arg(
            arg!(--opt <val> "some option")
                .required(true)
                .overrides_with("other")
                .action(ArgAction::Set),
        )
        .arg(
            arg!(--other <val> "some other option")
                .required(true)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "--opt=some"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(m.contains_id("opt"));
    assert!(!m.contains_id("other"));
    assert_eq!(m.get_one::<String>("opt").map(|v| v.as_str()), Some("some"));
}

#[test]
fn aaos_opts_w_override_as_conflict_2() {
    // opts with other overrides, rev
    let res = Command::new("posix")
        .arg(
            arg!(--opt <val> "some option")
                .required(true)
                .overrides_with("other")
                .action(ArgAction::Set),
        )
        .arg(
            arg!(--other <val> "some other option")
                .required(true)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "--other=some"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(!m.contains_id("opt"));
    assert!(m.contains_id("other"));
    assert_eq!(
        m.get_one::<String>("other").map(|v| v.as_str()),
        Some("some")
    );
}

#[test]
fn aaos_opts_mult_req_delims() {
    // opts with multiple and require delims
    let res = Command::new("posix")
        .arg(
            arg!(--opt <val> ... "some option")
                .action(ArgAction::Set)
                .value_delimiter(',')
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec!["", "--opt=some", "--opt=other", "--opt=one,two"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(
        m.get_many::<String>("opt")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["some", "other", "one", "two"]
    );
}

#[test]
fn aaos_opts_mult() {
    // opts with multiple
    let res = Command::new("posix")
        .arg(
            arg!(--opt <val> ... "some option")
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec![
            "",
            "--opt",
            "first",
            "overrides",
            "--opt",
            "some",
            "other",
            "val",
        ]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(
        m.get_many::<String>("opt")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["first", "overrides", "some", "other", "val"]
    );
}

#[test]
fn aaos_pos_mult() {
    // opts with multiple
    let res = Command::new("posix")
        .arg(arg!([val] ... "some pos"))
        .try_get_matches_from(vec!["", "some", "other", "value"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(m.contains_id("val"));
    assert_eq!(
        m.get_many::<String>("val")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["some", "other", "value"]
    );
}

#[test]
fn aaos_option_use_delim_false() {
    let m = Command::new("posix")
        .args_override_self(true)
        .arg(
            arg!(--opt <val> "some option")
                .required(true)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "--opt=some,other", "--opt=one,two"])
        .unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(
        m.get_many::<String>("opt")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["one,two"]
    );
}

#[test]
#[cfg(feature = "color")]
fn color_is_global() {
    let mut cmd = Command::new("myprog")
        .color(clap::ColorChoice::Never)
        .subcommand(Command::new("foo"));
    cmd.build();
    assert_eq!(cmd.get_color(), clap::ColorChoice::Never);

    let sub = cmd.get_subcommands().collect::<Vec<_>>()[0];
    assert_eq!(sub.get_color(), clap::ColorChoice::Never);
}

```

`clap/tests/builder/arg_aliases.rs`:

```rs
use super::utils;

use clap::{arg, Arg, ArgAction, Command};

#[test]
fn single_alias_of_option() {
    let a = Command::new("single_alias")
        .arg(
            Arg::new("alias")
                .long("alias")
                .action(ArgAction::Set)
                .help("single alias")
                .alias("new-opt"),
        )
        .try_get_matches_from(vec!["", "--new-opt", "cool"]);
    assert!(a.is_ok(), "{}", a.unwrap_err());
    let a = a.unwrap();
    assert!(a.contains_id("alias"));
    assert_eq!(
        a.get_one::<String>("alias").map(|v| v.as_str()).unwrap(),
        "cool"
    );
}

#[test]
fn multiple_aliases_of_option() {
    let a = Command::new("multiple_aliases").arg(
        Arg::new("aliases")
            .long("aliases")
            .action(ArgAction::Set)
            .help("multiple aliases")
            .aliases(["alias1", "alias2", "alias3"]),
    );
    let long = a
        .clone()
        .try_get_matches_from(vec!["", "--aliases", "value"]);
    assert!(long.is_ok(), "{}", long.unwrap_err());
    let long = long.unwrap();

    let als1 = a
        .clone()
        .try_get_matches_from(vec!["", "--alias1", "value"]);
    assert!(als1.is_ok(), "{}", als1.unwrap_err());
    let als1 = als1.unwrap();

    let als2 = a
        .clone()
        .try_get_matches_from(vec!["", "--alias2", "value"]);
    assert!(als2.is_ok(), "{}", als2.unwrap_err());
    let als2 = als2.unwrap();

    let als3 = a
        .clone()
        .try_get_matches_from(vec!["", "--alias3", "value"]);
    assert!(als3.is_ok(), "{}", als3.unwrap_err());
    let als3 = als3.unwrap();

    assert!(long.contains_id("aliases"));
    assert!(als1.contains_id("aliases"));
    assert!(als2.contains_id("aliases"));
    assert!(als3.contains_id("aliases"));
    assert_eq!(
        long.get_one::<String>("aliases")
            .map(|v| v.as_str())
            .unwrap(),
        "value"
    );
    assert_eq!(
        als1.get_one::<String>("aliases")
            .map(|v| v.as_str())
            .unwrap(),
        "value"
    );
    assert_eq!(
        als2.get_one::<String>("aliases")
            .map(|v| v.as_str())
            .unwrap(),
        "value"
    );
    assert_eq!(
        als3.get_one::<String>("aliases")
            .map(|v| v.as_str())
            .unwrap(),
        "value"
    );
}

#[test]
fn get_aliases() {
    let a = Arg::new("aliases")
        .long("aliases")
        .action(ArgAction::Set)
        .help("multiple aliases")
        .aliases(["alias1", "alias2", "alias3"])
        .short_aliases(['a', 'b', 'c'])
        .visible_aliases(["alias4", "alias5", "alias6"])
        .visible_short_aliases(['d', 'e', 'f']);

    assert!(a.get_short_and_visible_aliases().is_none());
    assert_eq!(
        a.get_long_and_visible_aliases().unwrap(),
        ["aliases", "alias4", "alias5", "alias6"]
    );
    assert_eq!(
        a.get_visible_aliases().unwrap(),
        ["alias4", "alias5", "alias6"]
    );
    assert_eq!(
        a.get_all_aliases().unwrap(),
        ["alias1", "alias2", "alias3", "alias4", "alias5", "alias6"]
    );
    assert_eq!(a.get_visible_short_aliases().unwrap(), vec!['d', 'e', 'f']);
    assert_eq!(
        a.get_all_short_aliases().unwrap(),
        vec!['a', 'b', 'c', 'd', 'e', 'f']
    );
}

#[test]
fn single_alias_of_flag() {
    let a = Command::new("test")
        .arg(
            Arg::new("flag")
                .long("flag")
                .alias("alias")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["", "--alias"]);
    assert!(a.is_ok(), "{}", a.unwrap_err());
    let a = a.unwrap();
    assert!(*a.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn multiple_aliases_of_flag() {
    let a = Command::new("test").arg(
        Arg::new("flag")
            .long("flag")
            .aliases(["invisible", "set", "of", "cool", "aliases"])
            .action(ArgAction::SetTrue),
    );

    let flag = a.clone().try_get_matches_from(vec!["", "--flag"]);
    assert!(flag.is_ok(), "{}", flag.unwrap_err());
    let flag = flag.unwrap();

    let inv = a.clone().try_get_matches_from(vec!["", "--invisible"]);
    assert!(inv.is_ok(), "{}", inv.unwrap_err());
    let inv = inv.unwrap();

    let cool = a.clone().try_get_matches_from(vec!["", "--cool"]);
    assert!(cool.is_ok(), "{}", cool.unwrap_err());
    let cool = cool.unwrap();

    let als = a.clone().try_get_matches_from(vec!["", "--aliases"]);
    assert!(als.is_ok(), "{}", als.unwrap_err());
    let als = als.unwrap();

    assert!(*flag.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*inv.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*cool.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*als.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn alias_on_a_subcommand_option() {
    let m = Command::new("test")
        .subcommand(
            Command::new("some").arg(
                Arg::new("test")
                    .short('t')
                    .long("test")
                    .action(ArgAction::Set)
                    .alias("opt")
                    .help("testing testing"),
            ),
        )
        .arg(Arg::new("other").long("other").aliases(["o1", "o2", "o3"]))
        .try_get_matches_from(vec!["test", "some", "--opt", "awesome"])
        .unwrap();

    assert!(m.subcommand_matches("some").is_some());
    let sub_m = m.subcommand_matches("some").unwrap();
    assert!(sub_m.contains_id("test"));
    assert_eq!(
        sub_m.get_one::<String>("test").map(|v| v.as_str()).unwrap(),
        "awesome"
    );
}

#[test]
fn invisible_arg_aliases_help_output() {
    static SC_INVISIBLE_ALIAS_HELP: &str = "\
Some help

Usage: ct test [OPTIONS]

Options:
  -o, --opt <opt>  
  -f, --flag       
  -h, --help       Print help
  -V, --version    Print version
";

    let cmd = Command::new("ct").author("Salim Afiune").subcommand(
        Command::new("test")
            .about("Some help")
            .version("1.2")
            .arg(
                Arg::new("opt")
                    .long("opt")
                    .short('o')
                    .action(ArgAction::Set)
                    .aliases(["invisible", "als1", "more"]),
            )
            .arg(arg!(-f - -flag).aliases(["unseeable", "flg1", "anyway"])),
    );
    utils::assert_output(cmd, "ct test --help", SC_INVISIBLE_ALIAS_HELP, false);
}

#[test]
fn visible_arg_aliases_help_output() {
    static SC_VISIBLE_ALIAS_HELP: &str = "\
Some help

Usage: ct test [OPTIONS]

Options:
  -o, --opt <opt>  [aliases: visible]
  -f, --flag       [aliases: v_flg, flag2, flg3]
  -h, --help       Print help
  -V, --version    Print version
";

    let cmd = Command::new("ct").author("Salim Afiune").subcommand(
        Command::new("test")
            .about("Some help")
            .version("1.2")
            .arg(
                Arg::new("opt")
                    .long("opt")
                    .short('o')
                    .action(ArgAction::Set)
                    .alias("invisible")
                    .visible_alias("visible"),
            )
            .arg(
                Arg::new("flg")
                    .long("flag")
                    .short('f')
                    .action(ArgAction::SetTrue)
                    .visible_aliases(["v_flg", "flag2", "flg3"]),
            ),
    );
    utils::assert_output(cmd, "ct test --help", SC_VISIBLE_ALIAS_HELP, false);
}

```

`clap/tests/builder/arg_aliases_short.rs`:

```rs
use super::utils;

use clap::{arg, Arg, ArgAction, Command};

#[test]
fn single_short_alias_of_option() {
    let a = Command::new("single_alias")
        .arg(
            Arg::new("alias")
                .long("alias")
                .action(ArgAction::Set)
                .help("single short alias")
                .short_alias('a'),
        )
        .try_get_matches_from(vec!["", "-a", "cool"]);
    assert!(a.is_ok(), "{}", a.unwrap_err());
    let a = a.unwrap();
    assert!(a.contains_id("alias"));
    assert_eq!(
        a.get_one::<String>("alias").map(|v| v.as_str()).unwrap(),
        "cool"
    );
}

#[test]
fn multiple_short_aliases_of_option() {
    let a = Command::new("multiple_aliases").arg(
        Arg::new("aliases")
            .long("aliases")
            .action(ArgAction::Set)
            .help("multiple aliases")
            .short_aliases(['1', '2', '3']),
    );
    let long = a
        .clone()
        .try_get_matches_from(vec!["", "--aliases", "value"]);
    assert!(long.is_ok(), "{}", long.unwrap_err());
    let long = long.unwrap();

    let als1 = a.clone().try_get_matches_from(vec!["", "-1", "value"]);
    assert!(als1.is_ok(), "{}", als1.unwrap_err());
    let als1 = als1.unwrap();

    let als2 = a.clone().try_get_matches_from(vec!["", "-2", "value"]);
    assert!(als2.is_ok(), "{}", als2.unwrap_err());
    let als2 = als2.unwrap();

    let als3 = a.clone().try_get_matches_from(vec!["", "-3", "value"]);
    assert!(als3.is_ok(), "{}", als3.unwrap_err());
    let als3 = als3.unwrap();

    assert!(long.contains_id("aliases"));
    assert!(als1.contains_id("aliases"));
    assert!(als2.contains_id("aliases"));
    assert!(als3.contains_id("aliases"));
    assert_eq!(
        long.get_one::<String>("aliases")
            .map(|v| v.as_str())
            .unwrap(),
        "value"
    );
    assert_eq!(
        als1.get_one::<String>("aliases")
            .map(|v| v.as_str())
            .unwrap(),
        "value"
    );
    assert_eq!(
        als2.get_one::<String>("aliases")
            .map(|v| v.as_str())
            .unwrap(),
        "value"
    );
    assert_eq!(
        als3.get_one::<String>("aliases")
            .map(|v| v.as_str())
            .unwrap(),
        "value"
    );
}

#[test]
fn single_short_alias_of_flag() {
    let a = Command::new("test")
        .arg(
            Arg::new("flag")
                .long("flag")
                .short_alias('f')
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["", "-f"]);
    assert!(a.is_ok(), "{}", a.unwrap_err());
    let a = a.unwrap();
    assert!(*a.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn multiple_short_aliases_of_flag() {
    let a = Command::new("test").arg(
        Arg::new("flag")
            .long("flag")
            .short_aliases(['a', 'b', 'c', 'd', 'e'])
            .action(ArgAction::SetTrue),
    );

    let flag = a.clone().try_get_matches_from(vec!["", "--flag"]);
    assert!(flag.is_ok(), "{}", flag.unwrap_err());
    let flag = flag.unwrap();

    let als1 = a.clone().try_get_matches_from(vec!["", "-a"]);
    assert!(als1.is_ok(), "{}", als1.unwrap_err());
    let als1 = als1.unwrap();

    let als2 = a.clone().try_get_matches_from(vec!["", "-b"]);
    assert!(als2.is_ok(), "{}", als2.unwrap_err());
    let als2 = als2.unwrap();

    let als3 = a.clone().try_get_matches_from(vec!["", "-c"]);
    assert!(als3.is_ok(), "{}", als3.unwrap_err());
    let als3 = als3.unwrap();

    assert!(*flag.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*als1.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*als2.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*als3.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn short_alias_on_a_subcommand_option() {
    let m = Command::new("test")
        .subcommand(
            Command::new("some").arg(
                Arg::new("test")
                    .short('t')
                    .long("test")
                    .action(ArgAction::Set)
                    .short_alias('o')
                    .help("testing testing"),
            ),
        )
        .arg(
            Arg::new("other")
                .long("other")
                .short_aliases(['1', '2', '3']),
        )
        .try_get_matches_from(vec!["test", "some", "-o", "awesome"])
        .unwrap();

    assert!(m.subcommand_matches("some").is_some());
    let sub_m = m.subcommand_matches("some").unwrap();
    assert!(sub_m.contains_id("test"));
    assert_eq!(
        sub_m.get_one::<String>("test").map(|v| v.as_str()).unwrap(),
        "awesome"
    );
}

#[test]
fn invisible_short_arg_aliases_help_output() {
    static SC_INVISIBLE_ALIAS_HELP: &str = "\
Some help

Usage: ct test [OPTIONS]

Options:
  -o, --opt <opt>  
  -f, --flag       
  -h, --help       Print help
  -V, --version    Print version
";

    let cmd = Command::new("ct").author("Salim Afiune").subcommand(
        Command::new("test")
            .about("Some help")
            .version("1.2")
            .arg(
                Arg::new("opt")
                    .long("opt")
                    .short('o')
                    .action(ArgAction::Set)
                    .short_aliases(['a', 'b', 'c']),
            )
            .arg(arg!(-f - -flag).short_aliases(['x', 'y', 'z'])),
    );
    utils::assert_output(cmd, "ct test --help", SC_INVISIBLE_ALIAS_HELP, false);
}

#[test]
fn visible_short_arg_aliases_help_output() {
    static SC_VISIBLE_ALIAS_HELP: &str = "\
Some help

Usage: ct test [OPTIONS]

Options:
  -o, --opt <opt>  [short aliases: v]
  -f, --flag       [aliases: flag1] [short aliases: a, b, 🦆]
  -h, --help       Print help
  -V, --version    Print version
";

    let cmd = Command::new("ct").author("Salim Afiune").subcommand(
        Command::new("test")
            .about("Some help")
            .version("1.2")
            .arg(
                Arg::new("opt")
                    .long("opt")
                    .short('o')
                    .action(ArgAction::Set)
                    .short_alias('i')
                    .visible_short_alias('v'),
            )
            .arg(
                Arg::new("flg")
                    .long("flag")
                    .short('f')
                    .action(ArgAction::SetTrue)
                    .visible_alias("flag1")
                    .visible_short_aliases(['a', 'b', '🦆']),
            ),
    );
    utils::assert_output(cmd, "ct test --help", SC_VISIBLE_ALIAS_HELP, false);
}

```

`clap/tests/builder/arg_matches.rs`:

```rs
use clap::{arg, value_parser, Command};
use clap::{Arg, ArgAction};

#[test]
fn ids() {
    let m = Command::new("test")
        .arg(arg!(--color <when>).value_parser(["auto", "always", "never"]))
        .arg(arg!(--config <path>).value_parser(value_parser!(std::path::PathBuf)))
        .try_get_matches_from(["test", "--config=config.toml", "--color=auto"])
        .unwrap();
    assert_eq!(
        m.ids().map(|id| id.as_str()).collect::<Vec<_>>(),
        ["config", "color"]
    );
    assert_eq!(m.ids().len(), 2);
}

#[test]
fn ids_ignore_unused() {
    let m = Command::new("test")
        .arg(arg!(--color <when>).value_parser(["auto", "always", "never"]))
        .arg(arg!(--config <path>).value_parser(value_parser!(std::path::PathBuf)))
        .try_get_matches_from(["test", "--config=config.toml"])
        .unwrap();
    assert_eq!(
        m.ids().map(|id| id.as_str()).collect::<Vec<_>>(),
        ["config"]
    );
    assert_eq!(m.ids().len(), 1);
}

#[test]
fn ids_ignore_overridden() {
    let m = Command::new("test")
        .arg(arg!(--color <when>).value_parser(["auto", "always", "never"]))
        .arg(
            arg!(--config <path>)
                .value_parser(value_parser!(std::path::PathBuf))
                .overrides_with("color"),
        )
        .try_get_matches_from(["test", "--config=config.toml", "--color=auto"])
        .unwrap();
    assert_eq!(m.ids().map(|id| id.as_str()).collect::<Vec<_>>(), ["color"]);
    assert_eq!(m.ids().len(), 1);
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "Unknown argument or group id.  Make sure you are using the argument id and not the short or long flags"]
fn arg_matches_if_present_wrong_arg() {
    let m = Command::new("test")
        .arg(Arg::new("flag").short('f').action(ArgAction::SetTrue))
        .try_get_matches_from(["test", "-f"])
        .unwrap();

    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    m.contains_id("f");
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "Mismatch between definition and access of `o`. Unknown argument or group id.  Make sure you are using the argument id and not the short or long flags"]
fn arg_matches_value_of_wrong_arg() {
    let m = Command::new("test")
        .arg(Arg::new("opt").short('o').action(ArgAction::Set))
        .try_get_matches_from(["test", "-o", "val"])
        .unwrap();

    assert_eq!(m.get_one::<String>("opt").map(|v| v.as_str()), Some("val"));
    m.get_one::<String>("o").map(|v| v.as_str());
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "`seed` is not a name of a subcommand."]
fn arg_matches_subcommand_matches_wrong_sub() {
    let m = Command::new("test")
        .subcommand(Command::new("speed"))
        .try_get_matches_from(["test", "speed"])
        .unwrap();

    assert!(m.subcommand_matches("speed").is_some());
    m.subcommand_matches("seed");
}

#[test]
fn args_present_positional() {
    let c = Command::new("test").arg(Arg::new("positional"));

    let m = c.clone().try_get_matches_from(["test"]).unwrap();
    assert!(!m.args_present());

    let m = c.clone().try_get_matches_from(["test", "value"]).unwrap();
    assert!(m.args_present());
}

#[test]
fn args_present_flag() {
    let c = Command::new("test").arg(Arg::new("flag").long("flag").action(ArgAction::SetTrue));

    let m = c.clone().try_get_matches_from(["test"]).unwrap();
    assert!(!m.args_present());

    let m = c.clone().try_get_matches_from(["test", "--flag"]).unwrap();
    assert!(m.args_present());
}

#[test]
fn args_present_subcommand() {
    let c = Command::new("test").subcommand(Command::new("sub"));

    let m = c.clone().try_get_matches_from(["test"]).unwrap();
    assert!(!m.args_present());

    let m = c.clone().try_get_matches_from(["test", "sub"]).unwrap();
    assert!(!m.args_present());
}

```

`clap/tests/builder/borrowed.rs`:

```rs
use clap::{Arg, Command};

#[test]
fn borrowed_args() {
    let arg = Arg::new("some").short('s').long("some").help("other help");
    let arg2 = Arg::new("some2")
        .short('S')
        .long("some-thing")
        .help("other help");
    let result = Command::new("sub_command_negate")
        .arg(Arg::new("test").index(1))
        .arg(&arg)
        .arg(&arg2)
        .subcommand(Command::new("sub1").arg(&arg))
        .try_get_matches_from(vec!["prog"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
}

```

`clap/tests/builder/cargo.rs`:

```rs
#![cfg(feature = "cargo")]

use clap::{
    crate_authors, crate_description, crate_name, crate_version, error::ErrorKind, Command,
};
use snapbox::str;

use crate::utils;

#[test]
fn crate_version() {
    let res = Command::new("prog")
        .version(crate_version!())
        .help_template(utils::FULL_TEMPLATE)
        .try_get_matches_from(vec!["prog", "--version"]);

    assert!(res.is_err());
    let err = res.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::DisplayVersion);
    assert_eq!(
        err.to_string(),
        format!("prog {}\n", env!("CARGO_PKG_VERSION"))
    );
}

#[test]
fn crate_description() {
    let res = Command::new("prog")
        .version("1")
        .about(crate_description!())
        .help_template(utils::FULL_TEMPLATE)
        .try_get_matches_from(vec!["prog", "--help"]);

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(err, ErrorKind::DisplayHelp, str![[r#"
prog 1
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: prog

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]], false);
}

#[test]
fn crate_authors() {
    let res = Command::new("prog")
        .version("1")
        .author(crate_authors!())
        .help_template(utils::FULL_TEMPLATE)
        .try_get_matches_from(vec!["prog", "--help"]);

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(err, ErrorKind::DisplayHelp, str![[r#"
prog 1


Usage: prog

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]], false);
}

#[test]
fn crate_authors_with_sep() {
    let res = Command::new("prog")
        .version("1")
        .author(crate_authors!(", "))
        .help_template(utils::FULL_TEMPLATE)
        .try_get_matches_from(vec!["prog", "--help"]);

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(err, ErrorKind::DisplayHelp, str![[r#"
prog 1


Usage: prog

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]], false);
}

#[test]
fn crate_name() {
    let res = Command::new(crate_name!())
        .help_template(utils::FULL_TEMPLATE)
        .version("3.0")
        .try_get_matches_from(vec!["clap", "--version"]);

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(err, ErrorKind::DisplayVersion, str![[r#"
clap 3.0

"#]], false);
}

```

`clap/tests/builder/command.rs`:

```rs
#![cfg(feature = "cargo")]

use clap::{command, error::ErrorKind};

use crate::utils;

static EVERYTHING: &str = "clap {{version}}
A simple to use, efficient, and full-featured Command Line Argument Parser

Usage: clap

Options:
  -h, --help     Print help
  -V, --version  Print version
";

#[test]
fn command() {
    let res = command!()
        .help_template(utils::FULL_TEMPLATE)
        .try_get_matches_from(vec!["clap", "--help"]);

    assert!(res.is_err());
    let err = res.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::DisplayHelp);
    assert_eq!(
        err.to_string(),
        EVERYTHING.replace("{{version}}", env!("CARGO_PKG_VERSION"))
    );
}

```

`clap/tests/builder/conflicts.rs`:

```rs
use clap::{arg, error::ErrorKind, Arg, ArgAction, ArgGroup, Command};

#[cfg(feature = "error-context")]
use super::utils;

#[test]
fn flag_conflict() {
    let result = Command::new("flag_conflict")
        .arg(arg!(-f --flag "some flag").conflicts_with("other"))
        .arg(arg!(-o --other "some flag"))
        .try_get_matches_from(vec!["myprog", "-f", "-o"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
}

#[test]
fn flag_conflict_2() {
    let result = Command::new("flag_conflict")
        .arg(arg!(-f --flag "some flag").conflicts_with("other"))
        .arg(arg!(-o --other "some flag"))
        .try_get_matches_from(vec!["myprog", "-o", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
}

#[test]
fn flag_conflict_with_all() {
    let result = Command::new("flag_conflict")
        .arg(arg!(-f --flag "some flag").conflicts_with_all(["other"]))
        .arg(arg!(-o --other "some flag"))
        .try_get_matches_from(vec!["myprog", "-o", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
}

#[test]
fn exclusive_flag() {
    let cmd = Command::new("flag_conflict")
        .arg(arg!(-f --flag "some flag").exclusive(true))
        .arg(arg!(-o --other "some flag"));
    let result = cmd.clone().try_get_matches_from(vec!["myprog", "-f"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());

    let result = cmd.clone().try_get_matches_from(vec!["myprog", "-o", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
}

#[test]
fn exclusive_option() {
    let result = Command::new("flag_conflict")
        .arg(arg!(-f --flag <VALUE> "some flag").exclusive(true))
        .arg(arg!(-o --other <VALUE> "some flag"))
        .try_get_matches_from(vec!["myprog", "-o=val1", "-f=val2"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
}

#[test]
fn not_exclusive_with_defaults() {
    let result = Command::new("flag_conflict")
        .arg(arg!(-f --flag <VALUE> "some flag").exclusive(true))
        .arg(
            arg!(-o --other <VALUE> "some flag")
                .required(false)
                .default_value("val1"),
        )
        .try_get_matches_from(vec!["myprog", "-f=val2"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
}

#[test]
fn not_exclusive_with_group() {
    let cmd = Command::new("test")
        .group(ArgGroup::new("test").arg("foo"))
        .arg(
            Arg::new("foo")
                .long("foo")
                .exclusive(true)
                .action(ArgAction::SetTrue),
        );
    let result = cmd.try_get_matches_from(vec!["test", "--foo"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
}

#[test]
fn default_doesnt_activate_exclusive() {
    let result = Command::new("flag_conflict")
        .arg(
            arg!(-f --flag <VALUE> "some flag")
                .exclusive(true)
                .default_value("val2"),
        )
        .arg(arg!(-o --other <VALUE> "some flag").default_value("val1"))
        .try_get_matches_from(vec!["myprog"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
}

#[test]
fn arg_conflicts_with_group() {
    let mut cmd = Command::new("group_conflict")
        .arg(arg!(-f --flag "some flag").conflicts_with("gr"))
        .group(ArgGroup::new("gr").arg("some").arg("other"))
        .arg(arg!(--some "some arg"))
        .arg(arg!(--other "other arg"));

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--other", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "-f", "--some"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--some"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--other"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--flag"]);
    if let Err(err) = result {
        panic!("{err}");
    }
}

#[test]
fn arg_conflicts_with_group_with_multiple_sources() {
    let mut cmd = Command::new("group_conflict")
        .arg(clap::arg!(-f --flag "some flag").conflicts_with("gr"))
        .group(ArgGroup::new("gr").multiple(true))
        .arg(clap::arg!(--some <name> "some arg").group("gr"))
        .arg(
            clap::arg!(--other <secs> "other arg")
                .default_value("1000")
                .group("gr"),
        );

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "-f"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--some", "usb1"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--some", "usb1", "--other", "40"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "-f", "--some", "usb1"]);
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
}

#[test]
fn group_conflicts_with_arg() {
    let mut cmd = Command::new("group_conflict")
        .arg(arg!(-f --flag "some flag"))
        .group(
            ArgGroup::new("gr")
                .arg("some")
                .arg("other")
                .conflicts_with("flag"),
        )
        .arg(arg!(--some "some arg"))
        .arg(arg!(--other "other arg"));

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--other", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "-f", "--some"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--some"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--other"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--flag"]);
    if let Err(err) = result {
        panic!("{err}");
    }
}

#[test]
fn arg_conflicts_with_required_group() {
    let mut cmd = Command::new("group_conflict")
        .arg(arg!(-f --flag "some flag").conflicts_with("gr"))
        .group(ArgGroup::new("gr").required(true).arg("some").arg("other"))
        .arg(arg!(--some "some arg"))
        .arg(arg!(--other "other arg"));

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--other", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "-f", "--some"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--some"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--other"]);
    if let Err(err) = result {
        panic!("{err}");
    }
}

#[test]
fn arg_conflicts_with_group_with_required_memeber() {
    let mut cmd = Command::new("group_conflict")
        .arg(arg!(-f --flag "some flag").conflicts_with("gr"))
        .group(ArgGroup::new("gr").arg("some").arg("other"))
        .arg(arg!(--some "some arg").required(true))
        .arg(arg!(--other "other arg"));

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--other", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "-f", "--some"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--some"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--flag"]);
    if let Err(err) = result {
        panic!("{err}");
    }
}

#[test]
fn required_group_conflicts_with_arg() {
    let mut cmd = Command::new("group_conflict")
        .arg(arg!(-f --flag "some flag"))
        .group(
            ArgGroup::new("gr")
                .required(true)
                .arg("some")
                .arg("other")
                .conflicts_with("flag"),
        )
        .arg(arg!(--some "some arg"))
        .arg(arg!(--other "other arg"));

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--other", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "-f", "--some"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--some"]);
    if let Err(err) = result {
        panic!("{err}");
    }

    let result = cmd.try_get_matches_from_mut(vec!["myprog", "--other"]);
    if let Err(err) = result {
        panic!("{err}");
    }
}

#[test]
fn get_arg_conflicts_with_group() {
    let flag = arg!(--flag).conflicts_with("gr");
    let mut cmd = Command::new("group_conflict")
        .arg(&flag)
        .group(ArgGroup::new("gr").arg("some").arg("other"))
        .arg(arg!(--some))
        .arg(arg!(--other));

    cmd.build();

    let result = cmd.get_arg_conflicts_with(&flag);

    assert_eq!(result.len(), 2);
    assert_eq!(result[0].get_id(), "some");
    assert_eq!(result[1].get_id(), "other");
}

#[test]
#[cfg(feature = "error-context")]
fn conflict_output() {
    static CONFLICT_ERR: &str = "\
error: the argument '--flag...' cannot be used with '-F'

Usage: clap-test --flag... --long-option-2 <option2> <positional> <positional2> [positional3]...

For more information, try '--help'.
";

    utils::assert_output(
        utils::complex_app(),
        "clap-test val1 fa --flag --long-option-2 val2 -F",
        CONFLICT_ERR,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn conflict_output_rev() {
    static CONFLICT_ERR_REV: &str = "\
error: the argument '-F' cannot be used with '--flag...'

Usage: clap-test -F --long-option-2 <option2> <positional> <positional2> [positional3]...

For more information, try '--help'.
";

    utils::assert_output(
        utils::complex_app(),
        "clap-test val1 fa -F --long-option-2 val2 --flag",
        CONFLICT_ERR_REV,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn conflict_output_repeat() {
    static ERR: &str = "\
error: the argument '-F' cannot be used multiple times

Usage: clap-test [OPTIONS] [positional] [positional2] [positional3]... [COMMAND]

For more information, try '--help'.
";

    utils::assert_output(utils::complex_app(), "clap-test -F -F", ERR, true);
}

#[test]
#[cfg(feature = "error-context")]
fn conflict_output_with_required() {
    static CONFLICT_ERR: &str = "\
error: the argument '--flag...' cannot be used with '-F'

Usage: clap-test --flag... --long-option-2 <option2> <positional> <positional2> [positional3]...

For more information, try '--help'.
";

    utils::assert_output(
        utils::complex_app(),
        "clap-test val1 --flag --long-option-2 val2 -F",
        CONFLICT_ERR,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn conflict_output_rev_with_required() {
    static CONFLICT_ERR_REV: &str = "\
error: the argument '-F' cannot be used with '--flag...'

Usage: clap-test -F --long-option-2 <option2> <positional> <positional2> [positional3]...

For more information, try '--help'.
";

    utils::assert_output(
        utils::complex_app(),
        "clap-test val1 -F --long-option-2 val2 --flag",
        CONFLICT_ERR_REV,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn conflict_output_three_conflicting() {
    static CONFLICT_ERR_THREE: &str = "\
error: the argument '--one' cannot be used with:
  --two
  --three

Usage: three_conflicting_arguments --one

For more information, try '--help'.
";

    let cmd = Command::new("three_conflicting_arguments")
        .arg(
            Arg::new("one")
                .long("one")
                .action(ArgAction::SetTrue)
                .conflicts_with_all(["two", "three"]),
        )
        .arg(
            Arg::new("two")
                .long("two")
                .action(ArgAction::SetTrue)
                .conflicts_with_all(["one", "three"]),
        )
        .arg(
            Arg::new("three")
                .long("three")
                .action(ArgAction::SetTrue)
                .conflicts_with_all(["one", "two"]),
        );
    utils::assert_output(
        cmd,
        "three_conflicting_arguments --one --two --three",
        CONFLICT_ERR_THREE,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn two_conflicting_arguments() {
    let a = Command::new("two_conflicting_arguments")
        .arg(
            Arg::new("develop")
                .long("develop")
                .action(ArgAction::SetTrue)
                .conflicts_with("production"),
        )
        .arg(
            Arg::new("production")
                .long("production")
                .action(ArgAction::SetTrue)
                .conflicts_with("develop"),
        )
        .try_get_matches_from(vec!["", "--develop", "--production"]);

    assert!(a.is_err());
    let a = a.unwrap_err();
    assert!(
        a.to_string()
            .contains("the argument \'--develop\' cannot be used with \'--production\'"),
        "{}",
        a
    );
}

#[test]
#[cfg(feature = "error-context")]
fn three_conflicting_arguments() {
    let a = Command::new("three_conflicting_arguments")
        .arg(
            Arg::new("one")
                .long("one")
                .action(ArgAction::SetTrue)
                .conflicts_with_all(["two", "three"]),
        )
        .arg(
            Arg::new("two")
                .long("two")
                .action(ArgAction::SetTrue)
                .conflicts_with_all(["one", "three"]),
        )
        .arg(
            Arg::new("three")
                .long("three")
                .action(ArgAction::SetTrue)
                .conflicts_with_all(["one", "two"]),
        )
        .try_get_matches_from(vec!["", "--one", "--two", "--three"]);

    assert!(a.is_err());
    let a = a.unwrap_err();
    assert!(
        a.to_string()
            .contains("the argument \'--one\' cannot be used with:"),
        "{}",
        a
    );
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Argument 'config' cannot conflict with itself"]
fn self_conflicting_arg() {
    let _ = Command::new("prog")
        .arg(Arg::new("config").long("config").conflicts_with("config"))
        .try_get_matches_from(vec!["", "--config"]);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Argument or group 'extra' specified in 'conflicts_with*' for 'config' does not exist"]
fn conflicts_with_invalid_arg() {
    let _ = Command::new("prog")
        .arg(Arg::new("config").long("config").conflicts_with("extra"))
        .try_get_matches_from(vec!["", "--config"]);
}

#[test]
fn conflict_with_unused_default() {
    let result = Command::new("conflict")
        .arg(arg!(-o --opt <opt> "some opt").default_value("default"))
        .arg(
            arg!(-f --flag "some flag")
                .conflicts_with("opt")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["myprog", "-f"]);

    assert!(result.is_ok(), "{}", result.unwrap_err());
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn conflicts_with_alongside_default() {
    let result = Command::new("conflict")
        .arg(
            arg!(-o --opt <opt> "some opt")
                .default_value("default")
                .conflicts_with("flag"),
        )
        .arg(arg!(-f --flag "some flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["myprog", "-f"]);

    assert!(
        result.is_ok(),
        "conflicts_with should ignore default_value: {:?}",
        result.unwrap_err()
    );
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn group_in_conflicts_with() {
    let result = Command::new("conflict")
        .arg(
            Arg::new("opt")
                .long("opt")
                .default_value("default")
                .group("one"),
        )
        .arg(
            Arg::new("flag")
                .long("flag")
                .conflicts_with("one")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["myprog", "--flag"]);

    assert!(
        result.is_ok(),
        "conflicts_with on an arg group should ignore default_value: {:?}",
        result.unwrap_err()
    );
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn group_conflicts_with_default_value() {
    let result = Command::new("conflict")
        .arg(
            Arg::new("opt")
                .long("opt")
                .default_value("default")
                .group("one"),
        )
        .arg(
            Arg::new("flag")
                .long("flag")
                .group("one")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["myprog", "--flag"]);

    assert!(
        result.is_ok(),
        "arg group count should ignore default_value: {:?}",
        result.unwrap_err()
    );
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn group_conflicts_with_default_arg() {
    let result = Command::new("conflict")
        .arg(Arg::new("opt").long("opt").default_value("default"))
        .arg(
            Arg::new("flag")
                .long("flag")
                .group("one")
                .action(ArgAction::SetTrue),
        )
        .group(ArgGroup::new("one").conflicts_with("opt"))
        .try_get_matches_from(vec!["myprog", "--flag"]);

    assert!(
        result.is_ok(),
        "arg group conflicts_with should ignore default_value: {:?}",
        result.unwrap_err()
    );
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn exclusive_with_required() {
    let cmd = Command::new("bug")
        .arg(
            Arg::new("test")
                .long("test")
                .action(ArgAction::SetTrue)
                .exclusive(true),
        )
        .arg(Arg::new("input").action(ArgAction::Set).required(true));

    cmd.clone()
        .try_get_matches_from(["bug", "--test", "required"])
        .unwrap_err();

    cmd.clone()
        .try_get_matches_from(["bug", "required"])
        .unwrap();

    cmd.clone().try_get_matches_from(["bug", "--test"]).unwrap();
}

#[test]
fn exclusive_with_required_unless_present() {
    let cmd = Command::new("bug")
        .arg(
            Arg::new("exclusive")
                .long("exclusive")
                .action(ArgAction::SetTrue)
                .exclusive(true),
        )
        .arg(
            Arg::new("required")
                .long("required")
                .action(ArgAction::SetTrue)
                .required_unless_present("alternative"),
        )
        .arg(
            Arg::new("alternative")
                .long("alternative")
                .action(ArgAction::SetTrue),
        );

    cmd.clone()
        .try_get_matches_from(["bug", "--required"])
        .unwrap();

    cmd.clone()
        .try_get_matches_from(["bug", "--alternative"])
        .unwrap();

    cmd.clone().try_get_matches_from(["bug"]).unwrap_err();

    cmd.clone()
        .try_get_matches_from(["bug", "--exclusive", "--required"])
        .unwrap_err();

    cmd.clone()
        .try_get_matches_from(["bug", "--exclusive"])
        .unwrap();
}

#[test]
fn exclusive_with_required_unless_present_any() {
    let cmd = Command::new("bug")
        .arg(
            Arg::new("exclusive")
                .long("exclusive")
                .action(ArgAction::SetTrue)
                .exclusive(true),
        )
        .arg(
            Arg::new("required")
                .long("required")
                .action(ArgAction::SetTrue)
                .required_unless_present_any(["alternative"]),
        )
        .arg(
            Arg::new("alternative")
                .long("alternative")
                .action(ArgAction::SetTrue),
        );

    cmd.clone()
        .try_get_matches_from(["bug", "--required"])
        .unwrap();

    cmd.clone()
        .try_get_matches_from(["bug", "--alternative"])
        .unwrap();

    cmd.clone().try_get_matches_from(["bug"]).unwrap_err();

    cmd.clone()
        .try_get_matches_from(["bug", "--exclusive", "--required"])
        .unwrap_err();

    cmd.clone()
        .try_get_matches_from(["bug", "--exclusive"])
        .unwrap();
}

#[test]
fn exclusive_with_required_unless_present_all() {
    let cmd = Command::new("bug")
        .arg(
            Arg::new("exclusive")
                .long("exclusive")
                .action(ArgAction::SetTrue)
                .exclusive(true),
        )
        .arg(
            Arg::new("required")
                .long("required")
                .action(ArgAction::SetTrue)
                .required_unless_present_all(["alternative"]),
        )
        .arg(
            Arg::new("alternative")
                .long("alternative")
                .action(ArgAction::SetTrue),
        );

    cmd.clone()
        .try_get_matches_from(["bug", "--required"])
        .unwrap();

    cmd.clone()
        .try_get_matches_from(["bug", "--alternative"])
        .unwrap();

    cmd.clone().try_get_matches_from(["bug"]).unwrap_err();

    cmd.clone()
        .try_get_matches_from(["bug", "--exclusive", "--required"])
        .unwrap_err();

    cmd.clone()
        .try_get_matches_from(["bug", "--exclusive"])
        .unwrap();
}

#[test]
#[cfg(feature = "error-context")]
fn option_conflicts_with_subcommand() {
    static CONFLICT_ERR: &str = "\
error: the subcommand 'sub1' cannot be used with '--place <place id>'

Usage: test [OPTIONS]
       test <COMMAND>

For more information, try '--help'.
";

    let cmd = Command::new("test")
        .args_conflicts_with_subcommands(true)
        .arg(arg!(-p --place <"place id"> "Place ID to open"))
        .subcommand(Command::new("sub1"));

    utils::assert_output(cmd, "test --place id sub1", CONFLICT_ERR, true);
}

#[test]
#[cfg(feature = "error-context")]
fn positional_conflicts_with_subcommand() {
    static CONFLICT_ERR: &str = "\
error: the subcommand 'sub1' cannot be used with '<arg1>'

Usage: test <arg1>
       test <COMMAND>

For more information, try '--help'.
";

    let cmd = Command::new("test")
        .args_conflicts_with_subcommands(true)
        .arg(arg!(<arg1> "some arg"))
        .subcommand(Command::new("sub1"));

    utils::assert_output(cmd, "test value1 sub1", CONFLICT_ERR, true);
}

#[test]
#[cfg(feature = "error-context")]
fn flag_conflicts_with_subcommand_long_flag() {
    static CONFLICT_ERR: &str = "\
error: the subcommand 'sub' cannot be used with '--hello'

Usage: test [OPTIONS]
       test <COMMAND>

For more information, try '--help'.
";

    let cmd = Command::new("test")
        .args_conflicts_with_subcommands(true)
        .arg(arg!(--hello))
        .subcommand(Command::new("sub").long_flag("sub"));

    utils::assert_output(cmd, "test --hello --sub", CONFLICT_ERR, true);
}

#[test]
#[cfg(feature = "error-context")]
fn flag_conflicts_with_subcommand_short_flag() {
    static CONFLICT_ERR: &str = "\
error: the subcommand 'sub' cannot be used with '--hello'

Usage: test [OPTIONS]
       test <COMMAND>

For more information, try '--help'.
";

    let cmd = Command::new("test")
        .args_conflicts_with_subcommands(true)
        .arg(arg!(--hello))
        .subcommand(Command::new("sub").short_flag('s'));

    utils::assert_output(cmd, "test --hello -s", CONFLICT_ERR, true);
}

#[test]
#[cfg(feature = "error-context")]
fn positional_conflicts_with_subcommand_precedent() {
    static CONFLICT_ERR: &str = "\
error: the subcommand 'sub' cannot be used with '<arg1>'

Usage: test <arg1>
       test <COMMAND>

For more information, try '--help'.
";

    let cmd = Command::new("test")
        .args_conflicts_with_subcommands(true)
        .subcommand_precedence_over_arg(true)
        .arg(arg!(<arg1> "some arg"))
        .subcommand(Command::new("sub"));

    utils::assert_output(cmd, "test hello sub", CONFLICT_ERR, true);
}

#[test]
#[cfg(feature = "error-context")]
fn flag_conflicts_with_subcommand_precedent() {
    static CONFLICT_ERR: &str = "\
error: the subcommand 'sub' cannot be used with '--hello'

Usage: test [OPTIONS]
       test <COMMAND>

For more information, try '--help'.
";

    let cmd = Command::new("test")
        .args_conflicts_with_subcommands(true)
        .subcommand_precedence_over_arg(true)
        .arg(arg!(--hello))
        .subcommand(Command::new("sub"));

    utils::assert_output(cmd, "test --hello sub", CONFLICT_ERR, true);
}

#[test]
fn subcommand_conflict_negates_required() {
    let cmd = Command::new("test")
        .args_conflicts_with_subcommands(true)
        .subcommand(Command::new("config"))
        .arg(arg!(-p --place <"place id"> "Place ID to open").required(true));

    let result = cmd.try_get_matches_from(["test", "config"]);
    assert!(
        result.is_ok(),
        "args_conflicts_with_subcommands should ignore required: {}",
        result.unwrap_err()
    );
    let m = result.unwrap();
    assert_eq!(m.subcommand_name().unwrap(), "config");
}

#[test]
fn args_negate_subcommands_one_level() {
    let res = Command::new("disablehelp")
        .args_conflicts_with_subcommands(true)
        .subcommand_negates_reqs(true)
        .arg(arg!(<arg1> "some arg"))
        .arg(arg!(<arg2> "some arg"))
        .subcommand(
            Command::new("sub1").subcommand(Command::new("sub2").subcommand(Command::new("sub3"))),
        )
        .try_get_matches_from(vec!["", "pickles", "sub1"]);
    assert!(res.is_ok(), "error: {:?}", res.unwrap_err().kind());
    let m = res.unwrap();
    assert_eq!(
        m.get_one::<String>("arg2").map(|v| v.as_str()),
        Some("sub1")
    );
}

#[test]
fn args_negate_subcommands_two_levels() {
    let res = Command::new("disablehelp")
        .args_conflicts_with_subcommands(true)
        .subcommand_negates_reqs(true)
        .arg(arg!(<arg1> "some arg"))
        .arg(arg!(<arg2> "some arg"))
        .subcommand(
            Command::new("sub1")
                .args_conflicts_with_subcommands(true)
                .subcommand_negates_reqs(true)
                .arg(arg!(<arg> "some"))
                .arg(arg!(<arg2> "some"))
                .subcommand(Command::new("sub2").subcommand(Command::new("sub3"))),
        )
        .try_get_matches_from(vec!["", "sub1", "arg", "sub2"]);
    assert!(res.is_ok(), "error: {:?}", res.unwrap_err().kind());
    let m = res.unwrap();
    assert_eq!(
        m.subcommand_matches("sub1")
            .unwrap()
            .get_one::<String>("arg2")
            .map(|v| v.as_str()),
        Some("sub2")
    );
}

```

`clap/tests/builder/default_missing_vals.rs`:

```rs
use clap::{arg, Arg, ArgAction, Command};

#[test]
fn opt_missing() {
    let r = Command::new("df")
        .arg(
            Arg::new("color")
                .long("color")
                .default_value("auto")
                .num_args(0..=1)
                .require_equals(true)
                .default_missing_value("always"),
        )
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "auto"
    );
    assert_eq!(
        m.value_source("color").unwrap(),
        clap::parser::ValueSource::DefaultValue
    );
    assert_eq!(m.index_of("color"), Some(1));
}

#[test]
fn opt_present_with_missing_value() {
    let r = Command::new("df")
        .arg(
            Arg::new("color")
                .long("color")
                .default_value("auto")
                .num_args(0..=1)
                .require_equals(true)
                .default_missing_value("always"),
        )
        .try_get_matches_from(vec!["", "--color"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "always"
    );
    assert_eq!(
        m.value_source("color").unwrap(),
        clap::parser::ValueSource::CommandLine
    );
    assert_eq!(m.index_of("color"), Some(2));
}

#[test]
fn opt_present_with_value() {
    let r = Command::new("df")
        .arg(
            Arg::new("color")
                .long("color")
                .default_value("auto")
                .num_args(0..=1)
                .require_equals(true)
                .default_missing_value("always"),
        )
        .try_get_matches_from(vec!["", "--color=never"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "never"
    );
    assert_eq!(
        m.value_source("color").unwrap(),
        clap::parser::ValueSource::CommandLine
    );
    assert_eq!(m.index_of("color"), Some(2));
}

#[test]
fn opt_present_with_empty_value() {
    let r = Command::new("df")
        .arg(
            Arg::new("color")
                .long("color")
                .default_value("auto")
                .require_equals(true)
                .default_missing_value("always"),
        )
        .try_get_matches_from(vec!["", "--color="]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        ""
    );
    assert_eq!(
        m.value_source("color").unwrap(),
        clap::parser::ValueSource::CommandLine
    );
    assert_eq!(m.index_of("color"), Some(2));
}

//## `default_value`/`default_missing_value` non-interaction checks

#[test]
fn opt_default() {
    // assert no change to usual argument handling when adding default_missing_value()
    let r = Command::new("cmd")
        .arg(
            arg!(o: -o [opt] "some opt")
                .default_value("default")
                .default_missing_value("default_missing"),
        )
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.get_one::<String>("o").map(|v| v.as_str()).unwrap(),
        "default"
    );
}

#[test]
fn opt_default_user_override() {
    // assert no change to usual argument handling when adding default_missing_value()
    let r = Command::new("cmd")
        .arg(
            arg!(o: -o [opt] "some opt")
                .default_value("default")
                .default_missing_value("default_missing"),
        )
        .try_get_matches_from(vec!["", "-o=value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.get_one::<String>("o").map(|v| v.as_str()).unwrap(),
        "value"
    );
}

#[test]
fn default_missing_value_per_occurrence() {
    // assert no change to usual argument handling when adding default_missing_value()
    let r = Command::new("cmd")
        .arg(
            arg!(o: -o [opt] ... "some opt")
                .default_value("default")
                .default_missing_value("default_missing"),
        )
        .try_get_matches_from(vec!["", "-o", "-o=value", "-o"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert_eq!(
        m.get_many::<String>("o")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        vec!["default_missing", "value", "default_missing"]
    );
}

#[test]
#[allow(clippy::bool_assert_comparison)]
fn default_missing_value_flag_value() {
    let cmd = Command::new("test").arg(
        Arg::new("flag")
            .long("flag")
            .action(ArgAction::Set)
            .num_args(0..=1)
            .default_value("false")
            .default_missing_value("true"),
    );

    let m = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()),
        Some("false")
    );
    assert_eq!(
        m.value_source("flag").unwrap(),
        clap::parser::ValueSource::DefaultValue
    );

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "--flag"])
        .unwrap();
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()),
        Some("true")
    );
    assert_eq!(
        m.value_source("flag").unwrap(),
        clap::parser::ValueSource::CommandLine
    );

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "--flag=true"])
        .unwrap();
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()),
        Some("true")
    );
    assert_eq!(
        m.value_source("flag").unwrap(),
        clap::parser::ValueSource::CommandLine
    );

    let m = cmd.try_get_matches_from(["test", "--flag=false"]).unwrap();
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()),
        Some("false")
    );
    assert_eq!(
        m.value_source("flag").unwrap(),
        clap::parser::ValueSource::CommandLine
    );
}

#[test]
fn delimited_missing_value() {
    let cmd = Command::new("test").arg(
        Arg::new("flag")
            .long("flag")
            .default_value("one,two")
            .default_missing_value("three,four")
            .num_args(0..)
            .value_delimiter(',')
            .require_equals(true),
    );

    let m = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(
        m.get_many::<String>("flag")
            .unwrap()
            .map(|s| s.as_str())
            .collect::<Vec<_>>(),
        vec!["one", "two"]
    );

    let m = cmd.try_get_matches_from(["test", "--flag"]).unwrap();
    assert_eq!(
        m.get_many::<String>("flag")
            .unwrap()
            .map(|s| s.as_str())
            .collect::<Vec<_>>(),
        vec!["three", "four"]
    );
}

#[test]
fn valid_index() {
    let m = Command::new("df")
        .arg(
            Arg::new("color")
                .long("color")
                .default_value("auto")
                .num_args(0..=1)
                .require_equals(true)
                .default_missing_value("always"),
        )
        .arg(Arg::new("sync").long("sync").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["df", "--color", "--sync"])
        .unwrap();
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "always"
    );
    assert_eq!(
        m.value_source("color").unwrap(),
        clap::parser::ValueSource::CommandLine
    );

    // Make sure the index reflects `--color`s position and not something else
    assert_eq!(m.index_of("color"), Some(2));
}

```

`clap/tests/builder/default_vals.rs`:

```rs
use std::ffi::OsStr;
use std::ffi::OsString;

use clap::builder::ArgPredicate;
#[cfg(feature = "error-context")]
use clap::error::ErrorKind;
use clap::{arg, value_parser, Arg, ArgAction, Command};
use snapbox::str;

#[cfg(feature = "error-context")]
use super::utils;

#[test]
fn opts() {
    let r = Command::new("df")
        .arg(arg!(o: -o <opt> "some opt").default_value("default"))
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.value_source("o").unwrap(),
        clap::parser::ValueSource::DefaultValue
    );
    assert_eq!(
        m.get_one::<String>("o").map(|v| v.as_str()).unwrap(),
        "default"
    );
}

#[test]
fn default_has_index() {
    let r = Command::new("df")
        .arg(arg!(o: -o <opt> "some opt").default_value("default"))
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert_eq!(m.index_of("o"), Some(1));
}

#[test]
#[cfg(feature = "error-context")]
fn opt_without_value_fail() {
    let r = Command::new("df")
        .arg(
            arg!(o: -o <opt> "some opt")
                .default_value("default")
                .value_parser(clap::builder::NonEmptyStringValueParser::new()),
        )
        .try_get_matches_from(vec!["", "-o"]);
    assert!(r.is_err());
    let err = r.unwrap_err();
    utils::assert_error(err, ErrorKind::InvalidValue, str![[r#"
error: a value is required for '-o <opt>' but none was supplied

For more information, try '--help'.

"#]], true);
}

#[test]
fn opt_user_override() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg").default_value("default"))
        .try_get_matches_from(vec!["", "--opt", "value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(
        m.value_source("opt").unwrap(),
        clap::parser::ValueSource::CommandLine
    );
    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()).unwrap(),
        "value"
    );
}

#[test]
fn positionals() {
    let r = Command::new("df")
        .arg(arg!([arg] "some opt").default_value("default"))
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.value_source("arg").unwrap(),
        clap::parser::ValueSource::DefaultValue
    );
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "default"
    );
}

#[test]
fn positional_user_override() {
    let r = Command::new("df")
        .arg(arg!([arg] "some arg").default_value("default"))
        .try_get_matches_from(vec!["", "value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.value_source("arg").unwrap(),
        clap::parser::ValueSource::CommandLine
    );
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "value"
    );
}

// OsStr Default Values

#[test]
fn osstr_opts() {
    use std::ffi::OsStr;
    let expected = OsStr::new("default");

    let r = Command::new("df")
        .arg(arg!(o: -o <opt> "some opt").default_value(expected))
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.get_one::<String>("o").map(|v| v.as_str()).unwrap(),
        expected
    );
}

#[test]
fn osstr_opt_user_override() {
    use std::ffi::OsStr;
    let default = OsStr::new("default");

    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg").default_value(default))
        .try_get_matches_from(vec!["", "--opt", "value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()).unwrap(),
        "value"
    );
}

#[test]
fn osstr_positionals() {
    use std::ffi::OsStr;
    let expected = OsStr::new("default");

    let r = Command::new("df")
        .arg(arg!([arg] "some opt").default_value(expected))
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        expected
    );
}

#[test]
fn osstr_positional_user_override() {
    use std::ffi::OsStr;
    let default = OsStr::new("default");

    let r = Command::new("df")
        .arg(arg!([arg] "some arg").default_value(default))
        .try_get_matches_from(vec!["", "value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "value"
    );
}

// --- Default if arg is present

#[test]
fn default_if_arg_present_no_default() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg").required(true))
        .arg(arg!([arg] "some arg").default_value_if(
            "opt",
            ArgPredicate::IsPresent,
            Some("default"),
        ))
        .try_get_matches_from(vec!["", "--opt", "some"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "default"
    );
}

#[test]
fn default_if_arg_present_no_default_user_override() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(arg!([arg] "some arg").default_value_if(
            "opt",
            ArgPredicate::IsPresent,
            Some("default"),
        ))
        .try_get_matches_from(vec!["", "--opt", "some", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn default_if_arg_present_no_arg_with_default() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", ArgPredicate::IsPresent, Some("default")),
        )
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "first"
    );
}

#[test]
fn default_if_arg_present_with_default() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", ArgPredicate::IsPresent, Some("default")),
        )
        .try_get_matches_from(vec!["", "--opt", "some"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "default"
    );
}

#[test]
fn default_if_arg_present_with_default_user_override() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", ArgPredicate::IsPresent, Some("default")),
        )
        .try_get_matches_from(vec!["", "--opt", "some", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn default_if_arg_present_no_arg_with_default_user_override() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", ArgPredicate::IsPresent, Some("default")),
        )
        .try_get_matches_from(vec!["", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

// Conditional Default Values

#[test]
fn default_if_arg_present_with_value_no_default() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(arg!([arg] "some arg").default_value_if("opt", "value", Some("default")))
        .try_get_matches_from(vec!["", "--opt", "value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "default"
    );
}

#[test]
fn default_if_arg_present_with_value_no_default_fail() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(arg!([arg] "some arg").default_value_if("opt", "value", Some("default")))
        .try_get_matches_from(vec!["", "--opt", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(!m.contains_id("arg"));
    assert!(m.get_one::<String>("arg").map(|v| v.as_str()).is_none());
}

#[test]
fn default_if_arg_present_with_value_no_default_user_override() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(arg!([arg] "some arg").default_value_if("opt", "some", Some("default")))
        .try_get_matches_from(vec!["", "--opt", "some", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn default_if_arg_present_with_value_no_arg_with_default() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", "some", Some("default")),
        )
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "first"
    );
}

#[test]
fn default_if_arg_present_with_value_no_arg_with_default_fail() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", "some", Some("default")),
        )
        .try_get_matches_from(vec!["", "--opt", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "first"
    );
}

#[test]
fn default_if_arg_present_with_value_with_default() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", "some", Some("default")),
        )
        .try_get_matches_from(vec!["", "--opt", "some"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "default"
    );
}

#[test]
fn default_if_arg_present_with_value_with_default_user_override() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", "some", Some("default")),
        )
        .try_get_matches_from(vec!["", "--opt", "some", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn default_if_arg_present_no_arg_with_value_with_default_user_override() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", "some", Some("default")),
        )
        .try_get_matches_from(vec!["", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn default_if_arg_present_no_arg_with_value_with_default_user_override_fail() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_if("opt", "some", Some("default")),
        )
        .try_get_matches_from(vec!["", "--opt", "value", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

// Unsetting the default

#[test]
fn no_default_if_arg_present_with_value_no_default() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(arg!([arg] "some arg").default_value_if("opt", "value", None))
        .try_get_matches_from(vec!["", "--opt", "value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(!m.contains_id("arg"));
}

#[test]
fn no_default_if_arg_present_with_value_with_default() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("default")
                .default_value_if("opt", "value", None),
        )
        .try_get_matches_from(vec!["", "--opt", "value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(!m.contains_id("arg"));
    assert!(m.get_one::<String>("arg").map(|v| v.as_str()).is_none());
}

#[test]
fn no_default_if_arg_present_with_value_with_default_user_override() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("default")
                .default_value_if("opt", "value", None),
        )
        .try_get_matches_from(vec!["", "--opt", "value", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn no_default_if_arg_present_no_arg_with_value_with_default() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("default")
                .default_value_if("opt", "value", None),
        )
        .try_get_matches_from(vec!["", "--opt", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "default"
    );
}

// Multiple conditions

#[test]
fn default_ifs_arg_present() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(arg!(--flag "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_ifs([
                    ("opt", ArgPredicate::from("some"), Some("default")),
                    ("flag", ArgPredicate::IsPresent, Some("flg")),
                ]),
        )
        .try_get_matches_from(vec!["", "--flag"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "flg"
    );
}

#[test]
fn no_default_ifs_arg_present() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(arg!(--flag "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_ifs([
                    ("opt", ArgPredicate::from("some"), Some("default")),
                    ("flag", ArgPredicate::IsPresent, None),
                ]),
        )
        .try_get_matches_from(vec!["", "--flag"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(!m.contains_id("arg"));
    assert!(m.get_one::<String>("arg").map(|v| v.as_str()).is_none());
}

#[test]
fn default_ifs_arg_present_user_override() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(arg!(--flag "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_ifs([
                    ("opt", ArgPredicate::from("some"), Some("default")),
                    ("flag", ArgPredicate::IsPresent, Some("flg")),
                ]),
        )
        .try_get_matches_from(vec!["", "--flag", "value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "value"
    );
}

#[test]
fn default_ifs_arg_present_order() {
    let r = Command::new("df")
        .arg(arg!(--opt <FILE> "some arg"))
        .arg(arg!(--flag "some arg"))
        .arg(
            arg!([arg] "some arg")
                .default_value("first")
                .default_value_ifs([
                    ("opt", ArgPredicate::from("some"), Some("default")),
                    ("flag", ArgPredicate::IsPresent, Some("flg")),
                ]),
        )
        .try_get_matches_from(vec!["", "--opt=some", "--flag"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "default"
    );
}

#[test]
fn default_value_ifs_os() {
    let cmd = Command::new("my_cargo")
        .arg(
            Arg::new("flag")
                .long("flag")
                .value_parser(value_parser!(OsString))
                .action(ArgAction::Set),
        )
        .arg(
            Arg::new("other")
                .long("other")
                .value_parser(value_parser!(OsString))
                .default_value_ifs([("flag", "标记2", OsStr::new("flag=标记2"))]),
        );
    let result = cmd.try_get_matches_from(["my_cargo", "--flag", "标记2"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
    let m = result.unwrap();
    assert_eq!(
        m.get_one::<OsString>("flag").map(OsString::as_os_str),
        Some(OsStr::new("标记2"))
    );
    assert_eq!(
        m.get_one::<OsString>("other").map(OsString::as_os_str),
        Some(OsStr::new("flag=标记2")),
    );
}

// Interaction with requires

#[test]
fn conditional_reqs_pass() {
    let m = Command::new("Test cmd")
        .arg(
            Arg::new("target")
                .action(ArgAction::Set)
                .default_value("file")
                .long("target"),
        )
        .arg(
            Arg::new("input")
                .action(ArgAction::Set)
                .required(true)
                .long("input"),
        )
        .arg(
            Arg::new("output")
                .action(ArgAction::Set)
                .required_if_eq("target", "file")
                .long("output"),
        )
        .try_get_matches_from(vec!["test", "--input", "some", "--output", "other"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(
        m.get_one::<String>("output").map(|v| v.as_str()),
        Some("other")
    );
    assert_eq!(
        m.get_one::<String>("input").map(|v| v.as_str()),
        Some("some")
    );
}

#[test]
fn multiple_defaults() {
    let r = Command::new("diff")
        .arg(
            Arg::new("files")
                .long("files")
                .num_args(2)
                .default_values(["old", "new"]),
        )
        .try_get_matches_from(vec![""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("files"));
    assert_eq!(
        m.get_many::<String>("files").unwrap().collect::<Vec<_>>(),
        vec!["old", "new"]
    );
}

#[test]
fn multiple_defaults_override() {
    let r = Command::new("diff")
        .arg(
            Arg::new("files")
                .long("files")
                .num_args(2)
                .default_values(["old", "new"]),
        )
        .try_get_matches_from(vec!["", "--files", "other", "mine"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("files"));
    assert_eq!(
        m.get_many::<String>("files").unwrap().collect::<Vec<_>>(),
        vec!["other", "mine"]
    );
}

#[test]
#[cfg(feature = "error-context")]
fn default_vals_donnot_show_in_smart_usage() {
    let cmd = Command::new("bug")
        .arg(
            Arg::new("foo")
                .long("config")
                .action(ArgAction::Set)
                .default_value("bar"),
        )
        .arg(Arg::new("input").required(true));

    utils::assert_output(
        cmd,
        "bug",
        "\
error: the following required arguments were not provided:
  <input>

Usage: bug <input>

For more information, try '--help'.
",
        true,
    );
}

#[test]
fn issue_1050_num_vals_and_defaults() {
    let res = Command::new("hello")
        .arg(
            Arg::new("exit-code")
                .long("exit-code")
                .action(ArgAction::Set)
                .num_args(1)
                .default_value("0"),
        )
        .try_get_matches_from(vec!["hello", "--exit-code=1"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert_eq!(
        m.get_one::<String>("exit-code").map(|v| v.as_str()),
        Some("1")
    );
}

#[test]
fn required_groups_with_default_values() {
    use clap::{Arg, ArgGroup, Command};

    let cmd = Command::new("test")
        .arg(Arg::new("arg").default_value("value"))
        .group(ArgGroup::new("group").args(["arg"]).required(true));

    let result = cmd.clone().try_get_matches_from(["test"]);
    assert!(result.is_err());

    let result = cmd.clone().try_get_matches_from(["test", "value"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
    let m = result.unwrap();
    assert!(m.contains_id("arg"));
    assert!(m.contains_id("group"));
}

#[test]
fn required_args_with_default_values() {
    use clap::{Arg, Command};

    let cmd = Command::new("test").arg(Arg::new("arg").required(true).default_value("value"));

    let result = cmd.clone().try_get_matches_from(["test"]);
    assert!(result.is_err());

    let result = cmd.clone().try_get_matches_from(["test", "value"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
    let m = result.unwrap();
    assert!(m.contains_id("arg"));
}

#[test]
fn valid_delimited_default_values() {
    use clap::{Arg, Command};

    Command::new("test")
        .arg(
            Arg::new("arg")
                .value_parser(clap::value_parser!(u32))
                .value_delimiter(',')
                .default_value("1,2,3"),
        )
        .debug_assert();
}

#[test]
fn with_value_delimiter() {
    let cmd = Command::new("multiple_values").arg(
        Arg::new("option")
            .long("option")
            .help("multiple options")
            .value_delimiter(';')
            .default_value("first;second"),
    );

    let matches = cmd.try_get_matches_from(vec![""]).unwrap();

    assert_eq!(
        matches
            .get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["first", "second"]
    );
}

#[test]
fn missing_with_value_delimiter() {
    let cmd = Command::new("program").arg(
        Arg::new("option")
            .long("option")
            .value_delimiter(';')
            .num_args(0..=1)
            .default_missing_values(["value1;value2;value3", "value4;value5"]),
    );

    let matches = cmd
        .try_get_matches_from(vec!["program", "--option"])
        .unwrap();

    assert_eq!(
        matches
            .get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["value1", "value2", "value3", "value4", "value5"]
    );
}

#[test]
fn default_independent_of_trailing() {
    let cmd = Command::new("test")
        .dont_delimit_trailing_values(true)
        .arg(Arg::new("pos").required(true))
        .arg(
            Arg::new("flag")
                .long("flag")
                .default_value("one,two")
                .value_delimiter(','),
        );

    // Baseline behavior
    let m = cmd
        .clone()
        .try_get_matches_from(vec!["program", "here"])
        .unwrap();
    assert_eq!(
        m.get_one::<String>("pos").map(|v| v.as_str()).unwrap(),
        "here"
    );
    assert_eq!(
        m.get_many::<String>("flag")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["one", "two"]
    );

    // Trailing-values behavior should match the baseline
    let m = cmd
        .try_get_matches_from(vec!["program", "--", "here"])
        .unwrap();
    assert_eq!(
        m.get_one::<String>("pos").map(|v| v.as_str()).unwrap(),
        "here"
    );
    assert_eq!(
        m.get_many::<String>("flag")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["one", "two"]
    );
}

```

`clap/tests/builder/delimiters.rs`:

```rs
use clap::{Arg, ArgAction, Command};

#[test]
fn opt_default_no_delim() {
    let m = Command::new("no_delim")
        .arg(Arg::new("option").long("option").action(ArgAction::Set))
        .try_get_matches_from(vec!["", "--option", "val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_one::<String>("option").map(|v| v.as_str()).unwrap(),
        "val1,val2,val3"
    );
}

#[test]
fn opt_eq_no_delim() {
    let m = Command::new("no_delim")
        .arg(Arg::new("option").long("option").action(ArgAction::Set))
        .try_get_matches_from(vec!["", "--option=val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_one::<String>("option").map(|v| v.as_str()).unwrap(),
        "val1,val2,val3"
    );
}

#[test]
fn opt_s_eq_no_delim() {
    let m = Command::new("no_delim")
        .arg(Arg::new("option").short('o').action(ArgAction::Set))
        .try_get_matches_from(vec!["", "-o=val1,val2,val3"]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_one::<String>("option").map(|v| v.as_str()).unwrap(),
        "val1,val2,val3"
    );
}

#[test]
fn opt_s_default_no_delim() {
    let m = Command::new("no_delim")
        .arg(Arg::new("option").short('o').action(ArgAction::Set))
        .try_get_matches_from(vec!["", "-o", "val1,val2,val3"]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_one::<String>("option").map(|v| v.as_str()).unwrap(),
        "val1,val2,val3"
    );
}

#[test]
fn opt_s_no_space_no_delim() {
    let m = Command::new("no_delim")
        .arg(Arg::new("option").short('o').action(ArgAction::Set))
        .try_get_matches_from(vec!["", "-o", "val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_one::<String>("option").map(|v| v.as_str()).unwrap(),
        "val1,val2,val3"
    );
}

#[test]
fn opt_s_no_space_mult_no_delim() {
    let m = Command::new("no_delim")
        .arg(
            Arg::new("option")
                .short('o')
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .try_get_matches_from(vec!["", "-o", "val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_one::<String>("option").map(|v| v.as_str()).unwrap(),
        "val1,val2,val3"
    );
}

#[test]
fn opt_eq_mult_def_delim() {
    let m = Command::new("no_delim")
        .arg(
            Arg::new("option")
                .long("opt")
                .action(ArgAction::Set)
                .num_args(1..)
                .value_delimiter(','),
        )
        .try_get_matches_from(vec!["", "--opt=val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

```

`clap/tests/builder/derive_order.rs`:

```rs
use super::utils;

use std::str;

use clap::{Arg, ArgAction, Command};

#[test]
fn no_derive_order() {
    static NO_DERIVE_ORDER: &str = "\
Usage: test [OPTIONS]

Options:
      --flag_a               second flag
      --flag_b               first flag
  -h, --help                 Print help
      --option_a <option_a>  second option
      --option_b <option_b>  first option
  -V, --version              Print version
";

    let cmd = Command::new("test")
        .version("1.2")
        .next_display_order(None)
        .args([
            Arg::new("flag_b")
                .long("flag_b")
                .help("first flag")
                .action(ArgAction::SetTrue),
            Arg::new("option_b")
                .long("option_b")
                .action(ArgAction::Set)
                .help("first option"),
            Arg::new("flag_a")
                .long("flag_a")
                .help("second flag")
                .action(ArgAction::SetTrue),
            Arg::new("option_a")
                .long("option_a")
                .action(ArgAction::Set)
                .help("second option"),
        ]);

    utils::assert_output(cmd, "test --help", NO_DERIVE_ORDER, false);
}

#[test]
fn derive_order() {
    static UNIFIED_HELP_AND_DERIVE: &str = "\
Usage: test [OPTIONS]

Options:
      --flag_b               first flag
      --option_b <option_b>  first option
      --flag_a               second flag
      --option_a <option_a>  second option
  -h, --help                 Print help
  -V, --version              Print version
";

    let cmd = Command::new("test").version("1.2").args([
        Arg::new("flag_b")
            .long("flag_b")
            .help("first flag")
            .action(ArgAction::SetTrue),
        Arg::new("option_b")
            .long("option_b")
            .action(ArgAction::Set)
            .help("first option"),
        Arg::new("flag_a")
            .long("flag_a")
            .help("second flag")
            .action(ArgAction::SetTrue),
        Arg::new("option_a")
            .long("option_a")
            .action(ArgAction::Set)
            .help("second option"),
    ]);

    utils::assert_output(cmd, "test --help", UNIFIED_HELP_AND_DERIVE, false);
}

#[test]
fn derive_order_next_order() {
    static HELP: &str = "\
Usage: test [OPTIONS]

Options:
      --flag_b               first flag
      --option_b <option_b>  first option
  -h, --help                 Print help
  -V, --version              Print version
      --flag_a               second flag
      --option_a <option_a>  second option
";

    let cmd = Command::new("test")
        .version("1.2")
        .next_display_order(10000)
        .arg(
            Arg::new("flag_a")
                .long("flag_a")
                .help("second flag")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("option_a")
                .long("option_a")
                .action(ArgAction::Set)
                .help("second option"),
        )
        .next_display_order(10)
        .arg(
            Arg::new("flag_b")
                .long("flag_b")
                .help("first flag")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("option_b")
                .long("option_b")
                .action(ArgAction::Set)
                .help("first option"),
        );

    utils::assert_output(cmd, "test --help", HELP, false);
}

#[test]
fn derive_order_no_next_order() {
    static HELP: &str = "\
Usage: test [OPTIONS]

Options:
      --flag_a               first flag
      --flag_b               second flag
  -h, --help                 Print help
      --option_a <option_a>  first option
      --option_b <option_b>  second option
  -V, --version              Print version
";

    let cmd = Command::new("test")
        .version("1.2")
        .next_display_order(None)
        .arg(
            Arg::new("flag_a")
                .long("flag_a")
                .help("first flag")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("option_a")
                .long("option_a")
                .action(ArgAction::Set)
                .help("first option"),
        )
        .arg(
            Arg::new("flag_b")
                .long("flag_b")
                .help("second flag")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("option_b")
                .long("option_b")
                .action(ArgAction::Set)
                .help("second option"),
        );

    utils::assert_output(cmd, "test --help", HELP, false);
}

#[test]
fn derive_order_subcommand_propagate() {
    static UNIFIED_DERIVE_SC_PROP: &str = "\
Usage: test sub [OPTIONS]

Options:
      --flag_b               first flag
      --option_b <option_b>  first option
      --flag_a               second flag
      --option_a <option_a>  second option
  -h, --help                 Print help
  -V, --version              Print version
";

    let cmd = Command::new("test").subcommand(
        Command::new("sub").version("1.2").args([
            Arg::new("flag_b")
                .long("flag_b")
                .help("first flag")
                .action(ArgAction::SetTrue),
            Arg::new("option_b")
                .long("option_b")
                .action(ArgAction::Set)
                .help("first option"),
            Arg::new("flag_a")
                .long("flag_a")
                .help("second flag")
                .action(ArgAction::SetTrue),
            Arg::new("option_a")
                .long("option_a")
                .action(ArgAction::Set)
                .help("second option"),
        ]),
    );

    utils::assert_output(cmd, "test sub --help", UNIFIED_DERIVE_SC_PROP, false);
}

#[test]
fn derive_order_subcommand_propagate_with_explicit_display_order() {
    static UNIFIED_DERIVE_SC_PROP_EXPLICIT_ORDER: &str = "\
Usage: test sub [OPTIONS]

Options:
      --flag_a               second flag
      --flag_b               first flag
      --option_b <option_b>  first option
      --option_a <option_a>  second option
  -h, --help                 Print help
  -V, --version              Print version
";

    let cmd = Command::new("test").subcommand(
        Command::new("sub").version("1.2").args([
            Arg::new("flag_b")
                .long("flag_b")
                .help("first flag")
                .action(ArgAction::SetTrue),
            Arg::new("option_b")
                .long("option_b")
                .action(ArgAction::Set)
                .help("first option"),
            Arg::new("flag_a")
                .long("flag_a")
                .help("second flag")
                .display_order(0)
                .action(ArgAction::SetTrue),
            Arg::new("option_a")
                .long("option_a")
                .action(ArgAction::Set)
                .help("second option"),
        ]),
    );

    utils::assert_output(
        cmd,
        "test sub --help",
        UNIFIED_DERIVE_SC_PROP_EXPLICIT_ORDER,
        false,
    );
}

#[test]
fn subcommand_sorted_display_order() {
    static SUBCMD_ALPHA_ORDER: &str = "\
Usage: test [COMMAND]

Commands:
  a1    blah a1
  b1    blah b1
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
";

    let app_subcmd_alpha_order = Command::new("test")
        .version("1")
        .next_display_order(None)
        .subcommands(vec![
            Command::new("b1")
                .about("blah b1")
                .arg(Arg::new("test").short('t').action(ArgAction::SetTrue)),
            Command::new("a1")
                .about("blah a1")
                .arg(Arg::new("roster").short('r').action(ArgAction::SetTrue)),
        ]);

    utils::assert_output(
        app_subcmd_alpha_order,
        "test --help",
        SUBCMD_ALPHA_ORDER,
        false,
    );
}

#[test]
fn subcommand_derived_display_order() {
    static SUBCMD_DECL_ORDER: &str = "\
Usage: test [COMMAND]

Commands:
  b1    blah b1
  a1    blah a1
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
";

    let app_subcmd_decl_order = Command::new("test").version("1").subcommands(vec![
        Command::new("b1")
            .about("blah b1")
            .arg(Arg::new("test").short('t').action(ArgAction::SetTrue)),
        Command::new("a1")
            .about("blah a1")
            .arg(Arg::new("roster").short('r').action(ArgAction::SetTrue)),
    ]);

    utils::assert_output(
        app_subcmd_decl_order,
        "test --help",
        SUBCMD_DECL_ORDER,
        false,
    );
}

```

`clap/tests/builder/display_order.rs`:

```rs
use super::utils;

use clap::Command;

#[test]
fn very_large_display_order() {
    let cmd = Command::new("test").subcommand(Command::new("sub").display_order(usize::MAX));

    utils::assert_output(
        cmd,
        "test --help",
        "\
Usage: test [COMMAND]

Commands:
  help  Print this message or the help of the given subcommand(s)
  sub   

Options:
  -h, --help  Print help
",
        false,
    );
}

```

`clap/tests/builder/double_require.rs`:

```rs
use clap::{error::ErrorKind, Arg, ArgAction, Command};
use snapbox::str;

use crate::utils;

fn cmd() -> Command {
    Command::new("prog")
        .arg(
            Arg::new("a")
                .short('a')
                .action(ArgAction::SetTrue)
                .required_unless_present_any(["b", "c"])
                .conflicts_with_all(["b", "c"]),
        )
        .arg(
            Arg::new("b")
                .short('b')
                .action(ArgAction::SetTrue)
                .required_unless_present("a")
                .requires("c"),
        )
        .arg(
            Arg::new("c")
                .short('c')
                .action(ArgAction::SetTrue)
                .required_unless_present("a")
                .requires("b"),
        )
}

#[test]
fn valid_cases() {
    let res = cmd().try_get_matches_from(vec!["", "-a"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let res = cmd().clone().try_get_matches_from(vec!["", "-b", "-c"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let res = cmd().try_get_matches_from(vec!["", "-c", "-b"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn help_text() {
    let res = cmd().try_get_matches_from(vec!["prog", "--help"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(err, ErrorKind::DisplayHelp, str![[r#"
Usage: prog [OPTIONS]

Options:
  -a          
  -b          
  -c          
  -h, --help  Print help

"#]], false);
}

#[test]
#[cfg(feature = "error-context")]
fn no_duplicate_error() {
    let res = cmd().try_get_matches_from(vec!["", "-b"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::MissingRequiredArgument,
        str![[r#"
error: the following required arguments were not provided:
  -c

Usage: prog -b -c

For more information, try '--help'.

"#]],
        true,
    );

    let res = cmd().try_get_matches_from(vec!["", "-c"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::MissingRequiredArgument,
        str![[r#"
error: the following required arguments were not provided:
  -b

Usage: prog -c -b

For more information, try '--help'.

"#]],
        true,
    );
}

```

`clap/tests/builder/empty_values.rs`:

```rs
use clap::{error::ErrorKind, Arg, ArgAction, Command};

#[cfg(feature = "error-context")]
use super::utils;

#[test]
fn empty_values() {
    let m = Command::new("config")
        .arg(Arg::new("config").long("config").action(ArgAction::Set))
        .try_get_matches_from(["config", "--config", ""])
        .unwrap();
    assert_eq!(m.get_one::<String>("config").map(|v| v.as_str()), Some(""));
}

#[test]
fn empty_values_with_equals() {
    let m = Command::new("config")
        .arg(Arg::new("config").long("config").action(ArgAction::Set))
        .try_get_matches_from(["config", "--config="])
        .unwrap();
    assert_eq!(m.get_one::<String>("config").map(|v| v.as_str()), Some(""));

    let m = Command::new("config")
        .arg(Arg::new("config").short('c').action(ArgAction::Set))
        .try_get_matches_from(["config", "-c="])
        .unwrap();
    assert_eq!(m.get_one::<String>("config").map(|v| v.as_str()), Some(""));
}

#[test]
fn no_empty_values() {
    let m = Command::new("config")
        .arg(
            Arg::new("config")
                .long("config")
                .action(ArgAction::Set)
                .value_parser(clap::builder::NonEmptyStringValueParser::new()),
        )
        .try_get_matches_from(["config", "--config", ""]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);

    let m = Command::new("config")
        .arg(
            Arg::new("config")
                .short('c')
                .action(ArgAction::Set)
                .value_parser(clap::builder::NonEmptyStringValueParser::new()),
        )
        .try_get_matches_from(["config", "-c", ""]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
fn no_empty_values_with_equals() {
    let m = Command::new("config")
        .arg(
            Arg::new("config")
                .long("config")
                .action(ArgAction::Set)
                .value_parser(clap::builder::NonEmptyStringValueParser::new()),
        )
        .try_get_matches_from(["config", "--config="]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);

    let m = Command::new("config")
        .arg(
            Arg::new("config")
                .short('c')
                .action(ArgAction::Set)
                .value_parser(clap::builder::NonEmptyStringValueParser::new()),
        )
        .try_get_matches_from(["config", "-c="]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
fn no_empty_values_without_equals() {
    let m = Command::new("config")
        .arg(
            Arg::new("config")
                .long("config")
                .action(ArgAction::Set)
                .value_parser(clap::builder::NonEmptyStringValueParser::new()),
        )
        .try_get_matches_from(["config", "--config"]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);

    let m = Command::new("config")
        .arg(
            Arg::new("config")
                .short('c')
                .action(ArgAction::Set)
                .value_parser(clap::builder::NonEmptyStringValueParser::new()),
        )
        .try_get_matches_from(["config", "-c"]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
#[cfg(feature = "error-context")]
fn no_empty_values_without_equals_but_requires_equals() {
    let cmd = Command::new("config").arg(
        Arg::new("config")
            .long("config")
            .action(ArgAction::Set)
            .value_parser(clap::builder::NonEmptyStringValueParser::new())
            .require_equals(true),
    );
    let m = cmd.clone().try_get_matches_from(["config", "--config"]);
    // Should error on no equals rather than empty value.
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::NoEquals);

    static NO_EUQALS_ERROR: &str =
        "error: equal sign is needed when assigning values to '--config=<config>'

Usage: config [OPTIONS]

For more information, try '--help'.
";

    utils::assert_output(cmd, "config --config", NO_EUQALS_ERROR, true);
}

```

`clap/tests/builder/env.rs`:

```rs
#![cfg(feature = "env")]

use std::env;
use std::ffi::OsStr;

use clap::{arg, builder::FalseyValueParser, Arg, ArgAction, Command};

#[test]
fn env() {
    env::set_var("CLP_TEST_ENV", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.value_source("arg").unwrap(),
        clap::parser::ValueSource::EnvVariable
    );
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "env"
    );
}

#[test]
fn env_bool_literal() {
    env::set_var("CLP_TEST_FLAG_TRUE", "On");
    env::set_var("CLP_TEST_FLAG_FALSE", "nO");

    let r = Command::new("df")
        .arg(
            Arg::new("present")
                .short('p')
                .env("CLP_TEST_FLAG_TRUE")
                .action(ArgAction::SetTrue)
                .value_parser(FalseyValueParser::new()),
        )
        .arg(
            Arg::new("negated")
                .short('n')
                .env("CLP_TEST_FLAG_FALSE")
                .action(ArgAction::SetTrue)
                .value_parser(FalseyValueParser::new()),
        )
        .arg(
            Arg::new("absent")
                .short('a')
                .env("CLP_TEST_FLAG_ABSENT")
                .action(ArgAction::SetTrue)
                .value_parser(FalseyValueParser::new()),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(*m.get_one::<bool>("present").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("negated").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("absent").expect("defaulted by clap"));
}

#[test]
fn env_os() {
    env::set_var("CLP_TEST_ENV_OS", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env(OsStr::new("CLP_TEST_ENV_OS"))
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "env"
    );
}

#[test]
fn no_env() {
    // All the other tests use the presence of the Environment variable...
    // we need another variable just in case one of the others is running at the same time...
    env::remove_var("CLP_TEST_ENV_NONE");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_NONE")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(!m.contains_id("arg"));
    assert_eq!(m.value_source("arg"), None);
    assert_eq!(m.get_one::<String>("arg").map(|v| v.as_str()), None);
}

#[test]
fn no_env_no_takes_value() {
    // All the other tests use the presence of the Environment variable...
    // we need another variable just in case one of the others is running at the same time...
    env::remove_var("CLP_TEST_ENV_NONE");

    let r = Command::new("df")
        .arg(arg!([arg] "some opt").env("CLP_TEST_ENV_NONE"))
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(!m.contains_id("arg"));
    assert_eq!(m.value_source("arg"), None);
    assert_eq!(m.get_one::<String>("arg").map(|v| v.as_str()), None);
}

#[test]
fn with_default() {
    env::set_var("CLP_TEST_ENV_WD", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_WD")
                .action(ArgAction::Set)
                .default_value("default"),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.value_source("arg").unwrap(),
        clap::parser::ValueSource::EnvVariable
    );
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "env"
    );
}

#[test]
fn opt_user_override() {
    env::set_var("CLP_TEST_ENV_OR", "env");

    let r = Command::new("df")
        .arg(
            arg!(--arg [FILE] "some arg")
                .env("CLP_TEST_ENV_OR")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "--arg", "opt"]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.value_source("arg").unwrap(),
        clap::parser::ValueSource::CommandLine
    );
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "opt"
    );

    // see https://github.com/clap-rs/clap/issues/1835
    let values: Vec<_> = m
        .get_many::<String>("arg")
        .unwrap()
        .map(|v| v.as_str())
        .collect();
    assert_eq!(values, vec!["opt"]);
}

#[test]
fn positionals() {
    env::set_var("CLP_TEST_ENV_P", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_P")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.value_source("arg").unwrap(),
        clap::parser::ValueSource::EnvVariable
    );
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "env"
    );
}

#[test]
fn positionals_user_override() {
    env::set_var("CLP_TEST_ENV_POR", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_POR")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "opt"]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.value_source("arg").unwrap(),
        clap::parser::ValueSource::CommandLine
    );
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "opt"
    );

    // see https://github.com/clap-rs/clap/issues/1835
    let values: Vec<_> = m
        .get_many::<String>("arg")
        .unwrap()
        .map(|v| v.as_str())
        .collect();
    assert_eq!(values, vec!["opt"]);
}

#[test]
fn multiple_one() {
    env::set_var("CLP_TEST_ENV_MO", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_MO")
                .action(ArgAction::Set)
                .value_delimiter(',')
                .num_args(1..),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_many::<String>("arg")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        vec!["env"]
    );
}

#[test]
fn multiple_three() {
    env::set_var("CLP_TEST_ENV_MULTI1", "env1,env2,env3");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_MULTI1")
                .action(ArgAction::Set)
                .value_delimiter(',')
                .num_args(1..),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_many::<String>("arg")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        vec!["env1", "env2", "env3"]
    );
}

#[test]
fn multiple_no_delimiter() {
    env::set_var("CLP_TEST_ENV_MULTI2", "env1 env2 env3");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_MULTI2")
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_many::<String>("arg")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        vec!["env1 env2 env3"]
    );
}

#[test]
fn possible_value() {
    env::set_var("CLP_TEST_ENV_PV", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_PV")
                .action(ArgAction::Set)
                .value_parser(["env"]),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "env"
    );
}

#[test]
fn not_possible_value() {
    env::set_var("CLP_TEST_ENV_NPV", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_NPV")
                .action(ArgAction::Set)
                .value_parser(["never"]),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_err());
}

#[test]
fn value_parser() {
    env::set_var("CLP_TEST_ENV_VDOR", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_VDOR")
                .action(ArgAction::Set)
                .value_parser(|s: &str| -> Result<String, String> {
                    if s == "env" {
                        Ok(s.to_owned())
                    } else {
                        Err("not equal".to_owned())
                    }
                }),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "env"
    );
}

#[test]
fn value_parser_output() {
    env::set_var("CLP_TEST_ENV_VO", "42");

    let m = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_VO")
                .action(ArgAction::Set)
                .value_parser(clap::value_parser!(i32)),
        )
        .try_get_matches_from(vec![""])
        .unwrap();

    assert_eq!(*m.get_one::<i32>("arg").unwrap(), 42);
}

#[test]
fn value_parser_invalid() {
    env::set_var("CLP_TEST_ENV_IV", "env");

    let r = Command::new("df")
        .arg(
            arg!([arg] "some opt")
                .env("CLP_TEST_ENV_IV")
                .action(ArgAction::Set)
                .value_parser(|s: &str| -> Result<String, String> {
                    if s != "env" {
                        Ok(s.to_owned())
                    } else {
                        Err("is equal".to_string())
                    }
                }),
        )
        .try_get_matches_from(vec![""]);

    assert!(r.is_err());
}

```

`clap/tests/builder/error.rs`:

```rs
use clap::{arg, builder::ArgAction, error::ErrorKind, value_parser, Arg, Command};
use snapbox::str;

use crate::utils::assert_error;

#[test]
fn app_error() {
    let message = str![[r#"
error: failed for mysterious reasons

Usage: test [OPTIONS] --all

For more information, try '--help'.

"#]];
    let cmd = Command::new("test")
        .arg(
            Arg::new("all")
                .short('a')
                .long("all")
                .required(true)
                .action(ArgAction::SetTrue)
                .help("Also do versioning for private crates (will not be published)"),
        )
        .arg(
            Arg::new("exact")
                .long("exact")
                .help("Specify inter dependency version numbers exactly with `=`"),
        )
        .arg(
            Arg::new("no_git_commit")
                .long("no-git-commit")
                .help("Do not commit version changes"),
        )
        .arg(
            Arg::new("no_git_push")
                .long("no-git-push")
                .help("Do not push generated commit and tags to git remote"),
        );
    let mut cmd = cmd;
    let expected_kind = ErrorKind::InvalidValue;
    let err = cmd.error(expected_kind, "failed for mysterious reasons");
    assert_error(err, expected_kind, message, true);
}

#[test]
fn value_validation_has_newline() {
    let res = Command::new("test")
        .arg(
            arg!(<PORT>)
                .value_parser(value_parser!(usize))
                .help("Network port to use"),
        )
        .try_get_matches_from(["test", "foo"]);

    assert!(res.is_err());
    let err = res.unwrap_err();
    assert!(
        err.to_string().ends_with('\n'),
        "Errors should have a trailing newline, got {:?}",
        err.to_string()
    );
}

#[test]
fn kind_prints_help() {
    let cmd = Command::new("test");
    let res = cmd
        .try_get_matches_from(["test", "--help"])
        .map_err(|e| e.apply::<clap::error::KindFormatter>());
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::DisplayHelp;
    let message = str![[r#"
Usage: test

Options:
  -h, --help  Print help

"#]];
    assert_error(err, expected_kind, message, false);
}

#[test]
fn kind_formats_validation_error() {
    let cmd = Command::new("test");
    let res = cmd
        .try_get_matches_from(["test", "unused"])
        .map_err(|e| e.apply::<clap::error::KindFormatter>());
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::UnknownArgument;
    let message = str![[r#"
error: unexpected argument found

"#]];
    assert_error(err, expected_kind, message, true);
}

#[test]
#[cfg(feature = "error-context")]
fn rich_formats_validation_error() {
    let cmd = Command::new("test");
    let res = cmd.try_get_matches_from(["test", "unused"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::UnknownArgument;
    let message = str![[r#"
error: unexpected argument 'unused' found

Usage: test

For more information, try '--help'.

"#]];
    assert_error(err, expected_kind, message, true);
}

#[test]
#[cfg(feature = "error-context")]
fn suggest_trailing() {
    let cmd = Command::new("rg").arg(arg!([PATTERN]));

    let res = cmd.try_get_matches_from(["rg", "--foo"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::UnknownArgument;
    let message = str![[r#"
error: unexpected argument '--foo' found

  tip: to pass '--foo' as a value, use '-- --foo'

Usage: rg [PATTERN]

For more information, try '--help'.

"#]];
    assert_error(err, expected_kind, message, true);
}

#[test]
#[cfg(feature = "error-context")]
fn suggest_trailing_last() {
    let cmd = Command::new("cargo")
        .arg(arg!([TESTNAME]).last(true))
        .arg(arg!(--"ignore-rust-version"));

    let res = cmd.try_get_matches_from(["cargo", "--ignored"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::UnknownArgument;
    let message = str![[r#"
error: unexpected argument '--ignored' found

  tip: a similar argument exists: '--ignore-rust-version'
  tip: to pass '--ignored' as a value, use '-- --ignored'

Usage: cargo --ignore-rust-version [-- <TESTNAME>]

For more information, try '--help'.

"#]];
    assert_error(err, expected_kind, message, true);
}

#[test]
#[cfg(feature = "error-context")]
fn trailing_already_in_use() {
    let cmd = Command::new("rg").arg(arg!([PATTERN]));

    let res = cmd.try_get_matches_from(["rg", "--", "--foo", "--foo"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::UnknownArgument;
    let message = str![[r#"
error: unexpected argument '--foo' found

Usage: rg [PATTERN]

For more information, try '--help'.

"#]];
    assert_error(err, expected_kind, message, true);
}

#[test]
#[cfg(feature = "error-context")]
fn cant_use_trailing() {
    let cmd = Command::new("test");

    let res = cmd.try_get_matches_from(["test", "--foo"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::UnknownArgument;
    let message = str![[r#"
error: unexpected argument '--foo' found

Usage: test

For more information, try '--help'.

"#]];
    assert_error(err, expected_kind, message, true);
}

#[test]
#[cfg(feature = "error-context")]
fn edit_error() {
    use clap::error::{ContextKind, ContextValue};
    use snapbox::assert_data_eq;

    let cmd = Command::new("rg").arg(arg!([PATTERN]));

    let res = cmd.try_get_matches_from(["rg", "--foo"]);
    assert!(res.is_err());
    let mut err = res.unwrap_err();

    let orig_message = str![[r#"
error: unexpected argument '--foo' found

  tip: to pass '--foo' as a value, use '-- --foo'

Usage: rg [PATTERN]

For more information, try '--help'.

"#]];
    assert_data_eq!(err.to_string(), orig_message);

    assert!(err.remove(ContextKind::Suggested).is_some());
    assert!(err.remove(ContextKind::Suggested).is_none());
    assert!(err
        .insert(
            ContextKind::SuggestedArg,
            ContextValue::String("--bar".to_string())
        )
        .is_none());
    let edited_message = str![[r#"
error: unexpected argument '--foo' found

  tip: a similar argument exists: '--bar'

Usage: rg [PATTERN]

For more information, try '--help'.

"#]];
    assert_data_eq!(err.to_string(), edited_message);
}

#[test]
#[cfg(feature = "error-context")]
#[cfg(feature = "suggestions")]
fn cant_use_trailing_subcommand() {
    let cmd = Command::new("test").subcommand(Command::new("bar"));

    let res = cmd.try_get_matches_from(["test", "baz"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::InvalidSubcommand;
    let message = str![[r#"
error: unrecognized subcommand 'baz'

  tip: a similar subcommand exists: 'bar'

Usage: test [COMMAND]

For more information, try '--help'.

"#]];
    assert_error(err, expected_kind, message, true);
}

#[test]
#[cfg(feature = "error-context")]
#[cfg(feature = "suggestions")]
fn unknown_argument_option() {
    let cmd = Command::new("test").args([
        Arg::new("current-dir").short('C'),
        Arg::new("current-dir-unknown")
            .long("cwd")
            .aliases(["current-dir", "directory", "working-directory", "root"])
            .value_parser(
                clap::builder::UnknownArgumentValueParser::suggest_arg("-C")
                    .and_suggest("not much else to say"),
            )
            .hide(true),
    ]);

    let res = cmd.clone().try_get_matches_from(["test"]);
    assert!(res.is_ok());

    let res = cmd.try_get_matches_from(["test", "--cwd", ".."]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::UnknownArgument;
    let message = str![[r#"
error: unexpected argument '--cwd <current-dir-unknown>' found

  tip: a similar argument exists: '-C'
  tip: not much else to say

Usage: test [OPTIONS]

For more information, try '--help'.

"#]];
    assert_error(err, expected_kind, message, true);
}

#[test]
#[cfg(feature = "error-context")]
#[cfg(feature = "suggestions")]
fn unknown_argument_flag() {
    let cmd = Command::new("test").args([
        Arg::new("ignore-rust-version").long("ignore-rust-version"),
        Arg::new("libtest-ignore")
            .long("ignored")
            .action(ArgAction::SetTrue)
            .value_parser(
                clap::builder::UnknownArgumentValueParser::suggest_arg("-- --ignored")
                    .and_suggest("not much else to say"),
            )
            .hide(true),
    ]);

    let res = cmd.clone().try_get_matches_from(["test"]);
    assert!(res.is_ok());

    let res = cmd.try_get_matches_from(["test", "--ignored"]);
    assert!(res.is_err());
    let err = res.unwrap_err();
    let expected_kind = ErrorKind::UnknownArgument;
    let message = str![[r#"
error: unexpected argument '--ignored' found

  tip: a similar argument exists: '-- --ignored'
  tip: not much else to say

Usage: test [OPTIONS]

For more information, try '--help'.

"#]];
    assert_error(err, expected_kind, message, true);
}

```

`clap/tests/builder/flag_subcommands.rs`:

```rs
use super::utils;

use clap::{arg, error::ErrorKind, Arg, ArgAction, Command};

#[test]
fn flag_subcommand_normal() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some").short_flag('S').long_flag("some").arg(
                Arg::new("test")
                    .short('t')
                    .long("test")
                    .help("testing testing")
                    .action(ArgAction::SetTrue),
            ),
        )
        .try_get_matches_from(vec!["myprog", "some", "--test"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("test")
        .expect("defaulted by clap"));
}

#[test]
fn flag_subcommand_normal_with_alias() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some")
                .short_flag('S')
                .long_flag("S")
                .arg(
                    Arg::new("test")
                        .short('t')
                        .long("test")
                        .help("testing testing")
                        .action(ArgAction::SetTrue),
                )
                .alias("result"),
        )
        .try_get_matches_from(vec!["myprog", "result", "--test"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("test")
        .expect("defaulted by clap"));
}

#[test]
fn flag_subcommand_short() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some").short_flag('S').arg(
                Arg::new("test")
                    .short('t')
                    .long("test")
                    .help("testing testing")
                    .action(ArgAction::SetTrue),
            ),
        )
        .try_get_matches_from(vec!["myprog", "-S", "--test"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("test")
        .expect("defaulted by clap"));
}

#[test]
fn flag_subcommand_short_with_args() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some").short_flag('S').arg(
                Arg::new("test")
                    .short('t')
                    .long("test")
                    .help("testing testing")
                    .action(ArgAction::SetTrue),
            ),
        )
        .try_get_matches_from(vec!["myprog", "-St"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("test")
        .expect("defaulted by clap"));
}

#[test]
fn flag_subcommand_short_with_alias() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some")
                .short_flag('S')
                .arg(
                    Arg::new("test")
                        .short('t')
                        .long("test")
                        .help("testing testing")
                        .action(ArgAction::SetTrue),
                )
                .short_flag_alias('M')
                .short_flag_alias('B'),
        )
        .try_get_matches_from(vec!["myprog", "-Bt"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("test")
        .expect("defaulted by clap"));
}

#[test]
fn flag_subcommand_short_with_alias_same_as_short_flag() {
    let matches = Command::new("test")
        .subcommand(Command::new("some").short_flag('S').short_flag_alias('S'))
        .try_get_matches_from(vec!["myprog", "-S"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
}

#[test]
fn flag_subcommand_long_with_alias_same_as_long_flag() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some")
                .long_flag("sync")
                .long_flag_alias("sync"),
        )
        .try_get_matches_from(vec!["myprog", "--sync"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
}

#[test]
fn flag_subcommand_short_with_aliases_vis_and_hidden() {
    let cmd = Command::new("test").subcommand(
        Command::new("some")
            .short_flag('S')
            .arg(
                Arg::new("test")
                    .short('t')
                    .long("test")
                    .help("testing testing"),
            )
            .visible_short_flag_aliases(['M', 'B'])
            .short_flag_alias('C'),
    );
    let app1 = cmd.clone();
    let matches1 = app1.try_get_matches_from(vec!["test", "-M"]).unwrap();
    assert_eq!(matches1.subcommand_name().unwrap(), "some");

    let app2 = cmd.clone();
    let matches2 = app2.try_get_matches_from(vec!["test", "-C"]).unwrap();
    assert_eq!(matches2.subcommand_name().unwrap(), "some");

    let app3 = cmd.clone();
    let matches3 = app3.try_get_matches_from(vec!["test", "-B"]).unwrap();
    assert_eq!(matches3.subcommand_name().unwrap(), "some");
}

#[test]
fn flag_subcommand_short_with_aliases() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some")
                .short_flag('S')
                .arg(
                    Arg::new("test")
                        .short('t')
                        .long("test")
                        .help("testing testing")
                        .action(ArgAction::SetTrue),
                )
                .short_flag_aliases(['M', 'B']),
        )
        .try_get_matches_from(vec!["myprog", "-Bt"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("test")
        .expect("defaulted by clap"));
}

#[test]
#[should_panic]
fn flag_subcommand_short_with_alias_hyphen() {
    let _ = Command::new("test")
        .subcommand(
            Command::new("some")
                .short_flag('S')
                .arg(
                    Arg::new("test")
                        .short('t')
                        .long("test")
                        .help("testing testing"),
                )
                .short_flag_alias('-'),
        )
        .try_get_matches_from(vec!["myprog", "-Bt"])
        .unwrap();
}

#[test]
#[should_panic]
fn flag_subcommand_short_with_aliases_hyphen() {
    let _ = Command::new("test")
        .subcommand(
            Command::new("some")
                .short_flag('S')
                .arg(
                    Arg::new("test")
                        .short('t')
                        .long("test")
                        .help("testing testing"),
                )
                .short_flag_aliases(['-', '-', '-']),
        )
        .try_get_matches_from(vec!["myprog", "-Bt"])
        .unwrap();
}

#[test]
fn flag_subcommand_short_after_long_arg() {
    let m = Command::new("pacman")
        .subcommand(
            Command::new("sync")
                .short_flag('S')
                .arg(Arg::new("clean").short('c').action(ArgAction::SetTrue)),
        )
        .arg(Arg::new("arg").long("arg").action(ArgAction::Set))
        .try_get_matches_from(vec!["pacman", "--arg", "foo", "-Sc"])
        .unwrap();
    let subm = m.subcommand_matches("sync");
    assert!(subm.is_some());
    let subm = subm.unwrap();
    assert!(*subm.get_one::<bool>("clean").expect("defaulted by clap"));
}

#[test]
fn flag_subcommand_long() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some").long_flag("some").arg(
                Arg::new("test")
                    .short('t')
                    .long("test")
                    .help("testing testing")
                    .action(ArgAction::SetTrue),
            ),
        )
        .try_get_matches_from(vec!["myprog", "--some", "--test"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("test")
        .expect("defaulted by clap"));
}

#[test]
fn flag_subcommand_long_with_alias() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some")
                .long_flag("some")
                .arg(
                    Arg::new("test")
                        .short('t')
                        .long("test")
                        .help("testing testing")
                        .action(ArgAction::SetTrue),
                )
                .long_flag_alias("result"),
        )
        .try_get_matches_from(vec!["myprog", "--result", "--test"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("test")
        .expect("defaulted by clap"));
}

#[test]
fn flag_subcommand_long_with_aliases() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some")
                .long_flag("some")
                .arg(
                    Arg::new("test")
                        .short('t')
                        .long("test")
                        .help("testing testing")
                        .action(ArgAction::SetTrue),
                )
                .long_flag_aliases(["result", "someall"]),
        )
        .try_get_matches_from(vec!["myprog", "--result", "--test"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("test")
        .expect("defaulted by clap"));
}

#[test]
fn flag_subcommand_multiple() {
    let matches = Command::new("test")
        .subcommand(
            Command::new("some")
                .short_flag('S')
                .long_flag("some")
                .arg(arg!(-f --flag "some flag").action(ArgAction::SetTrue))
                .arg(arg!(-p --print "print something").action(ArgAction::SetTrue))
                .subcommand(
                    Command::new("result")
                        .short_flag('R')
                        .long_flag("result")
                        .arg(arg!(-f --flag "some flag").action(ArgAction::SetTrue))
                        .arg(arg!(-p --print "print something").action(ArgAction::SetTrue)),
                ),
        )
        .try_get_matches_from(vec!["myprog", "-SfpRfp"])
        .unwrap();
    assert_eq!(matches.subcommand_name().unwrap(), "some");
    let sub_matches = matches.subcommand_matches("some").unwrap();
    assert!(*sub_matches
        .get_one::<bool>("flag")
        .expect("defaulted by clap"));
    assert!(*sub_matches
        .get_one::<bool>("print")
        .expect("defaulted by clap"));
    assert_eq!(sub_matches.subcommand_name().unwrap(), "result");
    let result_matches = sub_matches.subcommand_matches("result").unwrap();
    assert!(*result_matches
        .get_one::<bool>("flag")
        .expect("defaulted by clap"));
    assert!(*result_matches
        .get_one::<bool>("print")
        .expect("defaulted by clap"));
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "the \'-f\' short flag for the \'test\' argument conflicts with the short flag for \'some\' subcommand"]
fn flag_subcommand_short_conflict_with_arg() {
    let _ = Command::new("test")
        .subcommand(Command::new("some").short_flag('f').long_flag("some"))
        .arg(Arg::new("test").short('f'))
        .try_get_matches_from(vec!["myprog", "-f"])
        .unwrap();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "the \'-f\' short flag is specified for both \'some\' and \'result\' subcommands"]
fn flag_subcommand_short_conflict_with_alias() {
    let _ = Command::new("test")
        .subcommand(Command::new("some").short_flag('f').long_flag("some"))
        .subcommand(Command::new("result").short_flag('t').short_flag_alias('f'))
        .try_get_matches_from(vec!["myprog", "-f"])
        .unwrap();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "the \'--flag\' long flag is specified for both \'some\' and \'result\' subcommands"]
fn flag_subcommand_long_conflict_with_alias() {
    let _ = Command::new("test")
        .subcommand(Command::new("some").long_flag("flag"))
        .subcommand(
            Command::new("result")
                .long_flag("test")
                .long_flag_alias("flag"),
        )
        .try_get_matches_from(vec!["myprog", "--flag"])
        .unwrap();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "the \'-f\' short flag for the \'test\' argument conflicts with the short flag for \'some\' subcommand"]
fn flag_subcommand_short_conflict_with_arg_alias() {
    let _ = Command::new("test")
        .subcommand(Command::new("some").short_flag('f').long_flag("some"))
        .arg(Arg::new("test").short('t').short_alias('f'))
        .try_get_matches_from(vec!["myprog", "-f"])
        .unwrap();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "the \'--some\' long flag for the \'test\' argument conflicts with the short flag for \'some\' subcommand"]
fn flag_subcommand_long_conflict_with_arg_alias() {
    let _ = Command::new("test")
        .subcommand(Command::new("some").short_flag('f').long_flag("some"))
        .arg(Arg::new("test").long("test").alias("some"))
        .try_get_matches_from(vec!["myprog", "--some"])
        .unwrap();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "the \'--flag\' long flag for the \'flag\' argument conflicts with the short flag for \'some\' subcommand"]
fn flag_subcommand_long_conflict_with_arg() {
    let _ = Command::new("test")
        .subcommand(Command::new("some").short_flag('a').long_flag("flag"))
        .arg(Arg::new("flag").long("flag"))
        .try_get_matches_from(vec!["myprog", "--flag"])
        .unwrap();
}

#[test]
#[should_panic = "the '--help' long flag for the 'help' argument conflicts with the short flag for 'help' subcommand"]
fn flag_subcommand_conflict_with_help() {
    let _ = Command::new("test")
        .subcommand(Command::new("help").short_flag('h').long_flag("help"))
        .try_get_matches_from(vec!["myprog", "--help"])
        .unwrap();
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "the '--version' long flag for the 'version' argument conflicts with the short flag for 'ver' subcommand"]
fn flag_subcommand_conflict_with_version() {
    let _ = Command::new("test")
        .version("1.0.0")
        .subcommand(Command::new("ver").short_flag('V').long_flag("version"))
        .try_get_matches_from(vec!["myprog", "--version"])
        .unwrap();
}

#[test]
fn flag_subcommand_long_infer_pass() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test").long_flag("test"))
        .try_get_matches_from(vec!["prog", "--te"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

#[cfg(not(feature = "suggestions"))]
#[test]
fn flag_subcommand_long_infer_fail() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test").long_flag("test"))
        .subcommand(Command::new("temp").long_flag("temp"))
        .try_get_matches_from(vec!["prog", "--te"]);
    assert!(m.is_err(), "{:#?}", m.unwrap());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[cfg(feature = "suggestions")]
#[test]
fn flag_subcommand_long_infer_fail() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test").long_flag("test"))
        .subcommand(Command::new("temp").long_flag("temp"))
        .try_get_matches_from(vec!["prog", "--te"]);
    assert!(m.is_err(), "{:#?}", m.unwrap());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[test]
fn flag_subcommand_long_infer_pass_close() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test").long_flag("test"))
        .subcommand(Command::new("temp").long_flag("temp"))
        .try_get_matches_from(vec!["prog", "--tes"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

#[test]
fn flag_subcommand_long_infer_exact_match() {
    let m = Command::new("prog")
        .infer_subcommands(true)
        .subcommand(Command::new("test").long_flag("test"))
        .subcommand(Command::new("testa").long_flag("testa"))
        .subcommand(Command::new("testb").long_flag("testb"))
        .try_get_matches_from(vec!["prog", "--test"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

static FLAG_SUBCOMMAND_HELP: &str = "\
Query the package database.

Usage: pacman {query|--query|-Q} [OPTIONS]

Options:
  -s, --search <search>...  search locally installed packages for matching strings
  -i, --info <info>...      view package information
  -h, --help                Print help
";

#[test]
fn flag_subcommand_long_short_normal_usage_string() {
    let cmd = Command::new("pacman")
        .about("package manager utility")
        .version("5.2.1")
        .subcommand_required(true)
        .author("Pacman Development Team")
        // Query subcommand
        //
        // Only a few of its arguments are implemented below.
        .subcommand(
            Command::new("query")
                .short_flag('Q')
                .long_flag("query")
                .about("Query the package database.")
                .arg(
                    Arg::new("search")
                        .short('s')
                        .long("search")
                        .help("search locally installed packages for matching strings")
                        .conflicts_with("info")
                        .action(ArgAction::Set)
                        .num_args(1..),
                )
                .arg(
                    Arg::new("info")
                        .long("info")
                        .short('i')
                        .conflicts_with("search")
                        .help("view package information")
                        .action(ArgAction::Set)
                        .num_args(1..),
                ),
        );
    utils::assert_output(cmd, "pacman -Qh", FLAG_SUBCOMMAND_HELP, false);
}

static FLAG_SUBCOMMAND_NO_SHORT_HELP: &str = "\
Query the package database.

Usage: pacman {query|--query} [OPTIONS]

Options:
  -s, --search <search>...  search locally installed packages for matching strings
  -i, --info <info>...      view package information
  -h, --help                Print help
";

#[test]
fn flag_subcommand_long_normal_usage_string() {
    let cmd = Command::new("pacman")
        .about("package manager utility")
        .version("5.2.1")
        .subcommand_required(true)
        .author("Pacman Development Team")
        // Query subcommand
        //
        // Only a few of its arguments are implemented below.
        .subcommand(
            Command::new("query")
                .long_flag("query")
                .about("Query the package database.")
                .arg(
                    Arg::new("search")
                        .short('s')
                        .long("search")
                        .help("search locally installed packages for matching strings")
                        .conflicts_with("info")
                        .action(ArgAction::Set)
                        .num_args(1..),
                )
                .arg(
                    Arg::new("info")
                        .long("info")
                        .short('i')
                        .conflicts_with("search")
                        .help("view package information")
                        .action(ArgAction::Set)
                        .num_args(1..),
                ),
        );
    utils::assert_output(
        cmd,
        "pacman query --help",
        FLAG_SUBCOMMAND_NO_SHORT_HELP,
        false,
    );
}

static FLAG_SUBCOMMAND_NO_LONG_HELP: &str = "\
Query the package database.

Usage: pacman {query|-Q} [OPTIONS]

Options:
  -s, --search <search>...  search locally installed packages for matching strings
  -i, --info <info>...      view package information
  -h, --help                Print help
";

#[test]
fn flag_subcommand_short_normal_usage_string() {
    let cmd = Command::new("pacman")
        .about("package manager utility")
        .version("5.2.1")
        .subcommand_required(true)
        .author("Pacman Development Team")
        // Query subcommand
        //
        // Only a few of its arguments are implemented below.
        .subcommand(
            Command::new("query")
                .short_flag('Q')
                .about("Query the package database.")
                .arg(
                    Arg::new("search")
                        .short('s')
                        .long("search")
                        .help("search locally installed packages for matching strings")
                        .conflicts_with("info")
                        .action(ArgAction::Set)
                        .num_args(1..),
                )
                .arg(
                    Arg::new("info")
                        .long("info")
                        .short('i')
                        .conflicts_with("search")
                        .help("view package information")
                        .action(ArgAction::Set)
                        .num_args(1..),
                ),
        );
    utils::assert_output(
        cmd,
        "pacman query --help",
        FLAG_SUBCOMMAND_NO_LONG_HELP,
        false,
    );
}

```

`clap/tests/builder/flags.rs`:

```rs
use clap::{arg, Arg, ArgAction, Command};

#[cfg(feature = "error-context")]
use super::utils;

#[test]
fn flag_using_short() {
    let m = Command::new("flag")
        .args([
            arg!(-f --flag "some flag").action(ArgAction::SetTrue),
            arg!(-c --color "some other flag").action(ArgAction::SetTrue),
        ])
        .try_get_matches_from(vec!["", "-f", "-c"])
        .unwrap();
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
}

#[test]
fn lots_o_flags_sep() {
    let r = Command::new("opts")
        .args_override_self(true)
        .arg(arg!(o: -o ... "some flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec![
            "", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o", "-o",
            "-o", "-o", "-o",
        ]);
    assert!(r.is_ok(), "{:?}", r.unwrap_err().kind());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert!(*m.get_one::<bool>("o").expect("defaulted by clap"));
}

#[test]
fn lots_o_flags_combined() {
    let r = Command::new("opts")
        .args_override_self(true)
        .arg(arg!(o: -o ... "some flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec![
            "",
            "-oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo",
            "-oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo",
            "-oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo",
            "-oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo",
            "-ooooooooooooooooooooooooooooooooooooooooo",
        ]);
    assert!(r.is_ok(), "{:?}", r.unwrap_err().kind());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert!(*m.get_one::<bool>("o").expect("defaulted by clap"));
}

#[test]
fn flag_using_long() {
    let m = Command::new("flag")
        .args([
            arg!(--flag "some flag").action(ArgAction::SetTrue),
            arg!(--color "some other flag").action(ArgAction::SetTrue),
        ])
        .try_get_matches_from(vec!["", "--flag", "--color"])
        .unwrap();
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
}

#[test]
fn flag_using_long_with_literals() {
    use clap::error::ErrorKind;

    let m = Command::new("flag")
        .arg(
            Arg::new("rainbow")
                .long("rainbow")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["", "--rainbow=false"]);
    assert!(m.is_err(), "{:#?}", m.unwrap());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::TooManyValues);
}

#[test]
fn flag_using_mixed() {
    let m = Command::new("flag")
        .args([
            arg!(-f --flag "some flag").action(ArgAction::SetTrue),
            arg!(-c --color "some other flag").action(ArgAction::SetTrue),
        ])
        .try_get_matches_from(vec!["", "-f", "--color"])
        .unwrap();
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));

    let m = Command::new("flag")
        .args([
            arg!(-f --flag "some flag").action(ArgAction::SetTrue),
            arg!(-c --color "some other flag").action(ArgAction::SetTrue),
        ])
        .try_get_matches_from(vec!["", "--flag", "-c"])
        .unwrap();
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
}

#[test]
fn multiple_flags_in_single() {
    let m = Command::new("multe_flags")
        .args([
            arg!(-f --flag "some flag").action(ArgAction::SetTrue),
            arg!(-c --color "some other flag").action(ArgAction::SetTrue),
            arg!(-d --debug "another other flag").action(ArgAction::SetTrue),
        ])
        .try_get_matches_from(vec!["", "-fcd"])
        .unwrap();
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("debug").expect("defaulted by clap"));
}

#[test]
#[cfg(feature = "error-context")]
fn unexpected_value_error() {
    const USE_FLAG_AS_ARGUMENT: &str = "\
error: unexpected value 'foo' for '--a-flag' found; no more were expected

Usage: mycat --a-flag [filename]

For more information, try '--help'.
";

    let cmd = Command::new("mycat")
        .arg(Arg::new("filename"))
        .arg(Arg::new("a-flag").long("a-flag").action(ArgAction::SetTrue));

    utils::assert_output(cmd, "mycat --a-flag=foo", USE_FLAG_AS_ARGUMENT, true);
}

#[test]
#[cfg(feature = "error-context")]
fn issue_1284_argument_in_flag_style() {
    const USE_FLAG_AS_ARGUMENT: &str = "\
error: unexpected argument '--another-flag' found

  tip: to pass '--another-flag' as a value, use '-- --another-flag'

Usage: mycat [OPTIONS] [filename]

For more information, try '--help'.
";

    let cmd = Command::new("mycat")
        .arg(Arg::new("filename"))
        .arg(Arg::new("a-flag").long("a-flag").action(ArgAction::SetTrue));

    let m = cmd
        .clone()
        .try_get_matches_from(vec!["", "--", "--another-flag"])
        .unwrap();
    assert_eq!(
        m.get_one::<String>("filename").map(|v| v.as_str()),
        Some("--another-flag")
    );

    let m = cmd
        .clone()
        .try_get_matches_from(vec!["", "--a-flag"])
        .unwrap();
    assert!(*m.get_one::<bool>("a-flag").expect("defaulted by clap"));

    let m = cmd
        .clone()
        .try_get_matches_from(vec!["", "--", "--a-flag"])
        .unwrap();
    assert_eq!(
        m.get_one::<String>("filename").map(|v| v.as_str()),
        Some("--a-flag")
    );

    utils::assert_output(cmd, "mycat --another-flag", USE_FLAG_AS_ARGUMENT, true);
}

#[test]
#[cfg(feature = "error-context")]
fn issue_2308_multiple_dashes() {
    static MULTIPLE_DASHES: &str = "\
error: unexpected argument '-----' found

  tip: to pass '-----' as a value, use '-- -----'

Usage: test <arg>

For more information, try '--help'.
";
    let cmd = Command::new("test").arg(Arg::new("arg").action(ArgAction::Set).required(true));

    utils::assert_output(cmd, "test -----", MULTIPLE_DASHES, true);
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "Argument filename: long \"--filename\" must not start with a `-`, that will be handled by the parser"]
fn leading_dash_stripped() {
    let cmd = Command::new("mycat").arg(Arg::new("filename").long("--filename"));
    cmd.debug_assert();
}

#[test]
fn optional_value() {
    let cmd = Command::new("flag").args([arg!(-f --flag "some flag")
        .action(ArgAction::SetTrue)
        .num_args(0..=1)]);

    let m = cmd.clone().try_get_matches_from(vec![""]).unwrap();
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));

    let m = cmd.clone().try_get_matches_from(vec!["", "-f"]).unwrap();
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));

    let m = cmd
        .clone()
        .try_get_matches_from(vec!["", "-f", "false"])
        .unwrap();
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));

    let m = cmd
        .clone()
        .try_get_matches_from(vec!["", "-f", "true"])
        .unwrap();
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

```

`clap/tests/builder/global_args.rs`:

```rs
use clap::{arg, Arg, ArgAction, Command};

#[test]
fn issue_1076() {
    let mut cmd = Command::new("myprog")
        .arg(
            Arg::new("GLOBAL_ARG")
                .long("global-arg")
                .help("Specifies something needed by the subcommands")
                .global(true)
                .action(ArgAction::Set)
                .default_value("default_value"),
        )
        .arg(
            Arg::new("GLOBAL_FLAG")
                .long("global-flag")
                .help("Specifies something needed by the subcommands")
                .global(true)
                .action(ArgAction::Set),
        )
        .subcommand(Command::new("outer").subcommand(Command::new("inner")));
    let _ = cmd.try_get_matches_from_mut(vec!["myprog"]);
    let _ = cmd.try_get_matches_from_mut(vec!["myprog"]);
    let _ = cmd.try_get_matches_from_mut(vec!["myprog"]);
}

#[test]
fn propagate_global_arg_in_subcommand_to_subsubcommand_1385() {
    let m1 = Command::new("foo")
        .subcommand(
            Command::new("sub1")
                .arg(
                    Arg::new("arg1")
                        .long("arg1")
                        .action(ArgAction::Set)
                        .global(true),
                )
                .subcommand(Command::new("sub1a")),
        )
        .try_get_matches_from(["foo", "sub1", "--arg1", "v1", "sub1a"])
        .unwrap();
    assert_eq!(
        "v1",
        m1.subcommand_matches("sub1")
            .unwrap()
            .subcommand_matches("sub1a")
            .unwrap()
            .get_one::<String>("arg1")
            .map(|v| v.as_str())
            .unwrap()
    );
}

#[test]
fn propagate_global_arg_to_subcommand_in_subsubcommand_2053() {
    let m = Command::new("opts")
        .arg(arg!(--"global-flag").global(true))
        .arg(arg!(--"global-str" <str>).global(true))
        .subcommand(
            Command::new("test")
                .arg(arg!(--"sub-flag").global(true))
                .arg(arg!(--"sub-str" <str>).global(true))
                .subcommand(Command::new("test")),
        )
        .try_get_matches_from([
            "cmd",
            "test",
            "test",
            "--global-flag",
            "--global-str",
            "hello",
            "--sub-flag",
            "--sub-str",
            "world",
        ])
        .unwrap();
    assert_eq!(
        Some("world"),
        m.subcommand_matches("test")
            .unwrap()
            .get_one::<String>("sub-str")
            .map(|v| v.as_str())
    );
}

#[test]
fn global_arg_available_in_subcommand() {
    let m = Command::new("opt")
        .args([
            Arg::new("global")
                .global(true)
                .long("global")
                .action(ArgAction::SetTrue),
            Arg::new("not")
                .global(false)
                .long("not")
                .action(ArgAction::SetTrue),
        ])
        .subcommand(Command::new("ping"))
        .try_get_matches_from(["opt", "ping", "--global"])
        .unwrap();

    assert!(*m.get_one::<bool>("global").expect("defaulted by clap"));
    assert!(*m
        .subcommand_matches("ping")
        .unwrap()
        .get_one::<bool>("global")
        .expect("defaulted by clap"));
}

#[test]
fn deeply_nested_discovery() {
    let cmd = Command::new("a")
        .arg(arg!(--"long-a").global(true).action(ArgAction::SetTrue))
        .subcommand(
            Command::new("b")
                .arg(arg!(--"long-b").global(true).action(ArgAction::SetTrue))
                .subcommand(
                    Command::new("c")
                        .arg(arg!(--"long-c").global(true).action(ArgAction::SetTrue))
                        .subcommand(Command::new("d")),
                ),
        );

    let m = cmd
        .try_get_matches_from(["a", "b", "c", "d", "--long-a", "--long-b", "--long-c"])
        .unwrap();
    assert!(*m.get_one::<bool>("long-a").expect("defaulted by clap"));
    let m = m.subcommand_matches("b").unwrap();
    assert!(*m.get_one::<bool>("long-b").expect("defaulted by clap"));
    let m = m.subcommand_matches("c").unwrap();
    assert!(*m.get_one::<bool>("long-c").expect("defaulted by clap"));
}

#[test]
fn global_overrides_default() {
    let cmd = Command::new("test")
        .arg(
            Arg::new("name")
                .long("name")
                .global(true)
                .action(ArgAction::Set)
                .default_value("from_default"),
        )
        .subcommand(Command::new("sub"));

    let m = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(
        m.get_one::<String>("name").unwrap().as_str(),
        "from_default"
    );

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "--name", "from_arg"])
        .unwrap();
    assert_eq!(m.get_one::<String>("name").unwrap().as_str(), "from_arg");

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "--name", "from_arg", "sub"])
        .unwrap();
    assert_eq!(m.get_one::<String>("name").unwrap().as_str(), "from_arg");

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "sub", "--name", "from_arg"])
        .unwrap();
    assert_eq!(m.get_one::<String>("name").unwrap().as_str(), "from_arg");
}

#[test]
#[cfg(feature = "env")]
fn global_overrides_env() {
    std::env::set_var("GLOBAL_OVERRIDES_ENV", "from_env");

    let cmd = Command::new("test")
        .arg(
            Arg::new("name")
                .long("name")
                .global(true)
                .action(ArgAction::Set)
                .env("GLOBAL_OVERRIDES_ENV"),
        )
        .subcommand(Command::new("sub"));

    let m = cmd.clone().try_get_matches_from(["test"]).unwrap();
    assert_eq!(m.get_one::<String>("name").unwrap().as_str(), "from_env");

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "--name", "from_arg"])
        .unwrap();
    assert_eq!(m.get_one::<String>("name").unwrap().as_str(), "from_arg");

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "--name", "from_arg", "sub"])
        .unwrap();
    assert_eq!(m.get_one::<String>("name").unwrap().as_str(), "from_arg");

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "sub", "--name", "from_arg"])
        .unwrap();
    assert_eq!(m.get_one::<String>("name").unwrap().as_str(), "from_arg");
}

```

`clap/tests/builder/groups.rs`:

```rs
use clap::{arg, error::ErrorKind, Arg, ArgAction, ArgGroup, Command, Id};

use super::utils;

#[test]
fn required_group_missing_arg() {
    let result = Command::new("group")
        .arg(arg!(-f --flag "some flag"))
        .arg(arg!( -c --color "some other flag"))
        .group(ArgGroup::new("req").args(["flag", "color"]).required(true))
        .try_get_matches_from(vec![""]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command group: Argument group 'req' contains non-existent argument"]
fn non_existing_arg() {
    let _ = Command::new("group")
        .arg(arg!(-f --flag "some flag"))
        .arg(arg!(-c --color "some other flag"))
        .group(ArgGroup::new("req").args(["flg", "color"]).required(true))
        .try_get_matches_from(vec![""]);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command group: Argument group name must be unique\n\n\t'req' is already in use"]
fn unique_group_name() {
    let _ = Command::new("group")
        .arg(arg!(-f --flag "some flag"))
        .arg(arg!(-c --color "some other flag"))
        .group(ArgGroup::new("req").args(["flag"]).required(true))
        .group(ArgGroup::new("req").args(["color"]).required(true))
        .try_get_matches_from(vec![""]);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command group: Argument group name 'a' must not conflict with argument name"]
fn groups_new_of_arg_name() {
    let _ = Command::new("group")
        .arg(Arg::new("a").long("a").group("a"))
        .try_get_matches_from(vec!["", "--a"]);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command group: Argument group name 'a' must not conflict with argument name"]
fn arg_group_new_of_arg_name() {
    let _ = Command::new("group")
        .arg(Arg::new("a").long("a").group("a"))
        .group(ArgGroup::new("a"))
        .try_get_matches_from(vec!["", "--a"]);
}

#[test]
fn group_single_value() {
    let res = Command::new("group")
        .arg(arg!(-c --color [color] "some option"))
        .arg(arg!(-n --hostname <name> "another option"))
        .group(ArgGroup::new("grp").args(["hostname", "color"]))
        .try_get_matches_from(vec!["", "-c", "blue"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());

    let m = res.unwrap();
    assert!(m.contains_id("grp"));
    assert_eq!(m.get_one::<Id>("grp").map(|v| v.as_str()).unwrap(), "color");
}

#[test]
fn group_empty() {
    let res = Command::new("group")
        .arg(arg!(-f --flag "some flag"))
        .arg(arg!(-c --color [color] "some option"))
        .arg(arg!(-n --hostname <name> "another option"))
        .group(ArgGroup::new("grp").args(["hostname", "color", "flag"]))
        .try_get_matches_from(vec![""]);
    assert!(res.is_ok(), "{}", res.unwrap_err());

    let m = res.unwrap();
    assert!(!m.contains_id("grp"));
    assert!(m.get_one::<String>("grp").map(|v| v.as_str()).is_none());
}

#[test]
fn group_required_flags_empty() {
    let result = Command::new("group")
        .arg(arg!(-f --flag "some flag"))
        .arg(arg!(-c --color "some option"))
        .arg(arg!(-n --hostname <name> "another option"))
        .group(
            ArgGroup::new("grp")
                .required(true)
                .args(["hostname", "color", "flag"]),
        )
        .try_get_matches_from(vec![""]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn group_multi_value_single_arg() {
    let res = Command::new("group")
        .arg(arg!(-f --flag "some flag"))
        .arg(arg!(-c --color <color> "some option").num_args(1..))
        .arg(arg!(-n --hostname <name> "another option"))
        .group(ArgGroup::new("grp").args(["hostname", "color", "flag"]))
        .try_get_matches_from(vec!["", "-c", "blue", "red", "green"]);
    assert!(res.is_ok(), "{:?}", res.unwrap_err().kind());

    let m = res.unwrap();
    assert!(m.contains_id("grp"));
    assert_eq!(m.get_one::<Id>("grp").map(|v| v.as_str()).unwrap(), "color");
}

#[test]
fn empty_group() {
    let r = Command::new("empty_group")
        .arg(arg!(-f --flag "some flag"))
        .group(ArgGroup::new("vers").required(true))
        .try_get_matches_from(vec!["empty_prog"]);
    assert!(r.is_err());
    let err = r.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
#[cfg(feature = "error-context")]
fn req_group_usage_string() {
    static REQ_GROUP_USAGE: &str = "error: the following required arguments were not provided:
  <base|--delete>

Usage: clap-test <base|--delete>

For more information, try '--help'.
";

    let cmd = Command::new("req_group")
        .arg(arg!([base] "Base commit"))
        .arg(arg!(
            -d --delete "Remove the base commit information"
        ))
        .group(
            ArgGroup::new("base_or_delete")
                .args(["base", "delete"])
                .required(true),
        );

    utils::assert_output(cmd, "clap-test", REQ_GROUP_USAGE, true);
}

#[test]
#[cfg(feature = "error-context")]
fn req_group_with_conflict_usage_string() {
    static REQ_GROUP_CONFLICT_USAGE: &str = "\
error: the argument '--delete' cannot be used with '[base]'

Usage: clap-test <base|--delete>

For more information, try '--help'.
";

    let cmd = Command::new("req_group")
        .arg(arg!([base] "Base commit").conflicts_with("delete"))
        .arg(arg!(
            -d --delete "Remove the base commit information"
        ))
        .group(
            ArgGroup::new("base_or_delete")
                .args(["base", "delete"])
                .required(true),
        );

    utils::assert_output(
        cmd,
        "clap-test --delete base",
        REQ_GROUP_CONFLICT_USAGE,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn req_group_with_conflict_usage_string_only_options() {
    static REQ_GROUP_CONFLICT_ONLY_OPTIONS: &str = "\
error: the argument '--delete' cannot be used with '--all'

Usage: clap-test <--all|--delete>

For more information, try '--help'.
";

    let cmd = Command::new("req_group")
        .arg(arg!(-a --all "All").conflicts_with("delete"))
        .arg(arg!(
            -d --delete "Remove the base commit information"
        ))
        .group(
            ArgGroup::new("all_or_delete")
                .args(["all", "delete"])
                .required(true),
        );
    utils::assert_output(
        cmd,
        "clap-test --delete --all",
        REQ_GROUP_CONFLICT_ONLY_OPTIONS,
        true,
    );
}

#[test]
fn required_group_multiple_args() {
    let result = Command::new("group")
        .arg(arg!(-f --flag "some flag").action(ArgAction::SetTrue))
        .arg(arg!(-c --color "some other flag").action(ArgAction::SetTrue))
        .group(
            ArgGroup::new("req")
                .args(["flag", "color"])
                .required(true)
                .multiple(true),
        )
        .try_get_matches_from(vec!["group", "-f", "-c"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
    let m = result.unwrap();
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert_eq!(
        &*m.get_many::<Id>("req")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["flag", "color"]
    );
}

#[test]
fn group_multiple_args_error() {
    let result = Command::new("group")
        .arg(arg!(-f --flag "some flag"))
        .arg(arg!(-c --color "some other flag"))
        .group(ArgGroup::new("req").args(["flag", "color"]))
        .try_get_matches_from(vec!["group", "-f", "-c"]);
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
}

#[test]
fn group_overrides_required() {
    let command = Command::new("group")
        .arg(arg!(--foo <FOO>).required(true))
        .arg(arg!(--bar <BAR>).required(true))
        .group(ArgGroup::new("group").args(["foo", "bar"]).required(true));
    let result = command.try_get_matches_from(vec!["group", "--foo", "value"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
    let m = result.unwrap();
    assert!(m.contains_id("foo"));
    assert!(!m.contains_id("bar"));
}

#[test]
fn group_usage_use_val_name() {
    static GROUP_USAGE_USE_VAL_NAME: &str = "\
Usage: prog <A>

Arguments:
  [A]  

Options:
  -h, --help  Print help
";
    let cmd = Command::new("prog")
        .arg(Arg::new("a").value_name("A"))
        .group(ArgGroup::new("group").arg("a").required(true));
    utils::assert_output(cmd, "prog --help", GROUP_USAGE_USE_VAL_NAME, false);
}

#[test]
fn group_acts_like_arg() {
    let result = Command::new("prog")
        .arg(
            Arg::new("debug")
                .long("debug")
                .group("mode")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("verbose")
                .long("verbose")
                .group("mode")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["prog", "--debug"]);

    assert!(result.is_ok(), "{}", result.unwrap_err());
    let m = result.unwrap();
    assert!(m.contains_id("mode"));
    assert_eq!(m.get_one::<Id>("mode").unwrap(), "debug");
}

#[test]
fn conflict_with_overlapping_group_in_error() {
    static ERR: &str = "\
error: the argument '--major' cannot be used with '--minor'

Usage: prog --major

For more information, try '--help'.
";

    let cmd = Command::new("prog")
        .group(ArgGroup::new("all").multiple(true))
        .arg(arg!(--major).group("vers").group("all"))
        .arg(arg!(--minor).group("vers").group("all"))
        .arg(arg!(--other).group("all"));

    utils::assert_output(cmd, "prog --major --minor", ERR, true);
}

#[test]
fn requires_group_with_overlapping_group_in_error() {
    static ERR: &str = "\
error: the following required arguments were not provided:
  <--in|--spec>

Usage: prog --config <--in|--spec>

For more information, try '--help'.
";

    let cmd = Command::new("prog")
        .group(ArgGroup::new("all").multiple(true))
        .group(ArgGroup::new("input").required(true))
        .arg(arg!(--in).group("input").group("all"))
        .arg(arg!(--spec).group("input").group("all"))
        .arg(arg!(--config).requires("input").group("all"));

    utils::assert_output(cmd, "prog --config", ERR, true);
}

/* This is used to be fixed in a hack, we need to find a better way to fix it.
#[test]
fn issue_1794() {
    let cmd = clap::Command::new("hello")
        .bin_name("deno")
        .arg(Arg::new("option1").long("option1").action(ArgAction::SetTrue))
        .arg(Arg::new("pos1").action(ArgAction::Set))
        .arg(Arg::new("pos2").action(ArgAction::Set))
        .group(
            ArgGroup::new("arg1")
                .args(["pos1", "option1"])
                .required(true),
        );

    let m = cmd.clone().try_get_matches_from(["cmd", "pos1", "pos2"]).unwrap();
    assert_eq!(m.get_one::<String>("pos1").map(|v| v.as_str()), Some("pos1"));
    assert_eq!(m.get_one::<String>("pos2").map(|v| v.as_str()), Some("pos2"));
    assert!(!*m.get_one::<bool>("option1").expect("defaulted by clap"));

    let m = cmd
        .clone()
        .try_get_matches_from(["cmd", "--option1", "positional"]).unwrap();
    assert_eq!(m.get_one::<String>("pos1").map(|v| v.as_str()), None);
    assert_eq!(m.get_one::<String>("pos2").map(|v| v.as_str()), Some("positional"));
    assert!(*m.get_one::<bool>("option1").expect("defaulted by clap"));
}
*/

```

`clap/tests/builder/help.rs`:

```rs
#![cfg(feature = "help")]

use clap::{arg, builder::PossibleValue, error::ErrorKind, Arg, ArgAction, ArgGroup, Command};
use snapbox::assert_data_eq;
use snapbox::str;

use super::utils;

fn setup() -> Command {
    Command::new("test")
        .author("Kevin K.")
        .about("tests stuff")
        .version("1.3")
}

fn empty_args() -> impl IntoIterator<Item = String> {
    std::iter::empty()
}

#[test]
fn help_short() {
    let m = setup().try_get_matches_from(vec!["myprog", "-h"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::DisplayHelp);
}

#[test]
fn help_long() {
    let m = setup().try_get_matches_from(vec!["myprog", "--help"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::DisplayHelp);
}

#[test]
fn help_no_subcommand() {
    let m = setup().try_get_matches_from(vec!["myprog", "help"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[test]
fn help_subcommand() {
    let m = setup()
        .subcommand(
            Command::new("test")
                .about("tests things")
                .arg(arg!(-v --verbose "with verbosity")),
        )
        .try_get_matches_from(vec!["myprog", "help"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::DisplayHelp);
}

#[test]
#[cfg(feature = "error-context")]
fn help_multi_subcommand_error() {
    let cmd = Command::new("ctest").subcommand(
        Command::new("subcmd").subcommand(
            Command::new("multi")
                .about("tests subcommands")
                .author("Kevin K. <kbknapp@gmail.com>")
                .version("0.1")
                .arg(arg!(
                    -f --flag                    "tests flags"
                ))
                .arg(
                    arg!(
                        -o --option <scoption>    "tests options"
                    )
                    .required(false)
                    .num_args(1..)
                    .action(ArgAction::Append),
                ),
        ),
    );
    let err = cmd
        .try_get_matches_from(["ctest", "help", "subcmd", "multi", "foo"])
        .unwrap_err();

    assert_data_eq!(
        err.to_string(),
        str![[r#"
error: unrecognized subcommand 'foo'

Usage: ctest subcmd multi [OPTIONS]

For more information, try '--help'.

"#]]
    );
}

#[test]
fn req_last_arg_usage() {
    let cmd = Command::new("example")
        .version("1.0")
        .arg(Arg::new("FIRST").help("First").num_args(1..).required(true))
        .arg(
            Arg::new("SECOND")
                .help("Second")
                .num_args(1..)
                .required(true)
                .last(true),
        );
    let expected = str![[r#"
Usage: example <FIRST>... -- <SECOND>...

Arguments:
  <FIRST>...   First
  <SECOND>...  Second

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "example --help", expected, false);
}

#[test]
fn args_with_last_usage() {
    let cmd = Command::new("flamegraph")
        .version("0.1")
        .arg(
            Arg::new("verbose")
                .help("Prints out more stuff.")
                .short('v')
                .long("verbose")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("timeout")
                .help("Timeout in seconds.")
                .short('t')
                .long("timeout")
                .value_name("SECONDS"),
        )
        .arg(
            Arg::new("frequency")
                .help("The sampling frequency.")
                .short('f')
                .long("frequency")
                .value_name("HERTZ"),
        )
        .arg(
            Arg::new("binary path")
                .help("The path of the binary to be profiled. for a binary.")
                .value_name("BINFILE"),
        )
        .arg(
            Arg::new("pass through args")
                .help("Any arguments you wish to pass to the being profiled.")
                .action(ArgAction::Set)
                .num_args(1..)
                .last(true)
                .value_name("ARGS"),
        );
    let expected = str![[r#"
Usage: flamegraph [OPTIONS] [BINFILE] [-- <ARGS>...]

Arguments:
  [BINFILE]  The path of the binary to be profiled. for a binary.
  [ARGS]...  Any arguments you wish to pass to the being profiled.

Options:
  -v, --verbose            Prints out more stuff.
  -t, --timeout <SECONDS>  Timeout in seconds.
  -f, --frequency <HERTZ>  The sampling frequency.
  -h, --help               Print help
  -V, --version            Print version

"#]];
    utils::assert_output(cmd, "flamegraph --help", expected, false);
}

#[test]
fn subcommand_short_help() {
    let m = utils::complex_app().try_get_matches_from(vec!["clap-test", "subcmd", "-h"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::DisplayHelp);
}

#[test]
fn subcommand_long_help() {
    let m = utils::complex_app().try_get_matches_from(vec!["clap-test", "subcmd", "--help"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::DisplayHelp);
}

#[test]
fn subcommand_help_rev() {
    let m = utils::complex_app().try_get_matches_from(vec!["clap-test", "help", "subcmd"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::DisplayHelp);
}

#[test]
fn complex_help_output() {
    let expected = str![[r#"
clap-test v1.4.8
Kevin K. <kbknapp@gmail.com>
tests clap library

Usage: clap-test [OPTIONS] [positional] [positional2] [positional3]... [COMMAND]

Commands:
  subcmd  tests subcommands
  help    Print this message or the help of the given subcommand(s)

Arguments:
  [positional]      tests positionals
  [positional2]     tests positionals with exclusions
  [positional3]...  tests specific values [possible values: vi, emacs]

Options:
  -o, --option <opt>...                  tests options
  -f, --flag...                          tests flags
  -F                                     tests flags with exclusions
      --long-option-2 <option2>          tests long options with exclusions
  -O, --option3 <option3>                specific vals [possible values: fast, slow]
      --multvals <one> <two>             Tests multiple values, not mult occs
      --multvalsmo <one> <two>           Tests multiple values, and mult occs
      --minvals2 <minvals> <minvals>...  Tests 2 min vals
      --maxvals3 <maxvals>...            Tests 3 max vals
      --optvaleq[=<optval>]              Tests optional value, require = sign
      --optvalnoeq [<optval>]            Tests optional value
  -h, --help                             Print help
  -V, --version                          Print version

"#]];
    utils::assert_output(utils::complex_app(), "clap-test --help", expected, false);
}

#[test]
fn after_and_before_help_output() {
    let cmd = Command::new("clap-test")
        .version("v1.4.8")
        .about("tests clap library")
        .before_help("some text that comes before the help")
        .after_help("some text that comes after the help");

    let expected = str![[r#"
some text that comes before the help

tests clap library

Usage: clap-test

Options:
  -h, --help     Print help
  -V, --version  Print version

some text that comes after the help

"#]];
    utils::assert_output(cmd.clone(), "clap-test -h", expected, false);

    let expected = str![[r#"
some text that comes before the help

tests clap library

Usage: clap-test

Options:
  -h, --help     Print help
  -V, --version  Print version

some text that comes after the help

"#]];
    utils::assert_output(cmd, "clap-test --help", expected, false);
}

#[test]
fn after_and_before_long_help_output() {
    let cmd = Command::new("clap-test")
        .version("v1.4.8")
        .about("tests clap library")
        .before_help("some text that comes before the help")
        .after_help("some text that comes after the help")
        .before_long_help("some longer text that comes before the help")
        .after_long_help("some longer text that comes after the help");

    let expected = str![[r#"
some longer text that comes before the help

tests clap library

Usage: clap-test

Options:
  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version

some longer text that comes after the help

"#]];
    utils::assert_output(cmd.clone(), "clap-test --help", expected, false);

    let expected = str![[r#"
some text that comes before the help

tests clap library

Usage: clap-test

Options:
  -h, --help     Print help (see more with '--help')
  -V, --version  Print version

some text that comes after the help

"#]];
    utils::assert_output(cmd, "clap-test -h", expected, false);
}

#[test]
fn multi_level_sc_help() {
    let cmd = Command::new("ctest").subcommand(
        Command::new("subcmd").subcommand(
            Command::new("multi")
                .about("tests subcommands")
                .author("Kevin K. <kbknapp@gmail.com>")
                .version("0.1")
                .arg(arg!(
                    -f --flag                    "tests flags"
                ))
                .arg(
                    arg!(
                        -o --option <scoption>    "tests options"
                    )
                    .required(false)
                    .num_args(1..)
                    .action(ArgAction::Append),
                ),
        ),
    );

    let expected = str![[r#"
tests subcommands

Usage: ctest subcmd multi [OPTIONS]

Options:
  -f, --flag                  tests flags
  -o, --option <scoption>...  tests options
  -h, --help                  Print help
  -V, --version               Print version

"#]];
    utils::assert_output(cmd, "ctest help subcmd multi", expected, false);
}

#[test]
fn no_wrap_default_help() {
    let cmd = Command::new("ctest").version("1.0").term_width(0);

    let expected = str![[r#"
Usage: ctest

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
fn try_help_default() {
    let cmd = Command::new("ctest").version("1.0").term_width(0);

    let expected = str![[r#"
error: unexpected argument 'bar' found

Usage: ctest

For more information, try '--help'.

"#]];
    utils::assert_output(cmd, "ctest bar", expected, true);
}

#[test]
fn try_help_custom_flag() {
    let cmd = Command::new("ctest")
        .version("1.0")
        .disable_help_flag(true)
        .arg(
            Arg::new("help")
                .long("help")
                .short('h')
                .action(ArgAction::Help),
        )
        .term_width(0);

    let expected = str![[r#"
error: unexpected argument 'bar' found

Usage: ctest

For more information, try '--help'.

"#]];
    utils::assert_output(cmd, "ctest bar", expected, true);
}

#[test]
fn try_help_custom_flag_short() {
    let cmd = Command::new("ctest")
        .version("1.0")
        .disable_help_flag(true)
        .arg(Arg::new("help").short('h').action(ArgAction::HelpShort))
        .term_width(0);

    let expected = str![[r#"
error: unexpected argument 'bar' found

Usage: ctest

For more information, try '-h'.

"#]];
    utils::assert_output(cmd, "ctest bar", expected, true);
}

#[test]
fn try_help_custom_flag_long() {
    let cmd = Command::new("ctest")
        .version("1.0")
        .disable_help_flag(true)
        .arg(Arg::new("help").long("help").action(ArgAction::HelpShort))
        .term_width(0);

    let expected = str![[r#"
error: unexpected argument 'bar' found

Usage: ctest

For more information, try '--help'.

"#]];
    utils::assert_output(cmd, "ctest bar", expected, true);
}

#[test]
fn try_help_custom_flag_no_action() {
    let cmd = Command::new("ctest")
        .version("1.0")
        .disable_help_flag(true)
        // Note `ArgAction::Help` is excluded
        .arg(Arg::new("help").long("help").global(true))
        .term_width(0);

    let expected = str![[r#"
error: unexpected argument 'bar' found

Usage: ctest

"#]];
    utils::assert_output(cmd, "ctest bar", expected, true);
}

#[test]
fn try_help_subcommand_default() {
    let cmd = Command::new("ctest")
        .version("1.0")
        .subcommand(Command::new("foo"))
        .term_width(0);

    let expected = str![[r#"
error: unrecognized subcommand 'bar'

Usage: ctest [COMMAND]

For more information, try '--help'.

"#]];
    utils::assert_output(cmd, "ctest bar", expected, true);
}

#[test]
fn try_help_subcommand_custom_flag() {
    let cmd = Command::new("ctest")
        .version("1.0")
        .disable_help_flag(true)
        .arg(
            Arg::new("help")
                .long("help")
                .short('h')
                .action(ArgAction::Help)
                .global(true),
        )
        .subcommand(Command::new("foo"))
        .term_width(0);

    let expected = str![[r#"
error: unrecognized subcommand 'bar'

Usage: ctest [COMMAND]

For more information, try '--help'.

"#]];
    utils::assert_output(cmd, "ctest bar", expected, true);
}

#[test]
fn try_help_subcommand_custom_flag_no_action() {
    let cmd = Command::new("ctest")
        .version("1.0")
        .disable_help_flag(true)
        // Note `ArgAction::Help` is excluded
        .arg(Arg::new("help").long("help").global(true))
        .subcommand(Command::new("foo"))
        .term_width(0);

    let expected = str![[r#"
error: unrecognized subcommand 'bar'

Usage: ctest [COMMAND]

For more information, try 'help'.

"#]];
    utils::assert_output(cmd, "ctest bar", expected, true);
}

#[test]
#[cfg(feature = "wrap_help")]
fn wrapped_help() {
    let cmd = Command::new("test")
        .term_width(67)
        .arg(
            Arg::new("all")
                .short('a')
                .long("all")
                .action(ArgAction::SetTrue)
                .help("Also do versioning for private crates (will not be published)"),
        )
        .arg(
            Arg::new("exact")
                .long("exact")
                .action(ArgAction::SetTrue)
                .help("Specify inter dependency version numbers exactly with `=`"),
        )
        .arg(
            Arg::new("no_git_commit")
                .long("no-git-commit")
                .action(ArgAction::SetTrue)
                .help("Do not commit version changes"),
        )
        .arg(
            Arg::new("no_git_push")
                .long("no-git-push")
                .action(ArgAction::SetTrue)
                .help("Do not push generated commit and tags to git remote"),
        )
        .subcommand(
            Command::new("sub1")
                .about("One two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen")
        );

    let expected = str![[r#"
Usage: test [OPTIONS] [COMMAND]

Commands:
  sub1  One two three four five six seven eight nine ten eleven
        twelve thirteen fourteen fifteen
  help  Print this message or the help of the given subcommand(s)

Options:
  -a, --all            Also do versioning for private crates (will
                       not be published)
      --exact          Specify inter dependency version numbers
                       exactly with `=`
      --no-git-commit  Do not commit version changes
      --no-git-push    Do not push generated commit and tags to git
                       remote
  -h, --help           Print help

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn unwrapped_help() {
    let cmd = Command::new("test")
        .term_width(68)
        .arg(
            Arg::new("all")
                .short('a')
                .long("all")
                .action(ArgAction::SetTrue)
                .help("Also do versioning for private crates (will not be published)"),
        )
        .arg(
            Arg::new("exact")
                .long("exact")
                .action(ArgAction::SetTrue)
                .help("Specify inter dependency version numbers exactly with `=`"),
        )
        .arg(
            Arg::new("no_git_commit")
                .long("no-git-commit")
                .action(ArgAction::SetTrue)
                .help("Do not commit version changes"),
        )
        .arg(
            Arg::new("no_git_push")
                .long("no-git-push")
                .action(ArgAction::SetTrue)
                .help("Do not push generated commit and tags to git remote"),
        )
        .subcommand(
            Command::new("sub1")
                .about("One two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen")
        );

    let expected = str![[r#"
Usage: test [OPTIONS] [COMMAND]

Commands:
  sub1  One two three four five six seven eight nine ten eleven
        twelve thirteen fourteen fifteen
  help  Print this message or the help of the given subcommand(s)

Options:
  -a, --all            Also do versioning for private crates (will
                       not be published)
      --exact          Specify inter dependency version numbers
                       exactly with `=`
      --no-git-commit  Do not commit version changes
      --no-git-push    Do not push generated commit and tags to git
                       remote
  -h, --help           Print help

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn possible_value_wrapped_help() {
    let cmd = Command::new("test")
        .term_width(67)
        .arg(
            Arg::new("possible_values")
                .long("possible-values")
                .action(ArgAction::Set)
                .value_parser([
                    PossibleValue::new("short_name")
                        .help("Long enough help message, barely warrant wrapping"),
                    PossibleValue::new("second").help("Short help gets handled the same"),
                ]),
        )
        .arg(
            Arg::new("possible_values_with_new_line")
                .long("possible-values-with-new-line")
                .action(ArgAction::Set)
                .value_parser([
                    PossibleValue::new("long enough name to trigger new line").help(
                        "Really long enough help message to clearly warrant wrapping believe me",
                    ),
                    PossibleValue::new("second"),
                ]),
        )
        .arg(
            Arg::new("possible_values_without_new_line")
                .long("possible-values-without-new-line")
                .action(ArgAction::Set)
                .value_parser([
                    PossibleValue::new("name").help("Short enough help message with no wrapping"),
                    PossibleValue::new("second").help("short help"),
                ]),
        );

    let expected = str![[r#"
Usage: test [OPTIONS]

Options:
      --possible-values <possible_values>
          Possible values:
          - short_name: Long enough help message, barely warrant
            wrapping
          - second:     Short help gets handled the same

      --possible-values-with-new-line <possible_values_with_new_line>
          Possible values:
          - long enough name to trigger new line: Really long
            enough help message to clearly warrant wrapping believe
            me
          - second

      --possible-values-without-new-line <possible_values_without_new_line>
          Possible values:
          - name:   Short enough help message with no wrapping
          - second: short help

  -h, --help
          Print help (see a summary with '-h')

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn complex_subcommand_help_output() {
    let a = utils::complex_app();

    let expected = str![[r#"
clap-test-subcmd 0.1
Kevin K. <kbknapp@gmail.com>
tests subcommands

Usage: clap-test subcmd [OPTIONS] [scpositional]

Arguments:
  [scpositional]  tests positionals

Options:
  -o, --option <scoption>...   tests options
  -f, --flag...                tests flags
  -s, --subcmdarg <subcmdarg>  tests other args
  -h, --help                   Print help
  -V, --version                Print version

"#]];
    utils::assert_output(a, "clap-test subcmd --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn issue_626_unicode_cutoff() {
    let cmd = Command::new("ctest").version("0.1").term_width(70).arg(
        Arg::new("cafe")
            .short('c')
            .long("cafe")
            .value_name("FILE")
            .help(
                "A coffeehouse, coffee shop, or café is an establishment \
             which primarily serves hot coffee, related coffee beverages \
             (e.g., café latte, cappuccino, espresso), tea, and other hot \
             beverages. Some coffeehouses also serve cold beverages such as \
             iced coffee and iced tea. Many cafés also serve some type of \
             food, such as light snacks, muffins, or pastries.",
            )
            .action(ArgAction::Set),
    );

    let expected = str![[r#"
Usage: ctest [OPTIONS]

Options:
  -c, --cafe <FILE>  A coffeehouse, coffee shop, or café is an
                     establishment which primarily serves hot coffee,
                     related coffee beverages (e.g., café latte,
                     cappuccino, espresso), tea, and other hot
                     beverages. Some coffeehouses also serve cold
                     beverages such as iced coffee and iced tea. Many
                     cafés also serve some type of food, such as light
                     snacks, muffins, or pastries.
  -h, --help         Print help
  -V, --version      Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
fn hide_possible_vals() {
    let cmd = Command::new("ctest")
        .version("0.1")
        .arg(
            Arg::new("pos")
                .short('p')
                .long("pos")
                .value_name("VAL")
                .value_parser(["fast", "slow"])
                .help("Some vals")
                .action(ArgAction::Set),
        )
        .arg(
            Arg::new("cafe")
                .short('c')
                .long("cafe")
                .value_name("FILE")
                .hide_possible_values(true)
                .value_parser(["fast", "slow"])
                .help("A coffeehouse, coffee shop, or café.")
                .action(ArgAction::Set),
        );

    let expected = str![[r#"
Usage: ctest [OPTIONS]

Options:
  -p, --pos <VAL>    Some vals [possible values: fast, slow]
  -c, --cafe <FILE>  A coffeehouse, coffee shop, or café.
  -h, --help         Print help
  -V, --version      Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
fn hide_single_possible_val() {
    let cmd = Command::new("ctest")
        .version("0.1")
        .arg(
            Arg::new("pos")
                .short('p')
                .long("pos")
                .value_name("VAL")
                .value_parser([
                    "fast".into(),
                    "slow".into(),
                    PossibleValue::new("secret speed").hide(true),
                ])
                .help("Some vals")
                .action(ArgAction::Set),
        )
        .arg(
            Arg::new("cafe")
                .short('c')
                .long("cafe")
                .value_name("FILE")
                .help("A coffeehouse, coffee shop, or café.")
                .action(ArgAction::Set),
        );

    let expected = str![[r#"
Usage: ctest [OPTIONS]

Options:
  -p, --pos <VAL>    Some vals [possible values: fast, slow]
  -c, --cafe <FILE>  A coffeehouse, coffee shop, or café.
  -h, --help         Print help
  -V, --version      Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
fn possible_vals_with_help() {
    let app = Command::new("ctest")
        .version("0.1")
        .arg(
            Arg::new("pos")
                .short('p')
                .long("pos")
                .value_name("VAL")
                .value_parser([
                    PossibleValue::new("fast"),
                    PossibleValue::new("slow").help("not as fast"),
                    PossibleValue::new("secret speed").hide(true),
                ])
                .help("Some vals")
                .action(ArgAction::Set),
        )
        .arg(
            Arg::new("cafe")
                .short('c')
                .long("cafe")
                .value_name("FILE")
                .help("A coffeehouse, coffee shop, or café.")
                .action(ArgAction::Set),
        );

    let expected = str![[r#"
Usage: ctest [OPTIONS]

Options:
  -p, --pos <VAL>
          Some vals

          Possible values:
          - fast
          - slow: not as fast

  -c, --cafe <FILE>
          A coffeehouse, coffee shop, or café.

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version

"#]];
    utils::assert_output(app, "ctest --help", expected, false);
}

#[test]
fn hidden_possible_vals() {
    let app = Command::new("ctest").arg(
        Arg::new("pos")
            .hide_possible_values(true)
            .value_parser([
                PossibleValue::new("fast"),
                PossibleValue::new("slow").help("not as fast"),
            ])
            .action(ArgAction::Set),
    );

    let expected = str![[r#"
Usage: ctest [pos]

Arguments:
  [pos]  

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(app, "ctest --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn issue_626_panic() {
    let cmd = Command::new("ctest")
        .version("0.1")
        .term_width(52)
        .arg(Arg::new("cafe")
           .short('c')
           .long("cafe")
           .value_name("FILE")
           .help("La culture du café est très développée dans de nombreux pays à climat chaud d'Amérique, \
           d'Afrique et d'Asie, dans des plantations qui sont cultivées pour les marchés d'exportation. \
           Le café est souvent une contribution majeure aux exportations des régions productrices.")
           .action(ArgAction::Set));

    let expected = str![[r#"
Usage: ctest [OPTIONS]

Options:
  -c, --cafe <FILE>
          La culture du café est très développée
          dans de nombreux pays à climat chaud
          d'Amérique, d'Afrique et d'Asie, dans des
          plantations qui sont cultivées pour les
          marchés d'exportation. Le café est souvent
          une contribution majeure aux exportations
          des régions productrices.
  -h, --help
          Print help
  -V, --version
          Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn issue_626_variable_panic() {
    for i in 10..320 {
        let _ = Command::new("ctest")
            .version("0.1")
            .term_width(i)
            .arg(Arg::new("cafe")
               .short('c')
               .long("cafe")
               .value_name("FILE")
               .help("La culture du café est très développée dans de nombreux pays à climat chaud d'Amérique, \
               d'Afrique et d'Asie, dans des plantations qui sont cultivées pour les marchés d'exportation. \
               Le café est souvent une contribution majeure aux exportations des régions productrices.")
               .action(ArgAction::Set))
            .try_get_matches_from(vec!["ctest", "--help"]);
    }
}

#[test]
#[cfg(feature = "wrap_help")]
fn final_word_wrapping() {
    let cmd = Command::new("ctest").version("0.1").term_width(24);

    let expected = str![[r#"
Usage: ctest

Options:
  -h, --help
          Print help
  -V, --version
          Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn wrapping_newline_chars() {
    let cmd = Command::new("ctest")
        .version("0.1")
        .term_width(60)
        .arg(Arg::new("mode").help(
            "x, max, maximum   20 characters, contains symbols.\n\
             l, long           Copy-friendly, 14 characters, contains symbols.\n\
             m, med, medium    Copy-friendly, 8 characters, contains symbols.\n",
        ));

    let expected = str![[r#"
Usage: ctest [mode]

Arguments:
  [mode]  x, max, maximum   20 characters, contains symbols.
          l, long           Copy-friendly, 14 characters,
          contains symbols.
          m, med, medium    Copy-friendly, 8 characters,
          contains symbols.

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn wrapped_indentation() {
    let cmd = Command::new("ctest")
        .version("0.1")
        .term_width(60)
        .arg(Arg::new("mode").help(
            "Some values:
  - l, long           Copy-friendly, 14 characters, contains symbols.
  - m, med, medium    Copy-friendly, 8 characters, contains symbols.",
        ));

    let expected = str![[r#"
Usage: ctest [mode]

Arguments:
  [mode]  Some values:
            - l, long           Copy-friendly, 14
            characters, contains symbols.
            - m, med, medium    Copy-friendly, 8 characters,
            contains symbols.

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn wrapping_newline_variables() {
    let cmd = Command::new("ctest")
        .version("0.1")
        .term_width(60)
        .arg(Arg::new("mode").help(
            "x, max, maximum   20 characters, contains symbols.{n}\
             l, long           Copy-friendly, 14 characters, contains symbols.{n}\
             m, med, medium    Copy-friendly, 8 characters, contains symbols.{n}",
        ));

    let expected = str![[r#"
Usage: ctest [mode]

Arguments:
  [mode]  x, max, maximum   20 characters, contains symbols.
          l, long           Copy-friendly, 14 characters,
          contains symbols.
          m, med, medium    Copy-friendly, 8 characters,
          contains symbols.

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn dont_wrap_urls() {
    let cmd = Command::new("Example")
        .term_width(30)
        .subcommand(Command::new("update").arg(
            Arg::new("force-non-host")
                .help("Install toolchains that require an emulator. See https://github.com/rust-lang/rustup/wiki/Non-host-toolchains")
                .long("force-non-host")
                .action(ArgAction::SetTrue))
    );

    let expected = str![[r#"
Usage: Example update [OPTIONS]

Options:
      --force-non-host
          Install toolchains
          that require an
          emulator. See
          https://github.com/rust-lang/rustup/wiki/Non-host-toolchains
  -h, --help
          Print help

"#]];
    utils::assert_output(cmd, "Example update --help", expected, false);
}

#[test]
fn old_newline_chars() {
    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("mode")
            .short('m')
            .action(ArgAction::SetTrue)
            .help("Some help with some wrapping\n(Defaults to something)"),
    );

    let expected = str![[r#"
Usage: ctest [OPTIONS]

Options:
  -m             Some help with some wrapping
                 (Defaults to something)
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
fn old_newline_variables() {
    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("mode")
            .short('m')
            .action(ArgAction::SetTrue)
            .help("Some help with some wrapping{n}(Defaults to something)"),
    );

    let expected = str![[r#"
Usage: ctest [OPTIONS]

Options:
  -m             Some help with some wrapping
                 (Defaults to something)
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn issue_688_hide_pos_vals() {
    #[cfg(not(feature = "unstable-v5"))]
    let expected = str![[r#"
Usage: ctest [OPTIONS]

Options:
      --filter <filter>  Sets the filter, or sampling method, to use for interpolation when resizing the particle
                         images. The default is Linear (Bilinear). [possible values: Nearest, Linear, Cubic, Gaussian,
                         Lanczos3]
  -h, --help             Print help
  -V, --version          Print version

"#]];

    #[cfg(feature = "unstable-v5")]
    let expected = str![[r#"
Usage: ctest [OPTIONS]

Options:
      --filter <filter>  Sets the filter, or sampling method, to use for interpolation when resizing
                         the particle images. The default is Linear (Bilinear). [possible values:
                         Nearest, Linear, Cubic, Gaussian, Lanczos3]
  -h, --help             Print help
  -V, --version          Print version

"#]];

    let filter_values = ["Nearest", "Linear", "Cubic", "Gaussian", "Lanczos3"];

    let app1 = Command::new("ctest")
        .version("0.1")
			.term_width(120)
			.hide_possible_values(true)
			.arg(Arg::new("filter")
				.help("Sets the filter, or sampling method, to use for interpolation when resizing the particle \
            images. The default is Linear (Bilinear). [possible values: Nearest, Linear, Cubic, Gaussian, Lanczos3]")
				.long("filter")
				.value_parser(filter_values)
				.action(ArgAction::Set));

    utils::assert_output(app1, "ctest --help", expected.clone(), false);

    let app2 = Command::new("ctest")
        .version("0.1")
			.term_width(120)
			.arg(Arg::new("filter")
				.help("Sets the filter, or sampling method, to use for interpolation when resizing the particle \
            images. The default is Linear (Bilinear).")
				.long("filter")
				.value_parser(filter_values)
				.action(ArgAction::Set));

    utils::assert_output(app2, "ctest --help", expected.clone(), false);

    let app3 = Command::new("ctest")
        .version("0.1")
			.term_width(120)
			.arg(Arg::new("filter")
				.help("Sets the filter, or sampling method, to use for interpolation when resizing the particle \
            images. The default is Linear (Bilinear). [possible values: Nearest, Linear, Cubic, Gaussian, Lanczos3]")
				.long("filter")
				.action(ArgAction::Set));

    utils::assert_output(app3, "ctest --help", expected.clone(), false);
}

#[test]
fn issue_702_multiple_values() {
    let cmd = Command::new("myapp")
        .version("1.0")
        .author("foo")
        .about("bar")
        .arg(Arg::new("arg1").help("some option"))
        .arg(
            Arg::new("arg2")
                .action(ArgAction::Set)
                .num_args(1..)
                .help("some option"),
        )
        .arg(
            Arg::new("some")
                .help("some option")
                .short('s')
                .long("some")
                .action(ArgAction::Set),
        )
        .arg(
            Arg::new("other")
                .help("some other option")
                .short('o')
                .long("other")
                .action(ArgAction::Set),
        )
        .arg(
            Arg::new("label")
                .help("a label")
                .short('l')
                .long("label")
                .num_args(1..)
                .action(ArgAction::Set),
        );

    let expected = str![[r#"
bar

Usage: myapp [OPTIONS] [arg1] [arg2]...

Arguments:
  [arg1]     some option
  [arg2]...  some option

Options:
  -s, --some <some>       some option
  -o, --other <other>     some other option
  -l, --label <label>...  a label
  -h, --help              Print help
  -V, --version           Print version

"#]];
    utils::assert_output(cmd, "myapp --help", expected, false);
}

#[test]
fn long_about() {
    let cmd = Command::new("myapp")
        .version("1.0")
        .author("foo")
        .about("bar")
        .long_about(
            "something really really long, with\nmultiple lines of text\nthat should be displayed",
        )
        .arg(Arg::new("arg1").help("some option"));

    let expected = str![[r#"
something really really long, with
multiple lines of text
that should be displayed

Usage: myapp [arg1]

Arguments:
  [arg1]
          some option

Options:
  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version

"#]];
    utils::assert_output(cmd, "myapp --help", expected, false);
}

#[test]
fn explicit_short_long_help() {
    let cmd = Command::new("myapp")
        .disable_help_flag(true)
        .version("1.0")
        .author("foo")
        .about("bar")
        .long_about(
            "something really really long, with\nmultiple lines of text\nthat should be displayed",
        )
        .arg(Arg::new("arg1").help("some option"))
        .arg(Arg::new("short").short('?').action(ArgAction::HelpShort))
        .arg(
            Arg::new("long")
                .short('h')
                .long("help")
                .action(ArgAction::HelpLong),
        );

    let expected = str![[r#"
bar

Usage: myapp [arg1]

Arguments:
  [arg1]  some option

Options:
  -?             
  -h, --help     
  -V, --version  Print version

"#]];
    utils::assert_output(cmd.clone(), "myapp -?", expected, false);

    let expected = str![[r#"
something really really long, with
multiple lines of text
that should be displayed

Usage: myapp [arg1]

Arguments:
  [arg1]
          some option

Options:
  -?
          

  -h, --help
          

  -V, --version
          Print version

"#]];
    utils::assert_output(cmd.clone(), "myapp -h", expected, false);

    let expected = str![[r#"
something really really long, with
multiple lines of text
that should be displayed

Usage: myapp [arg1]

Arguments:
  [arg1]
          some option

Options:
  -?
          

  -h, --help
          

  -V, --version
          Print version

"#]];
    utils::assert_output(cmd, "myapp --help", expected, false);
}

#[test]
fn ripgrep_usage() {
    let cmd = Command::new("ripgrep").version("0.5").override_usage(
        "rg [OPTIONS] <pattern> [<path> ...]
       rg [OPTIONS] [-e PATTERN | -f FILE ]... [<path> ...]
       rg [OPTIONS] --files [<path> ...]
       rg [OPTIONS] --type-list",
    );

    let expected = str![[r#"
Usage: rg [OPTIONS] <pattern> [<path> ...]
       rg [OPTIONS] [-e PATTERN | -f FILE ]... [<path> ...]
       rg [OPTIONS] --files [<path> ...]
       rg [OPTIONS] --type-list

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "rg --help", expected, false);
}

#[test]
fn ripgrep_usage_using_templates() {
    #[cfg(not(feature = "unstable-v5"))]
    let cmd = Command::new("ripgrep")
        .version("0.5")
        .override_usage(
            "\
       rg [OPTIONS] <pattern> [<path> ...]
       rg [OPTIONS] [-e PATTERN | -f FILE ]... [<path> ...]
       rg [OPTIONS] --files [<path> ...]
       rg [OPTIONS] --type-list",
        )
        .help_template(
            "\
{bin} {version}

Usage: {usage}

Options:
{options}",
        );

    #[cfg(feature = "unstable-v5")]
    let cmd = Command::new("ripgrep")
        .version("0.5")
        .override_usage(
            "\
       rg [OPTIONS] <pattern> [<path> ...]
       rg [OPTIONS] [-e PATTERN | -f FILE ]... [<path> ...]
       rg [OPTIONS] --files [<path> ...]
       rg [OPTIONS] --type-list",
        )
        .help_template(
            "\
{name} {version}

Usage: {usage}

Options:
{options}",
        );

    let expected = str![[r#"
ripgrep 0.5

Usage: rg [OPTIONS] <pattern> [<path> ...]
       rg [OPTIONS] [-e PATTERN | -f FILE ]... [<path> ...]
       rg [OPTIONS] --files [<path> ...]
       rg [OPTIONS] --type-list

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "rg --help", expected, false);
}

#[test]
fn sc_negates_reqs() {
    let cmd = Command::new("prog")
        .version("1.0")
        .subcommand_negates_reqs(true)
        .arg(arg!(-o --opt <FILE> "tests options").required(true))
        .arg(Arg::new("PATH").help("help"))
        .subcommand(Command::new("test"));

    let expected = str![[r#"
Usage: prog --opt <FILE> [PATH]
       prog [PATH] <COMMAND>

Commands:
  test  
  help  Print this message or the help of the given subcommand(s)

Arguments:
  [PATH]  help

Options:
  -o, --opt <FILE>  tests options
  -h, --help        Print help
  -V, --version     Print version

"#]];
    utils::assert_output(cmd, "prog --help", expected, false);
}

#[test]
fn hide_args() {
    let cmd = Command::new("prog")
        .version("1.0")
        .arg(arg!(-f --flag "testing flags"))
        .arg(arg!(-o --opt <FILE> "tests options"))
        .arg(Arg::new("pos").hide(true));

    let expected = str![[r#"
Usage: prog [OPTIONS]

Options:
  -f, --flag        testing flags
  -o, --opt <FILE>  tests options
  -h, --help        Print help
  -V, --version     Print version

"#]];
    utils::assert_output(cmd, "prog --help", expected, false);
}

#[test]
fn args_negate_sc() {
    let cmd = Command::new("prog")
        .version("1.0")
        .args_conflicts_with_subcommands(true)
        .arg(arg!(-f --flag "testing flags"))
        .arg(arg!(-o --opt <FILE> "tests options"))
        .arg(Arg::new("PATH").help("help"))
        .subcommand(Command::new("test"));

    let expected = str![[r#"
Usage: prog [OPTIONS] [PATH]
       prog <COMMAND>

Commands:
  test  
  help  Print this message or the help of the given subcommand(s)

Arguments:
  [PATH]  help

Options:
  -f, --flag        testing flags
  -o, --opt <FILE>  tests options
  -h, --help        Print help
  -V, --version     Print version

"#]];
    utils::assert_output(cmd, "prog --help", expected, false);
}

#[test]
fn issue_1046_hide_scs() {
    let cmd = Command::new("prog")
        .version("1.0")
        .arg(arg!(-f --flag "testing flags"))
        .arg(arg!(-o --opt <FILE> "tests options"))
        .arg(Arg::new("PATH").help("some"))
        .subcommand(Command::new("test").hide(true));

    let expected = str![[r#"
Usage: prog [OPTIONS] [PATH]

Arguments:
  [PATH]  some

Options:
  -f, --flag        testing flags
  -o, --opt <FILE>  tests options
  -h, --help        Print help
  -V, --version     Print version

"#]];
    utils::assert_output(cmd, "prog --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn issue_777_wrap_all_things() {
    let cmd = Command::new("A cmd with a crazy very long long long name hahaha")
        .version("1.0")
        .author("Some Very Long Name and crazy long email <email@server.com>")
        .about("Show how the about text is not wrapped")
        .help_template(utils::FULL_TEMPLATE)
        .term_width(35);

    let expected = str![[r#"
A cmd with a crazy very long long
long name hahaha 1.0
Some Very Long Name and crazy long
email <email@server.com>
Show how the about text is not
wrapped

Usage: ctest

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "ctest --help", expected, false);
}

#[test]
fn dont_strip_padding_issue_5083() {
    let cmd = Command::new("test")
        .help_template("{subcommands}")
        .subcommands([
            Command::new("one"),
            Command::new("two"),
            Command::new("three"),
        ]);

    let expected = str![[r#"
  one    
  two    
  three  
  help   Print this message or the help of the given subcommand(s)

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn override_help_short() {
    let cmd = Command::new("test")
        .version("0.1")
        .arg(arg!(-H --help "Print help").action(ArgAction::Help))
        .disable_help_flag(true);

    let expected = str![[r#"
Usage: test

Options:
  -H, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd.clone(), "test --help", expected, false);

    let expected = str![[r#"
Usage: test

Options:
  -H, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "test -H", expected, false);
}

#[test]
fn override_help_long() {
    let cmd = Command::new("test")
        .version("0.1")
        .arg(arg!(-h --hell "Print help").action(ArgAction::Help))
        .disable_help_flag(true);

    let expected = str![[r#"
Usage: test

Options:
  -h, --hell     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd.clone(), "test --hell", expected, false);

    let expected = str![[r#"
Usage: test

Options:
  -h, --hell     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "test -h", expected, false);
}

#[test]
fn override_help_about() {
    let cmd = Command::new("test")
        .version("0.1")
        .arg(arg!(-h --help "Print custom help information").action(ArgAction::Help))
        .disable_help_flag(true);

    let expected = str![[r#"
Usage: test

Options:
  -h, --help     Print custom help information
  -V, --version  Print version

"#]];
    utils::assert_output(cmd.clone(), "test --help", expected, false);

    let expected = str![[r#"
Usage: test

Options:
  -h, --help     Print custom help information
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "test -h", expected, false);
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "Command conflict: Argument names must be unique, but 'help' is in use by more than one argument or group (call `cmd.disable_help_flag(true)` to remove the auto-generated `--help`)"]
fn arg_id_conflict_with_help() {
    Command::new("conflict")
        .arg(Arg::new("help").short('?').action(ArgAction::SetTrue))
        .build();
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "Command conflict: Short option names must be unique for each argument, but '-h' is in use by both 'home' and 'help' (call `cmd.disable_help_flag(true)` to remove the auto-generated `--help`)"]
fn arg_short_conflict_with_help() {
    Command::new("conflict")
        .arg(Arg::new("home").short('h').action(ArgAction::SetTrue))
        .build();
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "Command conflict: Long option names must be unique for each argument, but '--help' is in use by both 'custom-help' and 'help' (call `cmd.disable_help_flag(true)` to remove the auto-generated `--help`)"]
fn arg_long_conflict_with_help() {
    Command::new("conflict")
        .arg(
            Arg::new("custom-help")
                .long("help")
                .action(ArgAction::SetTrue),
        )
        .build();
}

#[test]
fn last_arg_mult_usage() {
    let cmd = Command::new("last")
        .version("0.1")
        .arg(Arg::new("TARGET").required(true).help("some"))
        .arg(Arg::new("CORPUS").help("some"))
        .arg(
            Arg::new("ARGS")
                .action(ArgAction::Set)
                .num_args(1..)
                .last(true)
                .help("some"),
        );

    let expected = str![[r#"
Usage: last <TARGET> [CORPUS] [-- <ARGS>...]

Arguments:
  <TARGET>   some
  [CORPUS]   some
  [ARGS]...  some

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "last --help", expected, false);
}

#[test]
fn last_arg_mult_usage_req() {
    let cmd = Command::new("last")
        .version("0.1")
        .arg(Arg::new("TARGET").required(true).help("some"))
        .arg(Arg::new("CORPUS").help("some"))
        .arg(
            Arg::new("ARGS")
                .action(ArgAction::Set)
                .num_args(1..)
                .last(true)
                .required(true)
                .help("some"),
        );

    let expected = str![[r#"
Usage: last <TARGET> [CORPUS] -- <ARGS>...

Arguments:
  <TARGET>   some
  [CORPUS]   some
  <ARGS>...  some

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "last --help", expected, false);
}

#[test]
fn last_arg_mult_usage_req_with_sc() {
    let cmd = Command::new("last")
        .version("0.1")
        .subcommand_negates_reqs(true)
        .arg(Arg::new("TARGET").required(true).help("some"))
        .arg(Arg::new("CORPUS").help("some"))
        .arg(
            Arg::new("ARGS")
                .action(ArgAction::Set)
                .num_args(1..)
                .last(true)
                .required(true)
                .help("some"),
        )
        .subcommand(Command::new("test").about("some"));

    let expected = str![[r#"
Usage: last <TARGET> [CORPUS] -- <ARGS>...
       last [TARGET] [CORPUS] <COMMAND>

Commands:
  test  some
  help  Print this message or the help of the given subcommand(s)

Arguments:
  <TARGET>   some
  [CORPUS]   some
  <ARGS>...  some

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "last --help", expected, false);
}

#[test]
fn last_arg_mult_usage_with_sc() {
    let cmd = Command::new("last")
        .version("0.1")
        .args_conflicts_with_subcommands(true)
        .arg(Arg::new("TARGET").required(true).help("some"))
        .arg(Arg::new("CORPUS").help("some"))
        .arg(
            Arg::new("ARGS")
                .action(ArgAction::Set)
                .num_args(1..)
                .last(true)
                .help("some"),
        )
        .subcommand(Command::new("test").about("some"));

    let expected = str![[r#"
Usage: last <TARGET> [CORPUS] [-- <ARGS>...]
       last <COMMAND>

Commands:
  test  some
  help  Print this message or the help of the given subcommand(s)

Arguments:
  <TARGET>   some
  [CORPUS]   some
  [ARGS]...  some

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "last --help", expected, false);
}

#[test]
fn hide_default_val() {
    let app1 = Command::new("default").version("0.1").term_width(120).arg(
        Arg::new("argument")
            .help("Pass an argument to the program. [default: default-argument]")
            .long("arg")
            .default_value("default-argument")
            .hide_default_value(true),
    );

    let expected = str![[r#"
Usage: default [OPTIONS]

Options:
      --arg <argument>  Pass an argument to the program. [default: default-argument]
  -h, --help            Print help
  -V, --version         Print version

"#]];
    utils::assert_output(app1, "default --help", expected, false);

    let app2 = Command::new("default").version("0.1").term_width(120).arg(
        Arg::new("argument")
            .help("Pass an argument to the program.")
            .long("arg")
            .default_value("default-argument"),
    );

    let expected = str![[r#"
Usage: default [OPTIONS]

Options:
      --arg <argument>  Pass an argument to the program. [default: default-argument]
  -h, --help            Print help
  -V, --version         Print version

"#]];
    utils::assert_output(app2, "default --help", expected, false);
}

#[test]
#[cfg(feature = "wrap_help")]
fn escaped_whitespace_values() {
    let app1 = Command::new("default").version("0.1").term_width(120).arg(
        Arg::new("argument")
            .help("Pass an argument to the program.")
            .long("arg")
            .default_value("\n")
            .value_parser(["normal", " ", "\n", "\t", "other"]),
    );

    #[cfg(not(feature = "unstable-v5"))]
    let expected = str![[r#"
Usage: default [OPTIONS]

Options:
      --arg <argument>  Pass an argument to the program. [default: "\n"] [possible values: normal, " ", "\n", "\t",
                        other]
  -h, --help            Print help
  -V, --version         Print version

"#]];

    #[cfg(feature = "unstable-v5")]
    let expected = str![[r#"
Usage: default [OPTIONS]

Options:
      --arg <argument>  Pass an argument to the program. [default: "\n"] [possible values: normal, "
                        ", "\n", "\t", other]
  -h, --help            Print help
  -V, --version         Print version

"#]];

    utils::assert_output(app1, "default --help", expected, false);
}

fn issue_1112_setup() -> Command {
    Command::new("test")
        .version("1.3")
        .disable_help_flag(true)
        .arg(
            Arg::new("help1")
                .long("help")
                .short('h')
                .help("some help")
                .action(ArgAction::SetTrue),
        )
        .subcommand(
            Command::new("foo").arg(
                Arg::new("help1")
                    .long("help")
                    .short('h')
                    .help("some help")
                    .action(ArgAction::SetTrue),
            ),
        )
}

#[test]
fn prefer_user_help_long_1112() {
    let m = issue_1112_setup().try_get_matches_from(vec!["test", "--help"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert!(*m.get_one::<bool>("help1").expect("defaulted by clap"));
}

#[test]
fn prefer_user_help_short_1112() {
    let m = issue_1112_setup().try_get_matches_from(vec!["test", "-h"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert!(*m.get_one::<bool>("help1").expect("defaulted by clap"));
}

#[test]
fn prefer_user_subcmd_help_long_1112() {
    let m = issue_1112_setup().try_get_matches_from(vec!["test", "foo", "--help"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert!(*m
        .subcommand_matches("foo")
        .unwrap()
        .get_one::<bool>("help1")
        .expect("defaulted by clap"));
}

#[test]
fn prefer_user_subcmd_help_short_1112() {
    let m = issue_1112_setup().try_get_matches_from(vec!["test", "foo", "-h"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert!(m
        .subcommand_matches("foo")
        .unwrap()
        .get_one::<bool>("help1")
        .expect("defaulted by clap"));
}

#[test]
fn issue_1052_require_delim_help() {
    let cmd = Command::new("test")
        .author("Kevin K.")
        .about("tests stuff")
        .version("1.3")
        .arg(
            arg!(-f --fake <s> "some help")
                .required(true)
                .value_names(["some", "val"])
                .action(ArgAction::Set)
                .value_delimiter(':'),
        );

    let expected = str![[r#"
tests stuff

Usage: test --fake <some> <val>

Options:
  -f, --fake <some> <val>  some help
  -h, --help               Print help
  -V, --version            Print version

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn custom_headers_headers() {
    let cmd = Command::new("blorp")
        .author("Will M.")
        .about("does stuff")
        .version("1.4")
        .arg(
            arg!(-f --fake <s> "some help")
                .required(true)
                .value_names(["some", "val"])
                .action(ArgAction::Set)
                .value_delimiter(':'),
        )
        .next_help_heading(Some("NETWORKING"))
        .arg(
            Arg::new("no-proxy")
                .short('n')
                .long("no-proxy")
                .action(ArgAction::SetTrue)
                .help("Do not use system proxy settings"),
        )
        .args([Arg::new("port").long("port").action(ArgAction::SetTrue)]);

    let expected = str![[r#"
does stuff

Usage: test [OPTIONS] --fake <some> <val>

Options:
  -f, --fake <some> <val>  some help
  -h, --help               Print help
  -V, --version            Print version

NETWORKING:
  -n, --no-proxy  Do not use system proxy settings
      --port

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn multiple_custom_help_headers() {
    let cmd = Command::new("blorp")
        .author("Will M.")
        .about("does stuff")
        .version("1.4")
        .arg(
            arg!(-f --fake <s> "some help")
                .required(true)
                .value_names(["some", "val"])
                .action(ArgAction::Set)
                .value_delimiter(':'),
        )
        .next_help_heading(Some("NETWORKING"))
        .arg(
            Arg::new("no-proxy")
                .short('n')
                .long("no-proxy")
                .action(ArgAction::SetTrue)
                .help("Do not use system proxy settings"),
        )
        .next_help_heading(Some("SPECIAL"))
        .arg(
            arg!(-b --"birthday-song" <song> "Change which song is played for birthdays")
                .required(true)
                .help_heading(Some("OVERRIDE SPECIAL")),
        )
        .arg(arg!(--style <style> "Choose musical style to play the song").help_heading(None))
        .arg(
            arg!(
                -v --"birthday-song-volume" <volume> "Change the volume of the birthday song"
            )
            .required(true),
        )
        .next_help_heading(None)
        .arg(
            Arg::new("server-addr")
                .short('a')
                .long("server-addr")
                .action(ArgAction::SetTrue)
                .help("Set server address")
                .help_heading(Some("NETWORKING")),
        )
        .arg(
            Arg::new("speed")
                .long("speed")
                .short('s')
                .value_name("SPEED")
                .value_parser(["fast", "slow"])
                .help("How fast?")
                .action(ArgAction::Set),
        );

    let expected = str![[r#"
does stuff

Usage: test [OPTIONS] --fake <some> <val> --birthday-song <song> --birthday-song-volume <volume>

Options:
  -f, --fake <some> <val>  some help
      --style <style>      Choose musical style to play the song
  -s, --speed <SPEED>      How fast? [possible values: fast, slow]
  -h, --help               Print help
  -V, --version            Print version

NETWORKING:
  -n, --no-proxy     Do not use system proxy settings
  -a, --server-addr  Set server address

OVERRIDE SPECIAL:
  -b, --birthday-song <song>  Change which song is played for birthdays

SPECIAL:
  -v, --birthday-song-volume <volume>  Change the volume of the birthday song

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn custom_help_headers_hide_args() {
    let cmd = Command::new("blorp")
        .author("Will M.")
        .about("does stuff")
        .version("1.4")
        .next_help_heading(Some("NETWORKING"))
        .arg(
            Arg::new("no-proxy")
                .short('n')
                .long("no-proxy")
                .help("Do not use system proxy settings")
                .hide_short_help(true),
        )
        .next_help_heading(Some("SPECIAL"))
        .arg(
            arg!(-b --song <song> "Change which song is played for birthdays")
                .required(true)
                .help_heading(Some("OVERRIDE SPECIAL")),
        )
        .arg(
            arg!(
                -v --"song-volume" <volume> "Change the volume of the birthday song"
            )
            .required(true),
        )
        .next_help_heading(None)
        .arg(
            Arg::new("server-addr")
                .short('a')
                .long("server-addr")
                .help("Set server address")
                .help_heading(Some("NETWORKING"))
                .hide_short_help(true),
        );

    let expected = str![[r#"
does stuff

Usage: test [OPTIONS] --song <song> --song-volume <volume>

Options:
  -h, --help     Print help (see more with '--help')
  -V, --version  Print version

OVERRIDE SPECIAL:
  -b, --song <song>  Change which song is played for birthdays

SPECIAL:
  -v, --song-volume <volume>  Change the volume of the birthday song

"#]];
    utils::assert_output(cmd, "test -h", expected, false);
}

#[test]
fn show_long_about_issue_897() {
    let cmd = Command::new("ctest").version("0.1").subcommand(
        Command::new("foo")
            .version("0.1")
            .about("About foo")
            .long_about("Long about foo"),
    );

    let expected = str![[r#"
Long about foo

Usage: ctest foo

Options:
  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version

"#]];
    utils::assert_output(cmd, "ctest foo --help", expected, false);
}

#[test]
fn show_short_about_issue_897() {
    let cmd = Command::new("ctest").version("0.1").subcommand(
        Command::new("foo")
            .version("0.1")
            .about("About foo")
            .long_about("Long about foo"),
    );

    let expected = str![[r#"
About foo

Usage: ctest foo

Options:
  -h, --help     Print help (see more with '--help')
  -V, --version  Print version

"#]];
    utils::assert_output(cmd, "ctest foo -h", expected, false);
}

#[test]
fn issue_1364_no_short_options() {
    let cmd = Command::new("demo")
        .arg(Arg::new("foo").short('f').action(ArgAction::SetTrue))
        .arg(
            Arg::new("baz")
                .short('z')
                .value_name("BAZ")
                .hide_short_help(true),
        )
        .arg(
            Arg::new("files")
                .value_name("FILES")
                .action(ArgAction::Set)
                .num_args(1..),
        );

    let expected = str![[r#"
Usage: demo [OPTIONS] [FILES]...

Arguments:
  [FILES]...  

Options:
  -f          
  -h, --help  Print help (see more with '--help')

"#]];
    utils::assert_output(cmd, "demo -h", expected, false);
}

#[test]
fn issue_1487() {
    let cmd = Command::new("test")
        .arg(Arg::new("arg1").group("group1"))
        .arg(Arg::new("arg2").group("group1"))
        .group(
            ArgGroup::new("group1")
                .args(["arg1", "arg2"])
                .required(true),
        );

    let expected = str![[r#"
Usage: ctest <arg1|arg2>

Arguments:
  [arg1]  
  [arg2]  

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "ctest -h", expected, false);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command::help_expected is enabled for the Command"]
fn help_required_but_not_given() {
    Command::new("myapp")
        .help_expected(true)
        .arg(Arg::new("foo"))
        .try_get_matches_from(empty_args())
        .unwrap();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command::help_expected is enabled for the Command"]
fn help_required_but_not_given_settings_after_args() {
    Command::new("myapp")
        .arg(Arg::new("foo"))
        .help_expected(true)
        .try_get_matches_from(empty_args())
        .unwrap();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command::help_expected is enabled for the Command"]
fn help_required_but_not_given_for_one_of_two_arguments() {
    Command::new("myapp")
        .help_expected(true)
        .arg(Arg::new("foo"))
        .arg(Arg::new("bar").help("It does bar stuff"))
        .try_get_matches_from(empty_args())
        .unwrap();
}

#[test]
#[should_panic = "List of such arguments: delete"]
fn help_required_globally() {
    Command::new("myapp")
        .help_expected(true)
        .arg(Arg::new("foo").help("It does foo stuff"))
        .subcommand(
            Command::new("bar")
                .arg(Arg::new("create").help("creates bar"))
                .arg(Arg::new("delete")),
        )
        .try_get_matches_from(empty_args())
        .unwrap();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command::help_expected is enabled for the Command"]
fn help_required_globally_but_not_given_for_subcommand() {
    Command::new("myapp")
        .help_expected(true)
        .arg(Arg::new("foo").help("It does foo stuff"))
        .subcommand(
            Command::new("bar")
                .arg(Arg::new("create").help("creates bar"))
                .arg(Arg::new("delete")),
        )
        .try_get_matches_from(empty_args())
        .unwrap();
}

#[test]
fn help_required_and_given_for_subcommand() {
    Command::new("myapp")
        .help_expected(true)
        .arg(Arg::new("foo").help("It does foo stuff"))
        .subcommand(
            Command::new("bar")
                .arg(Arg::new("create").help("creates bar"))
                .arg(Arg::new("delete").help("deletes bar")),
        )
        .try_get_matches_from(empty_args())
        .unwrap();
}

#[test]
fn help_required_and_given() {
    Command::new("myapp")
        .help_expected(true)
        .arg(Arg::new("foo").help("It does foo stuff"))
        .try_get_matches_from(empty_args())
        .unwrap();
}

#[test]
fn help_required_and_no_args() {
    Command::new("myapp")
        .help_expected(true)
        .try_get_matches_from(empty_args())
        .unwrap();
}

#[test]
fn issue_1642_long_help_spacing() {
    let cmd = Command::new("prog").arg(
        Arg::new("cfg")
            .long("config")
            .action(ArgAction::SetTrue)
            .long_help(
                "The config file used by the myprog must be in JSON format
with only valid keys and may not contain other nonsense
that cannot be read by this program. Obviously I'm going on
and on, so I'll stop now.",
            ),
    );

    let expected = str![[r#"
Usage: prog [OPTIONS]

Options:
      --config
          The config file used by the myprog must be in JSON format
          with only valid keys and may not contain other nonsense
          that cannot be read by this program. Obviously I'm going on
          and on, so I'll stop now.

  -h, --help
          Print help (see a summary with '-h')

"#]];
    utils::assert_output(cmd, "prog --help", expected, false);
}

const AFTER_HELP_NO_ARGS: &str = "\
Usage: myapp

This is after help.
";

#[test]
fn after_help_no_args() {
    let mut cmd = Command::new("myapp")
        .version("1.0")
        .disable_help_flag(true)
        .disable_version_flag(true)
        .after_help("This is after help.");

    let help = cmd.render_help().to_string();

    assert_eq!(help, AFTER_HELP_NO_ARGS);
}

#[test]
fn help_subcmd_help() {
    let cmd = Command::new("myapp")
        .subcommand(Command::new("subcmd").subcommand(Command::new("multi").version("1.0")));

    let expected = str![[r#"
Print this message or the help of the given subcommand(s)

Usage: myapp help [COMMAND]...

Arguments:
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd.clone(), "myapp help help", expected, false);
}

#[test]
fn subcmd_help_subcmd_help() {
    let cmd = Command::new("myapp")
        .subcommand(Command::new("subcmd").subcommand(Command::new("multi").version("1.0")));

    let expected = str![[r#"
Print this message or the help of the given subcommand(s)

Usage: myapp subcmd help [COMMAND]...

Arguments:
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd.clone(), "myapp subcmd help help", expected, false);
}

#[test]
fn global_args_should_show_on_toplevel_help_message() {
    let cmd = Command::new("myapp")
        .arg(
            Arg::new("someglobal")
                .short('g')
                .long("some-global")
                .global(true),
        )
        .subcommand(Command::new("subcmd").subcommand(Command::new("multi").version("1.0")));

    let expected = str![[r#"
Usage: myapp [OPTIONS] [COMMAND]

Commands:
  subcmd  
  help    Print this message or the help of the given subcommand(s)

Options:
  -g, --some-global <someglobal>  
  -h, --help                      Print help

"#]];
    utils::assert_output(cmd, "myapp help", expected, false);
}

#[test]
fn global_args_should_not_show_on_help_message_for_help_help() {
    let cmd = Command::new("myapp")
        .arg(
            Arg::new("someglobal")
                .short('g')
                .long("some-global")
                .global(true),
        )
        .subcommand(Command::new("subcmd").subcommand(Command::new("multi").version("1.0")));

    let expected = str![[r#"
Print this message or the help of the given subcommand(s)

Usage: myapp help [COMMAND]...

Arguments:
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "myapp help help", expected, false);
}

#[test]
fn global_args_should_show_on_help_message_for_subcommand() {
    let cmd = Command::new("myapp")
        .arg(
            Arg::new("someglobal")
                .short('g')
                .long("some-global")
                .global(true),
        )
        .subcommand(Command::new("subcmd").subcommand(Command::new("multi").version("1.0")));

    let expected = str![[r#"
Usage: myapp subcmd [OPTIONS] [COMMAND]

Commands:
  multi  
  help   Print this message or the help of the given subcommand(s)

Options:
  -g, --some-global <someglobal>  
  -h, --help                      Print help

"#]];
    utils::assert_output(cmd, "myapp help subcmd", expected, false);
}

#[test]
fn global_args_should_show_on_help_message_for_nested_subcommand() {
    let cmd = Command::new("myapp")
        .arg(
            Arg::new("someglobal")
                .short('g')
                .long("some-global")
                .global(true),
        )
        .subcommand(Command::new("subcmd").subcommand(Command::new("multi").version("1.0")));

    let expected = str![[r#"
Usage: myapp subcmd multi [OPTIONS]

Options:
  -g, --some-global <someglobal>  
  -h, --help                      Print help
  -V, --version                   Print version

"#]];
    utils::assert_output(cmd, "myapp help subcmd multi", expected, false);
}

#[test]
fn option_usage_order() {
    let cmd = Command::new("order").args([
        Arg::new("a").short('a').action(ArgAction::SetTrue),
        Arg::new("B").short('B').action(ArgAction::SetTrue),
        Arg::new("b").short('b').action(ArgAction::SetTrue),
        Arg::new("save").short('s').action(ArgAction::SetTrue),
        Arg::new("select_file")
            .long("select_file")
            .action(ArgAction::SetTrue),
        Arg::new("select_folder")
            .long("select_folder")
            .action(ArgAction::SetTrue),
        Arg::new("x").short('x').action(ArgAction::SetTrue),
    ]);

    let expected = str![[r#"
Usage: order [OPTIONS]

Options:
  -a                   
  -B                   
  -b                   
  -s                   
      --select_file    
      --select_folder  
  -x                   
  -h, --help           Print help

"#]];
    utils::assert_output(cmd, "order --help", expected, false);
}

#[test]
fn prefer_about_over_long_about_in_subcommands_list() {
    let cmd = Command::new("about-in-subcommands-list").subcommand(
        Command::new("sub")
            .long_about("long about sub")
            .about("short about sub"),
    );

    let expected = str![[r#"
Usage: about-in-subcommands-list [COMMAND]

Commands:
  sub   short about sub
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "about-in-subcommands-list --help", expected, false);
}

#[test]
fn issue_1794_usage() {
    let cmd = Command::new("hello")
        .bin_name("deno")
        .arg(
            Arg::new("option1")
                .long("option1")
                .action(ArgAction::SetTrue),
        )
        .arg(Arg::new("pos1").action(ArgAction::Set))
        .group(
            ArgGroup::new("arg1")
                .args(["pos1", "option1"])
                .required(true),
        )
        .arg(Arg::new("pos2").action(ArgAction::Set));

    let expected = str![[r#"
Usage: deno <pos1|--option1> [pos2]

Arguments:
  [pos1]  
  [pos2]  

Options:
      --option1  
  -h, --help     Print help

"#]];
    utils::assert_output(cmd, "deno --help", expected, false);
}

#[test]
fn custom_heading_pos() {
    let cmd = Command::new("test")
        .version("1.4")
        .arg(Arg::new("gear").help("Which gear"))
        .next_help_heading(Some("NETWORKING"))
        .arg(Arg::new("speed").help("How fast"));

    let expected = str![[r#"
Usage: test [gear] [speed]

Arguments:
  [gear]  Which gear

Options:
  -h, --help     Print help
  -V, --version  Print version

NETWORKING:
  [speed]  How fast

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn only_custom_heading_opts_no_args() {
    let cmd = Command::new("test")
        .version("1.4")
        .disable_version_flag(true)
        .disable_help_flag(true)
        .arg(arg!(--help).action(ArgAction::Help).hide(true))
        .next_help_heading(Some("NETWORKING"))
        .arg(arg!(-s --speed <SPEED> "How fast"));

    let expected = str![[r#"
Usage: test [OPTIONS]

NETWORKING:
  -s, --speed <SPEED>  How fast

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn only_custom_heading_pos_no_args() {
    let cmd = Command::new("test")
        .version("1.4")
        .disable_version_flag(true)
        .disable_help_flag(true)
        .arg(arg!(--help).action(ArgAction::Help).hide(true))
        .next_help_heading(Some("NETWORKING"))
        .arg(Arg::new("speed").help("How fast"));

    let expected = str![[r#"
Usage: test [speed]

NETWORKING:
  [speed]  How fast

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn issue_2508_number_of_values_with_single_value_name() {
    let cmd = Command::new("my_app")
        .arg(Arg::new("some_arg").long("some_arg").num_args(2))
        .arg(
            Arg::new("some_arg_issue")
                .long("some_arg_issue")
                .num_args(2)
                .value_name("ARG"),
        );

    let expected = str![[r#"
Usage: my_app [OPTIONS]

Options:
      --some_arg <some_arg> <some_arg>  
      --some_arg_issue <ARG> <ARG>      
  -h, --help                            Print help

"#]];
    utils::assert_output(cmd, "my_app --help", expected, false);
}

#[test]
fn missing_positional_final_required() {
    let cmd = Command::new("test")
        .allow_missing_positional(true)
        .arg(Arg::new("arg1"))
        .arg(Arg::new("arg2").required(true));

    let expected = str![[r#"
Usage: test [arg1] <arg2>

Arguments:
  [arg1]  
  <arg2>  

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn missing_positional_final_multiple() {
    let cmd = Command::new("test")
        .allow_missing_positional(true)
        .arg(Arg::new("foo"))
        .arg(Arg::new("bar"))
        .arg(Arg::new("baz").action(ArgAction::Set).num_args(1..));

    let expected = str![[r#"
Usage: test [foo] [bar] [baz]...

Arguments:
  [foo]     
  [bar]     
  [baz]...  

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn positional_multiple_values_is_dotted() {
    let cmd = Command::new("test").arg(
        Arg::new("foo")
            .required(true)
            .action(ArgAction::Set)
            .num_args(1..),
    );

    let expected = str![[r#"
Usage: test <foo>...

Arguments:
  <foo>...  

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "test --help", expected, false);

    let cmd = Command::new("test").arg(
        Arg::new("foo")
            .required(true)
            .action(ArgAction::Set)
            .value_name("BAR")
            .num_args(1..),
    );

    let expected = str![[r#"
Usage: test <BAR>...

Arguments:
  <BAR>...  

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn positional_multiple_occurrences_is_dotted() {
    let cmd = Command::new("test").arg(
        Arg::new("foo")
            .required(true)
            .action(ArgAction::Set)
            .num_args(1..)
            .action(ArgAction::Append),
    );

    let expected = str![[r#"
Usage: test <foo>...

Arguments:
  <foo>...  

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "test --help", expected, false);

    let cmd = Command::new("test").arg(
        Arg::new("foo")
            .required(true)
            .action(ArgAction::Set)
            .value_name("BAR")
            .num_args(1..)
            .action(ArgAction::Append),
    );

    let expected = str![[r#"
Usage: test <BAR>...

Arguments:
  <BAR>...  

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
fn too_few_value_names_is_dotted() {
    let cmd = Command::new("test").arg(
        Arg::new("foo")
            .long("foo")
            .required(true)
            .action(ArgAction::Set)
            .num_args(3)
            .value_names(["one", "two"]),
    );

    let expected = str![[r#"
Usage: test --foo <one> <two>...

Options:
      --foo <one> <two>...  
  -h, --help                Print help

"#]];
    utils::assert_output(cmd, "test --help", expected, false);
}

#[test]
#[should_panic = "Argument foo: Too many value names (2) compared to `num_args` (1)"]
fn too_many_value_names_panics() {
    Command::new("test")
        .arg(
            Arg::new("foo")
                .long("foo")
                .required(true)
                .action(ArgAction::Set)
                .num_args(1)
                .value_names(["one", "two"]),
        )
        .debug_assert();
}

#[test]
fn disabled_help_flag() {
    let res = Command::new("foo")
        .subcommand(Command::new("sub"))
        .disable_help_flag(true)
        .try_get_matches_from("foo a".split(' '));
    assert!(res.is_err());
    let err = res.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::InvalidSubcommand);
}

#[test]
fn disabled_help_flag_and_subcommand() {
    let res = Command::new("foo")
        .subcommand(Command::new("sub"))
        .disable_help_flag(true)
        .disable_help_subcommand(true)
        .try_get_matches_from("foo help".split(' '));
    assert!(res.is_err());
    let err = res.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::InvalidSubcommand);
    assert!(
        err.to_string().ends_with('\n'),
        "Errors should have a trailing newline, got {:?}",
        err.to_string()
    );
}

#[test]
fn override_help_subcommand() {
    let cmd = Command::new("bar")
        .subcommand(Command::new("help").arg(Arg::new("arg").action(ArgAction::Set)))
        .subcommand(Command::new("not_help").arg(Arg::new("arg").action(ArgAction::Set)))
        .disable_help_subcommand(true);
    let matches = cmd.try_get_matches_from(["bar", "help", "foo"]).unwrap();
    assert_eq!(
        matches
            .subcommand_matches("help")
            .unwrap()
            .get_one::<String>("arg")
            .map(|v| v.as_str()),
        Some("foo")
    );
}

#[test]
fn override_help_flag_using_long() {
    let cmd = Command::new("foo")
        .subcommand(Command::new("help").long_flag("help"))
        .disable_help_flag(true)
        .disable_help_subcommand(true);
    let matches = cmd.try_get_matches_from(["foo", "--help"]).unwrap();
    assert!(matches.subcommand_matches("help").is_some());
}

#[test]
fn override_help_flag_using_short() {
    let cmd = Command::new("foo")
        .disable_help_flag(true)
        .disable_help_subcommand(true)
        .subcommand(Command::new("help").short_flag('h'));
    let matches = cmd.try_get_matches_from(["foo", "-h"]).unwrap();
    assert!(matches.subcommand_matches("help").is_some());
}

#[test]
fn subcommand_help_doesnt_have_useless_help_flag() {
    // The main care-about is that the docs and behavior match.  Since the `help` subcommand
    // currently ignores the `--help` flag, the output shouldn't have it.
    let cmd = Command::new("example").subcommand(Command::new("test").about("Subcommand"));

    let expected = str![[r#"
Print this message or the help of the given subcommand(s)

Usage: example help [COMMAND]...

Arguments:
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "example help help", expected, false);
}

#[test]
fn disable_help_flag_affects_help_subcommand() {
    let mut cmd = Command::new("test_app")
        .disable_help_flag(true)
        .subcommand(Command::new("test").about("Subcommand"));
    cmd.build();

    let args = cmd
        .find_subcommand("help")
        .unwrap()
        .get_arguments()
        .map(|a| a.get_id().as_str())
        .collect::<Vec<_>>();
    assert!(
        !args.contains(&"help"),
        "`help` should not be present: {args:?}"
    );
}

#[test]
fn dont_propagate_version_to_help_subcommand() {
    let cmd = Command::new("example")
        .version("1.0")
        .propagate_version(true)
        .subcommand(Command::new("subcommand"));

    let expected = str![[r#"
Print this message or the help of the given subcommand(s)

Usage: example help [COMMAND]...

Arguments:
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd.clone(), "example help help", expected, false);

    cmd.debug_assert();
}

#[test]
fn help_without_short() {
    let mut cmd = Command::new("test")
        .arg(arg!(-h --hex <NUM>).required(true))
        .arg(arg!(--help).action(ArgAction::Help))
        .disable_help_flag(true);

    cmd.build();
    let help = cmd.get_arguments().find(|a| a.get_id() == "help").unwrap();
    assert_eq!(help.get_short(), None);

    let m = cmd.try_get_matches_from(["test", "-h", "0x100"]).unwrap();
    assert_eq!(
        m.get_one::<String>("hex").map(|v| v.as_str()),
        Some("0x100")
    );
}

#[test]
fn parent_cmd_req_in_usage_with_help_flag() {
    let cmd = Command::new("parent")
        .version("0.1")
        .arg(Arg::new("TARGET").required(true).help("some"))
        .arg(
            Arg::new("ARGS")
                .action(ArgAction::Set)
                .required(true)
                .help("some"),
        )
        .subcommand(Command::new("test").about("some"));

    let expected = str![[r#"
some

Usage: parent <TARGET> <ARGS> test

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "parent test --help", expected, false);
}

#[test]
fn parent_cmd_req_in_usage_with_help_subcommand() {
    let cmd = Command::new("parent")
        .version("0.1")
        .arg(Arg::new("TARGET").required(true).help("some"))
        .arg(
            Arg::new("ARGS")
                .action(ArgAction::Set)
                .required(true)
                .help("some"),
        )
        .subcommand(Command::new("test").about("some"));

    let expected = str![[r#"
some

Usage: parent <TARGET> <ARGS> test

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "parent help test", expected, false);
}

#[test]
fn parent_cmd_req_in_usage_with_render_help() {
    let mut cmd = Command::new("parent")
        .version("0.1")
        .arg(Arg::new("TARGET").required(true).help("some"))
        .arg(
            Arg::new("ARGS")
                .action(ArgAction::Set)
                .required(true)
                .help("some"),
        )
        .subcommand(Command::new("test").about("some"));
    cmd.build();
    let subcmd = cmd.find_subcommand_mut("test").unwrap();

    let help = subcmd.render_help().to_string();
    assert_data_eq!(
        help,
        str![[r#"
some

Usage: parent <TARGET> <ARGS> test

Options:
  -h, --help  Print help

"#]]
    );
}

#[test]
fn parent_cmd_req_ignored_when_negates_reqs() {
    let cmd = Command::new("ctest")
        .arg(arg!(<input>))
        .subcommand_negates_reqs(true)
        .subcommand(Command::new("subcmd"));

    let expected = str![[r#"
Usage: ctest subcmd

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "ctest subcmd --help", expected, false);
}

#[test]
fn parent_cmd_req_ignored_when_conflicts() {
    let cmd = Command::new("ctest")
        .arg(arg!(<input>))
        .args_conflicts_with_subcommands(true)
        .subcommand(Command::new("subcmd"));

    let expected = str![[r#"
Usage: ctest subcmd

Options:
  -h, --help  Print help

"#]];
    utils::assert_output(cmd, "ctest subcmd --help", expected, false);
}

#[test]
fn no_wrap_help() {
    static MULTI_SC_HELP: &str = "\
tests subcommands

Usage: ctest subcmd multi [OPTIONS]

Options:
  -f, --flag                  tests flags
  -o, --option <scoption>...  tests options
  -h, --help                  Print help
  -V, --version               Print version
";
    let cmd = Command::new("ctest")
        .term_width(0)
        .override_help(MULTI_SC_HELP);

    utils::assert_output(cmd, "ctest --help", MULTI_SC_HELP, false);
}

#[test]
fn display_name_default() {
    let mut cmd = Command::new("app").bin_name("app.exe");
    cmd.build();
    assert_eq!(cmd.get_display_name(), None);
}

#[test]
fn display_name_explicit() {
    let mut cmd = Command::new("app")
        .bin_name("app.exe")
        .display_name("app.display");
    cmd.build();
    assert_eq!(cmd.get_display_name(), Some("app.display"));
}

#[test]
fn display_name_subcommand_default() {
    let mut cmd = Command::new("parent").subcommand(Command::new("child").bin_name("child.exe"));
    cmd.build();
    assert_eq!(
        cmd.find_subcommand("child").unwrap().get_display_name(),
        Some("parent-child")
    );
}

#[test]
fn display_name_subcommand_explicit() {
    let mut cmd = Command::new("parent").subcommand(
        Command::new("child")
            .bin_name("child.exe")
            .display_name("child.display"),
    );
    cmd.build();
    assert_eq!(
        cmd.find_subcommand("child").unwrap().get_display_name(),
        Some("child.display")
    );
}

#[test]
fn flatten_basic() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(Arg::new("parent").long("parent"))
        .subcommand(
            Command::new("test")
                .about("test command")
                .arg(Arg::new("child").long("child")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent test [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>  
  -h, --help             Print help

parent test:
test command
      --child <child>  
  -h, --help           Print help

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_short_help() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(
            Arg::new("parent")
                .long("parent")
                .help("foo")
                .long_help("bar"),
        )
        .subcommand(
            Command::new("test")
                .about("test command")
                .long_about("long some")
                .arg(Arg::new("child").long("child").help("foo").long_help("bar")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent test [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>  foo
  -h, --help             Print help (see more with '--help')

parent test:
test command
      --child <child>  foo
  -h, --help           Print help (see more with '--help')

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_long_help() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(
            Arg::new("parent")
                .long("parent")
                .help("foo")
                .long_help("bar"),
        )
        .subcommand(
            Command::new("test")
                .about("test command")
                .long_about("long some")
                .arg(Arg::new("child").long("child").help("foo").long_help("bar")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent test [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>
          bar

  -h, --help
          Print help (see a summary with '-h')

parent test:
test command
      --child <child>
          bar

  -h, --help
          Print help (see a summary with '-h')

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...
          Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent --help", expected, false);
}

#[test]
fn flatten_help_cmd() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(
            Arg::new("parent")
                .long("parent")
                .help("foo")
                .long_help("bar"),
        )
        .subcommand(
            Command::new("test")
                .about("test command")
                .long_about("long some")
                .arg(Arg::new("child").long("child").help("foo").long_help("bar")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent test [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>
          bar

  -h, --help
          Print help (see a summary with '-h')

parent test:
test command
      --child <child>
          bar

  -h, --help
          Print help (see a summary with '-h')

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...
          Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent help", expected, false);
}

#[test]
fn flatten_with_global() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(Arg::new("parent").long("parent").global(true))
        .subcommand(
            Command::new("test")
                .about("test command")
                .arg(Arg::new("child").long("child")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent test [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>  
  -h, --help             Print help

parent test:
test command
      --child <child>  
  -h, --help           Print help

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_arg_required() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(Arg::new("parent").long("parent").required(true))
        .subcommand(
            Command::new("test")
                .about("test command")
                .arg(Arg::new("child").long("child").required(true)),
        );

    let expected = str![[r#"
parent command

Usage: parent --parent <parent>
       parent --parent <parent> test --child <child>
       parent --parent <parent> help [COMMAND]...

Options:
      --parent <parent>  
  -h, --help             Print help

parent --parent <parent> test:
test command
      --child <child>  
  -h, --help           Print help

parent --parent <parent> help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_with_external_subcommand() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .allow_external_subcommands(true)
        .arg(Arg::new("parent").long("parent"))
        .subcommand(
            Command::new("test")
                .about("test command")
                .arg(Arg::new("child").long("child")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent test [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>  
  -h, --help             Print help

parent test:
test command
      --child <child>  
  -h, --help           Print help

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_without_subcommands() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(Arg::new("parent").long("parent"));

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]

Options:
      --parent <parent>  
  -h, --help             Print help

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_with_subcommand_required() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .subcommand_required(true)
        .arg(Arg::new("parent").long("parent"))
        .subcommand(
            Command::new("test")
                .about("test command")
                .arg(Arg::new("child").long("child")),
        );

    let expected = str![[r#"
parent command

Usage: parent test [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>  
  -h, --help             Print help

parent test:
test command
      --child <child>  
  -h, --help           Print help

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_with_args_conflicts_with_subcommands() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .subcommand_required(true)
        .args_conflicts_with_subcommands(true)
        .arg(Arg::new("parent").long("parent"))
        .subcommand(
            Command::new("test")
                .about("test command")
                .arg(Arg::new("child").long("child")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent test [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>  
  -h, --help             Print help

parent test:
test command
      --child <child>  
  -h, --help           Print help

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_single_hidden_command() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(Arg::new("parent").long("parent"))
        .subcommand(
            Command::new("child1")
                .hide(true)
                .about("child1 command")
                .arg(Arg::new("child").long("child1")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]

Options:
      --parent <parent>  
  -h, --help             Print help

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_hidden_command() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(Arg::new("parent").long("parent"))
        .subcommand(
            Command::new("child1")
                .about("child1 command")
                .arg(Arg::new("child").long("child1")),
        )
        .subcommand(
            Command::new("child2")
                .about("child2 command")
                .arg(Arg::new("child").long("child2")),
        )
        .subcommand(
            Command::new("child3")
                .hide(true)
                .about("child3 command")
                .arg(Arg::new("child").long("child3")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent child1 [OPTIONS]
       parent child2 [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>  
  -h, --help             Print help

parent child1:
child1 command
      --child1 <child>  
  -h, --help            Print help

parent child2:
child2 command
      --child2 <child>  
  -h, --help            Print help

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_recursive() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(Arg::new("parent").long("parent"))
        .subcommand(
            Command::new("child1")
                .flatten_help(true)
                .about("child1 command")
                .arg(Arg::new("child").long("child1"))
                .subcommand(
                    Command::new("grandchild1")
                        .flatten_help(true)
                        .about("grandchild1 command")
                        .arg(Arg::new("grandchild").long("grandchild1"))
                        .subcommand(
                            Command::new("greatgrandchild1")
                                .about("greatgrandchild1 command")
                                .arg(Arg::new("greatgrandchild").long("greatgrandchild1")),
                        )
                        .subcommand(
                            Command::new("greatgrandchild2")
                                .about("greatgrandchild2 command")
                                .arg(Arg::new("greatgrandchild").long("greatgrandchild2")),
                        )
                        .subcommand(
                            Command::new("greatgrandchild3")
                                .about("greatgrandchild3 command")
                                .arg(Arg::new("greatgrandchild").long("greatgrandchild3")),
                        ),
                )
                .subcommand(
                    Command::new("grandchild2")
                        .about("grandchild2 command")
                        .arg(Arg::new("grandchild").long("grandchild2")),
                )
                .subcommand(
                    Command::new("grandchild3")
                        .about("grandchild3 command")
                        .arg(Arg::new("grandchild").long("grandchild3")),
                ),
        )
        .subcommand(
            Command::new("child2")
                .about("child2 command")
                .arg(Arg::new("child").long("child2")),
        )
        .subcommand(
            Command::new("child3")
                .hide(true)
                .about("child3 command")
                .arg(Arg::new("child").long("child3"))
                .subcommand(
                    Command::new("grandchild1")
                        .flatten_help(true)
                        .about("grandchild1 command")
                        .arg(Arg::new("grandchild").long("grandchild1"))
                        .subcommand(
                            Command::new("greatgrandchild1")
                                .about("greatgrandchild1 command")
                                .arg(Arg::new("greatgrandchild").long("greatgrandchild1")),
                        )
                        .subcommand(
                            Command::new("greatgrandchild2")
                                .about("greatgrandchild2 command")
                                .arg(Arg::new("greatgrandchild").long("greatgrandchild2")),
                        )
                        .subcommand(
                            Command::new("greatgrandchild3")
                                .about("greatgrandchild3 command")
                                .arg(Arg::new("greatgrandchild").long("greatgrandchild3")),
                        ),
                )
                .subcommand(
                    Command::new("grandchild2")
                        .about("grandchild2 command")
                        .arg(Arg::new("grandchild").long("grandchild2")),
                )
                .subcommand(
                    Command::new("grandchild3")
                        .about("grandchild3 command")
                        .arg(Arg::new("grandchild").long("grandchild3")),
                ),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent child1 [OPTIONS]
       parent child1 grandchild1 [OPTIONS]
       parent child1 grandchild1 greatgrandchild1 [OPTIONS]
       parent child1 grandchild1 greatgrandchild2 [OPTIONS]
       parent child1 grandchild1 greatgrandchild3 [OPTIONS]
       parent child1 grandchild1 help [COMMAND]
       parent child1 grandchild2 [OPTIONS]
       parent child1 grandchild3 [OPTIONS]
       parent child1 help [COMMAND]
       parent child2 [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>  
  -h, --help             Print help

parent child1:
child1 command
      --child1 <child>  
  -h, --help            Print help

parent child1 grandchild1:
grandchild1 command
      --grandchild1 <grandchild>  
  -h, --help                      Print help

parent child1 grandchild1 greatgrandchild1:
greatgrandchild1 command
      --greatgrandchild1 <greatgrandchild>  
  -h, --help                                Print help

parent child1 grandchild1 greatgrandchild2:
greatgrandchild2 command
      --greatgrandchild2 <greatgrandchild>  
  -h, --help                                Print help

parent child1 grandchild1 greatgrandchild3:
greatgrandchild3 command
      --greatgrandchild3 <greatgrandchild>  
  -h, --help                                Print help

parent child1 grandchild1 help:
Print this message or the help of the given subcommand(s)

parent child1 grandchild2:
grandchild2 command
      --grandchild2 <grandchild>  
  -h, --help                      Print help

parent child1 grandchild3:
grandchild3 command
      --grandchild3 <grandchild>  
  -h, --help                      Print help

parent child1 help:
Print this message or the help of the given subcommand(s)

parent child2:
child2 command
      --child2 <child>  
  -h, --help            Print help

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn flatten_not_recursive() {
    let cmd = Command::new("parent")
        .flatten_help(true)
        .about("parent command")
        .arg(Arg::new("parent").long("parent"))
        .subcommand(
            Command::new("child1")
                .about("child1 command")
                .arg(Arg::new("child").long("child1"))
                .subcommand(
                    Command::new("grandchild1")
                        .about("grandchild1 command")
                        .arg(Arg::new("grandchild").long("grandchild1")),
                )
                .subcommand(
                    Command::new("grandchild2")
                        .about("grandchild2 command")
                        .arg(Arg::new("grandchild").long("grandchild2")),
                )
                .subcommand(
                    Command::new("grandchild3")
                        .about("grandchild3 command")
                        .arg(Arg::new("grandchild").long("grandchild3")),
                ),
        )
        .subcommand(
            Command::new("child2")
                .about("child2 command")
                .arg(Arg::new("child").long("child2")),
        )
        .subcommand(
            Command::new("child3")
                .about("child3 command")
                .arg(Arg::new("child").long("child3")),
        );

    let expected = str![[r#"
parent command

Usage: parent [OPTIONS]
       parent child1 [OPTIONS] [COMMAND]
       parent child2 [OPTIONS]
       parent child3 [OPTIONS]
       parent help [COMMAND]...

Options:
      --parent <parent>  
  -h, --help             Print help

parent child1:
child1 command
      --child1 <child>  
  -h, --help            Print help

parent child2:
child2 command
      --child2 <child>  
  -h, --help            Print help

parent child3:
child3 command
      --child3 <child>  
  -h, --help            Print help

parent help:
Print this message or the help of the given subcommand(s)
  [COMMAND]...  Print help for the subcommand(s)

"#]];
    utils::assert_output(cmd, "parent -h", expected, false);
}

#[test]
fn mixed_argument_types() {
    let cmd = Command::new("myprog")
        .about("mixed arguments")
        .next_help_heading("Mixed")
        .arg(arg!(-b --both "Both long and short"))
        .arg(arg!(--long "Long only"))
        .arg(arg!(<POSITIONAL> "Positional"));

    let expected = str![[r#"
mixed arguments

Usage: myprog [OPTIONS] <POSITIONAL>

Options:
  -h, --help  Print help

Mixed:
  -b, --both    Both long and short
      --long    Long only
  <POSITIONAL>  Positional

"#]];
    utils::assert_output(cmd, "myprog --help", expected, false);
}

#[test]
fn mixed_argument_types_short_positional() {
    let cmd = Command::new("myprog")
        .about("mixed arguments")
        .next_help_heading("Mixed")
        .arg(arg!(-b --both "Both long and short"))
        .arg(arg!(--long "Long only"))
        .arg(arg!(<S> "Short positional"));

    let expected = str![[r#"
mixed arguments

Usage: myprog [OPTIONS] <S>

Options:
  -h, --help  Print help

Mixed:
  -b, --both  Both long and short
      --long  Long only
  <S>         Short positional

"#]];
    utils::assert_output(cmd, "myprog --help", expected, false);
}

#[test]
fn mixed_argument_types_no_short() {
    let cmd = Command::new("myprog")
        .about("mixed arguments")
        .next_help_heading("Mixed")
        .arg(arg!(--long "Long only"))
        .arg(arg!(<POSITIONAL> "Positional"));

    let expected = str![[r#"
mixed arguments

Usage: myprog [OPTIONS] <POSITIONAL>

Options:
  -h, --help  Print help

Mixed:
      --long    Long only
  <POSITIONAL>  Positional

"#]];
    utils::assert_output(cmd, "myprog --help", expected, false);
}

```

`clap/tests/builder/help_env.rs`:

```rs
#![cfg(feature = "env")]

use std::env;

use clap::{Arg, ArgAction, Command};

use super::utils;

static HIDE_ENV: &str = "\
Usage: ctest [OPTIONS]

Options:
  -c, --cafe <FILE>  A coffeehouse, coffee shop, or café.
  -h, --help         Print help
  -V, --version      Print version
";

static SHOW_ENV: &str = "\
Usage: ctest [OPTIONS]

Options:
  -c, --cafe <FILE>  A coffeehouse, coffee shop, or café. [env: ENVVAR=MYVAL]
  -h, --help         Print help
  -V, --version      Print version
";

static HIDE_ENV_VALS: &str = "\
Usage: ctest [OPTIONS]

Options:
  -c, --cafe <FILE>  A coffeehouse, coffee shop, or café. [env: ENVVAR]
  -h, --help         Print help
  -V, --version      Print version
";

static SHOW_ENV_VALS: &str = "\
Usage: ctest [OPTIONS]

Options:
  -c, --cafe <FILE>  A coffeehouse, coffee shop, or café. [env: ENVVAR=MYVAL]
  -h, --help         Print help
  -V, --version      Print version
";

static HIDE_ENV_FLAG: &str = "\
Usage: ctest [OPTIONS]

Options:
  -c, --cafe     A coffeehouse, coffee shop, or café.
  -h, --help     Print help
  -V, --version  Print version
";

static SHOW_ENV_FLAG: &str = "\
Usage: ctest [OPTIONS]

Options:
  -c, --cafe     A coffeehouse, coffee shop, or café. [env: ENVVAR=MYVAL]
  -h, --help     Print help
  -V, --version  Print version
";

static HIDE_ENV_VALS_FLAG: &str = "\
Usage: ctest [OPTIONS]

Options:
  -c, --cafe     A coffeehouse, coffee shop, or café. [env: ENVVAR]
  -h, --help     Print help
  -V, --version  Print version
";

static SHOW_ENV_VALS_FLAG: &str = "\
Usage: ctest [OPTIONS]

Options:
  -c, --cafe     A coffeehouse, coffee shop, or café. [env: ENVVAR=MYVAL]
  -h, --help     Print help
  -V, --version  Print version
";

#[test]
fn hide_env() {
    env::set_var("ENVVAR", "MYVAL");

    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("cafe")
            .short('c')
            .long("cafe")
            .value_name("FILE")
            .hide_env(true)
            .env("ENVVAR")
            .help("A coffeehouse, coffee shop, or café.")
            .action(ArgAction::Set),
    );

    utils::assert_output(cmd, "ctest --help", HIDE_ENV, false);
}

#[test]
fn show_env() {
    env::set_var("ENVVAR", "MYVAL");

    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("cafe")
            .short('c')
            .long("cafe")
            .value_name("FILE")
            .env("ENVVAR")
            .help("A coffeehouse, coffee shop, or café.")
            .action(ArgAction::Set),
    );

    utils::assert_output(cmd, "ctest --help", SHOW_ENV, false);
}

#[test]
fn hide_env_vals() {
    env::set_var("ENVVAR", "MYVAL");

    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("cafe")
            .short('c')
            .long("cafe")
            .value_name("FILE")
            .hide_env_values(true)
            .env("ENVVAR")
            .help("A coffeehouse, coffee shop, or café.")
            .action(ArgAction::Set),
    );

    utils::assert_output(cmd, "ctest --help", HIDE_ENV_VALS, false);
}

#[test]
fn show_env_vals() {
    env::set_var("ENVVAR", "MYVAL");

    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("cafe")
            .short('c')
            .long("cafe")
            .value_name("FILE")
            .env("ENVVAR")
            .help("A coffeehouse, coffee shop, or café.")
            .action(ArgAction::Set),
    );

    utils::assert_output(cmd, "ctest --help", SHOW_ENV_VALS, false);
}

#[test]
fn hide_env_flag() {
    env::set_var("ENVVAR", "MYVAL");

    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("cafe")
            .short('c')
            .long("cafe")
            .action(ArgAction::SetTrue)
            .hide_env(true)
            .env("ENVVAR")
            .help("A coffeehouse, coffee shop, or café."),
    );

    utils::assert_output(cmd, "ctest --help", HIDE_ENV_FLAG, false);
}

#[test]
fn show_env_flag() {
    env::set_var("ENVVAR", "MYVAL");

    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("cafe")
            .short('c')
            .long("cafe")
            .action(ArgAction::SetTrue)
            .env("ENVVAR")
            .help("A coffeehouse, coffee shop, or café."),
    );

    utils::assert_output(cmd, "ctest --help", SHOW_ENV_FLAG, false);
}

#[test]
fn hide_env_vals_flag() {
    env::set_var("ENVVAR", "MYVAL");

    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("cafe")
            .short('c')
            .long("cafe")
            .action(ArgAction::SetTrue)
            .hide_env_values(true)
            .env("ENVVAR")
            .help("A coffeehouse, coffee shop, or café."),
    );

    utils::assert_output(cmd, "ctest --help", HIDE_ENV_VALS_FLAG, false);
}

#[test]
fn show_env_vals_flag() {
    env::set_var("ENVVAR", "MYVAL");

    let cmd = Command::new("ctest").version("0.1").arg(
        Arg::new("cafe")
            .short('c')
            .long("cafe")
            .action(ArgAction::SetTrue)
            .env("ENVVAR")
            .help("A coffeehouse, coffee shop, or café."),
    );

    utils::assert_output(cmd, "ctest --help", SHOW_ENV_VALS_FLAG, false);
}

```

`clap/tests/builder/hidden_args.rs`:

```rs
use super::utils;

use clap::{arg, builder::PossibleValue, Arg, ArgAction, Command};

static HIDDEN_ARGS: &str = "\
tests stuff

Usage: test [OPTIONS]

Options:
  -F, --flag2         some other flag
      --option <opt>  some option
  -h, --help          Print help
  -V, --version       Print version
";

#[test]
fn hide_args() {
    let cmd = Command::new("test")
        .author("Kevin K.")
        .about("tests stuff")
        .version("1.4")
        .args([
            arg!(-f --flag "some flag").hide(true),
            arg!(-F --flag2 "some other flag"),
            arg!(--option <opt> "some option"),
            Arg::new("DUMMY").hide(true),
        ]);
    utils::assert_output(cmd, "test --help", HIDDEN_ARGS, false);
}

static HIDDEN_SHORT_ARGS: &str = "\
hides short args

Usage: test [OPTIONS]

Options:
  -v, --visible  This text should be visible
  -h, --help     Print help (see more with '--help')
  -V, --version  Print version
";

/// Ensure hide with short option
#[test]
fn hide_short_args() {
    let cmd = Command::new("test")
        .about("hides short args")
        .author("Steve P.")
        .version("2.31.2")
        .args([
            Arg::new("cfg")
                .short('c')
                .long("config")
                .hide_short_help(true)
                .action(ArgAction::SetTrue)
                .help("Some help text describing the --config arg"),
            Arg::new("visible")
                .short('v')
                .long("visible")
                .action(ArgAction::SetTrue)
                .help("This text should be visible"),
        ]);

    utils::assert_output(cmd, "test -h", HIDDEN_SHORT_ARGS, false);
}

/// Ensure visible with opposite option
#[test]
fn hide_short_args_long_help() {
    static HIDDEN_SHORT_ARGS_LONG_HELP: &str = "\
hides short args

Usage: test [OPTIONS]

Options:
  -c, --config
          Some help text describing the --config arg

  -v, --visible
          This text should be visible

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version
";

    let cmd = Command::new("test")
        .about("hides short args")
        .author("Steve P.")
        .version("2.31.2")
        .args([
            Arg::new("cfg")
                .short('c')
                .long("config")
                .hide_short_help(true)
                .action(ArgAction::SetTrue)
                .help("Some help text describing the --config arg"),
            Arg::new("visible")
                .short('v')
                .long("visible")
                .action(ArgAction::SetTrue)
                .help("This text should be visible"),
        ]);

    utils::assert_output(cmd, "test --help", HIDDEN_SHORT_ARGS_LONG_HELP, false);
}

static HIDDEN_LONG_ARGS: &str = "\
hides long args

Usage: test [OPTIONS]

Options:
  -v, --visible
          This text should be visible

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version
";

#[test]
fn hide_long_args() {
    let cmd = Command::new("test")
        .about("hides long args")
        .author("Steve P.")
        .version("2.31.2")
        .args([
            Arg::new("cfg")
                .short('c')
                .long("config")
                .hide_long_help(true)
                .action(ArgAction::SetTrue)
                .help("Some help text describing the --config arg"),
            Arg::new("visible")
                .short('v')
                .long("visible")
                .action(ArgAction::SetTrue)
                .help("This text should be visible"),
        ]);

    utils::assert_output(cmd, "test --help", HIDDEN_LONG_ARGS, false);
}

static HIDDEN_LONG_ARGS_SHORT_HELP: &str = "\
hides long args

Usage: test [OPTIONS]

Options:
  -c, --config   Some help text describing the --config arg
  -v, --visible  This text should be visible
  -h, --help     Print help (see more with '--help')
  -V, --version  Print version
";

#[test]
fn hide_long_args_short_help() {
    let cmd = Command::new("test")
        .about("hides long args")
        .author("Steve P.")
        .version("2.31.2")
        .args([
            Arg::new("cfg")
                .short('c')
                .long("config")
                .hide_long_help(true)
                .action(ArgAction::SetTrue)
                .help("Some help text describing the --config arg"),
            Arg::new("visible")
                .short('v')
                .long("visible")
                .action(ArgAction::SetTrue)
                .help("This text should be visible"),
        ]);

    utils::assert_output(cmd, "test -h", HIDDEN_LONG_ARGS_SHORT_HELP, false);
}

static HIDDEN_POS_ARGS: &str = "\
Usage: test [another]

Arguments:
  [another]  another pos

Options:
  -h, --help     Print help
  -V, --version  Print version
";

#[test]
fn hide_pos_args() {
    let cmd = Command::new("test").version("1.4").args([
        Arg::new("pos").help("some pos").hide(true),
        Arg::new("another").help("another pos"),
    ]);

    utils::assert_output(cmd, "test --help", HIDDEN_POS_ARGS, false);
}

static HIDDEN_SUBCMDS: &str = "\
Usage: test

Options:
  -h, --help     Print help
  -V, --version  Print version
";

#[test]
fn hide_subcmds() {
    let cmd = Command::new("test")
        .version("1.4")
        .subcommand(Command::new("sub").hide(true));

    utils::assert_output(cmd, "test --help", HIDDEN_SUBCMDS, false);
}

static HIDDEN_OPT_ARGS_ONLY: &str = "\
Usage: test

After help
";

#[test]
fn hide_opt_args_only() {
    let cmd = Command::new("test")
        .version("1.4")
        .after_help("After help")
        .disable_help_flag(true)
        .disable_version_flag(true)
        .arg(arg!(-h - -help).action(ArgAction::Help).hide(true))
        .arg(arg!(-v - -version).hide(true))
        .arg(arg!(--option <opt> "some option").hide(true));

    utils::assert_output(cmd, "test --help", HIDDEN_OPT_ARGS_ONLY, false);
}

static HIDDEN_POS_ARGS_ONLY: &str = "\
Usage: test

After help
";

#[test]
fn hide_pos_args_only() {
    let cmd = Command::new("test")
        .version("1.4")
        .after_help("After help")
        .disable_help_flag(true)
        .disable_version_flag(true)
        .arg(arg!(-h - -help).action(ArgAction::Help).hide(true))
        .arg(arg!(-v - -version).hide(true))
        .args([Arg::new("pos").help("some pos").hide(true)]);

    utils::assert_output(cmd, "test --help", HIDDEN_POS_ARGS_ONLY, false);
}

static HIDDEN_SUBCMDS_ONLY: &str = "\
Usage: test

After help
";

#[test]
fn hide_subcmds_only() {
    let cmd = Command::new("test")
        .version("1.4")
        .after_help("After help")
        .disable_help_flag(true)
        .disable_version_flag(true)
        .arg(arg!(-h - -help).action(ArgAction::Help).hide(true))
        .arg(arg!(-v - -version).hide(true))
        .subcommand(Command::new("sub").hide(true));

    utils::assert_output(cmd, "test --help", HIDDEN_SUBCMDS_ONLY, false);
}

#[test]
fn hidden_arg_with_possible_value_with_help() {
    // Normally the presence of a possible value with a help text triggers a
    // change of the --help help text by appending `(see more with '--help')`
    // or `(see a summary with '-h')`. When the argument is completely hidden
    // we however do not want it to trigger that change.
    static POS_VALS_HELP: &str = "\
Usage: ctest

Options:
  -h, --help  Print help
";
    let app = Command::new("ctest").arg(
        Arg::new("pos")
            .hide(true)
            .value_parser([
                PossibleValue::new("fast"),
                PossibleValue::new("slow").help("not as fast"),
            ])
            .action(ArgAction::Set),
    );
    utils::assert_output(app, "ctest --help", POS_VALS_HELP, false);
}

```

`clap/tests/builder/ignore_errors.rs`:

```rs
use clap::{arg, error::ErrorKind, parser::ValueSource, Arg, ArgAction, Command};
use snapbox::str;

use super::utils;

#[test]
fn single_short_arg_without_value() {
    let cmd = Command::new("cmd")
        .ignore_errors(true)
        .arg(arg!(
            -c --config <FILE> "Sets a custom config file"
        ))
        .arg(arg!(--"unset-flag"));

    let r = cmd.try_get_matches_from(vec!["cmd", "-c" /* missing: , "config file" */]);

    assert!(r.is_ok(), "unexpected error: {r:?}");
    let m = r.unwrap();
    assert!(m.contains_id("config"));
    assert_eq!(m.get_one::<String>("config").cloned(), None);
    assert_eq!(m.get_one::<bool>("unset-flag").copied(), Some(false));
}

#[test]
fn single_long_arg_without_value() {
    let cmd = Command::new("cmd")
        .ignore_errors(true)
        .arg(arg!(
            -c --config <FILE> "Sets a custom config file"
        ))
        .arg(arg!(--"unset-flag"));

    let r = cmd.try_get_matches_from(vec!["cmd", "--config" /* missing: , "config file" */]);

    assert!(r.is_ok(), "unexpected error: {r:?}");
    let m = r.unwrap();
    assert!(m.contains_id("config"));
    assert_eq!(m.get_one::<String>("config").cloned(), None);
    assert_eq!(m.get_one::<bool>("unset-flag").copied(), Some(false));
}

#[test]
fn multiple_args_and_final_arg_without_value() {
    let cmd = Command::new("cmd")
        .ignore_errors(true)
        .arg(arg!(
            -c --config <FILE> "Sets a custom config file"
        ))
        .arg(arg!(
            -x --stuff <FILE> "Sets a custom stuff file"
        ))
        .arg(arg!(f: -f "Flag").action(ArgAction::SetTrue))
        .arg(arg!(--"unset-flag"));

    let r = cmd.try_get_matches_from(vec![
        "cmd", "-c", "file", "-f", "-x", /* missing: , "some stuff" */
    ]);

    assert!(r.is_ok(), "unexpected error: {r:?}");
    let m = r.unwrap();
    assert_eq!(
        m.get_one::<String>("config").map(|v| v.as_str()),
        Some("file")
    );
    assert_eq!(m.get_one::<bool>("f").copied(), Some(true));
    assert_eq!(m.get_one::<String>("stuff").map(|v| v.as_str()), None);
    assert_eq!(m.get_one::<bool>("unset-flag").copied(), Some(false));
}

#[test]
fn multiple_args_and_intermittent_arg_without_value() {
    let cmd = Command::new("cmd")
        .ignore_errors(true)
        .arg(arg!(
            -c --config <FILE> "Sets a custom config file"
        ))
        .arg(arg!(
            -x --stuff <FILE> "Sets a custom stuff file"
        ))
        .arg(arg!(f: -f "Flag").action(ArgAction::SetTrue))
        .arg(arg!(--"unset-flag"));

    let r = cmd.try_get_matches_from(vec![
        "cmd", "-x", /* missing: ,"some stuff" */
        "-c", "file", "-f",
    ]);

    assert!(r.is_ok(), "unexpected error: {r:?}");
    let m = r.unwrap();
    assert_eq!(
        m.get_one::<String>("config").map(|v| v.as_str()),
        Some("file")
    );
    assert_eq!(m.get_one::<bool>("f").copied(), Some(true));
    assert_eq!(m.get_one::<String>("stuff").map(|v| v.as_str()), None);
    assert_eq!(m.get_one::<bool>("unset-flag").copied(), Some(false));
}

#[test]
fn unexpected_argument() {
    let cmd = Command::new("cmd")
        .ignore_errors(true)
        .arg(arg!(
            -c --config [FILE] "Sets a custom config file"
        ))
        .arg(arg!(--"unset-flag"));

    let r = cmd.try_get_matches_from(vec!["cmd", "-c", "config file", "unexpected"]);

    assert!(r.is_ok(), "unexpected error: {r:?}");
    let m = r.unwrap();
    assert!(m.contains_id("config"));
    assert_eq!(
        m.get_one::<String>("config").cloned(),
        Some("config file".to_owned())
    );
    assert_eq!(m.get_one::<bool>("unset-flag").copied(), Some(false));
}

#[test]
#[cfg(feature = "error-context")]
fn did_you_mean() {
    let mut cmd = Command::new("cmd").arg(arg!(--"ignore-immutable"));

    // Verify we are in a "did you mean" error
    let r = cmd.try_get_matches_from_mut(vec!["cmd", "--ig"]);
    assert!(r.is_err());
    let err = r.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::UnknownArgument,
        str![[r#"
error: unexpected argument '--ig' found

  tip: a similar argument exists: '--ignore-immutable'

Usage: cmd --ignore-immutable

For more information, try '--help'.

"#]],
        true,
    );

    let r = cmd
        .ignore_errors(true)
        .try_get_matches_from(vec!["cmd", "--ig"]);
    assert!(r.is_ok(), "unexpected error: {r:?}");
    let m = r.unwrap();
    assert!(m.contains_id("ignore-immutable"), "{m:#?}");
    assert_eq!(
        m.value_source("ignore-immutable"),
        Some(ValueSource::DefaultValue)
    );
}

#[test]
fn subcommand() {
    let cmd = Command::new("test")
        .ignore_errors(true)
        .subcommand(
            Command::new("some")
                .arg(
                    Arg::new("test")
                        .short('t')
                        .long("test")
                        .action(ArgAction::Set)
                        .help("testing testing"),
                )
                .arg(
                    Arg::new("stuff")
                        .short('x')
                        .long("stuff")
                        .action(ArgAction::Set)
                        .help("stuf value"),
                )
                .arg(arg!(--"unset-flag")),
        )
        .arg(Arg::new("other").long("other"))
        .arg(arg!(--"unset-flag"));

    let m = cmd
        .try_get_matches_from(vec![
            "myprog",
            "some",
            "--test", /* missing: ,"some val" */
            "-x",
            "some other val",
        ])
        .unwrap();

    assert_eq!(m.subcommand_name().unwrap(), "some");
    let sub_m = m.subcommand_matches("some").unwrap();
    assert!(
        sub_m.contains_id("test"),
        "expected subcommand to be present due to partial parsing"
    );
    assert_eq!(sub_m.get_one::<String>("test").map(|v| v.as_str()), None);
    assert_eq!(
        sub_m.get_one::<String>("stuff").map(|v| v.as_str()),
        Some("some other val")
    );
    assert_eq!(sub_m.get_one::<bool>("unset-flag").copied(), Some(false));

    assert_eq!(m.get_one::<bool>("unset-flag").copied(), Some(false));
}

#[test]
fn help_flag() {
    static HELP: &str = "\
Usage: test

Options:
  -h, --help  Print help
";

    let cmd = Command::new("test").ignore_errors(true);

    utils::assert_output(cmd, "test --help", HELP, false);
}

#[test]
fn version_flag() {
    let cmd = Command::new("test").ignore_errors(true).version("0.1");

    utils::assert_output(cmd, "test --version", "test 0.1\n", false);
}

```

`clap/tests/builder/indices.rs`:

```rs
use clap::{Arg, ArgAction, Command};

#[test]
fn indices_mult_opts() {
    let m = Command::new("ind")
        .args_override_self(true)
        .arg(
            Arg::new("exclude")
                .short('e')
                .action(ArgAction::Set)
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .arg(
            Arg::new("include")
                .short('i')
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .try_get_matches_from(vec!["ind", "-e", "A", "B", "-i", "B", "C", "-e", "C"])
        .unwrap();

    assert_eq!(
        m.indices_of("exclude").unwrap().collect::<Vec<_>>(),
        [2, 3, 8]
    );
    assert_eq!(m.indices_of("include").unwrap().collect::<Vec<_>>(), [5, 6]);
}

#[test]
fn index_mult_opts() {
    let m = Command::new("ind")
        .args_override_self(true)
        .arg(
            Arg::new("exclude")
                .short('e')
                .action(ArgAction::Set)
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .arg(
            Arg::new("include")
                .short('i')
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .try_get_matches_from(vec!["ind", "-e", "A", "B", "-i", "B", "C", "-e", "C"])
        .unwrap();

    assert_eq!(m.index_of("exclude"), Some(2));
    assert_eq!(m.index_of("include"), Some(5));
}

#[test]
fn index_flag() {
    let m = Command::new("ind")
        .args_override_self(true)
        .arg(Arg::new("exclude").short('e').action(ArgAction::SetTrue))
        .arg(Arg::new("include").short('i').action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["ind", "-e", "-i"])
        .unwrap();

    assert_eq!(m.index_of("exclude"), Some(1));
    assert_eq!(m.index_of("include"), Some(2));
}

#[test]
fn index_flags() {
    let m = Command::new("ind")
        .args_override_self(true)
        .arg(Arg::new("exclude").short('e').action(ArgAction::SetTrue))
        .arg(Arg::new("include").short('i').action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["ind", "-e", "-i", "-e", "-e", "-i"])
        .unwrap();

    assert_eq!(m.index_of("exclude"), Some(4));
    assert_eq!(m.index_of("include"), Some(5));
}

#[test]
fn indices_mult_flags() {
    let m = Command::new("ind")
        .args_override_self(true)
        .arg(Arg::new("exclude").short('e').action(ArgAction::SetTrue))
        .arg(Arg::new("include").short('i').action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["ind", "-e", "-i", "-e", "-e", "-i"])
        .unwrap();

    assert_eq!(m.indices_of("exclude").unwrap().collect::<Vec<_>>(), [4]);
    assert_eq!(m.indices_of("include").unwrap().collect::<Vec<_>>(), [5]);
}

#[test]
fn indices_mult_flags_combined() {
    let m = Command::new("ind")
        .args_override_self(true)
        .arg(Arg::new("exclude").short('e').action(ArgAction::SetTrue))
        .arg(Arg::new("include").short('i').action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["ind", "-eieei"])
        .unwrap();

    assert_eq!(m.indices_of("exclude").unwrap().collect::<Vec<_>>(), [4]);
    assert_eq!(m.indices_of("include").unwrap().collect::<Vec<_>>(), [5]);
}

#[test]
fn indices_mult_flags_opt_combined() {
    let m = Command::new("ind")
        .args_override_self(true)
        .arg(Arg::new("exclude").short('e').action(ArgAction::SetTrue))
        .arg(Arg::new("include").short('i').action(ArgAction::SetTrue))
        .arg(Arg::new("option").short('o').action(ArgAction::Set))
        .try_get_matches_from(vec!["ind", "-eieeio", "val"])
        .unwrap();

    assert_eq!(m.indices_of("exclude").unwrap().collect::<Vec<_>>(), [4]);
    assert_eq!(m.indices_of("include").unwrap().collect::<Vec<_>>(), [5]);
    assert_eq!(m.indices_of("option").unwrap().collect::<Vec<_>>(), [7]);
}

#[test]
fn indices_mult_flags_opt_combined_eq() {
    let m = Command::new("ind")
        .args_override_self(true)
        .arg(Arg::new("exclude").short('e').action(ArgAction::SetTrue))
        .arg(Arg::new("include").short('i').action(ArgAction::SetTrue))
        .arg(Arg::new("option").short('o').action(ArgAction::Set))
        .try_get_matches_from(vec!["ind", "-eieeio=val"])
        .unwrap();

    assert_eq!(m.indices_of("exclude").unwrap().collect::<Vec<_>>(), [4]);
    assert_eq!(m.indices_of("include").unwrap().collect::<Vec<_>>(), [5]);
    assert_eq!(m.indices_of("option").unwrap().collect::<Vec<_>>(), [7]);
}

#[test]
fn indices_mult_opt_value_delim_eq() {
    let m = Command::new("myapp")
        .args_override_self(true)
        .arg(
            Arg::new("option")
                .short('o')
                .action(ArgAction::Set)
                .value_delimiter(',')
                .num_args(1..),
        )
        .try_get_matches_from(vec!["myapp", "-o=val1,val2,val3"])
        .unwrap();
    assert_eq!(
        m.indices_of("option").unwrap().collect::<Vec<_>>(),
        [2, 3, 4]
    );
}

#[test]
fn indices_mult_opt_value_no_delim_eq() {
    let m = Command::new("myapp")
        .args_override_self(true)
        .arg(
            Arg::new("option")
                .short('o')
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .try_get_matches_from(vec!["myapp", "-o=val1,val2,val3"])
        .unwrap();
    assert_eq!(m.indices_of("option").unwrap().collect::<Vec<_>>(), [2]);
}

#[test]
fn indices_mult_opt_mult_flag() {
    let m = Command::new("myapp")
        .args_override_self(true)
        .arg(Arg::new("option").short('o').action(ArgAction::Append))
        .arg(Arg::new("flag").short('f').action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["myapp", "-o", "val1", "-f", "-o", "val2", "-f"])
        .unwrap();

    assert_eq!(m.indices_of("option").unwrap().collect::<Vec<_>>(), [2, 5]);
    assert_eq!(m.indices_of("flag").unwrap().collect::<Vec<_>>(), [6]);
}

```

`clap/tests/builder/main.rs`:

```rs
#![allow(clippy::self_named_module_files)] // false positive
#![cfg(feature = "help")]
#![cfg(feature = "usage")]

automod::dir!("tests/builder");

```

`clap/tests/builder/multiple_occurrences.rs`:

```rs
use clap::{arg, Arg, ArgAction, Command};

#[test]
fn multiple_occurrences_of_flags_long() {
    let m = Command::new("mo_flags_long")
        .args_override_self(true)
        .arg(arg!(--multflag "allowed multiple flag").action(ArgAction::SetTrue))
        .arg(arg!(--flag "disallowed multiple flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "--multflag", "--flag", "--multflag"])
        .unwrap();
    assert!(m.contains_id("multflag"));
    assert_eq!(m.get_one::<bool>("multflag").copied(), Some(true));
    assert!(m.contains_id("flag"));
    assert_eq!(m.get_one::<bool>("flag").copied(), Some(true));
}

#[test]
fn multiple_occurrences_of_flags_short() {
    let m = Command::new("mo_flags_short")
        .args_override_self(true)
        .arg(arg!(-m --multflag "allowed multiple flag").action(ArgAction::SetTrue))
        .arg(arg!(-f --flag "disallowed multiple flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-m", "-f", "-m"])
        .unwrap();
    assert!(m.contains_id("multflag"));
    assert_eq!(m.get_one::<bool>("multflag").copied(), Some(true));
    assert!(m.contains_id("flag"));
    assert_eq!(m.get_one::<bool>("flag").copied(), Some(true));
}

#[test]
fn multiple_occurrences_of_positional() {
    let cmd = Command::new("test").arg(Arg::new("multi").num_args(1..).action(ArgAction::Append));

    let m = cmd
        .clone()
        .try_get_matches_from(["test"])
        .expect("zero occurrences work");
    assert!(!m.contains_id("multi"));
    assert!(m.get_many::<String>("multi").is_none());

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "one"])
        .expect("single occurrence work");
    assert!(m.contains_id("multi"));
    assert_eq!(
        m.get_many::<String>("multi")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["one"]
    );

    let m = cmd
        .clone()
        .try_get_matches_from(["test", "one", "two", "three", "four"])
        .expect("many occurrences work");
    assert!(m.contains_id("multi"));
    assert_eq!(
        m.get_many::<String>("multi")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["one", "two", "three", "four"]
    );
}

#[test]
fn multiple_occurrences_of_flags_large_quantity() {
    let cmd = Command::new("mo_flags_large_qty")
        .arg(arg!(-m --multflag "allowed multiple flag").action(ArgAction::Count));

    let args: Vec<&str> = vec![""].into_iter().chain(vec!["-m"; 200]).collect();
    let m = cmd.clone().try_get_matches_from(args).unwrap();
    assert!(m.contains_id("multflag"));
    assert_eq!(m.get_one::<u8>("multflag").copied(), Some(200));

    let args: Vec<&str> = vec![""].into_iter().chain(vec!["-m"; 500]).collect();
    let m = cmd.try_get_matches_from(args).unwrap();
    assert!(m.contains_id("multflag"));
    assert_eq!(m.get_one::<u8>("multflag").copied(), Some(u8::MAX));
}

#[cfg(feature = "env")]
#[test]
fn multiple_occurrences_of_before_env() {
    let cmd = Command::new("mo_before_env").arg(
        Arg::new("verbose")
            .env("VERBOSE")
            .short('v')
            .long("verbose")
            .action(ArgAction::Count),
    );

    let m = cmd.clone().try_get_matches_from(vec![""]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(m.get_one::<u8>("verbose").copied(), Some(0));

    let m = cmd.clone().try_get_matches_from(vec!["", "-v"]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(m.get_one::<u8>("verbose").copied(), Some(1));

    let m = cmd.clone().try_get_matches_from(vec!["", "-vv"]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(m.get_one::<u8>("verbose").copied(), Some(2));

    let m = cmd.clone().try_get_matches_from(vec!["", "-vvv"]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(m.get_one::<u8>("verbose").copied(), Some(3));
}

#[cfg(feature = "env")]
#[test]
fn multiple_occurrences_of_after_env() {
    let cmd = Command::new("mo_after_env").arg(
        Arg::new("verbose")
            .short('v')
            .long("verbose")
            .action(ArgAction::Count)
            .env("VERBOSE"),
    );

    let m = cmd.clone().try_get_matches_from(vec![""]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(m.get_one::<u8>("verbose").copied(), Some(0));

    let m = cmd.clone().try_get_matches_from(vec!["", "-v"]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(m.get_one::<u8>("verbose").copied(), Some(1));

    let m = cmd.clone().try_get_matches_from(vec!["", "-vv"]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(m.get_one::<u8>("verbose").copied(), Some(2));

    let m = cmd.clone().try_get_matches_from(vec!["", "-vvv"]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(m.get_one::<u8>("verbose").copied(), Some(3));
}

```

`clap/tests/builder/multiple_values.rs`:

```rs
use clap::{error::ErrorKind, Arg, ArgAction, Command};
use snapbox::assert_data_eq;
use snapbox::str;

use crate::utils;

#[test]
fn option_long() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .long("option")
                .help("multiple options")
                .action(ArgAction::Set)
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec![
            "", "--option", "val1", "--option", "val2", "--option", "val3",
        ]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn option_short() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .action(ArgAction::Set)
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec!["", "-o", "val1", "-o", "val2", "-o", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn option_mixed() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .long("option")
                .short('o')
                .help("multiple options")
                .action(ArgAction::Set)
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec![
            "", "-o", "val1", "--option", "val2", "--option", "val3", "-o", "val4",
        ]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3", "val4"]
    );
}

#[test]
fn option_exact_exact() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(3)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec![
            "", "-o", "val1", "val2", "val3", "-o", "val4", "val5", "val6",
        ]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3", "val4", "val5", "val6"]
    );
}

#[test]
fn option_exact_exact_not_mult() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(3),
        )
        .try_get_matches_from(vec!["", "-o", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn option_exact_exact_mult() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(3)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec![
            "", "-o", "val1", "val2", "val3", "-o", "val4", "val5", "val6",
        ]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3", "val4", "val5", "val6"]
    );
}

#[test]
#[cfg(feature = "error-context")]
fn option_exact_less() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(3)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec!["", "-o", "val1", "-o", "val2"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::WrongNumberOfValues, str![[r#"
error: 3 values required for '-o <option> <option> <option>' but 1 was provided

Usage: multiple_values [OPTIONS]

For more information, try '--help'.

"#]], true);
}

#[test]
#[cfg(feature = "error-context")]
fn option_exact_more() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(3)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec![
            "", "-o", "val1", "-o", "val2", "-o", "val3", "-o", "val4",
        ]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::WrongNumberOfValues, str![[r#"
error: 3 values required for '-o <option> <option> <option>' but 1 was provided

Usage: multiple_values [OPTIONS]

For more information, try '--help'.

"#]], true);
}

#[test]
fn option_min_exact() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(3..)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "-o", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
#[cfg(feature = "error-context")]
fn option_min_less() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(3..)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "-o", "val1", "val2"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::TooFewValues, str![[r#"
error: 3 values required by '-o <option> <option> <option>...'; only 2 were provided

Usage: multiple_values [OPTIONS]

For more information, try '--help'.

"#]], true);
}

#[test]
fn option_short_min_more_mult_occurs() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("arg").required(true))
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(3..)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "pos", "-o", "val1", "val2", "val3", "val4"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3", "val4"]
    );
    assert_eq!(m.get_one::<String>("arg").map(|v| v.as_str()), Some("pos"));
}

#[test]
fn option_short_min_more_single_occur() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("arg").required(true))
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(3..),
        )
        .try_get_matches_from(vec!["", "pos", "-o", "val1", "val2", "val3", "val4"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3", "val4"]
    );
    assert_eq!(m.get_one::<String>("arg").map(|v| v.as_str()), Some("pos"));
}

#[test]
fn option_max_exact() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(1..=3)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "-o", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn option_max_less() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(1..=3)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "-o", "val1", "val2"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2"]
    );
}

#[test]
#[cfg(feature = "error-context")]
fn option_max_zero() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(1..=3)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "-o"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::InvalidValue, str![[r#"
error: a value is required for '-o <option>...' but none was supplied

For more information, try '--help'.

"#]], true);
}

#[test]
fn option_max_zero_eq() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(1..=3)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "-o="]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        [""]
    );
}

#[test]
#[cfg(feature = "error-context")]
fn option_max_more() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .num_args(1..=3)
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "-o", "val1", "val2", "val3", "val4"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    // Can end up being TooManyValues or UnknownArgument
    utils::assert_error(err, ErrorKind::UnknownArgument, str![[r#"
error: unexpected argument 'val4' found

Usage: multiple_values [OPTIONS]

For more information, try '--help'.

"#]], true);
}

#[test]
fn optional_value() {
    let mut cmd = Command::new("test").args_override_self(true).arg(
        Arg::new("port")
            .short('p')
            .value_name("NUM")
            .num_args(0..=1),
    );

    let r = cmd.try_get_matches_from_mut(["test", "-p42"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("port"));
    assert_eq!(m.get_one::<String>("port").unwrap(), "42");

    let r = cmd.try_get_matches_from_mut(["test", "-p"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("port"));
    assert!(m.get_one::<String>("port").is_none());

    let r = cmd.try_get_matches_from_mut(["test", "-p", "24", "-p", "42"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("port"));
    assert_eq!(m.get_one::<String>("port").unwrap(), "42");

    let help = cmd.render_help().to_string();
    assert_data_eq!(
        help,
        str![[r#"
Usage: test [OPTIONS]

Options:
  -p [<NUM>]      
  -h, --help      Print help

"#]]
    );
}

#[test]
fn positional() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("pos")
                .help("multiple positionals")
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .try_get_matches_from(vec!["myprog", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("pos"));
    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn positional_exact_exact() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(3))
        .try_get_matches_from(vec!["myprog", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("pos"));
    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
#[cfg(feature = "error-context")]
fn positional_exact_less() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(3))
        .try_get_matches_from(vec!["myprog", "val1", "val2"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::WrongNumberOfValues, str![[r#"
error: 3 values required for '[pos] [pos] [pos]' but 2 were provided

Usage: myprog [pos] [pos] [pos]

For more information, try '--help'.

"#]], true);
}

#[test]
#[cfg(feature = "error-context")]
fn positional_exact_more() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(3))
        .try_get_matches_from(vec!["myprog", "val1", "val2", "val3", "val4"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::WrongNumberOfValues, str![[r#"
error: 3 values required for '[pos] [pos] [pos]' but 4 were provided

Usage: myprog [pos] [pos] [pos]

For more information, try '--help'.

"#]], true);
}

#[test]
fn positional_min_exact() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(3..))
        .try_get_matches_from(vec!["myprog", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("pos"));
    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
#[cfg(feature = "error-context")]
fn positional_min_less() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(3..))
        .try_get_matches_from(vec!["myprog", "val1", "val2"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::TooFewValues, str![[r#"
error: 3 values required by '[pos] [pos] [pos]...'; only 2 were provided

Usage: myprog [pos] [pos] [pos]...

For more information, try '--help'.

"#]], true);
}

#[test]
fn positional_min_more() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(3..))
        .try_get_matches_from(vec!["myprog", "val1", "val2", "val3", "val4"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("pos"));
    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3", "val4"]
    );
}

#[test]
fn positional_max_exact() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(1..=3))
        .try_get_matches_from(vec!["myprog", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("pos"));
    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn positional_max_less() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(1..=3))
        .try_get_matches_from(vec!["myprog", "val1", "val2"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("pos"));
    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2"]
    );
}

#[test]
#[cfg(feature = "error-context")]
fn positional_max_more() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(1..=3))
        .try_get_matches_from(vec!["myprog", "val1", "val2", "val3", "val4"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::TooManyValues, str![[r#"
error: unexpected value 'val4' for '[pos]...' found; no more were expected

Usage: myprog [pos]...

For more information, try '--help'.

"#]], true);
}

#[test]
fn sep_long_equals() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .long("option")
                .help("multiple options")
                .value_delimiter(','),
        )
        .try_get_matches_from(vec!["", "--option=val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn sep_long_space() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .long("option")
                .help("multiple options")
                .value_delimiter(','),
        )
        .try_get_matches_from(vec!["", "--option", "val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn sep_short_equals() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .value_delimiter(','),
        )
        .try_get_matches_from(vec!["", "-o=val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn sep_short_space() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .value_delimiter(','),
        )
        .try_get_matches_from(vec!["", "-o", "val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn sep_short_no_space() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .help("multiple options")
                .value_delimiter(','),
        )
        .try_get_matches_from(vec!["", "-oval1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn sep_positional() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .help("multiple options")
                .value_delimiter(','),
        )
        .try_get_matches_from(vec!["", "val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn different_sep() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .long("option")
                .help("multiple options")
                .value_delimiter(';'),
        )
        .try_get_matches_from(vec!["", "--option=val1;val2;val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn different_sep_positional() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .help("multiple options")
                .value_delimiter(';'),
        )
        .try_get_matches_from(vec!["", "val1;val2;val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn no_sep() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .long("option")
                .help("multiple options")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "--option=val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_one::<String>("option").map(|v| v.as_str()).unwrap(),
        "val1,val2,val3"
    );
}

#[test]
fn no_sep_positional() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .help("multiple options")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec!["", "val1,val2,val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_one::<String>("option").map(|v| v.as_str()).unwrap(),
        "val1,val2,val3"
    );
}

#[test]
fn req_delimiter_long() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .long("option")
                .num_args(1)
                .value_delimiter(','),
        )
        .arg(
            Arg::new("args")
                .action(ArgAction::Set)
                .num_args(1..)
                .index(1),
        )
        .try_get_matches_from(vec!["", "--option", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1"]
    );
    assert_eq!(
        m.get_many::<String>("args")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val2", "val3"]
    );
}

#[test]
fn req_delimiter_long_with_equal() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .long("option")
                .num_args(1)
                .value_delimiter(','),
        )
        .arg(
            Arg::new("args")
                .action(ArgAction::Set)
                .num_args(1..)
                .index(1),
        )
        .try_get_matches_from(vec!["", "--option=val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1"]
    );
    assert_eq!(
        m.get_many::<String>("args")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val2", "val3"]
    );
}

#[test]
fn req_delimiter_short_with_space() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .num_args(1)
                .value_delimiter(','),
        )
        .arg(
            Arg::new("args")
                .action(ArgAction::Set)
                .num_args(1..)
                .index(1),
        )
        .try_get_matches_from(vec!["", "-o", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1"]
    );
    assert_eq!(
        m.get_many::<String>("args")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val2", "val3"]
    );
}

#[test]
fn req_delimiter_short_with_no_space() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .num_args(1)
                .value_delimiter(','),
        )
        .arg(
            Arg::new("args")
                .action(ArgAction::Set)
                .num_args(1..)
                .index(1),
        )
        .try_get_matches_from(vec!["", "-oval1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1"]
    );
    assert_eq!(
        m.get_many::<String>("args")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val2", "val3"]
    );
}

#[test]
fn req_delimiter_short_with_equal() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .short('o')
                .num_args(1)
                .value_delimiter(','),
        )
        .arg(
            Arg::new("args")
                .action(ArgAction::Set)
                .num_args(1..)
                .index(1),
        )
        .try_get_matches_from(vec!["", "-o=val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1"]
    );
    assert_eq!(
        m.get_many::<String>("args")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val2", "val3"]
    );
}

#[test]
fn req_delimiter_complex() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("option")
                .long("option")
                .short('o')
                .num_args(1)
                .action(ArgAction::Append)
                .value_delimiter(','),
        )
        .arg(Arg::new("args").num_args(1..).index(1))
        .try_get_matches_from(vec![
            "",
            "val1",
            "-oval2",
            "val3",
            "-o",
            "val4",
            "val5",
            "-o=val6",
            "val7",
            "--option=val8",
            "val9",
            "--option",
            "val10",
            "val11",
            "-oval12,val13",
            "val14",
            "-o",
            "val15,val16",
            "val17",
            "-o=val18,val19",
            "val20",
            "--option=val21,val22",
            "val23",
            "--option",
            "val24,val25",
            "val26",
        ]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        [
            "val2", "val4", "val6", "val8", "val10", "val12", "val13", "val15", "val16", "val18",
            "val19", "val21", "val22", "val24", "val25",
        ]
    );
    assert_eq!(
        m.get_many::<String>("args")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        [
            "val1", "val3", "val5", "val7", "val9", "val11", "val14", "val17", "val20", "val23",
            "val26",
        ]
    );
}

// This tests a programmer error and will only succeed with debug_assertions
#[cfg(debug_assertions)]
#[test]
#[should_panic = "Positional argument `[target]` *must* have `required(true)` or `last(true)` set \
because a prior positional argument (`<files>...`) has `num_args(1..)`"]
fn low_index_positional_not_required() {
    let _ = Command::new("lip")
        .arg(
            Arg::new("files")
                .index(1)
                .action(ArgAction::Set)
                .required(true)
                .num_args(1..),
        )
        .arg(Arg::new("target").index(2))
        .try_get_matches_from(vec![""]);
}

// This tests a programmer error and will only succeed with debug_assertions
#[cfg(debug_assertions)]
#[test]
#[should_panic = "Only one positional argument with `.num_args(1..)` \
set is allowed per command, unless the second one also has .last(true) set"]
fn low_index_positional_last_multiple_too() {
    let _ = Command::new("lip")
        .arg(
            Arg::new("files")
                .index(1)
                .action(ArgAction::Set)
                .required(true)
                .num_args(1..),
        )
        .arg(
            Arg::new("target")
                .index(2)
                .action(ArgAction::Set)
                .required(true)
                .num_args(1..),
        )
        .try_get_matches_from(vec![""]);
}

// This tests a programmer error and will only succeed with debug_assertions
#[cfg(debug_assertions)]
#[test]
#[should_panic = "Only the last positional argument, or second to \
last positional argument may be set to `.num_args(1..)`"]
fn low_index_positional_too_far_back() {
    let _ = Command::new("lip")
        .arg(
            Arg::new("files")
                .index(1)
                .action(ArgAction::Set)
                .required(true)
                .num_args(1..),
        )
        .arg(Arg::new("target").required(true).index(2))
        .arg(Arg::new("target2").required(true).index(3))
        .try_get_matches_from(vec![""]);
}

#[test]
fn low_index_positional() {
    let m = Command::new("lip")
        .arg(
            Arg::new("files")
                .index(1)
                .action(ArgAction::Set)
                .required(true)
                .num_args(1..),
        )
        .arg(Arg::new("target").index(2).required(true))
        .try_get_matches_from(vec!["lip", "file1", "file2", "file3", "target"]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();

    assert!(m.contains_id("files"));
    assert_eq!(
        m.get_many::<String>("files")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["file1", "file2", "file3"]
    );
    assert!(m.contains_id("target"));
    assert_eq!(
        m.get_one::<String>("target").map(|v| v.as_str()).unwrap(),
        "target"
    );
}

#[test]
fn low_index_positional_in_subcmd() {
    let m = Command::new("lip")
        .subcommand(
            Command::new("test")
                .arg(
                    Arg::new("files")
                        .index(1)
                        .action(ArgAction::Set)
                        .required(true)
                        .num_args(1..),
                )
                .arg(Arg::new("target").index(2).required(true)),
        )
        .try_get_matches_from(vec!["lip", "test", "file1", "file2", "file3", "target"]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();
    let sm = m.subcommand_matches("test").unwrap();

    assert!(sm.contains_id("files"));
    assert_eq!(
        sm.get_many::<String>("files")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["file1", "file2", "file3"]
    );
    assert!(sm.contains_id("target"));
    assert_eq!(
        sm.get_one::<String>("target").map(|v| v.as_str()).unwrap(),
        "target"
    );
}

#[test]
fn low_index_positional_with_option() {
    let m = Command::new("lip")
        .arg(
            Arg::new("files")
                .required(true)
                .index(1)
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .arg(Arg::new("target").index(2).required(true))
        .arg(Arg::new("opt").long("option").action(ArgAction::Set))
        .try_get_matches_from(vec![
            "lip", "file1", "file2", "file3", "target", "--option", "test",
        ]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();

    assert!(m.contains_id("files"));
    assert_eq!(
        m.get_many::<String>("files")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["file1", "file2", "file3"]
    );
    assert!(m.contains_id("target"));
    assert_eq!(
        m.get_one::<String>("target").map(|v| v.as_str()).unwrap(),
        "target"
    );
    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()).unwrap(),
        "test"
    );
}

#[test]
fn low_index_positional_with_flag() {
    let m = Command::new("lip")
        .arg(
            Arg::new("files")
                .index(1)
                .action(ArgAction::Set)
                .required(true)
                .num_args(1..),
        )
        .arg(Arg::new("target").index(2).required(true))
        .arg(Arg::new("flg").long("flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["lip", "file1", "file2", "file3", "target", "--flag"]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();

    assert!(m.contains_id("files"));
    assert_eq!(
        m.get_many::<String>("files")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["file1", "file2", "file3"]
    );
    assert!(m.contains_id("target"));
    assert_eq!(
        m.get_one::<String>("target").map(|v| v.as_str()).unwrap(),
        "target"
    );
    assert!(*m.get_one::<bool>("flg").expect("defaulted by clap"));
}

#[test]
fn low_index_positional_with_extra_flags() {
    let cmd = Command::new("test")
        .arg(Arg::new("yes").long("yes").action(ArgAction::SetTrue))
        .arg(Arg::new("one").long("one").action(ArgAction::Set))
        .arg(Arg::new("two").long("two").action(ArgAction::Set))
        .arg(Arg::new("input").num_args(1..).required(true))
        .arg(Arg::new("output").required(true));
    let m = cmd.try_get_matches_from([
        "test", "--one", "1", "--two", "2", "3", "4", "5", "6", "7", "8",
    ]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();

    assert_eq!(
        m.get_many::<String>("input")
            .unwrap()
            .map(String::from)
            .collect::<Vec<_>>(),
        vec![
            "3".to_owned(),
            "4".to_owned(),
            "5".to_owned(),
            "6".to_owned(),
            "7".to_owned()
        ],
    );
    assert_eq!(m.get_one::<String>("output").unwrap(), "8");
    assert_eq!(m.get_one::<String>("one").unwrap(), "1");
    assert_eq!(m.get_one::<String>("two").unwrap(), "2");
    assert!(!m.get_flag("yes"));
}

#[test]
fn multiple_value_terminator_option() {
    let m = Command::new("lip")
        .arg(
            Arg::new("files")
                .short('f')
                .value_terminator(";")
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .arg(Arg::new("other"))
        .try_get_matches_from(vec!["lip", "-f", "val1", "val2", ";", "otherval"]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();

    assert!(m.contains_id("other"));
    assert!(m.contains_id("files"));
    assert_eq!(
        m.get_many::<String>("files")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2"]
    );
    assert_eq!(
        m.get_one::<String>("other").map(|v| v.as_str()),
        Some("otherval")
    );
}

#[test]
fn multiple_value_terminator_option_other_arg() {
    let m = Command::new("lip")
        .arg(
            Arg::new("files")
                .short('f')
                .value_terminator(";")
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .arg(Arg::new("other"))
        .arg(Arg::new("flag").short('F').action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["lip", "-f", "val1", "val2", "-F", "otherval"]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();

    assert!(m.contains_id("other"));
    assert!(m.contains_id("files"));
    assert_eq!(
        m.get_many::<String>("files")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2"]
    );
    assert_eq!(
        m.get_one::<String>("other").map(|v| v.as_str()),
        Some("otherval")
    );
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn all_multiple_value_terminator() {
    let m = Command::new("lip")
        .arg(
            Arg::new("files")
                .value_terminator(";")
                .action(ArgAction::Set)
                .num_args(0..),
        )
        .arg(Arg::new("other").num_args(0..))
        .try_get_matches_from(vec!["test", "value", ";"]);

    assert!(m.is_ok(), "{:?}", m.unwrap_err().kind());
    let m = m.unwrap();

    assert!(m.contains_id("files"));
    assert!(!m.contains_id("other"));
    assert_eq!(
        m.get_many::<String>("files")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["value".to_owned()],
    );
}

#[test]
fn multiple_vals_with_hyphen() {
    let res = Command::new("do")
        .arg(
            Arg::new("cmds")
                .action(ArgAction::Set)
                .num_args(1..)
                .allow_hyphen_values(true)
                .value_terminator(";"),
        )
        .arg(Arg::new("location"))
        .try_get_matches_from(vec![
            "do",
            "find",
            "-type",
            "f",
            "-name",
            "special",
            ";",
            "/home/clap",
        ]);
    assert!(res.is_ok(), "{:?}", res.unwrap_err().kind());

    let m = res.unwrap();
    let cmds: Vec<_> = m
        .get_many::<String>("cmds")
        .unwrap()
        .map(|v| v.as_str())
        .collect();
    assert_eq!(&cmds, &["find", "-type", "f", "-name", "special"]);
    assert_eq!(
        m.get_one::<String>("location").map(|v| v.as_str()),
        Some("/home/clap")
    );
}

#[test]
fn multiple_positional_multiple_values() {
    let res = Command::new("do")
        .arg(
            Arg::new("cmd1")
                .action(ArgAction::Set)
                .num_args(1..)
                .allow_hyphen_values(true)
                .value_terminator(";"),
        )
        .arg(
            Arg::new("cmd2")
                .action(ArgAction::Set)
                .num_args(1..)
                .allow_hyphen_values(true)
                .value_terminator(";"),
        )
        .try_get_matches_from(vec![
            "do",
            "find",
            "-type",
            "f",
            "-name",
            "special",
            ";",
            "/home/clap",
            "foo",
        ]);
    assert!(res.is_ok(), "{:?}", res.unwrap_err().kind());

    let m = res.unwrap();
    let cmd1: Vec<_> = m
        .get_many::<String>("cmd1")
        .unwrap()
        .map(|v| v.as_str())
        .collect();
    assert_eq!(&cmd1, &["find", "-type", "f", "-name", "special"]);
    let cmd2: Vec<_> = m
        .get_many::<String>("cmd2")
        .unwrap()
        .map(|v| v.as_str())
        .collect();
    assert_eq!(&cmd2, &["/home/clap", "foo"]);
}

#[test]
fn value_terminator_has_higher_precedence_than_allow_hyphen_values() {
    let res = Command::new("do")
        .arg(
            Arg::new("cmd1")
                .action(ArgAction::Set)
                .num_args(1..)
                .allow_hyphen_values(true)
                .value_terminator("--foo"),
        )
        .arg(
            Arg::new("cmd2")
                .action(ArgAction::Set)
                .num_args(1..)
                .allow_hyphen_values(true)
                .value_terminator(";"),
        )
        .try_get_matches_from(vec![
            "do",
            "find",
            "-type",
            "f",
            "-name",
            "special",
            "--foo",
            "/home/clap",
            "foo",
        ]);
    assert!(res.is_ok(), "{:?}", res.unwrap_err().kind());

    let m = res.unwrap();
    let cmd1: Vec<_> = m
        .get_many::<String>("cmd1")
        .unwrap()
        .map(|v| v.as_str())
        .collect();
    assert_eq!(&cmd1, &["find", "-type", "f", "-name", "special"]);
    let cmd2: Vec<_> = m
        .get_many::<String>("cmd2")
        .unwrap()
        .map(|v| v.as_str())
        .collect();
    assert_eq!(&cmd2, &["/home/clap", "foo"]);
}

#[test]
fn value_terminator_restores_escaping_disabled_by_allow_hyphen_values() {
    let res = Command::new("do")
        .arg(
            Arg::new("cmd1")
                .action(ArgAction::Set)
                .num_args(1..)
                .allow_hyphen_values(true)
                .value_terminator("--"),
        )
        .arg(
            Arg::new("cmd2")
                .action(ArgAction::Set)
                .num_args(1..)
                .allow_hyphen_values(true)
                .value_terminator(";"),
        )
        .try_get_matches_from(vec![
            "do",
            "find",
            "-type",
            "f",
            "-name",
            "special",
            "--",
            "/home/clap",
            "foo",
        ]);
    assert!(res.is_ok(), "{:?}", res.unwrap_err().kind());

    let m = res.unwrap();
    let cmd1: Vec<_> = m
        .get_many::<String>("cmd1")
        .unwrap()
        .map(|v| v.as_str())
        .collect();
    assert_eq!(&cmd1, &["find", "-type", "f", "-name", "special"]);
    let cmd2: Vec<_> = m
        .get_many::<String>("cmd2")
        .unwrap()
        .map(|v| v.as_str())
        .collect();
    assert_eq!(&cmd2, &["/home/clap", "foo"]);
}

#[test]
fn issue_1480_max_values_consumes_extra_arg_1() {
    let res = Command::new("prog")
        .arg(Arg::new("field").num_args(..=1).long("field"))
        .arg(Arg::new("positional").required(true).index(1))
        .try_get_matches_from(vec!["prog", "--field", "1", "file"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
#[cfg(feature = "error-context")]
fn issue_1480_max_values_consumes_extra_arg_2() {
    let m = Command::new("prog")
        .arg(Arg::new("field").num_args(..=1).long("field"))
        .try_get_matches_from(vec!["prog", "--field", "1", "2"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::UnknownArgument, str![[r#"
error: unexpected argument '2' found

Usage: prog [OPTIONS]

For more information, try '--help'.

"#]], true);
}

#[test]
#[cfg(feature = "error-context")]
fn issue_1480_max_values_consumes_extra_arg_3() {
    let m = Command::new("prog")
        .arg(Arg::new("field").num_args(..=1).long("field"))
        .try_get_matches_from(vec!["prog", "--field", "1", "2", "3"]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::UnknownArgument, str![[r#"
error: unexpected argument '2' found

Usage: prog [OPTIONS]

For more information, try '--help'.

"#]], true);
}

#[test]
fn value_names_building_num_vals() {
    let m = Command::new("test")
        .arg(
            Arg::new("pos")
                .long("pos")
                .value_names(["who", "what", "why"]),
        )
        .try_get_matches_from(vec!["myprog", "--pos", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn value_names_building_num_vals_for_positional() {
    let m = Command::new("test")
        .arg(Arg::new("pos").value_names(["who", "what", "why"]))
        .try_get_matches_from(vec!["myprog", "val1", "val2", "val3"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3"]
    );
}

#[test]
fn num_args_preferred_over_value_names() {
    let m = Command::new("test")
        .arg(
            Arg::new("pos")
                .long("pos")
                .num_args(4)
                .value_names(["who", "what", "why"]),
        )
        .try_get_matches_from(vec!["myprog", "--pos", "val1", "val2", "val3", "val4"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3", "val4"]
    );
}

#[test]
fn values_per_occurrence_named() {
    let mut a = Command::new("test").arg(
        Arg::new("pos")
            .long("pos")
            .num_args(2)
            .action(ArgAction::Append),
    );

    let m = a.try_get_matches_from_mut(vec!["myprog", "--pos", "val1", "val2"]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2"]
    );

    let m = a.try_get_matches_from_mut(vec![
        "myprog", "--pos", "val1", "val2", "--pos", "val3", "val4",
    ]);
    let m = match m {
        Ok(m) => m,
        Err(err) => panic!("{err}"),
    };
    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2", "val3", "val4"]
    );
}

#[test]
fn values_per_occurrence_positional() {
    let mut a = Command::new("test").arg(Arg::new("pos").num_args(2).action(ArgAction::Append));

    let m = a.try_get_matches_from_mut(vec!["myprog", "val1", "val2"]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    assert_eq!(
        m.get_many::<String>("pos")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["val1", "val2"]
    );
}

#[test]
#[cfg(feature = "error-context")]
fn issue_2229() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos").help("multiple positionals").num_args(3))
        .try_get_matches_from(vec![
            "myprog", "val1", "val2", "val3", "val4", "val5", "val6",
        ]);

    assert!(m.is_err());
    let err = m.unwrap_err();
    utils::assert_error(err, ErrorKind::WrongNumberOfValues, str![[r#"
error: 3 values required for '[pos] [pos] [pos]' but 6 were provided

Usage: myprog [pos] [pos] [pos]

For more information, try '--help'.

"#]], true);
}

#[test]
#[should_panic = "Argument 'pos' is positional and it must take a value but action is SetTrue"]
fn disallow_positionals_without_values() {
    let cmd = Command::new("test").arg(Arg::new("pos").num_args(0));
    cmd.debug_assert();
}

```

`clap/tests/builder/occurrences.rs`:

```rs
use clap::{Arg, ArgAction, ArgMatches, Command};

fn occurrences_as_vec_vec<'a>(m: &'a ArgMatches, name: &str) -> Vec<Vec<&'a String>> {
    m.get_occurrences(name)
        .unwrap()
        .map(Iterator::collect)
        .collect()
}

#[test]
fn grouped_value_works() {
    let m = Command::new("cli")
        .arg(
            Arg::new("option")
                .long("option")
                .action(ArgAction::Set)
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .try_get_matches_from([
            "cli",
            "--option",
            "fr_FR:mon option 1",
            "en_US:my option 1",
            "--option",
            "fr_FR:mon option 2",
            "en_US:my option 2",
        ])
        .unwrap();
    let grouped_vals = occurrences_as_vec_vec(&m, "option");
    assert_eq!(
        grouped_vals,
        vec![
            vec!["fr_FR:mon option 1", "en_US:my option 1",],
            vec!["fr_FR:mon option 2", "en_US:my option 2",],
        ]
    );
}

#[test]
fn issue_1026() {
    let m = Command::new("cli")
        .arg(Arg::new("server").short('s').action(ArgAction::Set))
        .arg(Arg::new("user").short('u').action(ArgAction::Set))
        .arg(
            Arg::new("target")
                .long("target")
                .action(ArgAction::Set)
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .try_get_matches_from([
            "backup", "-s", "server", "-u", "user", "--target", "target1", "file1", "file2",
            "file3", "--target", "target2", "file4", "file5", "file6", "file7", "--target",
            "target3", "file8",
        ])
        .unwrap();
    let grouped_vals = occurrences_as_vec_vec(&m, "target");
    assert_eq!(
        grouped_vals,
        vec![
            vec!["target1", "file1", "file2", "file3"],
            vec!["target2", "file4", "file5", "file6", "file7",],
            vec!["target3", "file8"]
        ]
    );
}

#[test]
fn grouped_value_long_flag_delimiter() {
    let m = Command::new("myapp")
        .arg(
            Arg::new("option")
                .long("option")
                .action(ArgAction::Set)
                .value_delimiter(',')
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec![
            "myapp",
            "--option=hmm",
            "--option=val1,val2,val3",
            "--option",
            "alice,bob",
        ])
        .unwrap();
    let grouped_vals = occurrences_as_vec_vec(&m, "option");
    assert_eq!(
        grouped_vals,
        vec![
            vec!["hmm"],
            vec!["val1", "val2", "val3"],
            vec!["alice", "bob"]
        ]
    );
}

#[test]
fn grouped_value_short_flag_delimiter() {
    let m = Command::new("myapp")
        .arg(
            Arg::new("option")
                .short('o')
                .action(ArgAction::Set)
                .value_delimiter(',')
                .num_args(1..)
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec!["myapp", "-o=foo", "-o=val1,val2,val3", "-o=bar"])
        .unwrap();
    let grouped_vals = occurrences_as_vec_vec(&m, "option");
    assert_eq!(
        grouped_vals,
        vec![vec!["foo"], vec!["val1", "val2", "val3"], vec!["bar"]]
    );
}

#[test]
fn grouped_value_positional_arg() {
    let m = Command::new("multiple_values")
        .arg(
            Arg::new("pos")
                .help("multiple positionals")
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .try_get_matches_from(vec![
            "myprog", "val1", "val2", "val3", "val4", "val5", "val6",
        ])
        .unwrap();
    let grouped_vals = occurrences_as_vec_vec(&m, "pos");
    assert_eq!(
        grouped_vals,
        vec![vec!["val1", "val2", "val3", "val4", "val5", "val6"]]
    );
}

#[test]
fn grouped_value_multiple_positional_arg() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos1").help("multiple positionals"))
        .arg(
            Arg::new("pos2")
                .help("multiple positionals")
                .action(ArgAction::Set)
                .num_args(1..),
        )
        .try_get_matches_from(vec![
            "myprog", "val1", "val2", "val3", "val4", "val5", "val6",
        ])
        .unwrap();
    let grouped_vals = occurrences_as_vec_vec(&m, "pos2");
    assert_eq!(
        grouped_vals,
        vec![vec!["val2", "val3", "val4", "val5", "val6"]]
    );
}

#[test]
fn grouped_value_multiple_positional_arg_last_multiple() {
    let m = Command::new("multiple_values")
        .arg(Arg::new("pos1").help("multiple positionals"))
        .arg(
            Arg::new("pos2")
                .help("multiple positionals")
                .action(ArgAction::Set)
                .num_args(1..)
                .last(true),
        )
        .try_get_matches_from(vec![
            "myprog", "val1", "--", "val2", "val3", "val4", "val5", "val6",
        ])
        .unwrap();
    let grouped_vals = occurrences_as_vec_vec(&m, "pos2");
    assert_eq!(
        grouped_vals,
        vec![vec!["val2", "val3", "val4", "val5", "val6"]]
    );
}

#[test]
fn grouped_interleaved_positional_values() {
    let cmd = Command::new("foo")
        .arg(Arg::new("pos").num_args(1..))
        .arg(
            Arg::new("flag")
                .short('f')
                .long("flag")
                .action(ArgAction::Set)
                .action(ArgAction::Append),
        );

    let m = cmd
        .try_get_matches_from(["foo", "1", "2", "-f", "a", "3", "-f", "b", "4"])
        .unwrap();

    let pos = occurrences_as_vec_vec(&m, "pos");
    assert_eq!(pos, vec![vec!["1", "2"], vec!["3"], vec!["4"]]);

    let flag = occurrences_as_vec_vec(&m, "flag");
    assert_eq!(flag, vec![vec!["a"], vec!["b"]]);
}

#[test]
fn grouped_interleaved_positional_occurrences() {
    let cmd = Command::new("foo")
        .arg(Arg::new("pos").num_args(1..))
        .arg(
            Arg::new("flag")
                .short('f')
                .long("flag")
                .action(ArgAction::Set)
                .action(ArgAction::Append),
        );

    let m = cmd
        .try_get_matches_from(["foo", "1", "2", "-f", "a", "3", "-f", "b", "4"])
        .unwrap();

    let pos = occurrences_as_vec_vec(&m, "pos");
    assert_eq!(pos, vec![vec!["1", "2"], vec!["3"], vec!["4"]]);

    let flag = occurrences_as_vec_vec(&m, "flag");
    assert_eq!(flag, vec![vec!["a"], vec!["b"]]);
}

#[test]
fn issue_2171() {
    let schema = Command::new("ripgrep#1701 reproducer")
        .args_override_self(true)
        .arg(
            Arg::new("pretty")
                .short('p')
                .long("pretty")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("search_zip")
                .short('z')
                .long("search-zip")
                .action(ArgAction::SetTrue),
        );

    let test_args = [
        vec!["reproducer", "-pz", "-p"],
        vec!["reproducer", "-pzp"],
        vec!["reproducer", "-zpp"],
        vec!["reproducer", "-pp", "-z"],
        vec!["reproducer", "-p", "-p", "-z"],
        vec!["reproducer", "-p", "-pz"],
        vec!["reproducer", "-ppz"],
    ];

    for argv in test_args {
        let _ = schema.clone().try_get_matches_from(argv).unwrap();
    }
}

```

`clap/tests/builder/opts.rs`:

```rs
use clap::{arg, error::ErrorKind, Arg, ArgAction, ArgMatches, Command};

#[cfg(feature = "error-context")]
use super::utils;

#[test]
fn require_equals_fail() {
    let res = Command::new("prog")
        .arg(
            Arg::new("cfg")
                .require_equals(true)
                .value_parser(clap::builder::NonEmptyStringValueParser::new())
                .action(ArgAction::Set)
                .long("config"),
        )
        .try_get_matches_from(vec!["prog", "--config", "file.conf"]);
    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::NoEquals);
}

#[test]
#[cfg(feature = "error-context")]
fn require_equals_fail_message() {
    static NO_EQUALS: &str = "error: equal sign is needed when assigning values to '--config=<cfg>'

Usage: prog [OPTIONS]

For more information, try '--help'.
";
    let cmd = Command::new("prog").arg(
        Arg::new("cfg")
            .require_equals(true)
            .action(ArgAction::Set)
            .long("config"),
    );
    utils::assert_output(cmd, "prog --config file.conf", NO_EQUALS, true);
}

#[test]
fn require_equals_min_values_zero() {
    let res = Command::new("prog")
        .arg(
            Arg::new("cfg")
                .action(ArgAction::Set)
                .require_equals(true)
                .num_args(0..)
                .long("config"),
        )
        .arg(Arg::new("cmd"))
        .try_get_matches_from(vec!["prog", "--config", "cmd"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(m.contains_id("cfg"));
    assert_eq!(m.get_one::<String>("cmd").map(|v| v.as_str()), Some("cmd"));
}

#[test]
fn double_hyphen_as_value() {
    let res = Command::new("prog")
        .arg(
            Arg::new("cfg")
                .action(ArgAction::Set)
                .allow_hyphen_values(true)
                .long("config"),
        )
        .try_get_matches_from(vec!["prog", "--config", "--"]);
    assert!(res.is_ok(), "{res:?}");
    assert_eq!(
        res.unwrap().get_one::<String>("cfg").map(|v| v.as_str()),
        Some("--")
    );
}

#[test]
fn require_equals_no_empty_values_fail() {
    let res = Command::new("prog")
        .arg(
            Arg::new("cfg")
                .action(ArgAction::Set)
                .require_equals(true)
                .value_parser(clap::builder::NonEmptyStringValueParser::new())
                .long("config"),
        )
        .arg(Arg::new("some"))
        .try_get_matches_from(vec!["prog", "--config=", "file.conf"]);
    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
fn require_equals_empty_vals_pass() {
    let res = Command::new("prog")
        .arg(
            Arg::new("cfg")
                .action(ArgAction::Set)
                .require_equals(true)
                .long("config"),
        )
        .try_get_matches_from(vec!["prog", "--config="]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn require_equals_pass() {
    let res = Command::new("prog")
        .arg(
            Arg::new("cfg")
                .action(ArgAction::Set)
                .require_equals(true)
                .long("config"),
        )
        .try_get_matches_from(vec!["prog", "--config=file.conf"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn stdin_char() {
    let r = Command::new("opts")
        .arg(arg!(f: -f [flag] "some flag"))
        .try_get_matches_from(vec!["", "-f", "-"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("f"));
    assert_eq!(m.get_one::<String>("f").map(|v| v.as_str()).unwrap(), "-");
}

#[test]
fn opts_using_short() {
    let r = Command::new("opts")
        .args([
            arg!(f: -f [flag] "some flag"),
            arg!(c: -c [color] "some other flag"),
        ])
        .try_get_matches_from(vec!["", "-f", "some", "-c", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("f"));
    assert_eq!(
        m.get_one::<String>("f").map(|v| v.as_str()).unwrap(),
        "some"
    );
    assert!(m.contains_id("c"));
    assert_eq!(
        m.get_one::<String>("c").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn lots_o_vals() {
    let r = Command::new("opts")
        .arg(arg!(o: -o <opt> "some opt").num_args(1..).required(true))
        .try_get_matches_from(vec![
            "", "-o", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some",
        ]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(m.get_many::<String>("o").unwrap().count(), 297); // i.e. more than u8
}

#[test]
fn opts_using_long_space() {
    let r = Command::new("opts")
        .args([
            arg!(--flag [flag] "some flag"),
            arg!(--color [color] "some other flag"),
        ])
        .try_get_matches_from(vec!["", "--flag", "some", "--color", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()).unwrap(),
        "some"
    );
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn opts_using_long_equals() {
    let r = Command::new("opts")
        .args([
            arg!(--flag [flag] "some flag"),
            arg!(--color [color] "some other flag"),
        ])
        .try_get_matches_from(vec!["", "--flag=some", "--color=other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()).unwrap(),
        "some"
    );
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn opts_using_mixed() {
    let r = Command::new("opts")
        .args([
            arg!(-f --flag [flag] "some flag"),
            arg!(-c --color [color] "some other flag"),
        ])
        .try_get_matches_from(vec!["", "-f", "some", "--color", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()).unwrap(),
        "some"
    );
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn opts_using_mixed2() {
    let r = Command::new("opts")
        .args([
            arg!(-f --flag [flag] "some flag"),
            arg!(-c --color [color] "some other flag"),
        ])
        .try_get_matches_from(vec!["", "--flag=some", "-c", "other"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()).unwrap(),
        "some"
    );
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn default_values_user_value() {
    let r = Command::new("df")
        .arg(arg!(o: -o [opt] "some opt").default_value("default"))
        .try_get_matches_from(vec!["", "-o", "value"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.get_one::<String>("o").map(|v| v.as_str()).unwrap(),
        "value"
    );
}

#[test]
fn multiple_vals_pos_arg_equals() {
    let r = Command::new("mvae")
        .arg(arg!(o: -o [opt] ... "some opt"))
        .arg(arg!([file] "some file"))
        .try_get_matches_from(vec!["", "-o=1", "some"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(m.get_one::<String>("o").map(|v| v.as_str()).unwrap(), "1");
    assert!(m.contains_id("file"));
    assert_eq!(
        m.get_one::<String>("file").map(|v| v.as_str()).unwrap(),
        "some"
    );
}

#[test]
fn require_delims_no_delim() {
    let r = Command::new("mvae")
        .arg(arg!(o: -o [opt] ... "some opt").value_delimiter(','))
        .arg(arg!([file] "some file"))
        .try_get_matches_from(vec!["mvae", "-o", "1", "2", "some"]);
    assert!(r.is_err());
    let err = r.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::UnknownArgument);
}

#[test]
fn require_delims() {
    let r = Command::new("mvae")
        .arg(
            arg!(o: -o <opt> "some opt")
                .value_delimiter(',')
                .required(true),
        )
        .arg(arg!([file] "some file"))
        .try_get_matches_from(vec!["", "-o", "1,2", "some"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.get_many::<String>("o")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["1", "2"]
    );
    assert!(m.contains_id("file"));
    assert_eq!(
        m.get_one::<String>("file").map(|v| v.as_str()).unwrap(),
        "some"
    );
}

#[test]
fn leading_hyphen_pass() {
    let r = Command::new("mvae")
        .arg(
            arg!(o: -o <opt> "some opt")
                .required(true)
                .num_args(1..)
                .allow_hyphen_values(true),
        )
        .try_get_matches_from(vec!["", "-o", "-2", "3"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.get_many::<String>("o")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["-2", "3"]
    );
}

#[test]
fn leading_hyphen_fail() {
    let r = Command::new("mvae")
        .arg(arg!(o: -o <opt> "some opt").required(true))
        .try_get_matches_from(vec!["", "-o", "-2"]);
    assert!(r.is_err());
    let m = r.unwrap_err();
    assert_eq!(m.kind(), ErrorKind::UnknownArgument);
}

#[test]
fn leading_hyphen_with_flag_after() {
    let r = Command::new("mvae")
        .arg(
            arg!(o: -o <opt> "some opt")
                .required(true)
                .num_args(1..)
                .allow_hyphen_values(true),
        )
        .arg(arg!(f: -f "some flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-o", "-2", "-f"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.get_many::<String>("o")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["-2", "-f"]
    );
    assert!(!*m.get_one::<bool>("f").expect("defaulted by clap"));
}

#[test]
fn leading_hyphen_with_flag_before() {
    let r = Command::new("mvae")
        .arg(arg!(o: -o [opt] ... "some opt").allow_hyphen_values(true))
        .arg(arg!(f: -f "some flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-f", "-o", "-2"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.get_many::<String>("o")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["-2"]
    );
    assert!(*m.get_one::<bool>("f").expect("defaulted by clap"));
}

#[test]
fn leading_hyphen_with_only_pos_follows() {
    let r = Command::new("mvae")
        .arg(
            arg!(o: -o [opt] ... "some opt")
                .action(ArgAction::Set)
                .allow_hyphen_values(true),
        )
        .arg(arg!([arg] "some arg"))
        .try_get_matches_from(vec!["", "-o", "-2", "--", "val"]);
    assert!(r.is_ok(), "{r:?}");
    let m = r.unwrap();
    assert!(m.contains_id("o"));
    assert_eq!(
        m.get_many::<String>("o")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["-2"]
    );
    assert_eq!(m.get_one::<String>("arg").map(|v| v.as_str()), Some("val"));
}

#[test]
#[cfg(feature = "suggestions")]
#[cfg(feature = "error-context")]
fn did_you_mean() {
    static DYM: &str = "\
error: unexpected argument '--optio' found

  tip: a similar argument exists: '--option'

Usage: clap-test --option <opt>... [positional] [positional2] [positional3]...

For more information, try '--help'.
";

    utils::assert_output(utils::complex_app(), "clap-test --optio=foo", DYM, true);
}

#[test]
fn issue_1047_min_zero_vals_default_val() {
    let m = Command::new("foo")
        .arg(
            Arg::new("del")
                .short('d')
                .long("del")
                .action(ArgAction::Set)
                .require_equals(true)
                .num_args(0..)
                .default_missing_value("default"),
        )
        .try_get_matches_from(vec!["foo", "-d"])
        .unwrap();
    assert_eq!(
        m.get_one::<String>("del").map(|v| v.as_str()),
        Some("default")
    );
}

fn issue_1105_setup(argv: Vec<&'static str>) -> Result<ArgMatches, clap::Error> {
    Command::new("opts")
        .arg(arg!(-o --option <opt> "some option").required(true))
        .arg(arg!(--flag "some flag"))
        .try_get_matches_from(argv)
}

#[test]
fn issue_1105_empty_value_long_fail() {
    let r = issue_1105_setup(vec!["cmd", "--option", "--flag"]);
    assert!(r.is_err());
    assert_eq!(r.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
fn issue_1105_empty_value_long_explicit() {
    let r = issue_1105_setup(vec!["cmd", "--option", ""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert_eq!(m.get_one::<String>("option").map(|v| v.as_str()), Some(""));
}

#[test]
fn issue_1105_empty_value_long_equals() {
    let r = issue_1105_setup(vec!["cmd", "--option="]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert_eq!(m.get_one::<String>("option").map(|v| v.as_str()), Some(""));
}

#[test]
fn issue_1105_empty_value_short_fail() {
    let r = issue_1105_setup(vec!["cmd", "-o", "--flag"]);
    assert!(r.is_err());
    assert_eq!(r.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
fn issue_1105_empty_value_short_explicit() {
    let r = issue_1105_setup(vec!["cmd", "-o", ""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert_eq!(m.get_one::<String>("option").map(|v| v.as_str()), Some(""));
}

#[test]
fn issue_1105_empty_value_short_equals() {
    let r = issue_1105_setup(vec!["cmd", "-o="]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert_eq!(m.get_one::<String>("option").map(|v| v.as_str()), Some(""));
}

#[test]
fn issue_1105_empty_value_short_explicit_no_space() {
    let r = issue_1105_setup(vec!["cmd", "-o", ""]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert_eq!(m.get_one::<String>("option").map(|v| v.as_str()), Some(""));
}

#[test]
#[cfg(feature = "suggestions")]
#[cfg(feature = "error-context")]
fn issue_1073_suboptimal_flag_suggestion() {
    static DYM_ISSUE_1073: &str = "\
error: unexpected argument '--files-without-matches' found

  tip: a similar argument exists: '--files-without-match'

Usage: ripgrep-616 --files-without-match

For more information, try '--help'.
";

    let cmd = Command::new("ripgrep-616")
        .arg(
            Arg::new("files-with-matches")
                .long("files-with-matches")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("files-without-match")
                .long("files-without-match")
                .action(ArgAction::SetTrue),
        );
    utils::assert_output(
        cmd,
        "ripgrep-616 --files-without-matches",
        DYM_ISSUE_1073,
        true,
    );
}

#[test]
fn short_non_ascii_no_space() {
    let matches = Command::new("cmd")
        .arg(arg!(opt: -'磨' <opt>).required(true))
        .try_get_matches_from(["test", "-磨VALUE"])
        .unwrap();

    assert_eq!(
        "VALUE",
        matches
            .get_one::<String>("opt")
            .map(|v| v.as_str())
            .unwrap()
    );
}

#[test]
fn short_eq_val_starts_with_eq() {
    let matches = Command::new("cmd")
        .arg(arg!(opt: -f <opt>).required(true))
        .try_get_matches_from(["test", "-f==value"])
        .unwrap();

    assert_eq!(
        "=value",
        matches
            .get_one::<String>("opt")
            .map(|v| v.as_str())
            .unwrap()
    );
}

#[test]
fn long_eq_val_starts_with_eq() {
    let matches = Command::new("cmd")
        .arg(arg!(opt: --foo <opt>).required(true))
        .try_get_matches_from(["test", "--foo==value"])
        .unwrap();

    assert_eq!(
        "=value",
        matches
            .get_one::<String>("opt")
            .map(|v| v.as_str())
            .unwrap()
    );
}

#[test]
fn issue_2022_get_flags_misuse() {
    let cmd = Command::new("test")
        .next_help_heading(Some("test"))
        .arg(Arg::new("a").long("a").default_value("32"));
    let matches = cmd.try_get_matches_from([""]).unwrap();
    assert!(matches.get_one::<String>("a").map(|v| v.as_str()).is_some());
}

#[test]
fn issue_2279() {
    let before_help_heading = Command::new("cmd")
        .arg(Arg::new("foo").short('f').default_value("bar"))
        .next_help_heading(Some("This causes default_value to be ignored"))
        .try_get_matches_from([""])
        .unwrap();

    assert_eq!(
        before_help_heading
            .get_one::<String>("foo")
            .map(|v| v.as_str()),
        Some("bar")
    );

    let after_help_heading = Command::new("cmd")
        .next_help_heading(Some("This causes default_value to be ignored"))
        .arg(Arg::new("foo").short('f').default_value("bar"))
        .try_get_matches_from([""])
        .unwrap();

    assert_eq!(
        after_help_heading
            .get_one::<String>("foo")
            .map(|v| v.as_str()),
        Some("bar")
    );
}

#[test]
fn infer_long_arg_pass() {
    let cmd = Command::new("test")
        .infer_long_args(true)
        .arg(
            Arg::new("racetrack")
                .long("racetrack")
                .alias("autobahn")
                .action(ArgAction::SetTrue),
        )
        .arg(Arg::new("racecar").long("racecar").action(ArgAction::Set));

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--racec=hello"])
        .unwrap();
    assert!(!*matches
        .get_one::<bool>("racetrack")
        .expect("defaulted by clap"));
    assert_eq!(
        matches.get_one::<String>("racecar").map(|v| v.as_str()),
        Some("hello")
    );

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--racet"])
        .unwrap();
    assert!(*matches
        .get_one::<bool>("racetrack")
        .expect("defaulted by clap"));
    assert_eq!(
        matches.get_one::<String>("racecar").map(|v| v.as_str()),
        None
    );

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--auto"])
        .unwrap();
    assert!(*matches
        .get_one::<bool>("racetrack")
        .expect("defaulted by clap"));
    assert_eq!(
        matches.get_one::<String>("racecar").map(|v| v.as_str()),
        None
    );

    let cmd = Command::new("test")
        .infer_long_args(true)
        .arg(Arg::new("arg").long("arg").action(ArgAction::SetTrue));

    let matches = cmd.clone().try_get_matches_from(["test", "--"]).unwrap();
    assert!(!*matches.get_one::<bool>("arg").expect("defaulted by clap"));

    let matches = cmd.clone().try_get_matches_from(["test", "--a"]).unwrap();
    assert!(*matches.get_one::<bool>("arg").expect("defaulted by clap"));
}

#[test]
fn infer_long_arg_pass_conflicts_exact_match() {
    let cmd = Command::new("test")
        .infer_long_args(true)
        .arg(Arg::new("arg").long("arg").action(ArgAction::SetTrue))
        .arg(Arg::new("arg2").long("arg2").action(ArgAction::SetTrue));

    let matches = cmd.clone().try_get_matches_from(["test", "--arg"]).unwrap();
    assert!(*matches.get_one::<bool>("arg").expect("defaulted by clap"));

    let matches = cmd
        .clone()
        .try_get_matches_from(["test", "--arg2"])
        .unwrap();
    assert!(*matches.get_one::<bool>("arg2").expect("defaulted by clap"));
}

#[test]
fn infer_long_arg_pass_conflicting_aliases() {
    let cmd = Command::new("test").infer_long_args(true).arg(
        Arg::new("abc-123")
            .long("abc-123")
            .aliases(["a", "abc-xyz"])
            .action(ArgAction::SetTrue),
    );

    let matches = cmd.clone().try_get_matches_from(["test", "--ab"]).unwrap();
    assert!(*matches
        .get_one::<bool>("abc-123")
        .expect("defaulted by clap"));
}

#[test]
fn infer_long_arg_fail_conflicts() {
    let cmd = Command::new("test")
        .infer_long_args(true)
        .arg(
            Arg::new("abc-123")
                .long("abc-123")
                .action(ArgAction::SetTrue),
        )
        .arg(
            Arg::new("abc-xyz")
                .long("abc-xyz")
                .action(ArgAction::SetTrue),
        );

    let error = cmd
        .clone()
        .try_get_matches_from(["test", "--abc"])
        .unwrap_err();
    assert_eq!(error.kind(), ErrorKind::UnknownArgument);
}

```

`clap/tests/builder/positionals.rs`:

```rs
use clap::{arg, error::ErrorKind, Arg, ArgAction, Command};
use snapbox::assert_data_eq;
use snapbox::str;

#[test]
fn only_pos_follow() {
    let r = Command::new("onlypos")
        .args([arg!(f: -f [flag] "some opt"), arg!([arg] "some arg")])
        .try_get_matches_from(vec!["", "--", "-f"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert!(!m.contains_id("f"));
    assert_eq!(
        m.get_one::<String>("arg").map(|v| v.as_str()).unwrap(),
        "-f"
    );
}

#[test]
fn issue_946() {
    let r = Command::new("compiletest")
        .arg(arg!(--exact    "filters match exactly").action(ArgAction::SetTrue))
        .arg(
            Arg::new("filter")
                .index(1)
                .action(ArgAction::Set)
                .allow_hyphen_values(true)
                .help("filters to apply to output"),
        )
        .try_get_matches_from(vec!["compiletest", "--exact"]);
    assert!(r.is_ok(), "{r:#?}");
    let matches = r.unwrap();

    assert!(*matches.get_one::<bool>("exact").expect("defaulted by clap"));
    assert!(matches
        .get_one::<String>("filter")
        .map(|v| v.as_str())
        .is_none());
}

#[test]
fn positional() {
    let r = Command::new("positional")
        .args([
            arg!(-f --flag "some flag").action(ArgAction::SetTrue),
            Arg::new("positional").index(1),
        ])
        .try_get_matches_from(vec!["", "-f", "test"]);
    assert!(r.is_ok(), "{r:#?}");
    let m = r.unwrap();
    assert!(m.contains_id("positional"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert_eq!(
        m.get_one::<String>("positional")
            .map(|v| v.as_str())
            .unwrap(),
        "test"
    );

    let m = Command::new("positional")
        .args([
            arg!(-f --flag "some flag").action(ArgAction::SetTrue),
            Arg::new("positional").index(1),
        ])
        .try_get_matches_from(vec!["", "test", "--flag"])
        .unwrap();
    assert!(m.contains_id("positional"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert_eq!(
        m.get_one::<String>("positional")
            .map(|v| v.as_str())
            .unwrap(),
        "test"
    );
}

#[test]
fn lots_o_vals() {
    let r = Command::new("opts")
        .arg(arg!(<opt>... "some pos"))
        .try_get_matches_from(vec![
            "", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some", "some", "some", "some", "some", "some", "some", "some", "some", "some", "some",
            "some",
        ]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(m.get_many::<String>("opt").unwrap().count(), 297); // i.e. more than u8
}

#[test]
fn positional_multiple() {
    let r = Command::new("positional_multiple")
        .args([
            arg!(-f --flag "some flag").action(ArgAction::SetTrue),
            Arg::new("positional")
                .index(1)
                .action(ArgAction::Set)
                .num_args(1..),
        ])
        .try_get_matches_from(vec!["", "-f", "test1", "test2", "test3"]);
    assert!(r.is_ok(), "{r:#?}");
    let m = r.unwrap();
    assert!(m.contains_id("positional"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert_eq!(
        &*m.get_many::<String>("positional")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["test1", "test2", "test3"]
    );
}

#[test]
fn positional_multiple_3() {
    let r = Command::new("positional_multiple")
        .args([
            arg!(-f  --flag "some flag").action(ArgAction::SetTrue),
            Arg::new("positional")
                .index(1)
                .action(ArgAction::Set)
                .num_args(1..),
        ])
        .try_get_matches_from(vec!["", "test1", "test2", "test3", "--flag"]);
    assert!(r.is_ok(), "{r:#?}");
    let m = r.unwrap();
    assert!(m.contains_id("positional"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert_eq!(
        &*m.get_many::<String>("positional")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["test1", "test2", "test3"]
    );
}

#[test]
fn positional_multiple_2() {
    let result = Command::new("positional_multiple")
        .args([arg!(-f --flag "some flag"), Arg::new("positional").index(1)])
        .try_get_matches_from(vec!["", "-f", "test1", "test2", "test3"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::UnknownArgument);
}

#[test]
fn positional_possible_values() {
    let r = Command::new("positional_possible_values")
        .args([
            arg!(-f --flag "some flag").action(ArgAction::SetTrue),
            Arg::new("positional").index(1).value_parser(["test123"]),
        ])
        .try_get_matches_from(vec!["", "-f", "test123"]);
    assert!(r.is_ok(), "{r:#?}");
    let m = r.unwrap();
    assert!(m.contains_id("positional"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert_eq!(
        &*m.get_many::<String>("positional")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["test123"]
    );
}

#[test]
fn create_positional() {
    let _ = Command::new("test")
        .arg(Arg::new("test").index(1).help("testing testing"))
        .try_get_matches_from(vec![""])
        .unwrap();
}

#[test]
fn positional_hyphen_does_not_panic() {
    let _ = Command::new("test")
        .arg(Arg::new("dummy"))
        .try_get_matches_from(vec!["test", "-"])
        .unwrap();
}

#[test]
fn single_positional_usage_string() {
    let mut cmd = Command::new("test").arg(arg!([FILE] "some file"));
    assert_data_eq!(cmd.render_usage().to_string(), str!["Usage: test [FILE]"]);
}

#[test]
fn single_positional_multiple_usage_string() {
    let mut cmd = Command::new("test").arg(arg!([FILE]... "some file"));
    assert_data_eq!(cmd.render_usage().to_string(), str!["Usage: test [FILE]..."]);
}

#[test]
fn multiple_positional_usage_string() {
    let mut cmd = Command::new("test")
        .arg(arg!([FILE] "some file"))
        .arg(arg!([FILES]... "some file"));
    assert_data_eq!(cmd.render_usage().to_string(), str!["Usage: test [FILE] [FILES]..."],);
}

#[test]
fn multiple_positional_one_required_usage_string() {
    let mut cmd = Command::new("test")
        .arg(arg!(<FILE> "some file"))
        .arg(arg!([FILES]... "some file"));
    assert_data_eq!(cmd.render_usage().to_string(), str!["Usage: test <FILE> [FILES]..."]);
}

#[test]
fn single_positional_required_usage_string() {
    let mut cmd = Command::new("test").arg(arg!(<FILE> "some file"));
    assert_data_eq!(cmd.render_usage().to_string(), str!["Usage: test <FILE>"]);
}

// This tests a programmer error and will only succeed with debug_assertions
#[cfg(debug_assertions)]
#[test]
#[should_panic = "Found non-required positional argument \
with a lower index than a required positional argument"]
fn missing_required() {
    let _ = Command::new("test")
        .arg(arg!([FILE1] "some file"))
        .arg(arg!(<FILE2> "some file"))
        .try_get_matches_from(vec![""]);
}

#[test]
fn missing_required_2() {
    let r = Command::new("test")
        .arg(arg!(<FILE1> "some file"))
        .arg(arg!(<FILE2> "some file"))
        .try_get_matches_from(vec!["test", "file"]);
    assert!(r.is_err());
    assert_eq!(r.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn last_positional() {
    let r = Command::new("test")
        .arg(arg!(<TARGET> "some target"))
        .arg(arg!([CORPUS] "some corpus"))
        .arg(arg!([ARGS]... "some file").last(true))
        .try_get_matches_from(vec!["test", "tgt", "--", "arg"]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert_eq!(
        m.get_many::<String>("ARGS")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["arg"]
    );
}

#[test]
fn last_positional_no_double_dash() {
    let r = Command::new("test")
        .arg(arg!(<TARGET> "some target"))
        .arg(arg!([CORPUS] "some corpus"))
        .arg(arg!([ARGS]... "some file").last(true))
        .try_get_matches_from(vec!["test", "tgt", "crp", "arg"]);
    assert!(r.is_err());
    assert_eq!(r.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[test]
fn last_positional_second_to_last_mult() {
    let r = Command::new("test")
        .arg(arg!(<TARGET> "some target"))
        .arg(arg!([CORPUS]... "some corpus"))
        .arg(arg!([ARGS]... "some file").last(true))
        .try_get_matches_from(vec!["test", "tgt", "crp1", "crp2", "--", "arg"]);
    assert!(r.is_ok(), "{:?}", r.unwrap_err().kind());
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Argument 'arg' is a positional argument and can't have short or long name versions"]
fn positional_arg_with_long() {
    use clap::{Arg, Command};

    let _ = Command::new("test")
        .arg(Arg::new("arg").index(1).long("arg"))
        .try_get_matches();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Argument 'arg' is a positional argument and can't have short or long name versions"]
fn positional_arg_with_short() {
    use clap::{Arg, Command};

    let _ = Command::new("test")
        .arg(Arg::new("arg").index(1).short('a'))
        .try_get_matches();
}

#[test]
fn ignore_hyphen_values_on_last() {
    let cmd = Command::new("foo")
        .arg(
            Arg::new("cmd")
                .num_args(1..)
                .last(true)
                .allow_hyphen_values(true),
        )
        .arg(
            Arg::new("name")
                .long("name")
                .short('n')
                .action(ArgAction::Set)
                .required(false),
        );

    let matches = cmd.try_get_matches_from(["test", "-n", "foo"]).unwrap();
    assert_eq!(
        matches.get_one::<String>("name").map(|v| v.as_str()),
        Some("foo")
    );
}

```

`clap/tests/builder/posix_compatible.rs`:

```rs
use clap::{arg, error::ErrorKind, Arg, ArgAction, Command};

#[test]
fn flag_overrides_itself() {
    let res = Command::new("posix")
        .arg(
            arg!(--flag  "some flag"
            )
            .action(ArgAction::SetTrue)
            .overrides_with("flag"),
        )
        .try_get_matches_from(vec!["", "--flag", "--flag"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn option_overrides_itself() {
    let res = Command::new("posix")
        .arg(
            arg!(--opt <val> "some option")
                .required(false)
                .overrides_with("opt"),
        )
        .try_get_matches_from(vec!["", "--opt=some", "--opt=other"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(m.contains_id("opt"));
    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("other")
    );
}

#[test]
fn posix_compatible_flags_long() {
    let m = Command::new("posix")
        .arg(
            arg!(--flag  "some flag")
                .overrides_with("color")
                .action(ArgAction::SetTrue),
        )
        .arg(arg!(--color "some other flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "--flag", "--color"])
        .unwrap();
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn posix_compatible_flags_long_rev() {
    let m = Command::new("posix")
        .arg(
            arg!(--flag  "some flag")
                .overrides_with("color")
                .action(ArgAction::SetTrue),
        )
        .arg(arg!(--color "some other flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "--color", "--flag"])
        .unwrap();
    assert!(!*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn posix_compatible_flags_short() {
    let m = Command::new("posix")
        .arg(
            arg!(-f --flag  "some flag")
                .overrides_with("color")
                .action(ArgAction::SetTrue),
        )
        .arg(arg!(-c --color "some other flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-f", "-c"])
        .unwrap();
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn posix_compatible_flags_short_rev() {
    let m = Command::new("posix")
        .arg(
            arg!(-f --flag  "some flag")
                .overrides_with("color")
                .action(ArgAction::SetTrue),
        )
        .arg(arg!(-c --color "some other flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-c", "-f"])
        .unwrap();
    assert!(!*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn posix_compatible_opts_long() {
    let m = Command::new("posix")
        .arg(arg!(--flag <flag> "some flag").overrides_with("color"))
        .arg(arg!(--color <color> "some other flag"))
        .try_get_matches_from(vec!["", "--flag", "some", "--color", "other"])
        .unwrap();
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "other"
    );
    assert!(!m.contains_id("flag"));
}

#[test]
fn posix_compatible_opts_long_rev() {
    let m = Command::new("posix")
        .arg(arg!(--flag <flag> "some flag").overrides_with("color"))
        .arg(arg!(--color <color> "some other flag"))
        .try_get_matches_from(vec!["", "--color", "some", "--flag", "other"])
        .unwrap();
    assert!(!m.contains_id("color"));
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn posix_compatible_opts_long_equals() {
    let m = Command::new("posix")
        .arg(arg!(--flag <flag> "some flag").overrides_with("color"))
        .arg(arg!(--color <color> "some other flag"))
        .try_get_matches_from(vec!["", "--flag=some", "--color=other"])
        .unwrap();
    assert!(m.contains_id("color"));
    assert_eq!(
        m.get_one::<String>("color").map(|v| v.as_str()).unwrap(),
        "other"
    );
    assert!(!m.contains_id("flag"));
}

#[test]
fn posix_compatible_opts_long_equals_rev() {
    let m = Command::new("posix")
        .arg(arg!(--flag <flag> "some flag").overrides_with("color"))
        .arg(arg!(--color <color> "some other flag"))
        .try_get_matches_from(vec!["", "--color=some", "--flag=other"])
        .unwrap();
    assert!(!m.contains_id("color"));
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn posix_compatible_opts_short() {
    let m = Command::new("posix")
        .arg(arg!(f: -f <flag>  "some flag").overrides_with("c"))
        .arg(arg!(c: -c <color> "some other flag"))
        .try_get_matches_from(vec!["", "-f", "some", "-c", "other"])
        .unwrap();
    assert!(m.contains_id("c"));
    assert_eq!(
        m.get_one::<String>("c").map(|v| v.as_str()).unwrap(),
        "other"
    );
    assert!(!m.contains_id("f"));
}

#[test]
fn posix_compatible_opts_short_rev() {
    let m = Command::new("posix")
        .arg(arg!(f: -f <flag>  "some flag").overrides_with("c"))
        .arg(arg!(c: -c <color> "some other flag"))
        .try_get_matches_from(vec!["", "-c", "some", "-f", "other"])
        .unwrap();
    assert!(!m.contains_id("c"));
    assert!(m.contains_id("f"));
    assert_eq!(
        m.get_one::<String>("f").map(|v| v.as_str()).unwrap(),
        "other"
    );
}

#[test]
fn conflict_overridden() {
    let m = Command::new("conflict_overridden")
        .arg(
            arg!(-f --flag "some flag")
                .conflicts_with("debug")
                .action(ArgAction::SetTrue),
        )
        .arg(arg!(-d --debug "other flag").action(ArgAction::SetTrue))
        .arg(
            arg!(-c --color "third flag")
                .overrides_with("flag")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["", "-f", "-c", "-d"])
        .unwrap();
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("debug").expect("defaulted by clap"));
}

#[test]
fn conflict_overridden_2() {
    let result = Command::new("conflict_overridden")
        .arg(
            arg!(-f --flag "some flag")
                .conflicts_with("debug")
                .action(ArgAction::SetTrue),
        )
        .arg(arg!(-d --debug "other flag").action(ArgAction::SetTrue))
        .arg(
            arg!(-c --color "third flag")
                .overrides_with("flag")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["", "-f", "-d", "-c"]);
    assert!(result.is_ok(), "{}", result.unwrap_err());
    let m = result.unwrap();
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("debug").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn conflict_overridden_3() {
    let result = Command::new("conflict_overridden")
        .arg(arg!(-f --flag "some flag").conflicts_with("debug"))
        .arg(arg!(-d --debug "other flag"))
        .arg(arg!(-c --color "third flag").overrides_with("flag"))
        .try_get_matches_from(vec!["", "-d", "-c", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::ArgumentConflict);
}

#[test]
fn conflict_overridden_4() {
    let m = Command::new("conflict_overridden")
        .arg(
            arg!(-f --flag "some flag")
                .conflicts_with("debug")
                .action(ArgAction::SetTrue),
        )
        .arg(arg!(-d --debug "other flag").action(ArgAction::SetTrue))
        .arg(
            arg!(-c --color "third flag")
                .overrides_with("flag")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["", "-d", "-f", "-c"])
        .unwrap();
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("debug").expect("defaulted by clap"));
}

#[test]
fn pos_required_overridden_by_flag() {
    let result = Command::new("require_overridden")
        .arg(Arg::new("pos").index(1).required(true))
        .arg(arg!(-c --color "some flag").overrides_with("pos"))
        .try_get_matches_from(vec!["", "test", "-c"]);
    assert!(result.is_ok(), "{:?}", result.unwrap_err());
}

#[test]
fn require_overridden_2() {
    let m = Command::new("require_overridden")
        .arg(Arg::new("req_pos").required(true))
        .arg(
            arg!(-c --color "other flag")
                .overrides_with("req_pos")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["", "-c", "req_pos"])
        .unwrap();
    assert!(!*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(m.contains_id("req_pos"));
}

#[test]
fn require_overridden_3() {
    let m = Command::new("require_overridden")
        .arg(
            arg!(-f --flag "some flag")
                .requires("debug")
                .action(ArgAction::SetTrue),
        )
        .arg(arg!(-d --debug "other flag").action(ArgAction::SetTrue))
        .arg(
            arg!(-c --color "third flag")
                .overrides_with("flag")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(vec!["", "-f", "-c"])
        .unwrap();
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("debug").expect("defaulted by clap"));
}

#[test]
fn require_overridden_4() {
    let result = Command::new("require_overridden")
        .arg(arg!(-f --flag "some flag").requires("debug"))
        .arg(arg!(-d --debug "other flag"))
        .arg(arg!(-c --color "third flag").overrides_with("flag"))
        .try_get_matches_from(vec!["", "-c", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn incremental_override() {
    let mut cmd = Command::new("test")
        .arg(arg!(--name <NAME> ...).required(true))
        .arg(
            arg!(--"no-name")
                .overrides_with("name")
                .action(ArgAction::SetTrue),
        );
    let m = cmd
        .try_get_matches_from_mut(["test", "--name=ahmed", "--no-name", "--name=ali"])
        .unwrap();
    assert_eq!(
        m.get_many::<String>("name")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["ali"]
    );
    assert!(!*m.get_one::<bool>("no-name").expect("defaulted by clap"));
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Argument or group 'extra' specified in 'overrides_with*' for 'config' does not exist"]
fn overrides_with_invalid_arg() {
    let _ = Command::new("prog")
        .arg(Arg::new("config").long("config").overrides_with("extra"))
        .try_get_matches_from(vec!["", "--config"]);
}

```

`clap/tests/builder/possible_values.rs`:

```rs
use clap::{builder::PossibleValue, error::ErrorKind, Arg, ArgAction, Command};

#[cfg(feature = "error-context")]
use super::utils;

#[test]
fn possible_values_of_positional() {
    let m = Command::new("possible_values")
        .arg(Arg::new("positional").index(1).value_parser(["test123"]))
        .try_get_matches_from(vec!["myprog", "test123"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("positional"));
    assert_eq!(
        m.get_one::<String>("positional").map(|v| v.as_str()),
        Some("test123")
    );
}

#[test]
fn possible_value_arg_value() {
    let m = Command::new("possible_values")
        .arg(
            Arg::new("arg_value")
                .index(1)
                .value_parser([PossibleValue::new("test123")
                    .hide(false)
                    .help("It's just a test")]),
        )
        .try_get_matches_from(vec!["myprog", "test123"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("arg_value"));
    assert_eq!(
        m.get_one::<String>("arg_value").map(|v| v.as_str()),
        Some("test123")
    );
}

#[test]
fn possible_values_of_positional_fail() {
    let m = Command::new("possible_values")
        .arg(Arg::new("positional").index(1).value_parser(["test123"]))
        .try_get_matches_from(vec!["myprog", "notest"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
fn possible_values_of_positional_multiple() {
    let m = Command::new("possible_values")
        .arg(
            Arg::new("positional")
                .index(1)
                .action(ArgAction::Set)
                .value_parser(["test123", "test321"])
                .num_args(1..),
        )
        .try_get_matches_from(vec!["myprog", "test123", "test321"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("positional"));
    assert_eq!(
        m.get_many::<String>("positional")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        vec!["test123", "test321"]
    );
}

#[test]
fn possible_values_of_positional_multiple_fail() {
    let m = Command::new("possible_values")
        .arg(
            Arg::new("positional")
                .index(1)
                .action(ArgAction::Set)
                .value_parser(["test123", "test321"])
                .num_args(1..),
        )
        .try_get_matches_from(vec!["myprog", "test123", "notest"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
fn possible_values_of_option() {
    let m = Command::new("possible_values")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser(["test123"]),
        )
        .try_get_matches_from(vec!["myprog", "--option", "test123"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_one::<String>("option").map(|v| v.as_str()),
        Some("test123")
    );
}

#[test]
fn possible_values_of_option_fail() {
    let m = Command::new("possible_values")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser(["test123"]),
        )
        .try_get_matches_from(vec!["myprog", "--option", "notest"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
fn possible_values_of_option_multiple() {
    let m = Command::new("possible_values")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser(["test123", "test321"])
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec!["", "--option", "test123", "--option", "test321"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();

    assert!(m.contains_id("option"));
    assert_eq!(
        m.get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        vec!["test123", "test321"]
    );
}

#[test]
fn possible_values_of_option_multiple_fail() {
    let m = Command::new("possible_values")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser(["test123", "test321"])
                .action(ArgAction::Append),
        )
        .try_get_matches_from(vec!["", "--option", "test123", "--option", "notest"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
#[cfg(feature = "error-context")]
fn possible_values_output() {
    #[cfg(feature = "suggestions")]
    static PV_ERROR: &str = "\
error: invalid value 'slo' for '-O <option>'
  [possible values: slow, fast, \"ludicrous speed\"]

  tip: a similar value exists: 'slow'

For more information, try '--help'.
";

    #[cfg(not(feature = "suggestions"))]
    static PV_ERROR: &str = "\
error: invalid value 'slo' for '-O <option>'
  [possible values: slow, fast, \"ludicrous speed\"]

For more information, try '--help'.
";

    utils::assert_output(
        Command::new("test").arg(
            Arg::new("option")
                .short('O')
                .action(ArgAction::Set)
                .value_parser(["slow", "fast", "ludicrous speed"]),
        ),
        "clap-test -O slo",
        PV_ERROR,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn possible_values_alias_output() {
    #[cfg(feature = "suggestions")]
    static PV_ERROR: &str = "\
error: invalid value 'slo' for '-O <option>'
  [possible values: slow, fast, \"ludicrous speed\"]

  tip: a similar value exists: 'slow'

For more information, try '--help'.
";

    #[cfg(not(feature = "suggestions"))]
    static PV_ERROR: &str = "\
error: invalid value 'slo' for '-O <option>'
  [possible values: slow, fast, \"ludicrous speed\"]

For more information, try '--help'.
";

    utils::assert_output(
        Command::new("test").arg(
            Arg::new("option")
                .short('O')
                .action(ArgAction::Set)
                .value_parser([
                    "slow".into(),
                    PossibleValue::new("fast").alias("fost"),
                    PossibleValue::new("ludicrous speed").aliases(["ls", "lcs"]),
                ]),
        ),
        "clap-test -O slo",
        PV_ERROR,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn possible_values_hidden_output() {
    #[cfg(feature = "suggestions")]
    static PV_ERROR: &str = "\
error: invalid value 'slo' for '-O <option>'
  [possible values: slow, fast, \"ludicrous speed\"]

  tip: a similar value exists: 'slow'

For more information, try '--help'.
";

    #[cfg(not(feature = "suggestions"))]
    static PV_ERROR: &str = "\
error: invalid value 'slo' for '-O <option>'
  [possible values: slow, fast, \"ludicrous speed\"]

For more information, try '--help'.
";

    utils::assert_output(
        Command::new("test").arg(
            Arg::new("option")
                .short('O')
                .action(ArgAction::Set)
                .value_parser([
                    "slow".into(),
                    "fast".into(),
                    PossibleValue::new("ludicrous speed"),
                    PossibleValue::new("forbidden speed").hide(true),
                ]),
        ),
        "clap-test -O slo",
        PV_ERROR,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn escaped_possible_values_output() {
    #[cfg(feature = "suggestions")]
    static PV_ERROR_ESCAPED: &str = "\
error: invalid value 'ludicrous' for '-O <option>'
  [possible values: slow, fast, \"ludicrous speed\"]

  tip: a similar value exists: 'ludicrous speed'

For more information, try '--help'.
";

    #[cfg(not(feature = "suggestions"))]
    static PV_ERROR_ESCAPED: &str = "\
error: invalid value 'ludicrous' for '-O <option>'
  [possible values: slow, fast, \"ludicrous speed\"]

For more information, try '--help'.
";

    utils::assert_output(
        Command::new("test").arg(
            Arg::new("option")
                .short('O')
                .action(ArgAction::Set)
                .value_parser(["slow", "fast", "ludicrous speed"]),
        ),
        "clap-test -O ludicrous",
        PV_ERROR_ESCAPED,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn missing_possible_value_error() {
    static MISSING_PV_ERROR: &str = "\
error: a value is required for '-O <option>' but none was supplied
  [possible values: slow, fast, \"ludicrous speed\"]

For more information, try '--help'.
";

    utils::assert_output(
        Command::new("test").arg(
            Arg::new("option")
                .short('O')
                .action(ArgAction::Set)
                .value_parser([
                    "slow".into(),
                    PossibleValue::new("fast").alias("fost"),
                    PossibleValue::new("ludicrous speed"),
                    PossibleValue::new("forbidden speed").hide(true),
                ]),
        ),
        "clap-test -O",
        MISSING_PV_ERROR,
        true,
    );
}

#[test]
fn alias() {
    let m = Command::new("pv")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser([PossibleValue::new("test123").alias("123"), "test321".into()])
                .ignore_case(true),
        )
        .try_get_matches_from(vec!["pv", "--option", "123"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    assert!(m
        .unwrap()
        .get_one::<String>("option")
        .map(|v| v.as_str())
        .unwrap()
        .eq("123"));
}

#[test]
fn aliases() {
    let m = Command::new("pv")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser([
                    PossibleValue::new("test123").aliases(["1", "2", "3"]),
                    "test321".into(),
                ])
                .ignore_case(true),
        )
        .try_get_matches_from(vec!["pv", "--option", "2"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    assert!(m
        .unwrap()
        .get_one::<String>("option")
        .map(|v| v.as_str())
        .unwrap()
        .eq("2"));
}

#[test]
fn ignore_case() {
    let m = Command::new("pv")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser(["test123", "test321"])
                .ignore_case(true),
        )
        .try_get_matches_from(vec!["pv", "--option", "TeSt123"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    assert!(m
        .unwrap()
        .get_one::<String>("option")
        .map(|v| v.as_str())
        .unwrap()
        .eq_ignore_ascii_case("test123"));
}

#[test]
fn ignore_case_fail() {
    let m = Command::new("pv")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser(["test123", "test321"]),
        )
        .try_get_matches_from(vec!["pv", "--option", "TeSt123"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[test]
fn ignore_case_multiple() {
    let m = Command::new("pv")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser(["test123", "test321"])
                .num_args(1..)
                .ignore_case(true),
        )
        .try_get_matches_from(vec!["pv", "--option", "TeSt123", "teST123", "tESt321"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    assert_eq!(
        m.unwrap()
            .get_many::<String>("option")
            .unwrap()
            .map(|v| v.as_str())
            .collect::<Vec<_>>(),
        ["TeSt123", "teST123", "tESt321"]
    );
}

#[test]
fn ignore_case_multiple_fail() {
    let m = Command::new("pv")
        .arg(
            Arg::new("option")
                .short('o')
                .long("option")
                .action(ArgAction::Set)
                .value_parser(["test123", "test321"])
                .num_args(1..),
        )
        .try_get_matches_from(vec!["pv", "--option", "test123", "teST123", "test321"]);

    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidValue);
}

#[cfg(feature = "string")]
mod expensive {
    use std::sync::{Arc, Mutex};

    use clap::{Arg, Command};
    use clap_builder::builder::{PossibleValue, PossibleValuesParser, TypedValueParser};

    #[cfg(feature = "error-context")]
    use super::utils;

    #[derive(Clone)]
    struct ExpensiveValues {
        iterated: Arc<Mutex<bool>>,
    }

    impl ExpensiveValues {
        pub(crate) fn new() -> Self {
            ExpensiveValues {
                iterated: Arc::new(Mutex::new(false)),
            }
        }
    }

    impl IntoIterator for ExpensiveValues {
        type Item = String;

        type IntoIter = ExpensiveValuesIntoIterator;

        fn into_iter(self) -> Self::IntoIter {
            ExpensiveValuesIntoIterator { me: self, index: 0 }
        }
    }

    struct ExpensiveValuesIntoIterator {
        me: ExpensiveValues,
        index: usize,
    }

    impl Iterator for ExpensiveValuesIntoIterator {
        type Item = String;
        fn next(&mut self) -> Option<String> {
            let mut guard = self
                .me
                .iterated
                .lock()
                .expect("not working across multiple threads");

            *guard = true;
            self.index += 1;

            if self.index < 3 {
                Some(format!("expensive-value-{}", self.index))
            } else {
                None
            }
        }
    }

    impl TypedValueParser for ExpensiveValues {
        type Value = String;

        fn parse_ref(
            &self,
            _cmd: &Command,
            _arg: Option<&Arg>,
            _value: &std::ffi::OsStr,
        ) -> Result<Self::Value, clap_builder::Error> {
            unimplemented!()
        }

        fn possible_values(&self) -> Option<Box<dyn Iterator<Item = PossibleValue> + '_>> {
            Some(Box::new(self.clone().into_iter().map(PossibleValue::from)))
        }
    }

    #[test]
    fn no_iterate_when_hidden() {
        static PV_EXPECTED: &str = "\
Usage: clap-test [some-cheap-option] [some-expensive-option]

Arguments:
  [some-cheap-option]      cheap [possible values: some, cheap, values]
  [some-expensive-option]  expensive

Options:
  -h, --help  Print help
";
        let expensive = ExpensiveValues::new();
        utils::assert_output(
            Command::new("test")
                .arg(
                    Arg::new("some-cheap-option")
                        .help("cheap")
                        .value_parser(PossibleValuesParser::new(["some", "cheap", "values"])),
                )
                .arg(
                    Arg::new("some-expensive-option")
                        .help("expensive")
                        .hide_possible_values(true)
                        .value_parser(expensive.clone()),
                ),
            "clap-test -h",
            PV_EXPECTED,
            false,
        );
        assert_eq!(*expensive.iterated.lock().unwrap(), false);
    }

    #[test]
    fn iterate_when_displayed() {
        static PV_EXPECTED: &str = "\
Usage: clap-test [some-cheap-option] [some-expensive-option]

Arguments:
  [some-cheap-option]      cheap [possible values: some, cheap, values]
  [some-expensive-option]  expensive [possible values: expensive-value-1, expensive-value-2]

Options:
  -h, --help  Print help
";
        let expensive = ExpensiveValues::new();
        utils::assert_output(
            Command::new("test")
                .arg(
                    Arg::new("some-cheap-option")
                        .help("cheap")
                        .value_parser(PossibleValuesParser::new(["some", "cheap", "values"])),
                )
                .arg(
                    Arg::new("some-expensive-option")
                        .help("expensive")
                        .hide_possible_values(false)
                        .value_parser(expensive.clone()),
                ),
            "clap-test -h",
            PV_EXPECTED,
            false,
        );
        assert_eq!(*expensive.iterated.lock().unwrap(), true);
    }
}

```

`clap/tests/builder/propagate_globals.rs`:

```rs
use clap::{Arg, ArgAction, ArgMatches, Command};

fn get_app() -> Command {
    Command::new("myprog")
        .arg(
            Arg::new("GLOBAL_ARG")
                .long("global-arg")
                .help("Specifies something needed by the subcommands")
                .global(true)
                .action(ArgAction::Set)
                .default_value("default_value"),
        )
        .arg(
            Arg::new("GLOBAL_FLAG")
                .long("global-flag")
                .help("Specifies something needed by the subcommands")
                .global(true)
                .action(ArgAction::Count),
        )
        .subcommand(Command::new("outer").defer(|cmd| cmd.subcommand(Command::new("inner"))))
}

fn get_matches(cmd: Command, argv: &'static str) -> ArgMatches {
    cmd.try_get_matches_from(argv.split(' ').collect::<Vec<_>>())
        .unwrap()
}

fn get_outer_matches(m: &ArgMatches) -> &ArgMatches {
    m.subcommand_matches("outer")
        .expect("could not access outer subcommand")
}

fn get_inner_matches(m: &ArgMatches) -> &ArgMatches {
    get_outer_matches(m)
        .subcommand_matches("inner")
        .expect("could not access inner subcommand")
}

fn top_can_access_arg<T: Into<Option<&'static str>>>(m: &ArgMatches, val: T) -> bool {
    m.get_one::<String>("GLOBAL_ARG").map(|v| v.as_str()) == val.into()
}

fn inner_can_access_arg<T: Into<Option<&'static str>>>(m: &ArgMatches, val: T) -> bool {
    get_inner_matches(m)
        .get_one::<String>("GLOBAL_ARG")
        .map(|v| v.as_str())
        == val.into()
}

fn outer_can_access_arg<T: Into<Option<&'static str>>>(m: &ArgMatches, val: T) -> bool {
    get_outer_matches(m)
        .get_one::<String>("GLOBAL_ARG")
        .map(|v| v.as_str())
        == val.into()
}

fn top_can_access_flag(m: &ArgMatches, present: bool, occurrences: u8) -> bool {
    (m.contains_id("GLOBAL_FLAG") == present)
        && (m.get_one::<u8>("GLOBAL_FLAG").copied() == Some(occurrences))
}

fn inner_can_access_flag(m: &ArgMatches, present: bool, occurrences: u8) -> bool {
    let m = get_inner_matches(m);
    (m.contains_id("GLOBAL_FLAG") == present)
        && (m.get_one::<u8>("GLOBAL_FLAG").copied() == Some(occurrences))
}

fn outer_can_access_flag(m: &ArgMatches, present: bool, occurrences: u8) -> bool {
    let m = get_outer_matches(m);
    (m.contains_id("GLOBAL_FLAG") == present)
        && (m.get_one::<u8>("GLOBAL_FLAG").copied() == Some(occurrences))
}

#[test]
fn global_arg_used_top_level() {
    let m = get_matches(get_app(), "myprog --global-arg=some_value outer inner");

    assert!(top_can_access_arg(&m, "some_value"));
    assert!(inner_can_access_arg(&m, "some_value"));
    assert!(outer_can_access_arg(&m, "some_value"));
}

#[test]
fn global_arg_used_outer() {
    let m = get_matches(get_app(), "myprog outer --global-arg=some_value inner");

    assert!(top_can_access_arg(&m, "some_value"));
    assert!(inner_can_access_arg(&m, "some_value"));
    assert!(outer_can_access_arg(&m, "some_value"));
}

#[test]
fn global_arg_used_inner() {
    let m = get_matches(get_app(), "myprog outer inner --global-arg=some_value");

    assert!(top_can_access_arg(&m, "some_value"));
    assert!(inner_can_access_arg(&m, "some_value"));
    assert!(outer_can_access_arg(&m, "some_value"));
}

#[test]
fn global_arg_default_value() {
    let m = get_matches(get_app(), "myprog outer inner");

    assert!(top_can_access_arg(&m, "default_value"));
    assert!(inner_can_access_arg(&m, "default_value"));
    assert!(outer_can_access_arg(&m, "default_value"));
}

#[test]
fn global_flag_used_top_level() {
    let m = get_matches(get_app(), "myprog --global-flag outer inner");

    assert!(top_can_access_flag(&m, true, 1));
    assert!(inner_can_access_flag(&m, true, 1));
    assert!(outer_can_access_flag(&m, true, 1));
}

#[test]
fn global_flag_used_outer() {
    let m = get_matches(get_app(), "myprog outer --global-flag inner");

    assert!(top_can_access_flag(&m, true, 1));
    assert!(inner_can_access_flag(&m, true, 1));
    assert!(outer_can_access_flag(&m, true, 1));
}

#[test]
fn global_flag_used_inner() {
    let m = get_matches(get_app(), "myprog outer inner --global-flag");

    assert!(top_can_access_flag(&m, true, 1));
    assert!(inner_can_access_flag(&m, true, 1));
    assert!(outer_can_access_flag(&m, true, 1));
}

#[test]
fn global_flag_2x_used_top_level() {
    let m = get_matches(get_app(), "myprog --global-flag --global-flag outer inner");

    assert!(top_can_access_flag(&m, true, 2));
    assert!(inner_can_access_flag(&m, true, 2));
    assert!(outer_can_access_flag(&m, true, 2));
}

#[test]
fn global_flag_2x_used_inner() {
    let m = get_matches(get_app(), "myprog outer inner --global-flag --global-flag");

    assert!(top_can_access_flag(&m, true, 2));
    assert!(inner_can_access_flag(&m, true, 2));
    assert!(outer_can_access_flag(&m, true, 2));
}

```

`clap/tests/builder/require.rs`:

```rs
use clap::builder::ArgPredicate;
use clap::{arg, error::ErrorKind, Arg, ArgAction, ArgGroup, Command};

#[cfg(feature = "error-context")]
use super::utils;

#[test]
fn flag_required() {
    let result = Command::new("flag_required")
        .arg(arg!(-f --flag "some flag").requires("color"))
        .arg(arg!(-c --color "third flag"))
        .try_get_matches_from(vec!["", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn flag_required_2() {
    let m = Command::new("flag_required")
        .arg(
            arg!(-f --flag "some flag")
                .requires("color")
                .action(ArgAction::SetTrue),
        )
        .arg(arg!(-c --color "third flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-f", "-c"])
        .unwrap();
    assert!(*m.get_one::<bool>("color").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn option_required() {
    let result = Command::new("option_required")
        .arg(arg!(f: -f <flag> "some flag").requires("c"))
        .arg(arg!(c: -c <color> "third flag"))
        .try_get_matches_from(vec!["", "-f", "val"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn option_required_2() {
    let m = Command::new("option_required")
        .arg(arg!(f: -f <flag> "some flag").requires("c"))
        .arg(arg!(c: -c <color> "third flag"))
        .try_get_matches_from(vec!["", "-f", "val", "-c", "other_val"])
        .unwrap();
    assert!(m.contains_id("c"));
    assert_eq!(
        m.get_one::<String>("c").map(|v| v.as_str()).unwrap(),
        "other_val"
    );
    assert!(m.contains_id("f"));
    assert_eq!(m.get_one::<String>("f").map(|v| v.as_str()).unwrap(), "val");
}

#[test]
fn positional_required() {
    let result = Command::new("positional_required")
        .arg(Arg::new("flag").index(1).required(true))
        .try_get_matches_from(vec![""]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn positional_required_2() {
    let m = Command::new("positional_required")
        .arg(Arg::new("flag").index(1).required(true))
        .try_get_matches_from(vec!["", "someval"])
        .unwrap();
    assert!(m.contains_id("flag"));
    assert_eq!(
        m.get_one::<String>("flag").map(|v| v.as_str()).unwrap(),
        "someval"
    );
}

#[test]
#[cfg(feature = "error-context")]
fn positional_required_with_requires() {
    static POSITIONAL_REQ: &str = "\
error: the following required arguments were not provided:
  <flag>
  <opt>

Usage: clap-test <flag> <opt> [bar]

For more information, try '--help'.
";

    let cmd = Command::new("positional_required")
        .arg(Arg::new("flag").required(true).requires("opt"))
        .arg(Arg::new("opt"))
        .arg(Arg::new("bar"));

    utils::assert_output(cmd, "clap-test", POSITIONAL_REQ, true);
}

#[test]
#[cfg(feature = "error-context")]
fn positional_required_with_requires_if_no_value() {
    static POSITIONAL_REQ_IF_NO_VAL: &str = "\
error: the following required arguments were not provided:
  <flag>

Usage: clap-test <flag> [opt] [bar]

For more information, try '--help'.
";

    let cmd = Command::new("positional_required")
        .arg(Arg::new("flag").required(true).requires_if("val", "opt"))
        .arg(Arg::new("opt"))
        .arg(Arg::new("bar"));

    utils::assert_output(cmd, "clap-test", POSITIONAL_REQ_IF_NO_VAL, true);
}

#[test]
#[cfg(feature = "error-context")]
fn positional_required_with_requires_if_value() {
    static POSITIONAL_REQ_IF_VAL: &str = "\
error: the following required arguments were not provided:
  <foo>
  <opt>

Usage: clap-test <flag> <foo> <opt> [bar]

For more information, try '--help'.
";

    let cmd = Command::new("positional_required")
        .arg(Arg::new("flag").required(true).requires_if("val", "opt"))
        .arg(Arg::new("foo").required(true))
        .arg(Arg::new("opt"))
        .arg(Arg::new("bar"));

    utils::assert_output(cmd, "clap-test val", POSITIONAL_REQ_IF_VAL, true);
}

#[test]
fn group_required() {
    let result = Command::new("group_required")
        .arg(arg!(-f --flag "some flag"))
        .group(ArgGroup::new("gr").required(true).arg("some").arg("other"))
        .arg(arg!(--some "some arg"))
        .arg(arg!(--other "other arg"))
        .try_get_matches_from(vec!["", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn group_required_2() {
    let m = Command::new("group_required")
        .arg(arg!(-f --flag "some flag").action(ArgAction::SetTrue))
        .group(ArgGroup::new("gr").required(true).arg("some").arg("other"))
        .arg(arg!(--some "some arg").action(ArgAction::SetTrue))
        .arg(arg!(--other "other arg").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-f", "--some"])
        .unwrap();
    assert!(*m.get_one::<bool>("some").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("other").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn group_required_3() {
    let m = Command::new("group_required")
        .arg(arg!(-f --flag "some flag").action(ArgAction::SetTrue))
        .group(ArgGroup::new("gr").required(true).arg("some").arg("other"))
        .arg(arg!(--some "some arg").action(ArgAction::SetTrue))
        .arg(arg!(--other "other arg").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-f", "--other"])
        .unwrap();
    assert!(!*m.get_one::<bool>("some").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("other").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn arg_require_group() {
    let result = Command::new("arg_require_group")
        .arg(arg!(-f --flag "some flag").requires("gr"))
        .group(ArgGroup::new("gr").arg("some").arg("other"))
        .arg(arg!(--some "some arg"))
        .arg(arg!(--other "other arg"))
        .try_get_matches_from(vec!["", "-f"]);
    assert!(result.is_err());
    let err = result.err().unwrap();
    assert_eq!(err.kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn arg_require_group_2() {
    let res = Command::new("arg_require_group")
        .arg(
            arg!(-f --flag "some flag")
                .requires("gr")
                .action(ArgAction::SetTrue),
        )
        .group(ArgGroup::new("gr").arg("some").arg("other"))
        .arg(arg!(--some "some arg").action(ArgAction::SetTrue))
        .arg(arg!(--other "other arg").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-f", "--some"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(*m.get_one::<bool>("some").expect("defaulted by clap"));
    assert!(!*m.get_one::<bool>("other").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn arg_require_group_3() {
    let res = Command::new("arg_require_group")
        .arg(
            arg!(-f --flag "some flag")
                .requires("gr")
                .action(ArgAction::SetTrue),
        )
        .group(ArgGroup::new("gr").arg("some").arg("other"))
        .arg(arg!(--some "some arg").action(ArgAction::SetTrue))
        .arg(arg!(--other "other arg").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["", "-f", "--other"]);
    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(!*m.get_one::<bool>("some").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("other").expect("defaulted by clap"));
    assert!(*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

// REQUIRED_UNLESS

#[test]
fn issue_753() {
    let m = Command::new("test")
        .arg(arg!(
            -l --list "List available interfaces (and stop there)"
        ))
        .arg(
            arg!(
                -i --iface <INTERFACE> "Ethernet interface for fetching NTP packets"
            )
            .required(false)
            .required_unless_present("list"),
        )
        .arg(
            arg!(-f --file <TESTFILE> "Fetch NTP packets from pcap file")
                .conflicts_with("iface")
                .required_unless_present("list"),
        )
        .arg(arg!(-s --server <SERVER_IP> "NTP server IP address").required_unless_present("list"))
        .try_get_matches_from(vec!["test", "--list"]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
}

#[test]
fn required_unless_present() {
    let res = Command::new("unlesstest")
        .arg(
            Arg::new("cfg")
                .required_unless_present("dbg")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("dbg").long("debug").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["unlesstest", "--debug"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(*m.get_one::<bool>("dbg").expect("defaulted by clap"));
    assert!(!m.contains_id("cfg"));
}

#[test]
fn required_unless_present_err() {
    let res = Command::new("unlesstest")
        .arg(
            Arg::new("cfg")
                .required_unless_present("dbg")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("dbg").long("debug"))
        .try_get_matches_from(vec!["unlesstest"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn required_unless_present_with_optional_value() {
    let res = Command::new("unlesstest")
        .arg(Arg::new("opt").long("opt").num_args(0..=1))
        .arg(
            Arg::new("cfg")
                .required_unless_present("dbg")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("dbg").long("debug"))
        .try_get_matches_from(vec!["unlesstest", "--opt"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

// REQUIRED_UNLESS_ALL

#[test]
fn required_unless_present_all() {
    let res = Command::new("unlessall")
        .arg(
            Arg::new("cfg")
                .required_unless_present_all(["dbg", "infile"])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("dbg").long("debug").action(ArgAction::SetTrue))
        .arg(Arg::new("infile").short('i').action(ArgAction::Set))
        .try_get_matches_from(vec!["unlessall", "--debug", "-i", "file"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(*m.get_one::<bool>("dbg").expect("defaulted by clap"));
    assert!(m.contains_id("infile"));
    assert!(!m.contains_id("cfg"));
}

#[test]
fn required_unless_all_err() {
    let res = Command::new("unlessall")
        .arg(
            Arg::new("cfg")
                .required_unless_present_all(["dbg", "infile"])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("dbg").long("debug").action(ArgAction::SetTrue))
        .arg(Arg::new("infile").short('i').action(ArgAction::Set))
        .try_get_matches_from(vec!["unlessall", "--debug"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

// REQUIRED_UNLESS_ONE

#[test]
fn required_unless_present_any() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("cfg")
                .required_unless_present_any(["dbg", "infile"])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("dbg").long("debug").action(ArgAction::SetTrue))
        .arg(Arg::new("infile").short('i').action(ArgAction::Set))
        .try_get_matches_from(vec!["unlessone", "--debug"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(*m.get_one::<bool>("dbg").expect("defaulted by clap"));
    assert!(!m.contains_id("cfg"));
}

#[test]
fn required_unless_any_2() {
    // This tests that the required_unless_present_any works when the second arg in the array is used
    // instead of the first.
    let res = Command::new("unlessone")
        .arg(
            Arg::new("cfg")
                .required_unless_present_any(["dbg", "infile"])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("dbg").long("debug").action(ArgAction::SetTrue))
        .arg(Arg::new("infile").short('i').action(ArgAction::Set))
        .try_get_matches_from(vec!["unlessone", "-i", "file"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(m.contains_id("infile"));
    assert!(!m.contains_id("cfg"));
}

#[test]
fn required_unless_any_works_with_short() {
    // GitHub issue: https://github.com/clap-rs/clap/issues/1135
    let res = Command::new("unlessone")
        .arg(
            Arg::new("a")
                .conflicts_with("b")
                .short('a')
                .action(ArgAction::SetTrue),
        )
        .arg(Arg::new("b").short('b').action(ArgAction::SetTrue))
        .arg(
            Arg::new("x")
                .short('x')
                .action(ArgAction::SetTrue)
                .required_unless_present_any(["a", "b"]),
        )
        .try_get_matches_from(vec!["unlessone", "-a"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_unless_any_works_with_short_err() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("a")
                .conflicts_with("b")
                .short('a')
                .action(ArgAction::SetTrue),
        )
        .arg(Arg::new("b").short('b').action(ArgAction::SetTrue))
        .arg(
            Arg::new("x")
                .short('x')
                .action(ArgAction::SetTrue)
                .required_unless_present_any(["a", "b"]),
        )
        .try_get_matches_from(vec!["unlessone"]);

    assert!(res.is_err());
}

#[test]
fn required_unless_any_works_without() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("a")
                .conflicts_with("b")
                .short('a')
                .action(ArgAction::SetTrue),
        )
        .arg(Arg::new("b").short('b').action(ArgAction::SetTrue))
        .arg(Arg::new("x").required_unless_present_any(["a", "b"]))
        .try_get_matches_from(vec!["unlessone", "-a"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_unless_any_works_with_long() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("a")
                .conflicts_with("b")
                .short('a')
                .action(ArgAction::SetTrue),
        )
        .arg(Arg::new("b").short('b').action(ArgAction::SetTrue))
        .arg(
            Arg::new("x")
                .long("x_is_the_option")
                .action(ArgAction::SetTrue)
                .required_unless_present_any(["a", "b"]),
        )
        .try_get_matches_from(vec!["unlessone", "-a"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_unless_any_1() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("cfg")
                .required_unless_present_any(["dbg", "infile"])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("dbg").long("debug").action(ArgAction::SetTrue))
        .arg(Arg::new("infile").short('i').action(ArgAction::Set))
        .try_get_matches_from(vec!["unlessone", "--debug"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
    let m = res.unwrap();
    assert!(!m.contains_id("infile"));
    assert!(!m.contains_id("cfg"));
    assert!(*m.get_one::<bool>("dbg").expect("defaulted by clap"));
}

#[test]
fn required_unless_any_err() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("cfg")
                .required_unless_present_any(["dbg", "infile"])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("dbg").long("debug").action(ArgAction::SetTrue))
        .arg(Arg::new("infile").short('i').action(ArgAction::Set))
        .try_get_matches_from(vec!["unlessone"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
#[cfg(feature = "error-context")]
fn missing_required_output() {
    static MISSING_REQ: &str = "\
error: the following required arguments were not provided:
  --long-option-2 <option2>
  <positional>
  <positional2>

Usage: clap-test --long-option-2 <option2> -F <positional> <positional2> [positional3]...

For more information, try '--help'.
";

    utils::assert_output(utils::complex_app(), "clap-test -F", MISSING_REQ, true);
}

// Conditional external requirements

#[test]
fn requires_if_present_val() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("cfg")
                .requires_if("my.cfg", "extra")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").long("extra").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["unlessone", "--config=my.cfg"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn requires_if_present_mult() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("cfg")
                .requires_ifs([("my.cfg", "extra"), ("other.cfg", "other")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").long("extra").action(ArgAction::SetTrue))
        .arg(Arg::new("other").long("other").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["unlessone", "--config=other.cfg"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn requires_if_present_mult_pass() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("cfg")
                .requires_ifs([("my.cfg", "extra"), ("other.cfg", "other")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").long("extra").action(ArgAction::SetTrue))
        .arg(Arg::new("other").long("other").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["unlessone", "--config=some.cfg"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn requires_if_present_val_no_present_pass() {
    let res = Command::new("unlessone")
        .arg(
            Arg::new("cfg")
                .requires_if("my.cfg", "extra")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").long("extra").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["unlessone"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

// Conditionally required

#[test]
fn required_if_val_present_pass() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq("extra", "val")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .try_get_matches_from(vec!["ri", "--extra", "val", "--config", "my.cfg"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_if_val_present_fail() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq("extra", "val")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .try_get_matches_from(vec!["ri", "--extra", "val"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn required_if_val_present_ignore_case_pass() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq("extra", "Val")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(
            Arg::new("extra")
                .action(ArgAction::Set)
                .long("extra")
                .ignore_case(true),
        )
        .try_get_matches_from(vec!["ri", "--extra", "vaL", "--config", "my.cfg"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_if_val_present_ignore_case_fail() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq("extra", "Val")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(
            Arg::new("extra")
                .action(ArgAction::Set)
                .long("extra")
                .ignore_case(true),
        )
        .try_get_matches_from(vec!["ri", "--extra", "vaL"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn required_if_all_values_present_pass() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq_all([("extra", "val"), ("option", "spec")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .arg(Arg::new("option").action(ArgAction::Set).long("option"))
        .try_get_matches_from(vec![
            "ri", "--extra", "val", "--option", "spec", "--config", "my.cfg",
        ]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_if_some_values_present_pass() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq_all([("extra", "val"), ("option", "spec")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .arg(Arg::new("option").action(ArgAction::Set).long("option"))
        .try_get_matches_from(vec!["ri", "--extra", "val"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_if_all_values_present_fail() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq_all([("extra", "val"), ("option", "spec")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .arg(Arg::new("option").action(ArgAction::Set).long("option"))
        .try_get_matches_from(vec!["ri", "--extra", "val", "--option", "spec"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn required_if_any_all_values_present_pass() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq_all([("extra", "val"), ("option", "spec")])
                .required_if_eq_any([("extra", "val2"), ("option", "spec2")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .arg(Arg::new("option").action(ArgAction::Set).long("option"))
        .try_get_matches_from(vec![
            "ri", "--extra", "val", "--option", "spec", "--config", "my.cfg",
        ]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_if_any_all_values_present_fail() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq_all([("extra", "val"), ("option", "spec")])
                .required_if_eq_any([("extra", "val2"), ("option", "spec2")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .arg(Arg::new("option").action(ArgAction::Set).long("option"))
        .try_get_matches_from(vec!["ri", "--extra", "val", "--option", "spec"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
#[cfg(feature = "error-context")]
fn list_correct_required_args() {
    static COND_REQ_IN_USAGE: &str = "\
error: the following required arguments were not provided:
  --output <output>

Usage: test --target <target> --input <input> --output <output>

For more information, try '--help'.
";

    let cmd = Command::new("Test cmd")
        .version("1.0")
        .author("F0x06")
        .about("Arg test")
        .arg(
            Arg::new("target")
                .action(ArgAction::Set)
                .required(true)
                .value_parser(["file", "stdout"])
                .long("target"),
        )
        .arg(
            Arg::new("input")
                .action(ArgAction::Set)
                .required(true)
                .long("input"),
        )
        .arg(
            Arg::new("output")
                .action(ArgAction::Set)
                .required(true)
                .long("output"),
        );

    utils::assert_output(
        cmd,
        "test --input somepath --target file",
        COND_REQ_IN_USAGE,
        true,
    );
}

#[test]
#[cfg(feature = "error-context")]
fn required_if_val_present_fail_error_output() {
    static COND_REQ_IN_USAGE: &str = "\
error: the following required arguments were not provided:
  --output <output>

Usage: test --target <target> --input <input> --output <output>

For more information, try '--help'.
";

    let cmd = Command::new("Test cmd")
        .version("1.0")
        .author("F0x06")
        .about("Arg test")
        .arg(
            Arg::new("target")
                .action(ArgAction::Set)
                .required(true)
                .value_parser(["file", "stdout"])
                .long("target"),
        )
        .arg(
            Arg::new("input")
                .action(ArgAction::Set)
                .required(true)
                .long("input"),
        )
        .arg(
            Arg::new("output")
                .action(ArgAction::Set)
                .required_if_eq("target", "file")
                .long("output"),
        );

    utils::assert_output(
        cmd,
        "test --input somepath --target file",
        COND_REQ_IN_USAGE,
        true,
    );
}

#[test]
fn required_if_wrong_val() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq("extra", "val")
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .try_get_matches_from(vec!["ri", "--extra", "other"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_ifs_val_present_pass() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq_any([("extra", "val"), ("option", "spec")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("option").action(ArgAction::Set).long("option"))
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .try_get_matches_from(vec!["ri", "--option", "spec", "--config", "my.cfg"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_ifs_val_present_fail() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq_any([("extra", "val"), ("option", "spec")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .arg(Arg::new("option").action(ArgAction::Set).long("option"))
        .try_get_matches_from(vec!["ri", "--option", "spec"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
fn required_ifs_wrong_val() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq_any([("extra", "val"), ("option", "spec")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .arg(Arg::new("option").action(ArgAction::Set).long("option"))
        .try_get_matches_from(vec!["ri", "--option", "other"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn required_ifs_wrong_val_mult_fail() {
    let res = Command::new("ri")
        .arg(
            Arg::new("cfg")
                .required_if_eq_any([("extra", "val"), ("option", "spec")])
                .action(ArgAction::Set)
                .long("config"),
        )
        .arg(Arg::new("extra").action(ArgAction::Set).long("extra"))
        .arg(Arg::new("option").action(ArgAction::Set).long("option"))
        .try_get_matches_from(vec!["ri", "--extra", "other", "--option", "spec"]);

    assert!(res.is_err());
    assert_eq!(res.unwrap_err().kind(), ErrorKind::MissingRequiredArgument);
}

#[test]
#[cfg(feature = "error-context")]
fn require_eq() {
    static REQUIRE_EQUALS: &str = "\
error: the following required arguments were not provided:
  --opt=<FILE>

Usage: clap-test --opt=<FILE>

For more information, try '--help'.
";

    let cmd = Command::new("clap-test").version("v1.4.8").arg(
        Arg::new("opt")
            .long("opt")
            .short('o')
            .required(true)
            .require_equals(true)
            .value_name("FILE")
            .help("some"),
    );
    utils::assert_output(cmd, "clap-test", REQUIRE_EQUALS, true);
}

#[test]
#[cfg(feature = "error-context")]
fn require_eq_filtered() {
    static REQUIRE_EQUALS_FILTERED: &str = "\
error: the following required arguments were not provided:
  --opt=<FILE>

Usage: clap-test --opt=<FILE> --foo=<FILE>

For more information, try '--help'.
";

    let cmd = Command::new("clap-test")
        .version("v1.4.8")
        .arg(
            Arg::new("opt")
                .long("opt")
                .short('o')
                .required(true)
                .require_equals(true)
                .value_name("FILE")
                .help("some"),
        )
        .arg(
            Arg::new("foo")
                .long("foo")
                .short('f')
                .required(true)
                .require_equals(true)
                .value_name("FILE")
                .help("some other arg"),
        );
    utils::assert_output(cmd, "clap-test -f=blah", REQUIRE_EQUALS_FILTERED, true);
}

#[test]
#[cfg(feature = "error-context")]
fn require_eq_filtered_group() {
    static REQUIRE_EQUALS_FILTERED_GROUP: &str = "\
error: the following required arguments were not provided:
  --opt=<FILE>

Usage: clap-test --opt=<FILE> --foo=<FILE> <--g1=<FILE>|--g2=<FILE>>

For more information, try '--help'.
";

    let cmd = Command::new("clap-test")
        .version("v1.4.8")
        .arg(
            Arg::new("opt")
                .long("opt")
                .short('o')
                .required(true)
                .require_equals(true)
                .value_name("FILE")
                .help("some"),
        )
        .arg(
            Arg::new("foo")
                .long("foo")
                .short('f')
                .required(true)
                .require_equals(true)
                .value_name("FILE")
                .help("some other arg"),
        )
        .arg(
            Arg::new("g1")
                .long("g1")
                .require_equals(true)
                .value_name("FILE"),
        )
        .arg(
            Arg::new("g2")
                .long("g2")
                .require_equals(true)
                .value_name("FILE"),
        )
        .group(
            ArgGroup::new("test_group")
                .args(["g1", "g2"])
                .required(true),
        );
    utils::assert_output(
        cmd,
        "clap-test -f=blah --g1=blah",
        REQUIRE_EQUALS_FILTERED_GROUP,
        true,
    );
}

fn issue_1158_app() -> Command {
    Command::new("example")
        .arg(
            arg!(-c --config <FILE> "Custom config file.")
                .required_unless_present("ID")
                .conflicts_with("ID"),
        )
        .arg(
            arg!([ID] "ID")
                .required_unless_present("config")
                .conflicts_with("config")
                .requires_ifs([
                    (ArgPredicate::IsPresent, "x"),
                    (ArgPredicate::IsPresent, "y"),
                    (ArgPredicate::IsPresent, "z"),
                ]),
        )
        .arg(arg!(x: -x <X> "X"))
        .arg(arg!(y: -y <Y> "Y"))
        .arg(arg!(z: -z <Z> "Z"))
}

#[test]
#[cfg(feature = "error-context")]
fn multiple_required_unless_usage_printing() {
    static MULTIPLE_REQUIRED_UNLESS_USAGE: &str = "\
error: the following required arguments were not provided:
  --a <a>
  --b <b>

Usage: test --c <c> --a <a> --b <b>

For more information, try '--help'.
";
    let cmd = Command::new("test")
        .arg(
            Arg::new("a")
                .long("a")
                .action(ArgAction::Set)
                .required_unless_present("b")
                .conflicts_with("b"),
        )
        .arg(
            Arg::new("b")
                .long("b")
                .action(ArgAction::Set)
                .required_unless_present("a")
                .conflicts_with("a"),
        )
        .arg(
            Arg::new("c")
                .long("c")
                .action(ArgAction::Set)
                .required_unless_present("d")
                .conflicts_with("d"),
        )
        .arg(
            Arg::new("d")
                .long("d")
                .action(ArgAction::Set)
                .required_unless_present("c")
                .conflicts_with("c"),
        );
    utils::assert_output(cmd, "test --c asd", MULTIPLE_REQUIRED_UNLESS_USAGE, true);
}

#[test]
#[cfg(feature = "error-context")]
fn issue_1158_conflicting_requirements() {
    static ISSUE_1158: &str = "\
error: the following required arguments were not provided:
  -x <X>
  -y <Y>
  -z <Z>

Usage: example -x <X> -y <Y> -z <Z> <ID>

For more information, try '--help'.
";

    let cmd = issue_1158_app();

    utils::assert_output(cmd, "example id", ISSUE_1158, true);
}

#[test]
fn issue_1158_conflicting_requirements_rev() {
    let res = issue_1158_app().try_get_matches_from(["", "--config", "some.conf"]);

    assert!(res.is_ok(), "{}", res.unwrap_err());
}

#[test]
fn issue_1643_args_mutually_require_each_other() {
    use clap::*;

    let cmd = Command::new("test")
        .arg(
            Arg::new("relation_id")
                .help("The relation id to get the data from")
                .long("relation-id")
                .short('r')
                .action(ArgAction::Set)
                .requires("remote_unit_name"),
        )
        .arg(
            Arg::new("remote_unit_name")
                .help("The name of the remote unit to get data from")
                .long("remote-unit")
                .short('u')
                .action(ArgAction::Set)
                .requires("relation_id"),
        );

    cmd.try_get_matches_from(["test", "-u", "hello", "-r", "farewell"])
        .unwrap();
}

#[test]
fn short_flag_require_equals_with_minvals_zero() {
    let m = Command::new("foo")
        .arg(
            Arg::new("check")
                .short('c')
                .num_args(0..)
                .require_equals(true),
        )
        .arg(Arg::new("unique").short('u').action(ArgAction::SetTrue))
        .try_get_matches_from(["foo", "-cu"])
        .unwrap();
    assert!(m.contains_id("check"));
    assert!(*m.get_one::<bool>("unique").expect("defaulted by clap"));
}

#[test]
fn issue_2624() {
    let matches = Command::new("foo")
        .arg(
            Arg::new("check")
                .short('c')
                .long("check")
                .require_equals(true)
                .num_args(0..)
                .value_parser(["silent", "quiet", "diagnose-first"]),
        )
        .arg(
            Arg::new("unique")
                .short('u')
                .long("unique")
                .action(ArgAction::SetTrue),
        )
        .try_get_matches_from(["foo", "-cu"])
        .unwrap();
    assert!(matches.contains_id("check"));
    assert!(*matches
        .get_one::<bool>("unique")
        .expect("defaulted by clap"));
}

#[test]
fn required_unless_all_with_any() {
    let cmd = Command::new("prog")
        .arg(Arg::new("foo").long("foo").action(ArgAction::SetTrue))
        .arg(Arg::new("bar").long("bar").action(ArgAction::SetTrue))
        .arg(Arg::new("baz").long("baz").action(ArgAction::SetTrue))
        .arg(
            Arg::new("flag")
                .long("flag")
                .action(ArgAction::SetTrue)
                .required_unless_present_any(["foo"])
                .required_unless_present_all(["bar", "baz"]),
        );

    let result = cmd.clone().try_get_matches_from(vec!["myprog"]);
    assert!(result.is_err(), "{:?}", result.unwrap());

    let result = cmd.clone().try_get_matches_from(vec!["myprog", "--foo"]);
    assert!(result.is_ok(), "{:?}", result.unwrap_err());
    let matches = result.unwrap();
    assert!(!*matches.get_one::<bool>("flag").expect("defaulted by clap"));

    let result = cmd
        .clone()
        .try_get_matches_from(vec!["myprog", "--bar", "--baz"]);
    assert!(result.is_ok(), "{:?}", result.unwrap_err());
    let matches = result.unwrap();
    assert!(!*matches.get_one::<bool>("flag").expect("defaulted by clap"));

    let result = cmd.try_get_matches_from(vec!["myprog", "--bar"]);
    assert!(result.is_err(), "{:?}", result.unwrap());
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command prog: Argument or group 'extra' specified in 'requires*' for 'config' does not exist"]
fn requires_invalid_arg() {
    let _ = Command::new("prog")
        .arg(Arg::new("config").requires("extra").long("config"))
        .try_get_matches_from(vec!["", "--config"]);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command prog: Argument or group 'extra' specified in 'requires*' for 'config' does not exist"]
fn requires_if_invalid_arg() {
    let _ = Command::new("prog")
        .arg(
            Arg::new("config")
                .requires_if("val", "extra")
                .long("config"),
        )
        .try_get_matches_from(vec!["", "--config"]);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command prog: Argument or group 'extra' specified in 'required_if_eq*' for 'config' does not exist"]
fn required_if_invalid_arg() {
    let _ = Command::new("prog")
        .arg(
            Arg::new("config")
                .required_if_eq("extra", "val")
                .long("config"),
        )
        .try_get_matches_from(vec!["", "--config"]);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Command prog: Argument or group 'extra' specified in 'required_unless*' for 'config' does not exist"]
fn required_unless_invalid_arg() {
    let _ = Command::new("prog")
        .arg(
            Arg::new("config")
                .required_unless_present("extra")
                .long("config"),
        )
        .try_get_matches_from(vec![""]);
}

#[test]
fn requires_with_default_value() {
    let result = Command::new("prog")
        .arg(
            Arg::new("opt")
                .long("opt")
                .default_value("default")
                .requires("flag"),
        )
        .arg(Arg::new("flag").long("flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["myprog"]);

    assert!(
        result.is_ok(),
        "requires should ignore default_value: {:?}",
        result.unwrap_err()
    );
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn requires_if_with_default_value() {
    let result = Command::new("prog")
        .arg(
            Arg::new("opt")
                .long("opt")
                .default_value("default")
                .requires_if("default", "flag"),
        )
        .arg(Arg::new("flag").long("flag").action(ArgAction::SetTrue))
        .try_get_matches_from(vec!["myprog"]);

    assert!(
        result.is_ok(),
        "requires_if should ignore default_value: {:?}",
        result.unwrap_err()
    );
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn group_requires_with_default_value() {
    let result = Command::new("prog")
        .arg(Arg::new("opt").long("opt").default_value("default"))
        .arg(Arg::new("flag").long("flag").action(ArgAction::SetTrue))
        .group(ArgGroup::new("one").arg("opt").requires("flag"))
        .try_get_matches_from(vec!["myprog"]);

    assert!(
        result.is_ok(),
        "arg group requires should ignore default_value: {:?}",
        result.unwrap_err()
    );
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn required_if_eq_on_default_value() {
    let result = Command::new("prog")
        .arg(Arg::new("opt").long("opt").default_value("default"))
        .arg(
            Arg::new("flag")
                .long("flag")
                .action(ArgAction::SetTrue)
                .required_if_eq("opt", "default"),
        )
        .try_get_matches_from(vec!["myprog"]);

    assert!(
        result.is_ok(),
        "required_if_eq should ignore default_value: {:?}",
        result.unwrap_err()
    );
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn required_if_eq_all_on_default_value() {
    let result = Command::new("prog")
        .arg(Arg::new("opt").long("opt").default_value("default"))
        .arg(
            Arg::new("flag")
                .long("flag")
                .action(ArgAction::SetTrue)
                .required_if_eq_all([("opt", "default")]),
        )
        .try_get_matches_from(vec!["myprog"]);

    assert!(
        result.is_ok(),
        "required_if_eq_all should ignore default_value: {:?}",
        result.unwrap_err()
    );
    let m = result.unwrap();

    assert_eq!(
        m.get_one::<String>("opt").map(|v| v.as_str()),
        Some("default")
    );
    assert!(!*m.get_one::<bool>("flag").expect("defaulted by clap"));
}

#[test]
fn required_unless_on_default_value() {
    let result = Command::new("prog")
        .arg(Arg::new("opt").long("opt").default_value("default"))
        .arg(Arg::new("flag").long("flag").required_unless_present("opt"))
        .try_get_matches_from(vec!["myprog"]);

    assert!(result.is_err(), "{:?}", result.unwrap());
}

#[test]
fn required_unless_all_on_default_value() {
    let result = Command::new("prog")
        .arg(Arg::new("opt").long("opt").default_value("default"))
        .arg(
            Arg::new("flag")
                .long("flag")
                .required_unless_present_all(["opt"]),
        )
        .try_get_matches_from(vec!["myprog"]);

    assert!(result.is_err(), "{:?}", result.unwrap());
}

#[test]
#[cfg(feature = "error-context")]
fn required_error_doesnt_duplicate() {
    let cmd = Command::new("Clap-created-USAGE-string-bug")
        .arg(Arg::new("a").required(true))
        .arg(
            Arg::new("b")
                .short('b')
                .action(ArgAction::Set)
                .conflicts_with("c"),
        )
        .arg(
            Arg::new("c")
                .short('c')
                .action(ArgAction::Set)
                .conflicts_with("b"),
        );
    const EXPECTED: &str = "\
error: the argument '-b <b>' cannot be used with '-c <c>'

Usage: clap-test -b <b> <a>

For more information, try '--help'.
";
    utils::assert_output(cmd, "clap-test aaa -b bbb -c ccc", EXPECTED, true);
}

#[test]
#[cfg(feature = "error-context")]
fn required_require_with_group_shows_flag() {
    let cmd = Command::new("test")
        .arg(arg!(--"require-first").requires("first"))
        .arg(arg!(--first).group("either_or_both"))
        .arg(arg!(--second).group("either_or_both"))
        .group(
            ArgGroup::new("either_or_both")
                .multiple(true)
                .required(true),
        );
    const EXPECTED: &str = "\
error: the following required arguments were not provided:
  --first

Usage: test --require-first <--first|--second>

For more information, try '--help'.
";
    utils::assert_output(cmd, "test --require-first --second", EXPECTED, true);
}

#[test]
#[should_panic = "Argument flag cannot require itself"]
fn requires_self() {
    let _result = Command::new("flag_required")
        .arg(arg!(-f --flag "some flag").requires("flag"))
        .try_get_matches_from(vec![""]);
}

```

`clap/tests/builder/subcommands.rs`:

```rs
use clap::{arg, error::ErrorKind, Arg, ArgAction, Command};

use super::utils;
use snapbox::assert_data_eq;
use snapbox::str;

#[test]
fn subcommand() {
    let m = Command::new("test")
        .subcommand(Command::new("some").defer(|cmd| {
            cmd.arg(
                Arg::new("test")
                    .short('t')
                    .long("test")
                    .action(ArgAction::Set)
                    .help("testing testing"),
            )
        }))
        .arg(Arg::new("other").long("other"))
        .try_get_matches_from(vec!["myprog", "some", "--test", "testing"])
        .unwrap();

    assert_eq!(m.subcommand_name().unwrap(), "some");
    let sub_m = m.subcommand_matches("some").unwrap();
    assert!(sub_m.contains_id("test"));
    assert_eq!(
        sub_m.get_one::<String>("test").map(|v| v.as_str()).unwrap(),
        "testing"
    );
}

#[test]
fn subcommand_none_given() {
    let m = Command::new("test")
        .subcommand(Command::new("some").defer(|cmd| {
            cmd.arg(
                Arg::new("test")
                    .short('t')
                    .long("test")
                    .action(ArgAction::Set)
                    .help("testing testing"),
            )
        }))
        .arg(Arg::new("other").long("other"))
        .try_get_matches_from(vec![""])
        .unwrap();

    assert!(m.subcommand_name().is_none());
}

#[test]
fn subcommand_multiple() {
    let m = Command::new("test")
        .subcommands(vec![
            Command::new("some").defer(|cmd| {
                cmd.arg(
                    Arg::new("test")
                        .short('t')
                        .long("test")
                        .action(ArgAction::Set)
                        .help("testing testing"),
                )
            }),
            Command::new("add").defer(|cmd| cmd.arg(Arg::new("roster").short('r'))),
        ])
        .arg(Arg::new("other").long("other"))
        .try_get_matches_from(vec!["myprog", "some", "--test", "testing"])
        .unwrap();

    assert!(m.subcommand_matches("some").is_some());
    assert!(m.subcommand_matches("add").is_none());
    assert_eq!(m.subcommand_name().unwrap(), "some");
    let sub_m = m.subcommand_matches("some").unwrap();
    assert!(sub_m.contains_id("test"));
    assert_eq!(
        sub_m.get_one::<String>("test").map(|v| v.as_str()).unwrap(),
        "testing"
    );
}

#[test]
fn single_alias() {
    let m = Command::new("myprog")
        .subcommand(Command::new("test").alias("do-stuff"))
        .try_get_matches_from(vec!["myprog", "do-stuff"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

#[test]
fn multiple_aliases() {
    let m = Command::new("myprog")
        .subcommand(Command::new("test").aliases(["do-stuff", "test-stuff"]))
        .try_get_matches_from(vec!["myprog", "test-stuff"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("test"));
}

#[test]
#[cfg(feature = "suggestions")]
#[cfg(feature = "error-context")]
fn subcmd_did_you_mean_output() {
    #[cfg(feature = "suggestions")]
    static DYM_SUBCMD: &str = "\
error: unrecognized subcommand 'subcm'

  tip: a similar subcommand exists: 'subcmd'

Usage: dym [COMMAND]

For more information, try '--help'.
";

    let cmd = Command::new("dym").subcommand(Command::new("subcmd"));
    utils::assert_output(cmd, "dym subcm", DYM_SUBCMD, true);
}

#[test]
#[cfg(feature = "suggestions")]
#[cfg(feature = "error-context")]
fn subcmd_did_you_mean_output_ambiguous() {
    #[cfg(feature = "suggestions")]
    static DYM_SUBCMD_AMBIGUOUS: &str = "\
error: unrecognized subcommand 'te'

  tip: some similar subcommands exist: 'test', 'temp'

Usage: dym [COMMAND]

For more information, try '--help'.
";

    let cmd = Command::new("dym")
        .subcommand(Command::new("test"))
        .subcommand(Command::new("temp"));
    utils::assert_output(cmd, "dym te", DYM_SUBCMD_AMBIGUOUS, true);
}

#[test]
#[cfg(feature = "suggestions")]
#[cfg(feature = "error-context")]
fn subcmd_did_you_mean_output_arg() {
    static EXPECTED: &str = "\
error: unexpected argument '--subcmarg' found

  tip: 'subcmd --subcmdarg' exists

Usage: dym [COMMAND]

For more information, try '--help'.
";

    let cmd = Command::new("dym").subcommand(
        Command::new("subcmd").defer(|cmd| cmd.arg(arg!(-s --subcmdarg <subcmdarg> "tests"))),
    );

    utils::assert_output(cmd, "dym --subcmarg subcmd", EXPECTED, true);
}

#[test]
#[cfg(feature = "suggestions")]
#[cfg(feature = "error-context")]
fn subcmd_did_you_mean_output_arg_false_positives() {
    static EXPECTED: &str = "\
error: unexpected argument '--subcmarg' found

Usage: dym [COMMAND]

For more information, try '--help'.
";

    let cmd = Command::new("dym").subcommand(
        Command::new("subcmd").defer(|cmd| cmd.arg(arg!(-s --subcmdarg <subcmdarg> "tests"))),
    );

    utils::assert_output(cmd, "dym --subcmarg foo", EXPECTED, true);
}

#[test]
fn alias_help() {
    let m = Command::new("myprog")
        .subcommand(Command::new("test").alias("do-stuff"))
        .try_get_matches_from(vec!["myprog", "help", "do-stuff"]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::DisplayHelp);
}

#[test]
fn visible_aliases_help_output() {
    static VISIBLE_ALIAS_HELP: &str = "\
Usage: clap-test [COMMAND]

Commands:
  test  Some help [aliases: dongle, done]
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
";

    let cmd = Command::new("clap-test").version("2.6").subcommand(
        Command::new("test")
            .about("Some help")
            .alias("invisible")
            .visible_alias("dongle")
            .visible_alias("done"),
    );
    utils::assert_output(cmd, "clap-test --help", VISIBLE_ALIAS_HELP, false);
}

#[test]
fn invisible_aliases_help_output() {
    static INVISIBLE_ALIAS_HELP: &str = "\
Usage: clap-test [COMMAND]

Commands:
  test  Some help
  help  Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
";

    let cmd = Command::new("clap-test")
        .version("2.6")
        .subcommand(Command::new("test").about("Some help").alias("invisible"));
    utils::assert_output(cmd, "clap-test --help", INVISIBLE_ALIAS_HELP, false);
}

#[test]
fn issue_1031_args_with_same_name() {
    let res = Command::new("prog")
        .arg(arg!(--"ui-path" <PATH>).required(true))
        .subcommand(Command::new("signer"))
        .try_get_matches_from(vec!["prog", "--ui-path", "signer"]);

    assert!(res.is_ok(), "{:?}", res.unwrap_err().kind());
    let m = res.unwrap();
    assert_eq!(
        m.get_one::<String>("ui-path").map(|v| v.as_str()),
        Some("signer")
    );
}

#[test]
fn issue_1031_args_with_same_name_no_more_vals() {
    let res = Command::new("prog")
        .arg(arg!(--"ui-path" <PATH>).required(true))
        .subcommand(Command::new("signer"))
        .try_get_matches_from(vec!["prog", "--ui-path", "value", "signer"]);

    assert!(res.is_ok(), "{:?}", res.unwrap_err().kind());
    let m = res.unwrap();
    assert_eq!(
        m.get_one::<String>("ui-path").map(|v| v.as_str()),
        Some("value")
    );
    assert_eq!(m.subcommand_name(), Some("signer"));
}

#[test]
fn issue_1161_multiple_hyphen_hyphen() {
    // from example 22
    let res = Command::new("myprog")
        .arg(Arg::new("eff").short('f'))
        .arg(Arg::new("pea").short('p').action(ArgAction::Set))
        .arg(
            Arg::new("slop")
                .action(ArgAction::Set)
                .num_args(1..)
                .last(true),
        )
        .try_get_matches_from(vec![
            "-f",
            "-p=bob",
            "--",
            "sloppy",
            "slop",
            "-a",
            "--",
            "subprogram",
            "position",
            "args",
        ]);

    assert!(res.is_ok(), "{:?}", res.unwrap_err().kind());
    let m = res.unwrap();

    let expected = Some(vec![
        "sloppy",
        "slop",
        "-a",
        "--",
        "subprogram",
        "position",
        "args",
    ]);
    let actual = m
        .get_many::<String>("slop")
        .map(|vals| vals.map(|s| s.as_str()).collect::<Vec<_>>());

    assert_eq!(expected, actual);
}

#[test]
fn issue_1722_not_emit_error_when_arg_follows_similar_to_a_subcommand() {
    let m = Command::new("myprog")
        .subcommand(Command::new("subcommand"))
        .arg(Arg::new("argument"))
        .try_get_matches_from(vec!["myprog", "--", "subcommand"]);
    assert_eq!(
        m.unwrap().get_one::<String>("argument").map(|v| v.as_str()),
        Some("subcommand")
    );
}

#[test]
fn subcommand_placeholder_test() {
    let mut cmd = Command::new("myprog")
        .subcommand(Command::new("subcommand"))
        .subcommand_value_name("TEST_PLACEHOLDER")
        .subcommand_help_heading("TEST_HEADER");

    assert_eq!(
        &cmd.render_usage().to_string(),
        "Usage: myprog [TEST_PLACEHOLDER]"
    );

    let help_text = cmd.render_help().to_string();

    assert!(help_text.contains("TEST_HEADER:"));
}

#[test]
#[cfg(feature = "error-context")]
fn subcommand_used_after_double_dash() {
    static SUBCMD_AFTER_DOUBLE_DASH: &str = "\
error: unexpected argument 'subcmd' found

  tip: subcommand 'subcmd' exists; to use it, remove the '--' before it

Usage: cmd [COMMAND]

For more information, try '--help'.
";

    let cmd = Command::new("cmd").subcommand(Command::new("subcmd"));

    utils::assert_output(cmd, "cmd -- subcmd", SUBCMD_AFTER_DOUBLE_DASH, true);
}

#[test]
fn subcommand_after_argument() {
    let m = Command::new("myprog")
        .arg(Arg::new("some_text"))
        .subcommand(Command::new("test"))
        .try_get_matches_from(vec!["myprog", "teat", "test"])
        .unwrap();
    assert_eq!(
        m.get_one::<String>("some_text").map(|v| v.as_str()),
        Some("teat")
    );
    assert_eq!(m.subcommand().unwrap().0, "test");
}

#[test]
fn subcommand_after_argument_looks_like_help() {
    let m = Command::new("myprog")
        .arg(Arg::new("some_text"))
        .subcommand(Command::new("test"))
        .try_get_matches_from(vec!["myprog", "helt", "test"])
        .unwrap();
    assert_eq!(
        m.get_one::<String>("some_text").map(|v| v.as_str()),
        Some("helt")
    );
    assert_eq!(m.subcommand().unwrap().0, "test");
}

#[test]
fn issue_2494_subcommand_is_present() {
    let cmd = Command::new("opt")
        .arg(Arg::new("global").long("global").action(ArgAction::SetTrue))
        .subcommand(Command::new("global"));

    let m = cmd
        .clone()
        .try_get_matches_from(["opt", "--global", "global"])
        .unwrap();
    assert_eq!(m.subcommand_name().unwrap(), "global");
    assert!(*m.get_one::<bool>("global").expect("defaulted by clap"));

    let m = cmd
        .clone()
        .try_get_matches_from(["opt", "--global"])
        .unwrap();
    assert!(m.subcommand_name().is_none());
    assert!(*m.get_one::<bool>("global").expect("defaulted by clap"));

    let m = cmd.try_get_matches_from(["opt", "global"]).unwrap();
    assert_eq!(m.subcommand_name().unwrap(), "global");
    assert!(!*m.get_one::<bool>("global").expect("defaulted by clap"));
}

#[test]
#[cfg(feature = "error-context")]
fn subcommand_not_recognized() {
    let cmd = Command::new("fake")
        .subcommand(Command::new("sub"))
        .disable_help_subcommand(true)
        .infer_subcommands(true);
    utils::assert_output(
        cmd,
        "fake help",
        "error: unrecognized subcommand 'help'

Usage: fake [COMMAND]

For more information, try '--help'.
",
        true,
    );
}

#[test]
fn busybox_like_multicall() {
    fn applet_commands() -> [Command; 2] {
        [Command::new("true"), Command::new("false")]
    }
    let cmd = Command::new("busybox")
        .multicall(true)
        .subcommand(Command::new("busybox").defer(|cmd| cmd.subcommands(applet_commands())))
        .subcommands(applet_commands());

    let m = cmd
        .clone()
        .try_get_matches_from(["busybox", "true"])
        .unwrap();
    assert_eq!(m.subcommand_name(), Some("busybox"));
    assert_eq!(m.subcommand().unwrap().1.subcommand_name(), Some("true"));

    let m = cmd.clone().try_get_matches_from(["true"]).unwrap();
    assert_eq!(m.subcommand_name(), Some("true"));

    let m = cmd.clone().try_get_matches_from(["a.out"]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidSubcommand);
}

#[test]
fn hostname_like_multicall() {
    let mut cmd = Command::new("hostname")
        .multicall(true)
        .subcommand(Command::new("hostname"))
        .subcommand(Command::new("dnsdomainname"));

    let m = cmd.clone().try_get_matches_from(["hostname"]).unwrap();
    assert_eq!(m.subcommand_name(), Some("hostname"));

    let m = cmd.clone().try_get_matches_from(["dnsdomainname"]).unwrap();
    assert_eq!(m.subcommand_name(), Some("dnsdomainname"));

    let m = cmd.clone().try_get_matches_from(["a.out"]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidSubcommand);

    let m = cmd.try_get_matches_from_mut(["hostname", "hostname"]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::UnknownArgument);

    let m = cmd.try_get_matches_from(["hostname", "dnsdomainname"]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[test]
#[cfg(feature = "error-context")]
fn bad_multicall_command_error() {
    let cmd = Command::new("repl")
        .version("1.0.0")
        .propagate_version(true)
        .multicall(true)
        .subcommand(Command::new("foo"))
        .subcommand(Command::new("bar"));

    let err = cmd.clone().try_get_matches_from(["world"]).unwrap_err();
    assert_eq!(err.kind(), ErrorKind::InvalidSubcommand);
    assert_data_eq!(
        err.to_string(),
        str![[r#"
error: unrecognized subcommand 'world'

Usage: <COMMAND>

For more information, try 'help'.

"#]]
    );

    #[cfg(feature = "suggestions")]
    {
        let err = cmd.clone().try_get_matches_from(["baz"]).unwrap_err();
        utils::assert_error(err, ErrorKind::InvalidSubcommand, str![[r#"
error: unrecognized subcommand 'baz'

  tip: a similar subcommand exists: 'bar'

Usage: <COMMAND>

For more information, try 'help'.

"#]], true);
    }

    // Verify whatever we did to get the above to work didn't disable `--help` and `--version`.

    let err = cmd
        .clone()
        .try_get_matches_from(["foo", "--help"])
        .unwrap_err();
    assert_eq!(err.kind(), ErrorKind::DisplayHelp);

    let err = cmd
        .clone()
        .try_get_matches_from(["foo", "--version"])
        .unwrap_err();
    assert_eq!(err.kind(), ErrorKind::DisplayVersion);
}

#[test]
#[should_panic = "Command repl: Arguments like oh-no cannot be set on a multicall command"]
fn cant_have_args_with_multicall() {
    let mut cmd = Command::new("repl")
        .version("1.0.0")
        .propagate_version(true)
        .multicall(true)
        .subcommand(Command::new("foo"))
        .subcommand(Command::new("bar"))
        .arg(Arg::new("oh-no"));
    cmd.build();
}

#[test]
fn multicall_help_flag() {
    static EXPECTED: &str = "\
Usage: foo bar [value]

Arguments:
  [value]  

Options:
  -h, --help     Print help
  -V, --version  Print version
";
    let cmd = Command::new("repl")
        .version("1.0.0")
        .propagate_version(true)
        .multicall(true)
        .subcommand(Command::new("foo").defer(|cmd| {
            cmd.subcommand(Command::new("bar").defer(|cmd| cmd.arg(Arg::new("value"))))
        }));
    utils::assert_output(cmd, "foo bar --help", EXPECTED, false);
}

#[test]
fn multicall_help_subcommand() {
    static EXPECTED: &str = "\
Usage: foo bar [value]

Arguments:
  [value]  

Options:
  -h, --help     Print help
  -V, --version  Print version
";
    let cmd = Command::new("repl")
        .version("1.0.0")
        .propagate_version(true)
        .multicall(true)
        .subcommand(
            Command::new("foo")
                .defer(|cmd| cmd.subcommand(Command::new("bar").arg(Arg::new("value")))),
        );
    utils::assert_output(cmd, "help foo bar", EXPECTED, false);
}

#[test]
fn multicall_render_help() {
    let mut cmd = Command::new("repl")
        .version("1.0.0")
        .propagate_version(true)
        .multicall(true)
        .subcommand(
            Command::new("foo")
                .defer(|cmd| cmd.subcommand(Command::new("bar").arg(Arg::new("value")))),
        );
    cmd.build();
    let subcmd = cmd.find_subcommand_mut("foo").unwrap();
    let subcmd = subcmd.find_subcommand_mut("bar").unwrap();

    let help = subcmd.render_help().to_string();
    assert_data_eq!(
        help,
        str![[r#"
Usage: foo bar [value]

Arguments:
  [value]  

Options:
  -h, --help     Print help
  -V, --version  Print version

"#]]
    );
}

#[test]
#[should_panic = "Command test: command name `repeat` is duplicated"]
fn duplicate_subcommand() {
    Command::new("test")
        .subcommand(Command::new("repeat"))
        .subcommand(Command::new("repeat"))
        .build();
}

#[test]
#[should_panic = "Command test: command `unique` alias `repeat` is duplicated"]
fn duplicate_subcommand_alias() {
    Command::new("test")
        .subcommand(Command::new("repeat"))
        .subcommand(Command::new("unique").alias("repeat"))
        .build();
}

```

`clap/tests/builder/template_help.rs`:

```rs
use super::utils;

use clap::{arg, Command};

#[cfg(not(feature = "unstable-v5"))]
static EXAMPLE1_TMPL_S: &str = "{bin} {version}
{author}
{about}

Usage: {usage}

{all-args}";

#[cfg(feature = "unstable-v5")]
static EXAMPLE1_TMPL_S: &str = "{name} {version}
{author}
{about}

Usage: {usage}

{all-args}";

#[cfg(not(feature = "unstable-v5"))]
static EXAMPLE1_TMPS_F: &str = "{bin} {version}
{author}
{about}

Usage: {usage}

Options:
{options}
Arguments:
{positionals}
Commands:
{subcommands}";

#[cfg(feature = "unstable-v5")]
static EXAMPLE1_TMPS_F: &str = "{name} {version}
{author}
{about}

Usage: {usage}

Options:
{options}
Arguments:
{positionals}
Commands:
{subcommands}";

static CUSTOM_TEMPL_HELP: &str = "MyApp 1.0
Kevin K. <kbknapp@gmail.com>
Does awesome things

Usage: MyApp [OPTIONS] <output> [COMMAND]

Options:
  -c, --config <FILE>  Sets a custom config file
  -d...                Turn debugging information on
  -h, --help           Print help
  -V, --version        Print version
Arguments:
  <output>  Sets an optional output file
Commands:
  test  does testing things
  help  Print this message or the help of the given subcommand(s)
";

static SIMPLE_TEMPLATE: &str = "MyApp 1.0
Kevin K. <kbknapp@gmail.com>
Does awesome things

Usage: MyApp [OPTIONS] <output> [COMMAND]

Commands:
  test  does testing things
  help  Print this message or the help of the given subcommand(s)

Arguments:
  <output>  Sets an optional output file

Options:
  -c, --config <FILE>  Sets a custom config file
  -d...                Turn debugging information on
  -h, --help           Print help
  -V, --version        Print version
";

#[test]
fn with_template() {
    let cmd = get_app().help_template(EXAMPLE1_TMPL_S);
    utils::assert_output(cmd, "MyApp --help", SIMPLE_TEMPLATE, false);
}

#[test]
fn custom_template() {
    let cmd = get_app().help_template(EXAMPLE1_TMPS_F);
    utils::assert_output(cmd, "MyApp --help", CUSTOM_TEMPL_HELP, false);
}

#[test]
fn template_empty() {
    let cmd = Command::new("MyApp")
        .version("1.0")
        .author("Kevin K. <kbknapp@gmail.com>")
        .about("Does awesome things")
        .help_template("");
    utils::assert_output(cmd, "MyApp --help", "\n", false);
}

#[test]
fn template_notag() {
    let cmd = Command::new("MyApp")
        .version("1.0")
        .author("Kevin K. <kbknapp@gmail.com>")
        .about("Does awesome things")
        .help_template("test no tag test");
    utils::assert_output(cmd, "MyApp --help", "test no tag test\n", false);
}

#[test]
fn template_unknowntag() {
    let cmd = Command::new("MyApp")
        .version("1.0")
        .author("Kevin K. <kbknapp@gmail.com>")
        .about("Does awesome things")
        .help_template("test {unknown_tag} test");
    utils::assert_output(cmd, "MyApp --help", "test {unknown_tag} test\n", false);
}

#[test]
fn template_author_version() {
    #[cfg(not(feature = "unstable-v5"))]
    let cmd = Command::new("MyApp")
        .version("1.0")
        .author("Kevin K. <kbknapp@gmail.com>")
        .about("Does awesome things")
        .help_template("{author}\n{version}\n{about}\n{bin}");

    #[cfg(feature = "unstable-v5")]
    let cmd = Command::new("MyApp")
        .version("1.0")
        .author("Kevin K. <kbknapp@gmail.com>")
        .about("Does awesome things")
        .help_template("{author}\n{version}\n{about}\n{name}");

    utils::assert_output(
        cmd,
        "MyApp --help",
        "Kevin K. <kbknapp@gmail.com>\n1.0\nDoes awesome things\nMyApp\n",
        false,
    );
}

// ----------

fn get_app() -> Command {
    Command::new("MyApp")
        .version("1.0")
        .author("Kevin K. <kbknapp@gmail.com>")
        .about("Does awesome things")
        .arg(
            arg!(
                -c --config <FILE> "Sets a custom config file"
            )
            .required(false),
        )
        .arg(arg!(
            <output>            "Sets an optional output file"
        ))
        .arg(arg!(
            d: -d ...           "Turn debugging information on"
        ))
        .subcommand(
            Command::new("test")
                .about("does testing things")
                .arg(arg!(-l --list "lists test values")),
        )
}

```

`clap/tests/builder/tests.rs`:

```rs
use super::utils;

use std::io::Write;
use std::str;

use clap::{Arg, Command};
use snapbox::assert_data_eq;

static SCF2OP: &str = "flag present 2 times
option NOT present
positional NOT present
flag2 NOT present
option2 maybe present with value of: Nothing
positional2 maybe present with value of: Nothing
option3 NOT present
positional3 NOT present
option NOT present
positional NOT present
subcmd present
flag present 2 times
scoption present with value: some
An scoption: some
scpositional present with value: value
";

static SCFOP: &str = "flag present 1 times
option NOT present
positional NOT present
flag2 NOT present
option2 maybe present with value of: Nothing
positional2 maybe present with value of: Nothing
option3 NOT present
positional3 NOT present
option NOT present
positional NOT present
subcmd present
flag present 1 times
scoption present with value: some
An scoption: some
scpositional present with value: value
";

static O2P: &str = "flag NOT present
option present with value: some
An option: some
An option: other
positional present with value: value
flag2 NOT present
option2 maybe present with value of: Nothing
positional2 maybe present with value of: Nothing
option3 NOT present
positional3 NOT present
option present with value: some
An option: some
An option: other
positional present with value: value
subcmd NOT present
";

static F2OP: &str = "flag present 2 times
option present with value: some
An option: some
positional present with value: value
flag2 NOT present
option2 maybe present with value of: Nothing
positional2 maybe present with value of: Nothing
option3 NOT present
positional3 NOT present
option present with value: some
An option: some
positional present with value: value
subcmd NOT present
";

static FOP: &str = "flag present 1 times
option present with value: some
An option: some
positional present with value: value
flag2 NOT present
option2 maybe present with value of: Nothing
positional2 maybe present with value of: Nothing
option3 NOT present
positional3 NOT present
option present with value: some
An option: some
positional present with value: value
subcmd NOT present
";

pub(crate) fn check_complex_output(args: &str, out: impl snapbox::data::IntoData) {
    let mut w = vec![];
    let matches = utils::complex_app()
        .try_get_matches_from(args.split(' ').collect::<Vec<_>>())
        .unwrap();
    match matches.get_one::<u8>("flag").unwrap() {
        0 => {
            writeln!(w, "flag NOT present").unwrap();
        }
        n => {
            writeln!(w, "flag present {n} times").unwrap();
        }
    }

    if matches.contains_id("option") {
        if let Some(v) = matches.get_one::<String>("option").map(|v| v.as_str()) {
            writeln!(w, "option present with value: {v}").unwrap();
        }
        if let Some(ov) = matches.get_many::<String>("option") {
            for o in ov {
                writeln!(w, "An option: {o}").unwrap();
            }
        }
    } else {
        writeln!(w, "option NOT present").unwrap();
    }

    if let Some(p) = matches.get_one::<String>("positional").map(|v| v.as_str()) {
        writeln!(w, "positional present with value: {p}").unwrap();
    } else {
        writeln!(w, "positional NOT present").unwrap();
    }

    if *matches.get_one::<bool>("flag2").expect("defaulted by clap") {
        writeln!(w, "flag2 present").unwrap();
        writeln!(
            w,
            "option2 present with value of: {}",
            matches
                .get_one::<String>("long-option-2")
                .map(|v| v.as_str())
                .unwrap()
        )
        .unwrap();
        writeln!(
            w,
            "positional2 present with value of: {}",
            matches
                .get_one::<String>("positional2")
                .map(|v| v.as_str())
                .unwrap()
        )
        .unwrap();
    } else {
        writeln!(w, "flag2 NOT present").unwrap();
        writeln!(
            w,
            "option2 maybe present with value of: {}",
            matches
                .get_one::<String>("long-option-2")
                .map(|v| v.as_str())
                .unwrap_or("Nothing")
        )
        .unwrap();
        writeln!(
            w,
            "positional2 maybe present with value of: {}",
            matches
                .get_one::<String>("positional2")
                .map(|v| v.as_str())
                .unwrap_or("Nothing")
        )
        .unwrap();
    }

    let _ = match matches
        .get_one::<String>("option3")
        .map(|v| v.as_str())
        .unwrap_or("")
    {
        "fast" => writeln!(w, "option3 present quickly"),
        "slow" => writeln!(w, "option3 present slowly"),
        _ => writeln!(w, "option3 NOT present"),
    };

    let _ = match matches
        .get_one::<String>("positional3")
        .map(|v| v.as_str())
        .unwrap_or("")
    {
        "vi" => writeln!(w, "positional3 present in vi mode"),
        "emacs" => writeln!(w, "positional3 present in emacs mode"),
        _ => writeln!(w, "positional3 NOT present"),
    };

    if matches.contains_id("option") {
        if let Some(v) = matches.get_one::<String>("option").map(|v| v.as_str()) {
            writeln!(w, "option present with value: {v}").unwrap();
        }
        if let Some(ov) = matches.get_many::<String>("option") {
            for o in ov {
                writeln!(w, "An option: {o}").unwrap();
            }
        }
    } else {
        writeln!(w, "option NOT present").unwrap();
    }

    if let Some(p) = matches.get_one::<String>("positional").map(|v| v.as_str()) {
        writeln!(w, "positional present with value: {p}").unwrap();
    } else {
        writeln!(w, "positional NOT present").unwrap();
    }
    if let Some("subcmd") = matches.subcommand_name() {
        writeln!(w, "subcmd present").unwrap();
        if let Some(matches) = matches.subcommand_matches("subcmd") {
            match matches.get_one::<u8>("flag").unwrap() {
                0 => {
                    writeln!(w, "flag NOT present").unwrap();
                }
                n => {
                    writeln!(w, "flag present {n} times").unwrap();
                }
            }

            if matches.contains_id("option") {
                if let Some(v) = matches.get_one::<String>("option").map(|v| v.as_str()) {
                    writeln!(w, "scoption present with value: {v}").unwrap();
                }
                if let Some(ov) = matches.get_many::<String>("option") {
                    for o in ov {
                        writeln!(w, "An scoption: {o}").unwrap();
                    }
                }
            } else {
                writeln!(w, "scoption NOT present").unwrap();
            }

            if let Some(p) = matches
                .get_one::<String>("scpositional")
                .map(|v| v.as_str())
            {
                writeln!(w, "scpositional present with value: {p}").unwrap();
            }
        }
    } else {
        writeln!(w, "subcmd NOT present").unwrap();
    }

    let res = str::from_utf8(&w).unwrap();
    assert_data_eq!(res, out);
}

#[test]
fn create_app() {
    let _ = Command::new("test")
        .version("1.0")
        .author("kevin")
        .about("does awesome things")
        .try_get_matches_from(vec![""])
        .unwrap();
}

#[test]
fn add_multiple_arg() {
    let _ = Command::new("test")
        .args([Arg::new("test").short('s'), Arg::new("test2").short('l')])
        .try_get_matches_from(vec![""])
        .unwrap();
}
#[test]
fn flag_x2_opt() {
    check_complex_output(
        "clap-test value -f -f -o some",
        "flag present 2 times
option present with value: some
An option: some
positional present with value: value
flag2 NOT present
option2 maybe present with value of: Nothing
positional2 maybe present with value of: Nothing
option3 NOT present
positional3 NOT present
option present with value: some
An option: some
positional present with value: value
subcmd NOT present
",
    );
}

#[test]
fn long_opt_x2_pos() {
    check_complex_output("clap-test value --option some --option other", O2P);
}

#[test]
fn long_opt_eq_x2_pos() {
    check_complex_output("clap-test value --option=some --option=other", O2P);
}

#[test]
fn short_opt_x2_pos() {
    check_complex_output("clap-test value -o some -o other", O2P);
}

#[test]
fn short_opt_eq_x2_pos() {
    check_complex_output("clap-test value -o=some -o=other", O2P);
}

#[test]
fn short_flag_x2_comb_short_opt_pos() {
    check_complex_output("clap-test value -ff -o some", F2OP);
}

#[test]
fn short_flag_short_opt_pos() {
    check_complex_output("clap-test value -f -o some", FOP);
}

#[test]
fn long_flag_long_opt_pos() {
    check_complex_output("clap-test value --flag --option some", FOP);
}

#[test]
fn long_flag_long_opt_eq_pos() {
    check_complex_output("clap-test value --flag --option=some", FOP);
}

#[test]
fn sc_long_flag_long_opt() {
    check_complex_output("clap-test subcmd value --flag --option some", SCFOP);
}

#[test]
fn sc_long_flag_short_opt_pos() {
    check_complex_output("clap-test subcmd value --flag -o some", SCFOP);
}

#[test]
fn sc_long_flag_long_opt_eq_pos() {
    check_complex_output("clap-test subcmd value --flag --option=some", SCFOP);
}

#[test]
fn sc_short_flag_long_opt_pos() {
    check_complex_output("clap-test subcmd value -f --option some", SCFOP);
}

#[test]
fn sc_short_flag_short_opt_pos() {
    check_complex_output("clap-test subcmd value -f -o some", SCFOP);
}

#[test]
fn sc_short_flag_short_opt_eq_pos() {
    check_complex_output("clap-test subcmd value -f -o=some", SCFOP);
}

#[test]
fn sc_short_flag_long_opt_eq_pos() {
    check_complex_output("clap-test subcmd value -f --option=some", SCFOP);
}

#[test]
fn sc_short_flag_x2_comb_long_opt_pos() {
    check_complex_output("clap-test subcmd value -ff --option some", SCF2OP);
}

#[test]
fn sc_short_flag_x2_comb_short_opt_pos() {
    check_complex_output("clap-test subcmd value -ff -o some", SCF2OP);
}

#[test]
fn sc_short_flag_x2_comb_long_opt_eq_pos() {
    check_complex_output("clap-test subcmd value -ff --option=some", SCF2OP);
}

#[test]
fn sc_short_flag_x2_comb_short_opt_eq_pos() {
    check_complex_output("clap-test subcmd value -ff -o=some", SCF2OP);
}

#[test]
fn sc_long_flag_x2_long_opt_pos() {
    check_complex_output("clap-test subcmd value --flag --flag --option some", SCF2OP);
}

#[test]
fn sc_long_flag_x2_short_opt_pos() {
    check_complex_output("clap-test subcmd value --flag --flag -o some", SCF2OP);
}

#[test]
fn sc_long_flag_x2_short_opt_eq_pos() {
    check_complex_output("clap-test subcmd value --flag --flag -o=some", SCF2OP);
}

#[test]
fn sc_long_flag_x2_long_opt_eq_pos() {
    check_complex_output("clap-test subcmd value --flag --flag --option=some", SCF2OP);
}

#[test]
fn sc_short_flag_x2_long_opt_pos() {
    check_complex_output("clap-test subcmd value -f -f --option some", SCF2OP);
}

#[test]
fn sc_short_flag_x2_short_opt_pos() {
    check_complex_output("clap-test subcmd value -f -f -o some", SCF2OP);
}

#[test]
fn sc_short_flag_x2_short_opt_eq_pos() {
    check_complex_output("clap-test subcmd value -f -f -o=some", SCF2OP);
}

#[test]
fn sc_short_flag_x2_long_opt_eq_pos() {
    check_complex_output("clap-test subcmd value -f -f --option=some", SCF2OP);
}

#[test]
fn mut_arg_all() {
    let mut cmd = utils::complex_app();
    let arg_names = cmd
        .get_arguments()
        .map(|a| a.get_id().clone())
        .filter(|a| a != "version" && a != "help")
        .collect::<Vec<_>>();

    for arg_name in arg_names {
        cmd = cmd.mut_arg(arg_name, |arg| arg.hide_possible_values(true));
    }
}

#[test]
fn mut_subcommand_all() {
    let cmd = utils::complex_app();

    assert_eq!(
        cmd.find_subcommand("subcmd")
            .unwrap()
            .is_disable_version_flag_set(),
        false
    );
    let cmd = cmd.mut_subcommand("subcmd", |subcmd| subcmd.disable_version_flag(true));
    assert_eq!(
        cmd.find_subcommand("subcmd")
            .unwrap()
            .is_disable_version_flag_set(),
        true
    );
}

#[test]
fn mut_subcommand_with_alias_resolve() {
    let mut cmd =
        Command::new("foo").subcommand(Command::new("bar").alias("baz").about("test subcmd"));
    assert_eq!(
        cmd.find_subcommand("baz")
            .unwrap()
            .get_about()
            .unwrap()
            .to_string(),
        "test subcmd"
    );

    let true_name = cmd.find_subcommand("baz").unwrap().get_name().to_string();
    assert_eq!(true_name, "bar");

    cmd = cmd.mut_subcommand(&*true_name, |subcmd| subcmd.about("modified about"));
    assert_eq!(
        cmd.find_subcommand("baz")
            .unwrap()
            .get_about()
            .unwrap()
            .to_string(),
        "modified about"
    );
}

#[test]
fn issue_3669_command_build_recurses() {
    let mut cmd = Command::new("ctest").subcommand(
        Command::new("subcmd").subcommand(
            Command::new("multi")
                .about("tests subcommands")
                .author("Kevin K. <kbknapp@gmail.com>")
                .version("0.1")
                .arg(clap::arg!(
                    <FLAG>                    "tests flags"
                )),
        ),
    );
    cmd.build();
}

```

`clap/tests/builder/unicode.rs`:

```rs
#![cfg(feature = "unicode")]

#[test]
fn possible_values_ignore_case() {
    let m = clap::Command::new("pv")
        .arg(
            clap::Arg::new("option")
                .short('o')
                .long("option")
                .action(clap::ArgAction::Set)
                .value_parser(["ä"])
                .ignore_case(true),
        )
        .try_get_matches_from(vec!["pv", "--option", "Ä"]);

    assert!(m.is_ok(), "{}", m.unwrap_err());
    assert!(m
        .unwrap()
        .get_one::<String>("option")
        .map(|v| v.as_str())
        .is_some());
}

```

`clap/tests/builder/unique_args.rs`:

```rs
#[cfg(debug_assertions)]
#[test]
#[should_panic = "Argument names must be unique, but 'arg1' is in use by more than one argument or group"]
fn unique_arg_names() {
    use clap::{Arg, Command};

    let _ = Command::new("some")
        .args([Arg::new("arg1").short('a'), Arg::new("arg1").short('b')])
        .try_get_matches();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Short option names must be unique for each argument, but '-a' is in use by both 'arg1' and 'arg2'"]
fn unique_arg_shorts() {
    use clap::{Arg, Command};

    let _ = Command::new("some")
        .args([Arg::new("arg1").short('a'), Arg::new("arg2").short('a')])
        .try_get_matches();
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "Long option names must be unique for each argument, but '--long' is in use by both 'arg1' and 'arg2'"]
fn unique_arg_longs() {
    use clap::{Arg, Command};

    let _ = Command::new("some")
        .args([Arg::new("arg1").long("long"), Arg::new("arg2").long("long")])
        .try_get_matches();
}

```

`clap/tests/builder/utf16.rs`:

```rs
//! These Windows-only tests are ported from the Unix-only tests in
//! tests/utf16.rs. The tests that use StrictUtf8 mode are omitted here,
//! because that's a Unix-only feature.

#![cfg(windows)]

use clap::{arg, value_parser, Command};
use std::ffi::OsString;
use std::os::windows::ffi::OsStringExt;

// Take a slice of ASCII bytes, convert them to UTF-16, and then append a
// dangling surrogate character to make the result invalid UTF-16.
fn bad_osstring(ascii: &[u8]) -> OsString {
    let mut wide_chars: Vec<u16> = ascii.iter().map(|&c| c as u16).collect();
    // UTF-16 surrogate characters are only valid in pairs.
    let surrogate_char: u16 = 0xDC00;
    wide_chars.push(surrogate_char);
    let os = OsString::from_wide(&wide_chars);
    assert!(os.to_str().is_none(), "invalid Unicode");
    os
}

#[test]
fn invalid_utf16_positional() {
    let r = Command::new("bad_utf16")
        .arg(arg!(<arg> "some arg").value_parser(value_parser!(OsString)))
        .try_get_matches_from(vec![OsString::from(""), bad_osstring(b"")]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(&*m.get_one::<OsString>("arg").unwrap(), &*bad_osstring(b""));
}

#[test]
fn invalid_utf16_option_short_space() {
    let r = Command::new("bad_utf16")
        .arg(arg!(-a --arg <arg> "some arg").value_parser(value_parser!(OsString)))
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from("-a"),
            bad_osstring(b""),
        ]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(&*m.get_one::<OsString>("arg").unwrap(), &*bad_osstring(b""));
}

#[test]
fn invalid_utf16_option_short_equals() {
    let r = Command::new("bad_utf16")
        .arg(arg!(-a --arg <arg> "some arg").value_parser(value_parser!(OsString)))
        .try_get_matches_from(vec![OsString::from(""), bad_osstring(b"-a=")]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(&*m.get_one::<OsString>("arg").unwrap(), &*bad_osstring(b""));
}

#[test]
fn invalid_utf16_option_short_no_space() {
    let r = Command::new("bad_utf16")
        .arg(arg!(-a --arg <arg> "some arg").value_parser(value_parser!(OsString)))
        .try_get_matches_from(vec![OsString::from(""), bad_osstring(b"-a")]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(&*m.get_one::<OsString>("arg").unwrap(), &*bad_osstring(b""));
}

#[test]
fn invalid_utf16_option_long_space() {
    let r = Command::new("bad_utf16")
        .arg(arg!(-a --arg <arg> "some arg").value_parser(value_parser!(OsString)))
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from("--arg"),
            bad_osstring(b""),
        ]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(&*m.get_one::<OsString>("arg").unwrap(), &*bad_osstring(b""));
}

#[test]
fn invalid_utf16_option_long_equals() {
    let r = Command::new("bad_utf16")
        .arg(arg!(-a --arg <arg> "some arg").value_parser(value_parser!(OsString)))
        .try_get_matches_from(vec![OsString::from(""), bad_osstring(b"--arg=")]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(&*m.get_one::<OsString>("arg").unwrap(), &*bad_osstring(b""));
}

```

`clap/tests/builder/utf8.rs`:

```rs
#![cfg(not(windows))]

use clap::{arg, error::ErrorKind, value_parser, Arg, ArgAction, Command};
use std::ffi::OsString;
use std::os::unix::ffi::OsStringExt;

#[test]
fn invalid_utf8_strict_positional() {
    let m = Command::new("bad_utf8")
        .arg(Arg::new("arg"))
        .try_get_matches_from(vec![OsString::from(""), OsString::from_vec(vec![0xe9])]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_short_space() {
    let m = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from("-a"),
            OsString::from_vec(vec![0xe9]),
        ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_short_equals() {
    let m = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from_vec(vec![0x2d, 0x61, 0x3d, 0xe9]),
        ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_short_no_space() {
    let m = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from_vec(vec![0x2d, 0x61, 0xe9]),
        ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_long_space() {
    let m = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from("--arg"),
            OsString::from_vec(vec![0xe9]),
        ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_long_equals() {
    let m = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from_vec(vec![0x2d, 0x2d, 0x61, 0x72, 0x67, 0x3d, 0xe9]),
        ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_invalid_short() {
    let m = Command::new("bad_utf8").try_get_matches_from(vec![
        OsString::from(""),
        OsString::from("-a"),
        OsString::from_vec(vec![0xe9]),
    ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[test]
fn invalid_utf8_strict_invalid_long() {
    let m = Command::new("bad_utf8").try_get_matches_from(vec![
        OsString::from(""),
        OsString::from("--arg"),
        OsString::from_vec(vec![0xe9]),
    ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::UnknownArgument);
}

#[test]
fn invalid_utf8_positional() {
    let r = Command::new("bad_utf8")
        .arg(Arg::new("arg").value_parser(value_parser!(OsString)))
        .try_get_matches_from(vec![OsString::from(""), OsString::from_vec(vec![0xe9])]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<OsString>("arg").unwrap(),
        &*OsString::from_vec(vec![0xe9])
    );
}

#[test]
fn invalid_utf8_option_short_space() {
    let r = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set)
                .value_parser(value_parser!(OsString)),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from("-a"),
            OsString::from_vec(vec![0xe9]),
        ]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<OsString>("arg").unwrap(),
        &*OsString::from_vec(vec![0xe9])
    );
}

#[test]
fn invalid_utf8_option_short_equals() {
    let r = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set)
                .value_parser(value_parser!(OsString)),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from_vec(vec![0x2d, 0x61, 0x3d, 0xe9]),
        ]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<OsString>("arg").unwrap(),
        &*OsString::from_vec(vec![0xe9])
    );
}

#[test]
fn invalid_utf8_option_short_no_space() {
    let r = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set)
                .value_parser(value_parser!(OsString)),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from_vec(vec![0x2d, 0x61, 0xe9]),
        ]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<OsString>("arg").unwrap(),
        &*OsString::from_vec(vec![0xe9])
    );
}

#[test]
fn invalid_utf8_option_long_space() {
    let r = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set)
                .value_parser(value_parser!(OsString)),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from("--arg"),
            OsString::from_vec(vec![0xe9]),
        ]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<OsString>("arg").unwrap(),
        &*OsString::from_vec(vec![0xe9])
    );
}

#[test]
fn invalid_utf8_option_long_equals() {
    let r = Command::new("bad_utf8")
        .arg(
            Arg::new("arg")
                .short('a')
                .long("arg")
                .action(ArgAction::Set)
                .value_parser(value_parser!(OsString)),
        )
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from_vec(vec![0x2d, 0x2d, 0x61, 0x72, 0x67, 0x3d, 0xe9]),
        ]);
    assert!(r.is_ok(), "{}", r.unwrap_err());
    let m = r.unwrap();
    assert!(m.contains_id("arg"));
    assert_eq!(
        m.get_one::<OsString>("arg").unwrap(),
        &*OsString::from_vec(vec![0xe9])
    );
}

#[test]
fn refuse_invalid_utf8_subcommand_with_allow_external_subcommands() {
    let m = Command::new("bad_utf8")
        .allow_external_subcommands(true)
        .external_subcommand_value_parser(value_parser!(String))
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from_vec(vec![0xe9]),
            OsString::from("normal"),
        ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn refuse_invalid_utf8_subcommand_when_args_are_allowed_with_allow_external_subcommands() {
    let m = Command::new("bad_utf8")
        .allow_external_subcommands(true)
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from_vec(vec![0xe9]),
            OsString::from("normal"),
        ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn refuse_invalid_utf8_subcommand_args_with_allow_external_subcommands() {
    let m = Command::new("bad_utf8")
        .allow_external_subcommands(true)
        .external_subcommand_value_parser(value_parser!(String))
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from("subcommand"),
            OsString::from("normal"),
            OsString::from_vec(vec![0xe9]),
            OsString::from("--another_normal"),
        ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn allow_invalid_utf8_subcommand_args_with_allow_external_subcommands() {
    let m = Command::new("bad_utf8")
        .allow_external_subcommands(true)
        .try_get_matches_from(vec![
            OsString::from(""),
            OsString::from("subcommand"),
            OsString::from("normal"),
            OsString::from_vec(vec![0xe9]),
            OsString::from("--another_normal"),
        ]);
    assert!(m.is_ok(), "{}", m.unwrap_err());
    let m = m.unwrap();
    let (subcommand, args) = m.subcommand().unwrap();
    let args = args
        .get_many::<OsString>("")
        .unwrap()
        .cloned()
        .collect::<Vec<_>>();
    assert_eq!(subcommand, OsString::from("subcommand"));
    assert_eq!(
        args,
        vec![
            OsString::from("normal"),
            OsString::from_vec(vec![0xe9]),
            OsString::from("--another_normal"),
        ]
    );
}

#[test]
fn allow_validated_utf8_value_of() {
    let a = Command::new("test").arg(arg!(--name <NAME>));
    let m = a.try_get_matches_from(["test", "--name", "me"]).unwrap();
    let _ = m.get_one::<String>("name").map(|v| v.as_str());
}

#[test]
fn allow_validated_utf8_external_subcommand_values_of() {
    let a = Command::new("test")
        .allow_external_subcommands(true)
        .external_subcommand_value_parser(value_parser!(String));
    let m = a.try_get_matches_from(vec!["test", "cmd", "arg"]).unwrap();
    let (_ext, args) = m.subcommand().unwrap();
    args.get_many::<String>("").unwrap_or_default().count();
}

#[test]
#[should_panic = "Mismatch between definition and access of ``. Could not downcast to std::ffi::os_str::OsString, need to downcast to alloc::string::String"]
fn panic_validated_utf8_external_subcommand_values_of_os() {
    let a = Command::new("test")
        .allow_external_subcommands(true)
        .external_subcommand_value_parser(value_parser!(String));
    let m = a.try_get_matches_from(vec!["test", "cmd", "arg"]).unwrap();
    let (_ext, args) = m.subcommand().unwrap();
    args.get_many::<OsString>("").unwrap_or_default().count();
}

#[test]
fn allow_invalid_utf8_external_subcommand_values_of_os() {
    let a = Command::new("test").allow_external_subcommands(true);
    let m = a.try_get_matches_from(vec!["test", "cmd", "arg"]).unwrap();
    let (_ext, args) = m.subcommand().unwrap();
    args.get_many::<OsString>("").unwrap_or_default().count();
}

#[test]
#[should_panic = "Mismatch between definition and access of ``. Could not downcast to alloc::string::String, need to downcast to std::ffi::os_str::OsString"]
fn panic_invalid_utf8_external_subcommand_values_of() {
    let a = Command::new("test").allow_external_subcommands(true);
    let m = a.try_get_matches_from(vec!["test", "cmd", "arg"]).unwrap();
    let (_ext, args) = m.subcommand().unwrap();
    args.get_many::<String>("").unwrap_or_default().count();
}

```

`clap/tests/builder/utils.rs`:

```rs
#![allow(unused_imports, dead_code)]

use std::io::{BufRead, Cursor, Write};
use std::str;

use clap::{arg, error::Error, error::ErrorKind, Arg, ArgAction, ArgGroup, Command};
use snapbox::assert_data_eq;

pub(crate) const FULL_TEMPLATE: &str = "\
{before-help}{name} {version}
{author-with-newline}{about-with-newline}
{usage-heading} {usage}

{all-args}{after-help}";

#[track_caller]
pub(crate) fn assert_output(
    l: Command,
    args: &str,
    expected: impl snapbox::data::IntoData,
    stderr: bool,
) {
    let mut buf = Cursor::new(Vec::with_capacity(50));
    let res = l.try_get_matches_from(args.split(' ').collect::<Vec<_>>());
    let err = res.unwrap_err();
    write!(&mut buf, "{err}").unwrap();
    let actual = buf.into_inner();
    let actual = String::from_utf8(actual).unwrap();
    assert_eq!(
        stderr,
        err.use_stderr(),
        "Should Use STDERR failed. Should be {} but is {}",
        stderr,
        err.use_stderr()
    );
    assert_data_eq!(actual, expected.raw());
}

#[track_caller]
pub(crate) fn assert_error<F: clap::error::ErrorFormatter>(
    err: Error<F>,
    expected_kind: ErrorKind,
    expected_output: impl snapbox::data::IntoData,
    stderr: bool,
) {
    let actual_output = err.to_string();
    assert_eq!(
        stderr,
        err.use_stderr(),
        "Should Use STDERR failed. Should be {} but is {}",
        stderr,
        err.use_stderr()
    );
    assert_eq!(expected_kind, err.kind());
    #[cfg(feature = "error-context")]
    assert_data_eq!(actual_output, expected_output);
}

// Legacy tests from the python script days

pub(crate) fn complex_app() -> Command {
    let opt3_vals = ["fast", "slow"];
    let pos3_vals = ["vi", "emacs"];

    Command::new("clap-test")
        .version("v1.4.8")
        .about("tests clap library")
        .author("Kevin K. <kbknapp@gmail.com>")
        .help_template(FULL_TEMPLATE)
        .arg(
            arg!(
                -o --option <opt> "tests options"
            )
            .required(false)
            .num_args(1..)
            .action(ArgAction::Append),
        )
        .arg(arg!([positional] "tests positionals"))
        .arg(
            arg!(-f --flag  "tests flags")
                .action(ArgAction::Count)
                .global(true),
        )
        .args([
            arg!(flag2: -F "tests flags with exclusions")
                .conflicts_with("flag")
                .requires("long-option-2")
                .action(ArgAction::SetTrue),
            arg!(--"long-option-2" <option2> "tests long options with exclusions")
                .conflicts_with("option")
                .requires("positional2"),
            arg!([positional2] "tests positionals with exclusions"),
            arg!(-O --option3 <option3> "specific vals").value_parser(opt3_vals),
            arg!([positional3] ... "tests specific values").value_parser(pos3_vals),
            arg!(--multvals <val> "Tests multiple values, not mult occs")
                .value_names(["one", "two"]),
            arg!(--multvalsmo <val> ... "Tests multiple values, and mult occs")
                .value_names(["one", "two"]),
            arg!(--minvals2 <minvals> "Tests 2 min vals").num_args(2..),
            arg!(--maxvals3 <maxvals> "Tests 3 max vals").num_args(1..=3),
            arg!(--optvaleq <optval> "Tests optional value, require = sign")
                .num_args(0..=1)
                .require_equals(true),
            arg!(--optvalnoeq <optval> "Tests optional value").num_args(0..=1),
        ])
        .subcommand(
            Command::new("subcmd")
                .about("tests subcommands")
                .version("0.1")
                .author("Kevin K. <kbknapp@gmail.com>")
                .help_template(FULL_TEMPLATE)
                .arg(arg!(-o --option <scoption> "tests options").num_args(1..))
                .arg(arg!(-s --subcmdarg <subcmdarg> "tests other args"))
                .arg(arg!([scpositional] "tests positionals")),
        )
}

```

`clap/tests/builder/version.rs`:

```rs
use clap::{error::ErrorKind, ArgAction, Command};
use snapbox::str;

use crate::utils;

fn common() -> Command {
    Command::new("foo").help_template(utils::FULL_TEMPLATE)
}

fn with_version() -> Command {
    common().version("3.0")
}

fn with_long_version() -> Command {
    common().long_version("3.0 (abcdefg)")
}

fn with_both() -> Command {
    common().version("3.0").long_version("3.0 (abcdefg)")
}

fn with_subcommand() -> Command {
    with_version().subcommand(Command::new("bar").defer(|cmd| cmd.subcommand(Command::new("baz"))))
}

#[test]
fn version_short_flag_no_version() {
    let res = common().try_get_matches_from("foo -V".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::UnknownArgument,
        str![[r#"
error: unexpected argument '-V' found

Usage: foo

For more information, try '--help'.

"#]],
        true,
    );
}

#[test]
fn version_long_flag_no_version() {
    let res = common().try_get_matches_from("foo --version".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::UnknownArgument,
        str![[r#"
error: unexpected argument '--version' found

Usage: foo

For more information, try '--help'.

"#]],
        true,
    );
}

#[test]
fn version_short_flag_with_version() {
    let res = with_version().try_get_matches_from("foo -V".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::DisplayVersion,
        str![[r#"
foo 3.0

"#]],
        false,
    );
}

#[test]
fn version_long_flag_with_version() {
    let res = with_version().try_get_matches_from("foo --version".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::DisplayVersion,
        str![[r#"
foo 3.0

"#]],
        false,
    );
}

#[test]
fn version_short_flag_with_long_version() {
    let res = with_long_version().try_get_matches_from("foo -V".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::DisplayVersion,
        str![[r#"
foo 3.0 (abcdefg)

"#]],
        false,
    );
}

#[test]
fn version_long_flag_with_long_version() {
    let res = with_long_version().try_get_matches_from("foo --version".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::DisplayVersion,
        str![[r#"
foo 3.0 (abcdefg)

"#]],
        false,
    );
}

#[test]
fn version_short_flag_with_both() {
    let res = with_both().try_get_matches_from("foo -V".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(
        err,
        ErrorKind::DisplayVersion,
        str![[r#"
foo 3.0

"#]],
        false,
    );
}

#[test]
fn version_long_flag_with_both() {
    let res = with_both().try_get_matches_from("foo --version".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    utils::assert_error(err, ErrorKind::DisplayVersion, str![[r#"
foo 3.0 (abcdefg)

"#]], false);
}

#[test]
fn help_short_flag_no_version() {
    static EXPECTED: &str = "\
foo 

Usage: foo

Options:
  -h, --help  Print help
";
    let cmd = common();
    utils::assert_output(cmd, "foo -h", EXPECTED, false);
}

#[test]
fn help_long_flag_no_version() {
    static EXPECTED: &str = "\
foo 

Usage: foo

Options:
  -h, --help  Print help
";
    let cmd = common();
    utils::assert_output(cmd, "foo --help", EXPECTED, false);
}

#[test]
fn help_short_flag_with_version() {
    static EXPECTED: &str = "\
foo 3.0

Usage: foo

Options:
  -h, --help     Print help
  -V, --version  Print version
";
    let cmd = with_version();
    utils::assert_output(cmd, "foo -h", EXPECTED, false);
}

#[test]
fn help_long_flag_with_version() {
    static EXPECTED: &str = "\
foo 3.0

Usage: foo

Options:
  -h, --help     Print help
  -V, --version  Print version
";
    let cmd = with_version();
    utils::assert_output(cmd, "foo --help", EXPECTED, false);
}

#[test]
fn help_short_flag_with_long_version() {
    static EXPECTED: &str = "\
foo 3.0 (abcdefg)

Usage: foo

Options:
  -h, --help     Print help
  -V, --version  Print version
";
    let cmd = with_long_version();
    utils::assert_output(cmd, "foo -h", EXPECTED, false);
}

#[test]
fn help_long_flag_with_long_version() {
    static EXPECTED: &str = "\
foo 3.0 (abcdefg)

Usage: foo

Options:
  -h, --help     Print help
  -V, --version  Print version
";
    let cmd = with_long_version();
    utils::assert_output(cmd, "foo --help", EXPECTED, false);
}

#[test]
fn help_short_flag_with_both() {
    static EXPECTED: &str = "\
foo 3.0

Usage: foo

Options:
  -h, --help     Print help
  -V, --version  Print version
";
    let cmd = with_both();
    utils::assert_output(cmd, "foo -h", EXPECTED, false);
}

#[test]
fn help_long_flag_with_both() {
    static EXPECTED: &str = "\
foo 3.0

Usage: foo

Options:
  -h, --help     Print help
  -V, --version  Print version
";
    let cmd = with_both();
    utils::assert_output(cmd, "foo --help", EXPECTED, false);
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "Command foo: Long option names must be unique for each argument, but '--version' is in use by both 'ver' and 'version' (call `cmd.disable_version_flag(true)` to remove the auto-generated `--version`)"]
fn override_version_long_with_user_flag() {
    with_version()
        .arg(
            clap::Arg::new("ver")
                .long("version")
                .action(ArgAction::SetTrue),
        )
        .debug_assert();
}

#[test]
#[cfg(debug_assertions)]
#[should_panic = "Command foo: Short option names must be unique for each argument, but '-V' is in use by both 'ver' and 'version' (call `cmd.disable_version_flag(true)` to remove the auto-generated `--version`)"]
fn override_version_short_with_user_flag() {
    with_version()
        .arg(clap::Arg::new("ver").short('V').action(ArgAction::SetTrue))
        .debug_assert();
}

#[test]
fn no_propagation_by_default_long() {
    // Version Flag should not be propagated to subcommands
    let res = with_subcommand().try_get_matches_from("foo bar --version".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::UnknownArgument);
}

#[test]
fn no_propagation_by_default_short() {
    let res = with_subcommand().try_get_matches_from("foo bar -V".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::UnknownArgument);
}

#[test]
fn propagate_version_long() {
    let res = with_subcommand()
        .propagate_version(true)
        .try_get_matches_from("foo bar --version".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::DisplayVersion);
}

#[test]
fn propagate_version_short() {
    let res = with_subcommand()
        .propagate_version(true)
        .try_get_matches_from("foo bar -V".split(' '));

    assert!(res.is_err());
    let err = res.unwrap_err();
    assert_eq!(err.kind(), ErrorKind::DisplayVersion);
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "`ArgAction::Version` used without providing Command::version or Command::long_version"]
fn version_required() {
    let _res = common()
        .arg(clap::arg!(--version).action(ArgAction::Version))
        .try_get_matches_from("foo -z".split(' '));
}

#[test]
#[should_panic = "Argument `version` is undefined"]
fn mut_arg_version_no_auto_version() {
    let _ = common().mut_arg("version", |v| v.short('z').action(ArgAction::SetTrue));
}

#[cfg(debug_assertions)]
#[test]
#[should_panic = "No version information via Command::version or Command::long_version to propagate"]
fn propagate_version_no_version_info() {
    let _res = common()
        .propagate_version(true)
        .subcommand(Command::new("bar"))
        .try_get_matches_from("foo".split(' '));
}

```

`clap/tests/derive/app_name.rs`:

```rs
use clap::CommandFactory;
use clap::Parser;

use crate::utils::get_help;
use crate::utils::get_long_help;

#[test]
fn app_name_in_short_help_from_struct() {
    #[derive(Parser)]
    #[command(name = "my-cmd")]
    struct MyApp {}

    let help = get_help::<MyApp>();

    assert!(help.contains("my-cmd"));
}

#[test]
fn app_name_in_long_help_from_struct() {
    #[derive(Parser)]
    #[command(name = "my-cmd")]
    struct MyApp {}

    let help = get_help::<MyApp>();

    assert!(help.contains("my-cmd"));
}

#[test]
fn app_name_in_short_help_from_enum() {
    #[derive(Parser)]
    #[command(name = "my-cmd")]
    enum MyApp {}

    let help = get_help::<MyApp>();

    assert!(help.contains("my-cmd"));
}

#[test]
fn app_name_in_long_help_from_enum() {
    #[derive(Parser)]
    #[command(name = "my-cmd")]
    enum MyApp {}

    let help = get_long_help::<MyApp>();

    assert!(help.contains("my-cmd"));
}

#[test]
fn app_name_in_short_version_from_struct() {
    #[derive(Parser)]
    #[command(name = "my-cmd")]
    struct MyApp {}

    let version = MyApp::command().render_version();

    assert!(version.contains("my-cmd"));
}

#[test]
fn app_name_in_long_version_from_struct() {
    #[derive(Parser)]
    #[command(name = "my-cmd")]
    struct MyApp {}

    let version = MyApp::command().render_long_version();

    assert!(version.contains("my-cmd"));
}

#[test]
fn app_name_in_short_version_from_enum() {
    #[derive(Parser)]
    #[command(name = "my-cmd")]
    enum MyApp {}

    let version = MyApp::command().render_version();

    assert!(version.contains("my-cmd"));
}

#[test]
fn app_name_in_long_version_from_enum() {
    #[derive(Parser)]
    #[command(name = "my-cmd")]
    enum MyApp {}

    let version = MyApp::command().render_long_version();

    assert!(version.contains("my-cmd"));
}

```

`clap/tests/derive/arguments.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use clap::Parser;

use crate::utils::get_help;

#[test]
fn required_argument() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        arg: i32,
    }
    assert_eq!(
        Opt { arg: 42 },
        Opt::try_parse_from(["test", "42"]).unwrap()
    );
    assert!(Opt::try_parse_from(["test"]).is_err());
    assert!(Opt::try_parse_from(["test", "42", "24"]).is_err());
}

#[test]
fn argument_with_default() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(default_value = "42")]
        arg: i32,
    }
    assert_eq!(
        Opt { arg: 24 },
        Opt::try_parse_from(["test", "24"]).unwrap()
    );
    assert_eq!(Opt { arg: 42 }, Opt::try_parse_from(["test"]).unwrap());
    assert!(Opt::try_parse_from(["test", "42", "24"]).is_err());
}

#[test]
fn auto_value_name() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        my_special_arg: i32,
    }

    let help = get_help::<Opt>();

    assert!(help.contains("MY_SPECIAL_ARG"));
    // Ensure the implicit `num_vals` is just 1
    assert_eq!(
        Opt { my_special_arg: 10 },
        Opt::try_parse_from(["test", "10"]).unwrap()
    );
}

#[test]
fn explicit_value_name() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_name = "BROWNIE_POINTS")]
        my_special_arg: i32,
    }

    let help = get_help::<Opt>();

    assert!(help.contains("BROWNIE_POINTS"));
    assert!(!help.contains("MY_SPECIAL_ARG"));
    // Ensure the implicit `num_vals` is just 1
    assert_eq!(
        Opt { my_special_arg: 10 },
        Opt::try_parse_from(["test", "10"]).unwrap()
    );
}

#[test]
fn option_type_is_optional() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        arg: Option<i32>,
    }
    assert_eq!(
        Opt { arg: Some(42) },
        Opt::try_parse_from(["test", "42"]).unwrap()
    );
    assert_eq!(Opt { arg: None }, Opt::try_parse_from(["test"]).unwrap());
    assert!(Opt::try_parse_from(["test", "42", "24"]).is_err());
}

#[test]
fn vec_type_is_multiple_values() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        arg: Vec<i32>,
    }
    assert_eq!(
        Opt { arg: vec![24] },
        Opt::try_parse_from(["test", "24"]).unwrap()
    );
    assert_eq!(Opt { arg: vec![] }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(
        Opt { arg: vec![24, 42] },
        Opt::try_parse_from(["test", "24", "42"]).unwrap()
    );
    assert_eq!(
        clap::error::ErrorKind::ValueValidation,
        Opt::try_parse_from(["test", "NOPE"]).err().unwrap().kind()
    );
}

```

`clap/tests/derive/author_version_about.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use crate::utils;

use clap::Parser;

#[test]
fn no_author_version_about() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(name = "foo")]
    #[command(help_template = utils::FULL_TEMPLATE)]
    struct Opt {}

    let output = utils::get_long_help::<Opt>();
    assert!(output.starts_with("foo \n\nUsage:"));
}

#[test]
fn use_env() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(author, about, version)]
    #[command(help_template = utils::FULL_TEMPLATE)]
    struct Opt {}

    let output = utils::get_long_help::<Opt>();
    assert!(output.starts_with("clap"));
    assert!(output
        .contains("A simple to use, efficient, and full-featured Command Line Argument Parser"));
}

#[test]
fn explicit_version_not_str_lit() {
    const VERSION: &str = "custom version";

    #[derive(Parser)]
    #[command(version = VERSION)]
    #[command(help_template = utils::FULL_TEMPLATE)]
    pub(crate) struct Opt {}

    let output = utils::get_long_help::<Opt>();
    assert!(output.contains("custom version"));
}

```

`clap/tests/derive/basic.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use clap::Parser;

#[test]
fn basic() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(short = 'a', long = "arg")]
        arg: i32,
    }
    assert_eq!(
        Opt { arg: 24 },
        Opt::try_parse_from(["test", "-a24"]).unwrap()
    );
}

#[test]
fn update_basic() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(short, long)]
        first: i32,
        #[arg(short, long)]
        second: i32,
    }

    let mut opt = Opt::try_parse_from(["test", "-f0", "-s1"]).unwrap();

    opt.try_update_from(["test", "-f42"]).unwrap();

    assert_eq!(
        Opt {
            first: 42,
            second: 1
        },
        opt
    );
}

#[test]
fn update_explicit_required() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(short, long, required = true)]
        first: i32,
        #[arg(short, long, required = true)]
        second: i32,
    }

    let mut opt = Opt::try_parse_from(["test", "-f0", "-s1"]).unwrap();

    opt.try_update_from(["test", "-f42"]).unwrap();

    assert_eq!(
        Opt {
            first: 42,
            second: 1
        },
        opt
    );
}

#[test]
fn unit_struct() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt;

    assert_eq!(Opt {}, Opt::try_parse_from(["test"]).unwrap());
}

```

`clap/tests/derive/boxed.rs`:

```rs
use clap::{Args, Parser, Subcommand};

#[derive(Parser, PartialEq, Debug)]
struct Opt {
    #[command(subcommand)]
    sub: Box<Sub>,
}

#[derive(Subcommand, PartialEq, Debug)]
enum Sub {
    Flame {
        #[command(flatten)]
        arg: Box<Ext>,
    },
}

#[derive(Args, PartialEq, Debug)]
struct Ext {
    arg: u32,
}

#[test]
fn boxed_flatten_subcommand() {
    assert_eq!(
        Opt {
            sub: Box::new(Sub::Flame {
                arg: Box::new(Ext { arg: 1 })
            })
        },
        Opt::try_parse_from(["test", "flame", "1"]).unwrap()
    );
}

#[test]
fn update_boxed_flatten_subcommand() {
    let mut opt = Opt::try_parse_from(["test", "flame", "1"]).unwrap();

    opt.try_update_from(["test", "flame", "42"]).unwrap();

    assert_eq!(
        Opt {
            sub: Box::new(Sub::Flame {
                arg: Box::new(Ext { arg: 42 })
            })
        },
        opt
    );
}

```

`clap/tests/derive/custom_string_parsers.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use clap::Parser;

use std::num::ParseIntError;
use std::path::PathBuf;

#[derive(Parser, PartialEq, Debug)]
struct PathOpt {
    #[arg(short, long)]
    path: PathBuf,

    #[arg(short, default_value = "../")]
    default_path: PathBuf,

    #[arg(short)]
    vector_path: Vec<PathBuf>,

    #[arg(short)]
    option_path_1: Option<PathBuf>,

    #[arg(short = 'q')]
    option_path_2: Option<PathBuf>,
}

#[test]
fn test_path_opt_simple() {
    assert_eq!(
        PathOpt {
            path: PathBuf::from("/usr/bin"),
            default_path: PathBuf::from("../"),
            vector_path: vec![
                PathBuf::from("/a/b/c"),
                PathBuf::from("/d/e/f"),
                PathBuf::from("/g/h/i"),
            ],
            option_path_1: None,
            option_path_2: Some(PathBuf::from("j.zip")),
        },
        PathOpt::try_parse_from([
            "test", "-p", "/usr/bin", "-v", "/a/b/c", "-v", "/d/e/f", "-v", "/g/h/i", "-q",
            "j.zip",
        ])
        .unwrap()
    );
}

fn parse_hex(input: &str) -> Result<u64, ParseIntError> {
    u64::from_str_radix(input, 16)
}

#[derive(Parser, PartialEq, Debug)]
struct HexOpt {
    #[arg(short, value_parser = parse_hex)]
    number: u64,
}

#[test]
#[cfg(feature = "error-context")]
fn test_parse_hex() {
    assert_eq!(
        HexOpt { number: 5 },
        HexOpt::try_parse_from(["test", "-n", "5"]).unwrap()
    );
    assert_eq!(
        HexOpt {
            number: 0x00ab_cdef
        },
        HexOpt::try_parse_from(["test", "-n", "abcdef"]).unwrap()
    );

    let err = HexOpt::try_parse_from(["test", "-n", "gg"]).unwrap_err();
    assert!(
        err.to_string().contains("invalid digit found in string"),
        "{}",
        err
    );
}

#[derive(Debug)]
struct ErrCode(u32);
impl std::error::Error for ErrCode {}
impl std::fmt::Display for ErrCode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(&self.0, f)
    }
}
fn custom_parser_2(_: &str) -> Result<&'static str, ErrCode> {
    Ok("B")
}

#[derive(Parser, PartialEq, Debug)]
struct NoOpOpt {
    #[arg(short, value_parser = custom_parser_2)]
    b: &'static str,
}

#[test]
fn test_every_custom_parser() {
    assert_eq!(
        NoOpOpt { b: "B" },
        NoOpOpt::try_parse_from(["test", "-b=?"]).unwrap()
    );
}

#[test]
fn update_every_custom_parser() {
    let mut opt = NoOpOpt { b: "0" };

    opt.try_update_from(["test", "-b=?"]).unwrap();

    assert_eq!(NoOpOpt { b: "B" }, opt);
}

#[derive(Parser, PartialEq, Debug)]
struct DefaultedOpt {
    #[arg(short)]
    integer: u64,

    #[arg(short)]
    path: PathBuf,
}

#[test]
fn test_parser_with_default_value() {
    assert_eq!(
        DefaultedOpt {
            integer: 9000,
            path: PathBuf::from("src/lib.rs"),
        },
        DefaultedOpt::try_parse_from(["test", "-i", "9000", "-p", "src/lib.rs",]).unwrap()
    );
}

```

`clap/tests/derive/default_value.rs`:

```rs
use std::path::PathBuf;

use clap::{CommandFactory, Parser};

use crate::utils;

#[test]
fn default_value() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(default_value = "3")]
        arg: i32,
    }
    assert_eq!(Opt { arg: 3 }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(Opt { arg: 1 }, Opt::try_parse_from(["test", "1"]).unwrap());

    let help = utils::get_long_help::<Opt>();
    assert!(help.contains("[default: 3]"));
}

#[test]
fn default_value_t() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(default_value_t = 3)]
        arg: i32,
    }
    assert_eq!(Opt { arg: 3 }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(Opt { arg: 1 }, Opt::try_parse_from(["test", "1"]).unwrap());

    let help = utils::get_long_help::<Opt>();
    assert!(help.contains("[default: 3]"));
}

#[test]
fn auto_default_value_t() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(default_value_t)]
        arg: i32,
    }
    assert_eq!(Opt { arg: 0 }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(Opt { arg: 1 }, Opt::try_parse_from(["test", "1"]).unwrap());

    let help = utils::get_long_help::<Opt>();
    assert!(help.contains("[default: 0]"));
}

#[test]
fn default_values_t() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(default_values_t = vec![1, 2, 3])]
        arg1: Vec<i32>,

        #[arg(long, default_values_t = [4, 5, 6])]
        arg2: Vec<i32>,

        #[arg(long, default_values_t = [7, 8, 9])]
        arg3: Vec<i32>,

        #[arg(long, default_values_t = 10..=12)]
        arg4: Vec<i32>,

        #[arg(long, default_values_t = vec!["hello".to_string(), "world".to_string()])]
        arg5: Vec<String>,

        #[arg(long, default_values_t = &vec!["foo".to_string(), "bar".to_string()])]
        arg6: Vec<String>,
    }
    assert_eq!(
        Opt {
            arg1: vec![1, 2, 3],
            arg2: vec![4, 5, 6],
            arg3: vec![7, 8, 9],
            arg4: vec![10, 11, 12],
            arg5: vec!["hello".to_string(), "world".to_string()],
            arg6: vec!["foo".to_string(), "bar".to_string()],
        },
        Opt::try_parse_from(["test"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg1: vec![1],
            arg2: vec![4, 5, 6],
            arg3: vec![7, 8, 9],
            arg4: vec![10, 11, 12],
            arg5: vec!["hello".to_string(), "world".to_string()],
            arg6: vec!["foo".to_string(), "bar".to_string()],
        },
        Opt::try_parse_from(["test", "1"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg1: vec![1, 2, 3],
            arg2: vec![4, 5, 6],
            arg3: vec![7, 8, 9],
            arg4: vec![42, 15],
            arg5: vec!["baz".to_string()],
            arg6: vec!["foo".to_string(), "bar".to_string()],
        },
        Opt::try_parse_from(["test", "--arg4", "42", "--arg4", "15", "--arg5", "baz"]).unwrap()
    );

    let help = utils::get_long_help::<Opt>();
    assert!(help.contains("[default: 1 2 3]"));
}

#[test]
fn default_value_os_t() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(default_value_os_t = PathBuf::from("abc.def"))]
        arg: PathBuf,
    }
    assert_eq!(
        Opt {
            arg: PathBuf::from("abc.def")
        },
        Opt::try_parse_from(["test"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: PathBuf::from("ghi")
        },
        Opt::try_parse_from(["test", "ghi"]).unwrap()
    );

    let help = utils::get_long_help::<Opt>();
    assert!(help.contains("[default: abc.def]"));
}

#[test]
fn default_values_os_t() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(
            default_values_os_t = vec![PathBuf::from("abc.def"), PathBuf::from("123.foo")]
        )]
        arg1: Vec<PathBuf>,

        #[arg(
            long,
            default_values_os_t = [PathBuf::from("bar.baz")]
        )]
        arg2: Vec<PathBuf>,
    }
    assert_eq!(
        Opt {
            arg1: vec![PathBuf::from("abc.def"), PathBuf::from("123.foo")],
            arg2: vec![PathBuf::from("bar.baz")]
        },
        Opt::try_parse_from(["test"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg1: vec![PathBuf::from("ghi")],
            arg2: vec![PathBuf::from("baz.bar"), PathBuf::from("foo.bar")]
        },
        Opt::try_parse_from(["test", "ghi", "--arg2", "baz.bar", "--arg2", "foo.bar"]).unwrap()
    );

    let help = utils::get_long_help::<Opt>();
    assert!(help.contains("[default: abc.def 123.foo]"));
}

#[test]
fn detect_os_variant() {
    #![allow(deprecated)]

    #[derive(clap::Parser)]
    pub(crate) struct Options {
        #[arg(default_value_os = "123")]
        x: String,
    }
    Options::command().debug_assert();
}

```

`clap/tests/derive/deny_warnings.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

#![deny(unused_qualifications)]
#![deny(warnings)]

use clap::Parser;

fn try_str(s: &str) -> Result<String, std::convert::Infallible> {
    Ok(s.into())
}

#[test]
fn warning_never_struct() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(value_parser = try_str, default_value_t)]
        s: String,
    }
    assert_eq!(
        Opt {
            s: "foo".to_string()
        },
        Opt::try_parse_from(["test", "foo"]).unwrap()
    );
}

#[test]
fn warning_never_enum() {
    #[derive(Parser, Debug, PartialEq)]
    enum Opt {
        Foo {
            #[arg(value_parser = try_str, default_value_t)]
            s: String,
        },
    }
    assert_eq!(
        Opt::Foo {
            s: "foo".to_string()
        },
        Opt::try_parse_from(["test", "foo", "foo"]).unwrap()
    );
}

#[test]
fn warning_unused_qualifications() {
    // This causes `clap::Args` within the derive to be unused qualifications
    use clap::Args;

    #[derive(Args, Clone, Copy, Debug, Default)]
    #[group(skip)]
    pub(crate) struct Compose<L: Args> {
        #[command(flatten)]
        pub(crate) left: L,
    }
}

```

`clap/tests/derive/doc_comments_help.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use crate::utils;

use clap::{CommandFactory, Parser, Subcommand, ValueEnum};
use snapbox::str;

#[test]
fn doc_comments() {
    /// Lorem ipsum
    #[derive(Parser, PartialEq, Debug)]
    struct LoremIpsum {
        /// Fooify a bar
        /// and a baz
        #[arg(short, long)]
        foo: bool,
    }

    let help = utils::get_long_help::<LoremIpsum>();
    assert!(help.contains("Lorem ipsum"));
    assert!(help.contains("Fooify a bar and a baz"));
}

#[test]
fn help_is_better_than_comments() {
    /// Lorem ipsum
    #[derive(Parser, PartialEq, Debug)]
    #[command(name = "lorem-ipsum", about = "Dolor sit amet")]
    struct LoremIpsum {
        /// Fooify a bar
        #[arg(short, long, help = "DO NOT PASS A BAR UNDER ANY CIRCUMSTANCES")]
        foo: bool,
    }

    let help = utils::get_long_help::<LoremIpsum>();
    assert!(help.contains("Dolor sit amet"));
    assert!(!help.contains("Lorem ipsum"));
    assert!(help.contains("DO NOT PASS A BAR"));
}

#[test]
fn empty_line_in_doc_comment_is_double_linefeed() {
    /// Foo.
    ///
    /// Bar
    #[derive(Parser, PartialEq, Debug)]
    #[command(name = "lorem-ipsum")]
    struct LoremIpsum {}

    let help = utils::get_long_help::<LoremIpsum>();
    assert!(help.starts_with(
        "\
Foo.

Bar

Usage:"
    ));
}

#[test]
fn field_long_doc_comment_both_help_long_help() {
    /// Lorem ipsumclap
    #[derive(Parser, PartialEq, Debug)]
    #[command(name = "lorem-ipsum", about = "Dolor sit amet")]
    struct LoremIpsum {
        /// Dot is removed from multiline comments.
        ///
        /// Long help
        #[arg(long)]
        foo: bool,

        /// Dot is removed from one short comment.
        #[arg(long)]
        bar: bool,
    }

    let short_help = utils::get_help::<LoremIpsum>();
    let long_help = utils::get_long_help::<LoremIpsum>();

    assert!(short_help.contains("Dot is removed from one short comment"));
    assert!(!short_help.contains("Dot is removed from one short comment."));
    assert!(short_help.contains("Dot is removed from multiline comments"));
    assert!(!short_help.contains("Dot is removed from multiline comments."));
    assert!(long_help.contains("Long help"));
    assert!(!short_help.contains("Long help"));
}

#[test]
fn top_long_doc_comment_both_help_long_help() {
    /// Lorem ipsumclap
    #[derive(Parser, Debug)]
    #[command(name = "lorem-ipsum", about = "Dolor sit amet")]
    struct LoremIpsum {
        #[command(subcommand)]
        foo: SubCommand,
    }

    #[derive(Parser, Debug)]
    pub(crate) enum SubCommand {
        /// DO NOT PASS A BAR UNDER ANY CIRCUMSTANCES
        ///
        /// Or something else
        Foo {
            #[arg(help = "foo")]
            bars: String,
        },
    }

    let short_help = utils::get_help::<LoremIpsum>();
    let long_help = utils::get_subcommand_long_help::<LoremIpsum>("foo");

    assert!(!short_help.contains("Or something else"));
    assert!(long_help.contains("DO NOT PASS A BAR UNDER ANY CIRCUMSTANCES"));
    assert!(long_help.contains("Or something else"));
}

#[test]
fn verbatim_doc_comment() {
    /// DANCE!
    ///
    ///                    ()
    ///                    |
    ///               (   ()   )
    ///     ) ________    //  )
    ///  ()  |\       \  //
    /// ( \\__ \ ______\//
    ///    \__) |       |
    ///      |  |       |
    ///       \ |       |
    ///        \|_______|
    ///        //    \\
    ///       ((     ||
    ///        \\    ||
    ///      ( ()    ||
    ///       (      () ) )
    #[derive(Parser, Debug)]
    #[command(verbatim_doc_comment)]
    struct SeeFigure1 {
        #[arg(long)]
        foo: bool,
    }

    let help = utils::get_long_help::<SeeFigure1>();
    let sample = r"
                   ()
                   |
              (   ()   )
    ) ________    //  )
 ()  |\       \  //
( \\__ \ ______\//
   \__) |       |
     |  |       |
      \ |       |
       \|_______|
       //    \\
      ((     ||
       \\    ||
     ( ()    ||
      (      () ) )";

    assert!(help.contains(sample));
}

#[test]
fn verbatim_doc_comment_field() {
    #[derive(Parser, Debug)]
    struct Command {
        /// This help ends in a period.
        #[arg(long, verbatim_doc_comment)]
        foo: bool,
        /// This help does not end in a period.
        #[arg(long)]
        bar: bool,
    }

    let help = utils::get_long_help::<Command>();

    assert!(help.contains("This help ends in a period."));
    assert!(help.contains("This help does not end in a period"));
}

#[test]
fn multiline_separates_default() {
    #[derive(Parser, Debug)]
    struct Command {
        /// Multiline
        ///
        /// Doc comment
        #[arg(long, default_value = "x")]
        x: String,
    }

    let help = utils::get_long_help::<Command>();
    assert!(!help.contains("Doc comment [default"));
    assert!(help.lines().any(|s| s.trim().starts_with("[default")));

    // The short help should still have the default on the same line
    let help = utils::get_help::<Command>();
    assert!(help.contains("Multiline [default"));
}

#[test]
fn value_enum_multiline_doc_comment() {
    #[derive(Parser, Debug)]
    struct Command {
        x: LoremIpsum,
    }

    #[derive(ValueEnum, Clone, PartialEq, Debug)]
    enum LoremIpsum {
        /// Doc comment summary
        ///
        /// The doc comment body is ignored
        Bar,
    }

    let help = utils::get_long_help::<Command>();

    assert!(help.contains("Doc comment summary"));

    // There is no long help text for possible values. The long help only contains the summary.
    assert!(!help.contains("The doc comment body is ignored"));
}

#[test]
fn doc_comment_about_handles_both_abouts() {
    /// Opts doc comment summary
    #[derive(Parser, Debug)]
    pub(crate) struct Opts {
        #[command(subcommand)]
        pub(crate) cmd: Sub,
    }

    /// Sub doc comment summary
    ///
    /// Sub doc comment body
    #[derive(Parser, PartialEq, Eq, Debug)]
    pub(crate) enum Sub {
        Compress { output: String },
    }

    let cmd = Opts::command();
    assert_eq!(
        cmd.get_about().map(|s| s.to_string()),
        Some("Opts doc comment summary".to_owned())
    );
    // clap will fallback to `about` on `None`.  The main care about is not providing a `Sub` doc
    // comment.
    assert_eq!(cmd.get_long_about(), None);
}

#[test]
fn respect_subcommand_doc_comment() {
    #[derive(Parser, Debug)]
    pub(crate) enum Cmd {
        /// For child
        #[command(subcommand)]
        Child(Child),
    }

    #[derive(Subcommand, Debug)]
    pub(crate) enum Child {
        One,
        Twp,
    }

    let output = str![[r#"
Usage: cmd <COMMAND>

Commands:
  child  For child
  help   Print this message or the help of the given subcommand(s)

Options:
  -h, --help  Print help

"#]];
    utils::assert_output::<Cmd>("cmd --help", output, false);
}

#[test]
fn force_long_help() {
    /// Lorem ipsum
    #[derive(Parser, PartialEq, Debug)]
    struct LoremIpsum {
        /// Fooify a bar
        /// and a baz.
        #[arg(short, long, long_help)]
        foo: bool,
    }

    let help = utils::get_long_help::<LoremIpsum>();
    assert!(help.contains("Fooify a bar and a baz."));
}

```

`clap/tests/derive/explicit_name_no_renaming.rs`:

```rs
use crate::utils;

use clap::Parser;

#[test]
fn explicit_short_long_no_rename() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(short = '.', long = ".foo")]
        foo: String,
    }

    assert_eq!(
        Opt { foo: "long".into() },
        Opt::try_parse_from(["test", "--.foo", "long"]).unwrap()
    );

    assert_eq!(
        Opt {
            foo: "short".into(),
        },
        Opt::try_parse_from(["test", "-.", "short"]).unwrap()
    );
}

#[test]
fn explicit_name_no_rename() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(id = ".options")]
        foo: String,
    }

    let help = utils::get_long_help::<Opt>();
    assert!(help.contains("<.options>"));
}

```

`clap/tests/derive/flags.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use clap::builder::BoolishValueParser;
use clap::builder::TypedValueParser as _;
use clap::ArgAction;
use clap::CommandFactory;
use clap::Parser;

#[test]
fn bool_type_is_flag() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short, long)]
        alice: bool,
    }

    assert_eq!(Opt { alice: false }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(
        Opt { alice: true },
        Opt::try_parse_from(["test", "-a"]).unwrap()
    );
    assert_eq!(
        Opt { alice: true },
        Opt::try_parse_from(["test", "-a", "-a"]).unwrap()
    );
    assert_eq!(
        Opt { alice: true },
        Opt::try_parse_from(["test", "--alice"]).unwrap()
    );
    assert!(Opt::try_parse_from(["test", "-i"]).is_err());
    assert!(Opt::try_parse_from(["test", "-a", "foo"]).is_err());
}

#[test]
fn non_bool_type_flag() {
    fn parse_from_flag(b: bool) -> usize {
        if b {
            10
        } else {
            5
        }
    }

    #[derive(Parser, Debug)]
    struct Opt {
        #[arg(short, long, action = ArgAction::SetTrue, value_parser = BoolishValueParser::new().map(parse_from_flag))]
        alice: usize,
        #[arg(short, long, action = ArgAction::SetTrue, value_parser = BoolishValueParser::new().map(parse_from_flag))]
        bob: usize,
    }

    let opt = Opt::try_parse_from(["test"]).unwrap();
    assert_eq!(opt.alice, 5);
    assert_eq!(opt.bob, 5);

    let opt = Opt::try_parse_from(["test", "-a"]).unwrap();
    assert_eq!(opt.alice, 10);
    assert_eq!(opt.bob, 5);

    let opt = Opt::try_parse_from(["test", "-b"]).unwrap();
    assert_eq!(opt.alice, 5);
    assert_eq!(opt.bob, 10);

    let opt = Opt::try_parse_from(["test", "-b", "-a"]).unwrap();
    assert_eq!(opt.alice, 10);
    assert_eq!(opt.bob, 10);
}

#[test]
#[ignore] // Not a good path for supporting this atm
fn inferred_help() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        /// Foo
        #[arg(short, long)]
        help: bool,
    }

    let mut cmd = Opt::command();
    cmd.build();
    let arg = cmd.get_arguments().find(|a| a.get_id() == "help").unwrap();
    assert_eq!(
        arg.get_help().map(|s| s.to_string()),
        Some("Foo".to_owned()),
        "Incorrect help"
    );
    assert!(matches!(arg.get_action(), ArgAction::Help));
}

#[test]
#[ignore] // Not a good path for supporting this atm
fn inferred_version() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        /// Foo
        #[arg(short, long)]
        version: bool,
    }

    let mut cmd = Opt::command();
    cmd.build();
    let arg = cmd
        .get_arguments()
        .find(|a| a.get_id() == "version")
        .unwrap();
    assert_eq!(
        arg.get_help().map(|s| s.to_string()),
        Some("Foo".to_owned()),
        "Incorrect help"
    );
    assert!(matches!(arg.get_action(), ArgAction::Version));
}

#[test]
fn count() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        #[arg(short, long, action = clap::ArgAction::Count)]
        alice: u8,
        #[arg(short, long, action = clap::ArgAction::Count)]
        bob: u8,
    }

    assert_eq!(
        Opt { alice: 0, bob: 0 },
        Opt::try_parse_from(["test"]).unwrap()
    );
    assert_eq!(
        Opt { alice: 1, bob: 0 },
        Opt::try_parse_from(["test", "-a"]).unwrap()
    );
    assert_eq!(
        Opt { alice: 2, bob: 0 },
        Opt::try_parse_from(["test", "-a", "-a"]).unwrap()
    );
    assert_eq!(
        Opt { alice: 2, bob: 2 },
        Opt::try_parse_from(["test", "-a", "--alice", "-bb"]).unwrap()
    );
    assert_eq!(
        Opt { alice: 3, bob: 1 },
        Opt::try_parse_from(["test", "-aaa", "--bob"]).unwrap()
    );
    assert!(Opt::try_parse_from(["test", "-i"]).is_err());
    assert!(Opt::try_parse_from(["test", "-a", "foo"]).is_err());
}

#[test]
fn mixed_type_flags() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        #[arg(short, long)]
        alice: bool,
        #[arg(short, long, action = clap::ArgAction::Count)]
        bob: u8,
    }

    assert_eq!(
        Opt {
            alice: false,
            bob: 0
        },
        Opt::try_parse_from(["test"]).unwrap()
    );
    assert_eq!(
        Opt {
            alice: true,
            bob: 0
        },
        Opt::try_parse_from(["test", "-a"]).unwrap()
    );
    assert_eq!(
        Opt {
            alice: true,
            bob: 0
        },
        Opt::try_parse_from(["test", "-a"]).unwrap()
    );
    assert_eq!(
        Opt {
            alice: false,
            bob: 1
        },
        Opt::try_parse_from(["test", "-b"]).unwrap()
    );
    assert_eq!(
        Opt {
            alice: true,
            bob: 1
        },
        Opt::try_parse_from(["test", "--alice", "--bob"]).unwrap()
    );
    assert_eq!(
        Opt {
            alice: true,
            bob: 4
        },
        Opt::try_parse_from(["test", "-bb", "-a", "-bb"]).unwrap()
    );
}

#[test]
fn ignore_qualified_bool_type() {
    mod inner {
        #[allow(non_camel_case_types)]
        #[derive(PartialEq, Eq, Debug, Clone)]
        pub(crate) struct bool(pub(crate) String);

        impl std::str::FromStr for bool {
            type Err = String;

            fn from_str(s: &str) -> Result<Self, Self::Err> {
                Ok(bool(s.into()))
            }
        }
    }

    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        arg: inner::bool,
    }

    assert_eq!(
        Opt {
            arg: inner::bool("success".into())
        },
        Opt::try_parse_from(["test", "success"]).unwrap()
    );
}

#[test]
fn override_implicit_action() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        #[arg(long, action = clap::ArgAction::Set)]
        arg: bool,
    }

    assert_eq!(
        Opt { arg: false },
        Opt::try_parse_from(["test", "--arg", "false"]).unwrap()
    );

    assert_eq!(
        Opt { arg: true },
        Opt::try_parse_from(["test", "--arg", "true"]).unwrap()
    );
}

#[test]
fn override_implicit_from_flag_positional() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        #[arg(action = clap::ArgAction::Set)]
        arg: bool,
    }

    assert_eq!(
        Opt { arg: false },
        Opt::try_parse_from(["test", "false"]).unwrap()
    );

    assert_eq!(
        Opt { arg: true },
        Opt::try_parse_from(["test", "true"]).unwrap()
    );
}

#[test]
fn unit_for_negation() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        #[arg(long)]
        arg: bool,
        #[arg(long, action = ArgAction::SetTrue, overrides_with = "arg")]
        no_arg: (),
    }

    assert_eq!(
        Opt {
            arg: false,
            no_arg: ()
        },
        Opt::try_parse_from(["test"]).unwrap()
    );

    assert_eq!(
        Opt {
            arg: true,
            no_arg: ()
        },
        Opt::try_parse_from(["test", "--arg"]).unwrap()
    );

    assert_eq!(
        Opt {
            arg: false,
            no_arg: ()
        },
        Opt::try_parse_from(["test", "--no-arg"]).unwrap()
    );

    assert_eq!(
        Opt {
            arg: true,
            no_arg: ()
        },
        Opt::try_parse_from(["test", "--no-arg", "--arg"]).unwrap()
    );

    assert_eq!(
        Opt {
            arg: false,
            no_arg: ()
        },
        Opt::try_parse_from(["test", "--arg", "--no-arg"]).unwrap()
    );
}

#[test]
fn optional_value_flag() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        #[arg(short, long, num_args=0..=1)]
        alice: bool,
    }

    assert_eq!(Opt { alice: false }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(
        Opt { alice: true },
        Opt::try_parse_from(["test", "-a"]).unwrap()
    );
    assert_eq!(
        Opt { alice: true },
        Opt::try_parse_from(["test", "-a", "true"]).unwrap()
    );
    assert_eq!(
        Opt { alice: false },
        Opt::try_parse_from(["test", "-a", "false"]).unwrap()
    );
}

```

`clap/tests/derive/flatten.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use crate::utils;

use clap::{Args, Parser, Subcommand};

#[test]
fn flatten() {
    #[derive(Args, PartialEq, Debug)]
    struct Common {
        arg: i32,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[command(flatten)]
        common: Common,
    }
    assert_eq!(
        Opt {
            common: Common { arg: 42 }
        },
        Opt::try_parse_from(["test", "42"]).unwrap()
    );
    assert!(Opt::try_parse_from(["test"]).is_err());
    assert!(Opt::try_parse_from(["test", "42", "24"]).is_err());
}

#[cfg(debug_assertions)]
#[test]
#[should_panic]
fn flatten_twice() {
    #[derive(Args, PartialEq, Debug)]
    struct Common {
        arg: i32,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[command(flatten)]
        c1: Common,
        // Defines "arg" twice, so this should not work.
        #[command(flatten)]
        c2: Common,
    }
    Opt::try_parse_from(["test", "42", "43"]).unwrap();
}

#[test]
fn flatten_in_subcommand() {
    #[derive(Args, PartialEq, Debug)]
    struct Common {
        arg: i32,
    }

    #[derive(Args, PartialEq, Debug)]
    struct Add {
        #[arg(short)]
        interactive: bool,
        #[command(flatten)]
        common: Common,
    }

    #[derive(Parser, PartialEq, Debug)]
    enum Opt {
        Fetch {
            #[arg(short)]
            all: bool,
            #[command(flatten)]
            common: Common,
        },

        Add(Add),
    }

    assert_eq!(
        Opt::Fetch {
            all: false,
            common: Common { arg: 42 }
        },
        Opt::try_parse_from(["test", "fetch", "42"]).unwrap()
    );
    assert_eq!(
        Opt::Add(Add {
            interactive: true,
            common: Common { arg: 43 }
        }),
        Opt::try_parse_from(["test", "add", "-i", "43"]).unwrap()
    );
}

#[test]
fn update_args_with_flatten() {
    #[derive(Args, PartialEq, Debug)]
    struct Common {
        arg: i32,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[command(flatten)]
        common: Common,
    }

    let mut opt = Opt {
        common: Common { arg: 42 },
    };
    opt.try_update_from(["test"]).unwrap();
    assert_eq!(Opt::try_parse_from(["test", "42"]).unwrap(), opt);

    let mut opt = Opt {
        common: Common { arg: 42 },
    };
    opt.try_update_from(["test", "52"]).unwrap();
    assert_eq!(Opt::try_parse_from(["test", "52"]).unwrap(), opt);
}

#[derive(Subcommand, PartialEq, Debug)]
enum BaseCli {
    Command1(Command1),
}

#[derive(Args, PartialEq, Debug)]
struct Command1 {
    arg1: i32,

    arg2: i32,
}

#[derive(Args, PartialEq, Debug)]
struct Command2 {
    arg2: i32,
}

#[derive(Parser, PartialEq, Debug)]
enum Opt {
    #[command(flatten)]
    BaseCli(BaseCli),
    Command2(Command2),
}

#[test]
fn merge_subcommands_with_flatten() {
    assert_eq!(
        Opt::BaseCli(BaseCli::Command1(Command1 { arg1: 42, arg2: 44 })),
        Opt::try_parse_from(["test", "command1", "42", "44"]).unwrap()
    );
    assert_eq!(
        Opt::Command2(Command2 { arg2: 43 }),
        Opt::try_parse_from(["test", "command2", "43"]).unwrap()
    );
}

#[test]
fn update_subcommands_with_flatten() {
    let mut opt = Opt::BaseCli(BaseCli::Command1(Command1 { arg1: 12, arg2: 14 }));
    opt.try_update_from(["test", "command1", "42", "44"])
        .unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "command1", "42", "44"]).unwrap(),
        opt
    );

    let mut opt = Opt::BaseCli(BaseCli::Command1(Command1 { arg1: 12, arg2: 14 }));
    opt.try_update_from(["test", "command1", "42"]).unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "command1", "42", "14"]).unwrap(),
        opt
    );

    let mut opt = Opt::BaseCli(BaseCli::Command1(Command1 { arg1: 12, arg2: 14 }));
    opt.try_update_from(["test", "command2", "43"]).unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "command2", "43"]).unwrap(),
        opt
    );
}

#[test]
fn flatten_with_doc_comment() {
    #[derive(Args, PartialEq, Debug)]
    struct Common {
        /// This is an arg. Arg means "argument". Command line argument.
        arg: i32,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        /// The very important comment that clippy had me put here.
        /// It knows better.
        #[command(flatten)]
        common: Common,
    }
    assert_eq!(
        Opt {
            common: Common { arg: 42 }
        },
        Opt::try_parse_from(["test", "42"]).unwrap()
    );

    let help = utils::get_help::<Opt>();
    assert!(help.contains("This is an arg."));
    assert!(!help.contains("The very important"));
}

#[test]
fn docstrings_ordering_with_multiple_command() {
    /// This is the docstring for Flattened
    #[derive(Args)]
    struct Flattened {
        #[arg(long)]
        foo: bool,
    }

    /// This is the docstring for Command
    #[derive(Parser)]
    struct Command {
        #[command(flatten)]
        flattened: Flattened,
    }

    let short_help = utils::get_help::<Command>();

    assert!(short_help.contains("This is the docstring for Command"));
}

#[test]
fn docstrings_ordering_with_multiple_clap_partial() {
    /// This is the docstring for Flattened
    #[derive(Args)]
    struct Flattened {
        #[arg(long)]
        foo: bool,
    }

    #[derive(Parser)]
    struct Command {
        #[command(flatten)]
        flattened: Flattened,
    }

    let short_help = utils::get_help::<Command>();

    assert!(short_help.contains("This is the docstring for Flattened"));
}

#[test]
#[should_panic = "cannot `#[flatten]` an `Option<Args>` with `#[group(skip)]`"]
fn flatten_skipped_group() {
    #[derive(clap::Parser, Debug)]
    struct Cli {
        #[clap(flatten)]
        args: Option<Args>,
    }

    #[derive(clap::Args, Debug)]
    #[group(skip)]
    struct Args {
        #[clap(short)]
        param: bool,
    }

    Cli::try_parse_from(["test"]).unwrap();
}

```

`clap/tests/derive/generic.rs`:

```rs
use clap::{Args, Parser};

#[test]
fn generic_struct_flatten() {
    #[derive(Args, PartialEq, Debug)]
    struct Inner {
        pub(crate) answer: isize,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Outer<T: Args> {
        #[command(flatten)]
        pub(crate) inner: T,
    }

    assert_eq!(
        Outer {
            inner: Inner { answer: 42 }
        },
        Outer::parse_from(["--answer", "42"])
    );
}

#[test]
fn generic_struct_flatten_w_where_clause() {
    #[derive(Args, PartialEq, Debug)]
    struct Inner {
        pub(crate) answer: isize,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Outer<T>
    where
        T: Args,
    {
        #[command(flatten)]
        pub(crate) inner: T,
    }

    assert_eq!(
        Outer {
            inner: Inner { answer: 42 }
        },
        Outer::parse_from(["--answer", "42"])
    );
}

#[test]
fn generic_enum() {
    #[derive(Args, PartialEq, Debug)]
    struct Inner {
        pub(crate) answer: isize,
    }

    #[derive(Parser, PartialEq, Debug)]
    enum GenericEnum<T: Args> {
        Start(T),
        Stop,
    }

    assert_eq!(
        GenericEnum::Start(Inner { answer: 42 }),
        GenericEnum::parse_from(["test", "start", "42"])
    );
}

#[test]
fn generic_enum_w_where_clause() {
    #[derive(Args, PartialEq, Debug)]
    struct Inner {
        pub(crate) answer: isize,
    }

    #[derive(Parser, PartialEq, Debug)]
    enum GenericEnum<T>
    where
        T: Args,
    {
        Start(T),
        Stop,
    }

    assert_eq!(
        GenericEnum::Start(Inner { answer: 42 }),
        GenericEnum::parse_from(["test", "start", "42"])
    );
}

#[test]
fn generic_w_fromstr_trait_bound() {
    use std::str::FromStr;

    #[derive(Parser, PartialEq, Debug)]
    struct Opt<T>
    where
        T: FromStr + Send + Sync + Clone + 'static,
        <T as FromStr>::Err: std::error::Error + Sync + Send + 'static,
    {
        answer: T,
    }

    assert_eq!(
        Opt::<isize> { answer: 42 },
        Opt::<isize>::parse_from(["--answer", "42"])
    );
}

#[test]
fn generic_wo_trait_bound() {
    use std::time::Duration;

    #[derive(Parser, PartialEq, Debug)]
    struct Opt<T> {
        answer: isize,
        #[arg(skip)]
        took: Option<T>,
    }

    assert_eq!(
        Opt::<Duration> {
            answer: 42,
            took: None
        },
        Opt::<Duration>::parse_from(["--answer", "42"])
    );
}

#[test]
fn generic_where_clause_w_trailing_comma() {
    use std::str::FromStr;

    #[derive(Parser, PartialEq, Debug)]
    struct Opt<T>
    where
        T: FromStr + Send + Sync + Clone + 'static,
        <T as FromStr>::Err: std::error::Error + Sync + Send + 'static,
    {
        pub(crate) answer: T,
    }

    assert_eq!(
        Opt::<isize> { answer: 42 },
        Opt::<isize>::parse_from(["--answer", "42"])
    );
}

```

`clap/tests/derive/groups.rs`:

```rs
use clap::Parser;
use snapbox::str;

use crate::utils::assert_output;

#[test]
fn test_safely_nest_parser() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[command(flatten)]
        foo: Foo,
    }

    #[derive(Parser, Debug, PartialEq)]
    struct Foo {
        #[arg(long)]
        foo: bool,
    }

    assert_eq!(
        Opt {
            foo: Foo { foo: true }
        },
        Opt::try_parse_from(["test", "--foo"]).unwrap()
    );
}

#[test]
fn implicit_struct_group() {
    #[derive(Parser, Debug)]
    struct Opt {
        #[arg(short, long, requires = "Source")]
        add: bool,

        #[command(flatten)]
        source: Source,
    }

    #[derive(clap::Args, Debug)]
    struct Source {
        crates: Vec<String>,
        #[arg(long)]
        path: Option<std::path::PathBuf>,
        #[arg(long)]
        git: Option<String>,
    }

    let output = str![[r#"
error: the following required arguments were not provided:
  <CRATES|--path <PATH>|--git <GIT>>

Usage: prog --add <CRATES|--path <PATH>|--git <GIT>>

For more information, try '--help'.

"#]];
    assert_output::<Opt>("prog --add", output, true);

    use clap::Args;
    assert_eq!(Source::group_id(), Some(clap::Id::from("Source")));
    assert_eq!(Opt::group_id(), Some(clap::Id::from("Opt")));
}

#[test]
fn skip_group_avoids_duplicate_ids() {
    #[derive(Parser, Debug)]
    #[group(skip)]
    struct Opt {
        #[command(flatten)]
        first: Compose<Empty, Empty>,
        #[command(flatten)]
        second: Compose<Empty, Empty>,
    }

    #[derive(clap::Args, Debug)]
    #[group(skip)]
    pub(crate) struct Compose<L: Args, R: Args> {
        #[command(flatten)]
        pub(crate) left: L,
        #[command(flatten)]
        pub(crate) right: R,
    }

    #[derive(clap::Args, Clone, Copy, Debug)]
    #[group(skip)]
    pub(crate) struct Empty;

    use clap::CommandFactory;
    Opt::command().debug_assert();

    use clap::Args;
    assert_eq!(Empty::group_id(), None);
    assert_eq!(Compose::<Empty, Empty>::group_id(), None);
    assert_eq!(Opt::group_id(), None);
}

#[test]
fn optional_flatten() {
    #[derive(Parser, Debug, PartialEq, Eq)]
    struct Opt {
        #[command(flatten)]
        source: Option<Source>,
    }

    #[derive(clap::Args, Debug, PartialEq, Eq)]
    struct Source {
        crates: Vec<String>,
        #[arg(long)]
        path: Option<std::path::PathBuf>,
        #[arg(long)]
        git: Option<String>,
    }

    assert_eq!(Opt { source: None }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(
        Opt {
            source: Some(Source {
                crates: vec!["serde".to_owned()],
                path: None,
                git: None,
            }),
        },
        Opt::try_parse_from(["test", "serde"]).unwrap()
    );
    assert_eq!(
        Opt {
            source: Some(Source {
                crates: Vec::new(),
                path: Some("./".into()),
                git: None,
            }),
        },
        Opt::try_parse_from(["test", "--path=./"]).unwrap()
    );
}

#[test]
#[should_panic = "\
Command clap: Argument group name must be unique

\t'Compose' is already in use"]
fn helpful_panic_on_duplicate_groups() {
    #[derive(Parser, Debug)]
    struct Opt {
        #[command(flatten)]
        first: Compose<Empty, Empty>,
        #[command(flatten)]
        second: Compose<Empty, Empty>,
    }

    #[derive(clap::Args, Debug)]
    pub(crate) struct Compose<L: clap::Args, R: clap::Args> {
        #[command(flatten)]
        pub(crate) left: L,
        #[command(flatten)]
        pub(crate) right: R,
    }

    #[derive(clap::Args, Clone, Copy, Debug)]
    pub(crate) struct Empty;

    use clap::CommandFactory;
    Opt::command().debug_assert();
}

#[test]
fn custom_group_id() {
    #[derive(Parser, Debug, PartialEq, Eq)]
    struct Opt {
        #[command(flatten)]
        source: Option<Source>,
    }

    #[derive(clap::Args, Debug, PartialEq, Eq)]
    #[group(id = "source")]
    struct Source {
        crates: Vec<String>,
        #[arg(long)]
        path: Option<std::path::PathBuf>,
        #[arg(long)]
        git: Option<String>,
    }

    assert_eq!(Opt { source: None }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(
        Opt {
            source: Some(Source {
                crates: vec!["serde".to_owned()],
                path: None,
                git: None,
            }),
        },
        Opt::try_parse_from(["test", "serde"]).unwrap()
    );
    assert_eq!(
        Opt {
            source: Some(Source {
                crates: Vec::new(),
                path: Some("./".into()),
                git: None,
            }),
        },
        Opt::try_parse_from(["test", "--path=./"]).unwrap()
    );
}

#[test]
fn required_group() {
    #[derive(Parser, Debug, PartialEq, Eq)]
    struct Opt {
        #[command(flatten)]
        source: Source,
    }

    #[derive(clap::Args, Debug, PartialEq, Eq)]
    #[group(required = true, multiple = false)]
    struct Source {
        #[arg(long)]
        path: Option<std::path::PathBuf>,
        #[arg(long)]
        git: Option<String>,
    }

    assert_eq!(
        Opt {
            source: Source {
                path: Some("./".into()),
                git: None,
            },
        },
        Opt::try_parse_from(["test", "--path=./"]).unwrap()
    );

    let output = str![[r#"
error: the following required arguments were not provided:
  <--path <PATH>|--git <GIT>>

Usage: test <--path <PATH>|--git <GIT>>

For more information, try '--help'.

"#]];
    assert_output::<Opt>("test", output, true);
}

#[test]
#[cfg(feature = "error-context")]
#[cfg(feature = "suggestions")]
fn suggestion() {
    #[derive(Parser, Debug)]
    struct Args {
        name: String,

        #[arg(long)]
        hello: Option<u8>,

        #[arg(long)]
        count01: Vec<u8>,
        #[arg(long)]
        count02: Vec<u8>,
        #[arg(long)]
        count03: Vec<u8>,
        #[arg(long)]
        count04: Vec<u8>,
        #[arg(long)]
        count05: Vec<u8>,
        #[arg(long)]
        count06: Vec<u8>,
        #[arg(long)]
        count07: Vec<u8>,
        #[arg(long)]
        count08: Vec<u8>,
        #[arg(long)]
        count09: Vec<u8>,
        #[arg(long)]
        count10: Vec<u8>,
        #[arg(long)]
        count11: Vec<u8>,
        #[arg(long)]
        count12: Vec<u8>,
        #[arg(long)]
        count13: Vec<u8>,
        #[arg(long)]
        count14: Vec<u8>,
        #[arg(long)]
        count15: Vec<u8>,
        #[arg(long)]
        count16: Vec<u8>,
        #[arg(long)]
        count17: Vec<u8>,
        #[arg(long)]
        count18: Vec<u8>,
    }

    let output = str![[r#"
error: unexpected argument '--hell' found

  tip: a similar argument exists: '--hello'

Usage: test --hello <HELLO> <NAME>

For more information, try '--help'.

"#]];
    assert_output::<Args>("test --hell", output, true);
}

```

`clap/tests/derive/help.rs`:

```rs
use clap::{ArgAction, Args, CommandFactory, Parser, Subcommand};
use snapbox::assert_data_eq;
use snapbox::str;

#[test]
fn arg_help_heading_applied() {
    #[derive(Debug, Clone, Parser)]
    struct CliOptions {
        #[arg(long)]
        #[arg(help_heading = Some("HEADING A"))]
        should_be_in_section_a: u32,

        #[arg(long)]
        no_section: u32,
    }

    let cmd = CliOptions::command();

    let should_be_in_section_a = cmd
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_section_a")
        .unwrap();
    assert_eq!(should_be_in_section_a.get_help_heading(), Some("HEADING A"));

    let should_be_in_section_b = cmd
        .get_arguments()
        .find(|a| a.get_id() == "no_section")
        .unwrap();
    assert_eq!(should_be_in_section_b.get_help_heading(), None);
}

#[test]
fn app_help_heading_applied() {
    #[derive(Debug, Clone, Parser)]
    #[command(next_help_heading = "DEFAULT")]
    struct CliOptions {
        #[arg(long)]
        #[arg(help_heading = Some("HEADING A"))]
        should_be_in_section_a: u32,

        #[arg(long)]
        should_be_in_default_section: u32,
    }

    let cmd = CliOptions::command();

    let should_be_in_section_a = cmd
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_section_a")
        .unwrap();
    assert_eq!(should_be_in_section_a.get_help_heading(), Some("HEADING A"));

    let should_be_in_default_section = cmd
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_default_section")
        .unwrap();
    assert_eq!(
        should_be_in_default_section.get_help_heading(),
        Some("DEFAULT")
    );
}

#[test]
fn app_help_heading_flattened() {
    // Used to help track the cause in tests
    #![allow(clippy::enum_variant_names)]

    #[derive(Debug, Clone, Parser)]
    struct CliOptions {
        #[command(flatten)]
        options_a: OptionsA,

        #[command(flatten)]
        options_b: OptionsB,

        #[command(subcommand)]
        sub_a: SubA,

        #[arg(long)]
        should_be_in_default_section: u32,
    }

    #[derive(Debug, Clone, Args)]
    #[command(next_help_heading = "HEADING A")]
    struct OptionsA {
        #[arg(long)]
        should_be_in_section_a: u32,
    }

    #[derive(Debug, Clone, Args)]
    #[command(next_help_heading = "HEADING B")]
    struct OptionsB {
        #[arg(long)]
        should_be_in_section_b: u32,
    }

    #[derive(Debug, Clone, Subcommand)]
    enum SubA {
        #[command(flatten)]
        SubB(SubB),
        #[command(subcommand)]
        SubC(SubC),
        SubAOne,
        #[command(next_help_heading = "SUB A")]
        SubATwo {
            should_be_in_sub_a: u32,
        },
    }

    #[derive(Debug, Clone, Subcommand)]
    enum SubB {
        #[command(next_help_heading = "SUB B")]
        SubBOne { should_be_in_sub_b: u32 },
    }

    #[derive(Debug, Clone, Subcommand)]
    enum SubC {
        #[command(next_help_heading = "SUB C")]
        SubCOne { should_be_in_sub_c: u32 },
    }

    let cmd = CliOptions::command();

    let should_be_in_section_a = cmd
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_section_a")
        .unwrap();
    assert_eq!(should_be_in_section_a.get_help_heading(), Some("HEADING A"));

    let should_be_in_section_b = cmd
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_section_b")
        .unwrap();
    assert_eq!(should_be_in_section_b.get_help_heading(), Some("HEADING B"));

    let should_be_in_section_b = cmd
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_default_section")
        .unwrap();
    assert_eq!(should_be_in_section_b.get_help_heading(), Some("HEADING B"));

    let sub_a_two = cmd.find_subcommand("sub-a-two").unwrap();

    let should_be_in_sub_a = sub_a_two
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_sub_a")
        .unwrap();
    assert_eq!(should_be_in_sub_a.get_help_heading(), Some("SUB A"));

    let sub_b_one = cmd.find_subcommand("sub-b-one").unwrap();

    let should_be_in_sub_b = sub_b_one
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_sub_b")
        .unwrap();
    assert_eq!(should_be_in_sub_b.get_help_heading(), Some("SUB B"));

    let sub_c = cmd.find_subcommand("sub-c").unwrap();
    let sub_c_one = sub_c.find_subcommand("sub-c-one").unwrap();

    let should_be_in_sub_c = sub_c_one
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_sub_c")
        .unwrap();
    assert_eq!(should_be_in_sub_c.get_help_heading(), Some("SUB C"));
}

#[test]
fn flatten_field_with_help_heading() {
    #[derive(Debug, Clone, Parser)]
    struct CliOptions {
        #[command(flatten)]
        #[command(next_help_heading = "HEADING A")]
        options_a: OptionsA,
    }

    #[derive(Debug, Clone, Args)]
    struct OptionsA {
        #[arg(long)]
        should_be_in_section_a: u32,
    }

    let cmd = CliOptions::command();

    let should_be_in_section_a = cmd
        .get_arguments()
        .find(|a| a.get_id() == "should_be_in_section_a")
        .unwrap();
    assert_eq!(should_be_in_section_a.get_help_heading(), Some("HEADING A"));
}

// The challenge with this test is creating an error situation not caught by `clap`'s error checking
// but by the code that `clap_derive` generates.
//
// Ultimately, the easiest way to confirm is to put a debug statement in the desired error path.
#[test]
fn derive_generated_error_has_full_context() {
    #[derive(Debug, Parser)]
    #[command(subcommand_negates_reqs = true)]
    struct Opts {
        #[arg(long)]
        req_str: String,

        #[command(subcommand)]
        cmd: Option<SubCommands>,
    }

    #[derive(Debug, Parser)]
    enum SubCommands {
        Sub {
            #[arg(short, long, action = clap::ArgAction::Count)]
            verbose: u8,
        },
    }

    let result = Opts::try_parse_from(["test", "sub"]);
    assert!(
        result.is_err(),
        "`SubcommandsNegateReqs` with non-optional `req_str` should fail: {:?}",
        result.unwrap()
    );

    let expected = str![[r#"
error: The following required argument was not provided: req_str

Usage: clap --req-str <REQ_STR>
       clap <COMMAND>

For more information, try '--help'.

"#]];
    assert_data_eq!(result.unwrap_err().to_string(), expected);
}

#[test]
fn derive_order_next_order() {
    #[derive(Parser, Debug)]
    #[command(name = "test", version = "1.2")]
    struct Args {
        #[command(flatten)]
        a: A,
        #[command(flatten)]
        b: B,
    }

    #[derive(Args, Debug)]
    #[command(next_display_order = 10000)]
    struct A {
        /// second flag
        #[arg(long)]
        flag_a: bool,
        /// second option
        #[arg(long)]
        option_a: Option<String>,
    }

    #[derive(Args, Debug)]
    #[command(next_display_order = 10)]
    struct B {
        /// first flag
        #[arg(long)]
        flag_b: bool,
        /// first option
        #[arg(long)]
        option_b: Option<String>,
    }

    use clap::CommandFactory;
    let mut cmd = Args::command();

    let help = cmd.render_help().to_string();
    assert_data_eq!(
        help,
        snapbox::str![[r#"
Usage: test [OPTIONS]

Options:
      --flag-b               first flag
      --option-b <OPTION_B>  first option
  -h, --help                 Print help
  -V, --version              Print version
      --flag-a               second flag
      --option-a <OPTION_A>  second option

"#]],
    );
}

#[test]
fn derive_order_next_order_flatten() {
    #[derive(Parser, Debug)]
    #[command(name = "test", version = "1.2")]
    struct Args {
        #[command(flatten)]
        #[command(next_display_order = 10000)]
        a: A,
        #[command(flatten)]
        #[command(next_display_order = 10)]
        b: B,
    }

    #[derive(Args, Debug)]
    struct A {
        /// second flag
        #[arg(long)]
        flag_a: bool,
        /// second option
        #[arg(long)]
        option_a: Option<String>,
    }

    #[derive(Args, Debug)]
    struct B {
        /// first flag
        #[arg(long)]
        flag_b: bool,
        /// first option
        #[arg(long)]
        option_b: Option<String>,
    }

    use clap::CommandFactory;
    let mut cmd = Args::command();

    let help = cmd.render_help().to_string();
    assert_data_eq!(
        help,
        snapbox::str![[r#"
Usage: test [OPTIONS]

Options:
      --flag-b               first flag
      --option-b <OPTION_B>  first option
  -h, --help                 Print help
  -V, --version              Print version
      --flag-a               second flag
      --option-a <OPTION_A>  second option

"#]],
    );
}

#[test]
fn derive_order_no_next_order() {
    #[derive(Parser, Debug)]
    #[command(name = "test", version = "1.2")]
    #[command(next_display_order = None)]
    struct Args {
        #[command(flatten)]
        a: A,
        #[command(flatten)]
        b: B,
    }

    #[derive(Args, Debug)]
    struct A {
        /// first flag
        #[arg(long)]
        flag_a: bool,
        /// first option
        #[arg(long)]
        option_a: Option<String>,
    }

    #[derive(Args, Debug)]
    struct B {
        /// second flag
        #[arg(long)]
        flag_b: bool,
        /// second option
        #[arg(long)]
        option_b: Option<String>,
    }

    use clap::CommandFactory;
    let mut cmd = Args::command();

    let help = cmd.render_help().to_string();
    assert_data_eq!(help, str![[r#"
Usage: test [OPTIONS]

Options:
      --flag-a               first flag
      --flag-b               second flag
  -h, --help                 Print help
      --option-a <OPTION_A>  first option
      --option-b <OPTION_B>  second option
  -V, --version              Print version

"#]]);
}

#[test]
fn derive_possible_value_help() {
    /// Application help
    #[derive(Parser, PartialEq, Debug)]
    struct Args {
        /// Argument help
        #[arg(value_enum)]
        arg: ArgChoice,
    }

    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        /// Foo help
        Foo,
        /// Bar help
        Bar,
    }

    use clap::CommandFactory;
    let mut cmd = Args::command();

    let help = cmd.render_long_help().to_string();
    assert_data_eq!(
        help,
        str![[r#"
Application help

Usage: clap <ARG>

Arguments:
  <ARG>
          Argument help

          Possible values:
          - foo: Foo help
          - bar: Bar help

Options:
  -h, --help
          Print help (see a summary with '-h')

"#]]
    );
}

#[test]
fn custom_help_flag() {
    #[derive(Debug, Clone, Parser)]
    #[command(disable_help_flag = true)]
    struct CliOptions {
        #[arg(short = 'h', long = "verbose-help", action = ArgAction::Help, value_parser = clap::value_parser!(bool))]
        help: (),
    }

    let result = CliOptions::try_parse_from(["cmd", "--verbose-help"]);
    let err = result.unwrap_err();
    assert_eq!(err.kind(), clap::error::ErrorKind::DisplayHelp);

    CliOptions::try_parse_from(["cmd"]).unwrap();
}

#[test]
fn custom_version_flag() {
    #[derive(Debug, Clone, Parser)]
    #[command(disable_version_flag = true, version = "2.0.0")]
    struct CliOptions {
        #[arg(short = 'V', long = "verbose-version", action = ArgAction::Version, value_parser = clap::value_parser!(bool))]
        version: (),
    }

    let result = CliOptions::try_parse_from(["cmd", "--verbose-version"]);
    let err = result.unwrap_err();
    assert_eq!(err.kind(), clap::error::ErrorKind::DisplayVersion);

    CliOptions::try_parse_from(["cmd"]).unwrap();
}

```

`clap/tests/derive/issues.rs`:

```rs
// https://github.com/TeXitoi/structopt/issues/{NUMBER}

use crate::utils;

use clap::{ArgGroup, Args, Parser, Subcommand};

#[test]
fn issue_151_groups_within_subcommands() {
    #[derive(Args, Debug)]
    #[command(group = ArgGroup::new("verb").required(true).multiple(true))]
    struct Opt {
        #[arg(long, group = "verb")]
        foo: Option<String>,
        #[arg(long, group = "verb")]
        bar: Option<String>,
    }

    #[derive(Debug, Parser)]
    struct Cli {
        #[command(flatten)]
        a: Opt,
    }

    assert!(Cli::try_parse_from(["test"]).is_err());
    assert!(Cli::try_parse_from(["test", "--foo=v1"]).is_ok());
    assert!(Cli::try_parse_from(["test", "--bar=v2"]).is_ok());
    assert!(Cli::try_parse_from(["test", "--zebra=v3"]).is_err());
    assert!(Cli::try_parse_from(["test", "--foo=v1", "--bar=v2"]).is_ok());
}

#[test]
fn issue_289() {
    #[derive(Parser)]
    #[command(infer_subcommands = true)]
    enum Args {
        SomeCommand {
            #[command(subcommand)]
            sub: SubSubCommand,
        },
        AnotherCommand,
    }

    #[derive(Subcommand)]
    #[command(infer_subcommands = true)]
    enum SubSubCommand {
        TestCommand,
    }

    assert!(Args::try_parse_from(["test", "some-command", "test-command"]).is_ok());
    assert!(Args::try_parse_from(["test", "some", "test-command"]).is_ok());
    assert!(Args::try_parse_from(["test", "some-command", "test"]).is_ok());
    assert!(Args::try_parse_from(["test", "some", "test"]).is_ok());
}

#[test]
fn issue_324() {
    fn my_version() -> &'static str {
        "MY_VERSION"
    }

    #[derive(Parser)]
    #[command(version = my_version())]
    #[command(help_template = utils::FULL_TEMPLATE)]
    struct Opt {
        #[command(subcommand)]
        _cmd: SubCommand,
    }

    #[derive(Subcommand)]
    enum SubCommand {
        Start,
    }

    let help = utils::get_long_help::<Opt>();
    assert!(help.contains("MY_VERSION"));
}

#[test]
fn issue_418() {
    #[derive(Debug, Parser)]
    struct Opts {
        #[command(subcommand)]
        /// The command to run
        command: Command,
    }

    #[derive(Debug, Subcommand)]
    enum Command {
        /// Reticulate the splines
        #[command(visible_alias = "ret")]
        Reticulate {
            /// How many splines
            num_splines: u8,
        },
        /// Frobnicate the rest
        #[command(visible_alias = "frob")]
        Frobnicate,
    }

    let help = utils::get_long_help::<Opts>();
    assert!(help.contains("Reticulate the splines [aliases: ret]"));
}

#[test]
fn issue_490() {
    use clap::Parser;
    use std::iter::FromIterator;
    use std::str::FromStr;

    struct U16ish;
    impl FromStr for U16ish {
        type Err = ();
        fn from_str(_: &str) -> Result<Self, Self::Err> {
            unimplemented!()
        }
    }
    impl<'a> FromIterator<&'a U16ish> for Vec<u16> {
        fn from_iter<T: IntoIterator<Item = &'a U16ish>>(_: T) -> Self {
            unimplemented!()
        }
    }

    #[derive(Parser, Debug)]
    struct Opt {
        opt_vec: Vec<u16>,
        #[arg(long)]
        opt_opt_vec: Option<Vec<u16>>,
    }

    // Assert that it compiles
}

```

`clap/tests/derive/macros.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use clap::Parser;

// Tests that clap_derive properly detects an `Option` field
// that results from a macro expansion
#[test]
fn use_option() {
    macro_rules! expand_ty {
        ($name:ident: $ty:ty) => {
            #[derive(Parser)]
            struct Outer {
                #[arg(short, long)]
                #[allow(dead_code)]
                $name: $ty,
            }
        };
    }

    expand_ty!(my_field: Option<String>);
}

#[test]
fn issue_447() {
    macro_rules! Command {
        ( $name:ident, [
        #[$meta:meta] $var:ident($inner:ty)
      ] ) => {
            #[derive(Debug, PartialEq, clap::Parser)]
            enum $name {
                #[$meta]
                $var($inner),
            }
        };
    }

    Command! {GitCmd, [
      #[command(external_subcommand)]
      Ext(Vec<String>)
    ]}
}

```

`clap/tests/derive/main.rs`:

```rs
#![cfg(feature = "derive")]
#![cfg(feature = "help")]
#![cfg(feature = "usage")]

automod::dir!("tests/derive");

```

`clap/tests/derive/markdown.rs`:

```rs
#![cfg(feature = "unstable-markdown")]

use clap::CommandFactory;
use clap_derive::Parser;
use snapbox::file;

macro_rules! assert_help {
    ($Command:ty, $filename:literal) => {{
        let help = <$Command>::command().render_long_help().ansi().to_string();
        snapbox::assert_data_eq!(help, file![$filename]);
    }};
}

#[test]
fn headers() {
    /// # This is a header
    /// ## second level
    /// ### `additional` *styling **on ~top~ of** it*
    /// regular paragraph
    #[derive(Parser)]
    struct Command;

    assert_help!(Command, "snapshots/headers.term.svg");
}

#[test]
fn inline_styles() {
    /// *emphasis* **bold** ~strike through~ `code`
    ///
    /// *all **of ~them `combined` in~ one** line*
    #[derive(Parser)]
    struct Command;

    assert_help!(Command, "snapshots/inline_styles.term.svg");
}

#[test]
fn links() {
    /// <https://example.com/literal>
    ///
    /// [with name](https://example.com/with%20name)
    ///
    /// ![image](https://example.com/image)
    ///
    /// [referencing][reference]
    ///
    /// [reference]: https://example.com/reference
    #[derive(Parser)]
    struct Command;

    assert_help!(Command, "snapshots/links.term.svg");
}

#[test]
fn html() {
    /// <html>
    ///     <is>
    ///         <used>
    ///     </verbatim>
    /// </html>
    ///
    /// <inline>html</as-well>
    #[derive(Parser)]
    struct Command;

    assert_help!(Command, "snapshots/html.term.svg");
}

#[test]
fn blocks() {
    /// ```rust
    /// This is a *fenced* code block.
    ///
    /// There is not much going on in terms of **styling**.
    /// ```
    ///
    /// ---
    ///
    ///     Code blocks can also be initiated through
    ///     Indentation.
    ///
    /// > This is a block quote.
    /// > **Regular ~styling *should* work~ here.**
    /// >
    /// > # even headings
    /// > and regular paragraphs.
    /// >
    /// > - lists
    /// >   - are
    /// >
    /// > 1. also
    /// >    1. supported
    /// >
    /// > > nesting them
    /// > > > also works (not)
    ///
    #[derive(Parser)]
    struct Command;

    assert_help!(Command, "snapshots/blocks.term.svg");
}

#[test]
fn lists() {
    /// Lists:
    ///
    /// - unordered
    ///   - bullet
    ///     - lists
    /// - with multiple
    ///   - levels
    ///
    /// 0. numeric lists
    /// 1. only care
    ///    1. about the initial number
    /// 2. 5. and count from there
    ///    7. anything goes
    /// 3. though they need an empty line
    #[derive(Parser)]
    struct Command;

    assert_help!(Command, "snapshots/lists.term.svg");
}

#[test]
fn paragraphs() {
    /// Paragraphs are separated by empty lines.
    /// All lines will be joined onto one.
    ///
    /// The first paragraph is used as short help by clap.\
    /// backslashes can be used to insert hard line breaks.
    ///
    /// | these | can   |\
    /// | ----- | ----- |\
    /// | be    | used  |\
    /// | for   | tables|
    ///
    /// Because tables are not yet supported.
    ///
    #[doc = "You can also use trailing spaces for hard breaks,  \nbut this is not really recommended."]
    #[derive(Parser)]
    struct Command;

    assert_help!(Command, "snapshots/paragraphs.term.svg");
}

```

`clap/tests/derive/naming.rs`:

```rs
use clap::Args;
use clap::Parser;

#[test]
fn test_standalone_long_generates_kebab_case() {
    #[derive(Parser, Debug, PartialEq)]
    #[allow(non_snake_case)]
    struct Opt {
        #[arg(long)]
        FOO_OPTION: bool,
    }

    assert_eq!(
        Opt { FOO_OPTION: true },
        Opt::try_parse_from(["test", "--foo-option"]).unwrap()
    );
}

#[test]
fn test_custom_long_overwrites_default_name() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(long = "foo")]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "--foo"]).unwrap()
    );
}

#[test]
fn test_standalone_long_uses_previous_defined_custom_name() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(id = "foo", long)]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "--foo"]).unwrap()
    );
}

#[test]
fn test_standalone_long_ignores_afterwards_defined_custom_name() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(long, id = "foo")]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "--foo-option"]).unwrap()
    );
}

#[test]
fn test_standalone_long_uses_previous_defined_custom_id() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(id = "foo", long)]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "--foo"]).unwrap()
    );
}

#[test]
fn test_standalone_long_ignores_afterwards_defined_custom_id() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(long, id = "foo")]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "--foo-option"]).unwrap()
    );
}

#[test]
fn test_standalone_short_generates_kebab_case() {
    #[derive(Parser, Debug, PartialEq)]
    #[allow(non_snake_case)]
    struct Opt {
        #[arg(short)]
        FOO_OPTION: bool,
    }

    assert_eq!(
        Opt { FOO_OPTION: true },
        Opt::try_parse_from(["test", "-f"]).unwrap()
    );
}

#[test]
fn test_custom_short_overwrites_default_name() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short = 'o')]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "-o"]).unwrap()
    );
}

#[test]
fn test_standalone_short_uses_previous_defined_custom_name() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(id = "option", short)]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "-o"]).unwrap()
    );
}

#[test]
fn test_standalone_short_ignores_afterwards_defined_custom_name() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short, id = "option")]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "-f"]).unwrap()
    );
}

#[test]
fn test_standalone_short_uses_previous_defined_custom_id() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(id = "option", short)]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "-o"]).unwrap()
    );
}

#[test]
fn test_standalone_short_ignores_afterwards_defined_custom_id() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short, id = "option")]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "-f"]).unwrap()
    );
}

#[test]
fn test_standalone_long_uses_previous_defined_casing() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(rename_all = "screaming_snake", long)]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "--FOO_OPTION"]).unwrap()
    );
}

#[test]
fn test_standalone_short_uses_previous_defined_casing() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(rename_all = "screaming_snake", short)]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "-F"]).unwrap()
    );
}

#[test]
fn test_standalone_long_works_with_verbatim_casing() {
    #[derive(Parser, Debug, PartialEq)]
    #[allow(non_snake_case)]
    struct Opt {
        #[arg(rename_all = "verbatim", long)]
        _fOO_oPtiON: bool,
    }

    assert_eq!(
        Opt { _fOO_oPtiON: true },
        Opt::try_parse_from(["test", "--_fOO_oPtiON"]).unwrap()
    );
}

#[test]
fn test_standalone_short_works_with_verbatim_casing() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(rename_all = "verbatim", short)]
        _foo: bool,
    }

    assert_eq!(
        Opt { _foo: true },
        Opt::try_parse_from(["test", "-_"]).unwrap()
    );
}

#[test]
fn test_rename_all_is_propagated_from_struct_to_fields() {
    #[derive(Parser, Debug, PartialEq)]
    #[command(rename_all = "screaming_snake")]
    struct Opt {
        #[arg(long)]
        foo: bool,
    }

    assert_eq!(
        Opt { foo: true },
        Opt::try_parse_from(["test", "--FOO"]).unwrap()
    );
}

#[test]
fn test_rename_all_is_not_propagated_from_struct_into_flattened() {
    #[derive(Parser, Debug, PartialEq)]
    #[command(rename_all = "screaming_snake")]
    struct Opt {
        #[command(flatten)]
        foo: Foo,
    }

    #[derive(Args, Debug, PartialEq)]
    struct Foo {
        #[arg(long)]
        foo: bool,
    }

    assert_eq!(
        Opt {
            foo: Foo { foo: true }
        },
        Opt::try_parse_from(["test", "--foo"]).unwrap()
    );
}

#[test]
fn test_lower_is_renamed() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(rename_all = "lower", long)]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "--foooption"]).unwrap()
    );
}

#[test]
fn test_upper_is_renamed() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(rename_all = "upper", long)]
        foo_option: bool,
    }

    assert_eq!(
        Opt { foo_option: true },
        Opt::try_parse_from(["test", "--FOOOPTION"]).unwrap()
    );
}

#[test]
fn test_single_word_enum_variant_is_default_renamed_into_kebab_case() {
    #[derive(Parser, Debug, PartialEq)]
    enum Opt {
        Command { foo: u32 },
    }

    assert_eq!(
        Opt::Command { foo: 0 },
        Opt::try_parse_from(["test", "command", "0"]).unwrap()
    );
}

#[test]
fn test_multi_word_enum_variant_is_renamed() {
    #[derive(Parser, Debug, PartialEq)]
    enum Opt {
        FirstCommand { foo: u32 },
    }

    assert_eq!(
        Opt::FirstCommand { foo: 0 },
        Opt::try_parse_from(["test", "first-command", "0"]).unwrap()
    );
}

#[test]
fn test_rename_all_is_not_propagated_from_struct_into_subcommand() {
    #[derive(Parser, Debug, PartialEq)]
    #[command(rename_all = "screaming_snake")]
    struct Opt {
        #[command(subcommand)]
        foo: Foo,
    }

    #[derive(Parser, Debug, PartialEq)]
    enum Foo {
        Command {
            #[arg(long)]
            foo: bool,
        },
    }

    assert_eq!(
        Opt {
            foo: Foo::Command { foo: true }
        },
        Opt::try_parse_from(["test", "command", "--foo"]).unwrap()
    );
}

#[test]
fn test_rename_all_is_propagated_from_enum_to_variants() {
    #[derive(Parser, Debug, PartialEq)]
    #[command(rename_all = "screaming_snake")]
    enum Opt {
        FirstVariant,
        SecondVariant {
            #[arg(long)]
            foo: String,
        },
    }

    assert_eq!(
        Opt::FirstVariant,
        Opt::try_parse_from(["test", "FIRST_VARIANT"]).unwrap()
    );
}

#[test]
fn test_rename_all_is_propagated_from_enum_to_variant_fields() {
    #[derive(Parser, Debug, PartialEq)]
    #[command(rename_all = "screaming_snake")]
    enum Opt {
        FirstVariant,
        SecondVariant {
            #[arg(long)]
            foo: String,
        },
    }

    assert_eq!(
        Opt::SecondVariant {
            foo: "value".into()
        },
        Opt::try_parse_from(["test", "SECOND_VARIANT", "--FOO", "value"]).unwrap()
    );
}

#[test]
fn test_rename_all_is_propagation_can_be_overridden() {
    #[derive(Parser, Debug, PartialEq)]
    #[command(rename_all = "screaming_snake")]
    enum Opt {
        #[command(rename_all = "kebab_case")]
        FirstVariant {
            #[arg(long)]
            foo_option: bool,
        },
        SecondVariant {
            #[arg(rename_all = "kebab_case", long)]
            foo_option: bool,
        },
    }

    assert_eq!(
        Opt::FirstVariant { foo_option: true },
        Opt::try_parse_from(["test", "first-variant", "--foo-option"]).unwrap()
    );

    assert_eq!(
        Opt::SecondVariant { foo_option: true },
        Opt::try_parse_from(["test", "SECOND_VARIANT", "--foo-option"]).unwrap()
    );
}

```

`clap/tests/derive/nested_subcommands.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use clap::{Parser, Subcommand};

#[derive(Parser, PartialEq, Debug)]
struct Opt {
    #[arg(short, long)]
    force: bool,
    #[arg(short, long, action = clap::ArgAction::Count)]
    verbose: u8,
    #[command(subcommand)]
    cmd: Sub,
}

#[derive(Subcommand, PartialEq, Debug)]
enum Sub {
    Fetch {},
    Add {},
}

#[derive(Parser, PartialEq, Debug)]
struct Opt2 {
    #[arg(short, long)]
    force: bool,
    #[arg(short, long, action = clap::ArgAction::Count)]
    verbose: u8,
    #[command(subcommand)]
    cmd: Option<Sub>,
}

#[test]
fn test_no_cmd() {
    let result = Opt::try_parse_from(["test"]);
    assert!(result.is_err());

    assert_eq!(
        Opt2 {
            force: false,
            verbose: 0,
            cmd: None
        },
        Opt2::try_parse_from(["test"]).unwrap()
    );
}

#[test]
fn test_fetch() {
    assert_eq!(
        Opt {
            force: false,
            verbose: 3,
            cmd: Sub::Fetch {}
        },
        Opt::try_parse_from(["test", "-vvv", "fetch"]).unwrap()
    );
    assert_eq!(
        Opt {
            force: true,
            verbose: 0,
            cmd: Sub::Fetch {}
        },
        Opt::try_parse_from(["test", "--force", "fetch"]).unwrap()
    );
}

#[test]
fn test_add() {
    assert_eq!(
        Opt {
            force: false,
            verbose: 0,
            cmd: Sub::Add {}
        },
        Opt::try_parse_from(["test", "add"]).unwrap()
    );
    assert_eq!(
        Opt {
            force: false,
            verbose: 2,
            cmd: Sub::Add {}
        },
        Opt::try_parse_from(["test", "-vv", "add"]).unwrap()
    );
}

#[test]
fn test_badinput() {
    let result = Opt::try_parse_from(["test", "badcmd"]);
    assert!(result.is_err());
    let result = Opt::try_parse_from(["test", "add", "--verbose"]);
    assert!(result.is_err());
    let result = Opt::try_parse_from(["test", "--badopt", "add"]);
    assert!(result.is_err());
    let result = Opt::try_parse_from(["test", "add", "--badopt"]);
    assert!(result.is_err());
}

#[derive(Parser, PartialEq, Debug)]
struct Opt3 {
    #[arg(short, long)]
    all: bool,
    #[command(subcommand)]
    cmd: Sub2,
}

#[derive(Subcommand, PartialEq, Debug)]
enum Sub2 {
    Foo {
        file: String,
        #[command(subcommand)]
        cmd: Sub3,
    },
    Bar {},
}

#[derive(Subcommand, PartialEq, Debug)]
enum Sub3 {
    Baz {},
    Quux {},
}

#[test]
fn test_subsubcommand() {
    assert_eq!(
        Opt3 {
            all: true,
            cmd: Sub2::Foo {
                file: "lib.rs".to_string(),
                cmd: Sub3::Quux {}
            }
        },
        Opt3::try_parse_from(["test", "--all", "foo", "lib.rs", "quux"]).unwrap()
    );
}

#[derive(Parser, PartialEq, Debug)]
enum SubSubCmdWithOption {
    Remote {
        #[command(subcommand)]
        cmd: Option<Remote>,
    },
    Stash {
        #[command(subcommand)]
        cmd: Stash,
    },
}
#[derive(Subcommand, PartialEq, Debug)]
enum Remote {
    Add { name: String, url: String },
    Remove { name: String },
}

#[derive(Subcommand, PartialEq, Debug)]
enum Stash {
    Save,
    Pop,
}

#[test]
fn sub_sub_cmd_with_option() {
    fn make(args: &[&str]) -> Option<SubSubCmdWithOption> {
        SubSubCmdWithOption::try_parse_from(args).ok()
    }
    assert_eq!(
        Some(SubSubCmdWithOption::Remote { cmd: None }),
        make(&["", "remote"])
    );
    assert_eq!(
        Some(SubSubCmdWithOption::Remote {
            cmd: Some(Remote::Add {
                name: "origin".into(),
                url: "http".into()
            })
        }),
        make(&["", "remote", "add", "origin", "http"])
    );
    assert_eq!(
        Some(SubSubCmdWithOption::Stash { cmd: Stash::Save }),
        make(&["", "stash", "save"])
    );
    assert_eq!(None, make(&["", "stash"]));
}

```

`clap/tests/derive/non_literal_attributes.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use clap::error::ErrorKind;
use clap::Parser;
use std::num::ParseIntError;

pub(crate) const DISPLAY_ORDER: usize = 2;

// Check if the global settings compile
#[derive(Parser, Debug, PartialEq, Eq)]
#[command(group = clap::ArgGroup::new("foo"))]
struct Opt {
    #[arg(
        long = "x",
        display_order = DISPLAY_ORDER,
        next_line_help = true,
        default_value = "0",
        require_equals = true,
    )]
    x: i32,

    #[arg(short = 'l', long = "level", aliases = ["set-level", "lvl"])]
    level: String,

    #[arg(long("values"))]
    values: Vec<i32>,

    #[arg(id = "FILE", requires_if("FILE", "values"))]
    files: Vec<String>,
}

#[test]
fn test_slice() {
    assert_eq!(
        Opt {
            x: 0,
            level: "1".to_string(),
            files: Vec::new(),
            values: vec![],
        },
        Opt::try_parse_from(["test", "-l", "1"]).unwrap()
    );
    assert_eq!(
        Opt {
            x: 0,
            level: "1".to_string(),
            files: Vec::new(),
            values: vec![],
        },
        Opt::try_parse_from(["test", "--level", "1"]).unwrap()
    );
    assert_eq!(
        Opt {
            x: 0,
            level: "1".to_string(),
            files: Vec::new(),
            values: vec![],
        },
        Opt::try_parse_from(["test", "--set-level", "1"]).unwrap()
    );
    assert_eq!(
        Opt {
            x: 0,
            level: "1".to_string(),
            files: Vec::new(),
            values: vec![],
        },
        Opt::try_parse_from(["test", "--lvl", "1"]).unwrap()
    );
}

#[test]
fn test_multi_args() {
    assert_eq!(
        Opt {
            x: 0,
            level: "1".to_string(),
            files: vec!["file".to_string()],
            values: vec![],
        },
        Opt::try_parse_from(["test", "-l", "1", "file"]).unwrap()
    );
    assert_eq!(
        Opt {
            x: 0,
            level: "1".to_string(),
            files: vec!["FILE".to_string()],
            values: vec![1],
        },
        Opt::try_parse_from(["test", "-l", "1", "--values", "1", "--", "FILE"]).unwrap()
    );
}

#[test]
fn test_multi_args_fail() {
    let result = Opt::try_parse_from(["test", "-l", "1", "--", "FILE"]);
    assert!(result.is_err());
}

#[test]
fn test_bool() {
    assert_eq!(
        Opt {
            x: 1,
            level: "1".to_string(),
            files: vec![],
            values: vec![],
        },
        Opt::try_parse_from(["test", "-l", "1", "--x=1"]).unwrap()
    );
    let result = Opt::try_parse_from(["test", "-l", "1", "--x", "1"]);
    assert!(result.is_err());
    assert_eq!(result.unwrap_err().kind(), ErrorKind::NoEquals);
}

#[test]
#[cfg(feature = "error-context")]
fn test_parse_hex_function_path() {
    #[derive(Parser, PartialEq, Debug)]
    struct HexOpt {
        #[arg(short, value_parser = parse_hex)]
        number: u64,
    }

    fn parse_hex(input: &str) -> Result<u64, ParseIntError> {
        u64::from_str_radix(input, 16)
    }

    assert_eq!(
        HexOpt { number: 5 },
        HexOpt::try_parse_from(["test", "-n", "5"]).unwrap()
    );
    assert_eq!(
        HexOpt {
            number: 0x00ab_cdef
        },
        HexOpt::try_parse_from(["test", "-n", "abcdef"]).unwrap()
    );

    let err = HexOpt::try_parse_from(["test", "-n", "gg"]).unwrap_err();
    assert!(
        err.to_string().contains("invalid digit found in string"),
        "{}",
        err
    );
}

#[test]
#[cfg(feature = "error-context")]
fn test_const_name() {
    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(id = NAME, short, long)]
        number: u64,
    }

    const NAME: &str = "fun";

    assert_eq!(
        Opt { number: 5 },
        Opt::try_parse_from(["test", "-f", "5"]).unwrap()
    );
}

```

`clap/tests/derive/occurrences.rs`:

```rs
#![cfg(feature = "unstable-v5")]
use clap::Parser;

#[test]
fn test_vec_of_vec() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short = 'p', num_args = 2)]
        points: Vec<Vec<i32>>,
    }

    assert_eq!(
        Opt {
            points: vec![vec![1, 2], vec![0, 0]]
        },
        Opt::try_parse_from(["test", "-p", "1", "2", "-p", "0", "0"]).unwrap()
    );
}

#[test]
fn test_vec_of_vec_opt_out() {
    fn parser(s: &str) -> Result<Vec<String>, std::convert::Infallible> {
        Ok(s.split(',').map(str::to_owned).collect())
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_parser = parser, short = 'p')]
        arg: Vec<::std::vec::Vec<String>>,
    }

    assert_eq!(
        Opt {
            arg: vec![vec!["1".into(), "2".into()], vec!["a".into(), "b".into()]],
        },
        Opt::try_parse_from(["test", "-p", "1,2", "-p", "a,b"]).unwrap(),
    );
}

#[test]
fn test_vec_vec_empty() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short = 'p', num_args = 2)]
        points: Vec<Vec<i32>>,
    }

    assert_eq!(
        Opt { points: vec![] },
        Opt::try_parse_from(["test"]).unwrap()
    );
}

#[test]
fn test_option_vec_vec() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short = 'p', num_args = 2)]
        points: Option<Vec<Vec<i32>>>,
    }

    assert_eq!(
        Opt {
            points: Some(vec![vec![1, 2], vec![3, 4]])
        },
        Opt::try_parse_from(["test", "-p", "1", "2", "-p", "3", "4"]).unwrap()
    );
}

#[test]
fn test_option_vec_vec_empty() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short = 'p', num_args = 2)]
        points: Option<Vec<Vec<i32>>>,
    }

    assert_eq!(Opt { points: None }, Opt::try_parse_from(["test"]).unwrap());
}

```

`clap/tests/derive/options.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

#![allow(clippy::option_option)]

use crate::utils;

use clap::{Parser, Subcommand};

#[test]
fn required_option() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short, long)]
        arg: i32,
    }
    assert_eq!(
        Opt { arg: 42 },
        Opt::try_parse_from(["test", "-a42"]).unwrap()
    );
    assert_eq!(
        Opt { arg: 42 },
        Opt::try_parse_from(["test", "-a", "42"]).unwrap()
    );
    assert_eq!(
        Opt { arg: 42 },
        Opt::try_parse_from(["test", "--arg", "42"]).unwrap()
    );
    assert_eq!(
        Opt { arg: 42 },
        Opt::try_parse_from(["test", "--arg", "24", "--arg", "42"]).unwrap()
    );
    assert!(Opt::try_parse_from(["test"]).is_err());
}

#[test]
fn option_with_default() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short, default_value = "42")]
        arg: i32,
    }
    assert_eq!(
        Opt { arg: 24 },
        Opt::try_parse_from(["test", "-a24"]).unwrap()
    );
    assert_eq!(
        Opt { arg: 42 },
        Opt::try_parse_from(["test", "-a", "24", "-a", "42"]).unwrap()
    );
    assert_eq!(Opt { arg: 42 }, Opt::try_parse_from(["test"]).unwrap());
}

#[test]
fn option_with_raw_default() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short, default_value = "42")]
        arg: i32,
    }
    assert_eq!(
        Opt { arg: 24 },
        Opt::try_parse_from(["test", "-a24"]).unwrap()
    );
    assert_eq!(
        Opt { arg: 42 },
        Opt::try_parse_from(["test", "-a", "24", "-a", "42"]).unwrap()
    );
    assert_eq!(Opt { arg: 42 }, Opt::try_parse_from(["test"]).unwrap());
}

#[test]
fn option_from_str() {
    #[derive(Clone, Debug, PartialEq)]
    struct A;

    impl std::str::FromStr for A {
        type Err = std::convert::Infallible;

        fn from_str(_: &str) -> Result<A, Self::Err> {
            Ok(A)
        }
    }

    #[derive(Debug, Parser, PartialEq)]
    #[command(args_override_self = true)]
    struct Opt {
        a: Option<A>,
    }

    assert_eq!(Opt { a: None }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(
        Opt { a: Some(A) },
        Opt::try_parse_from(["test", "foo"]).unwrap()
    );
}

#[test]
fn vec_from_str() {
    #[derive(Clone, Debug, PartialEq)]
    struct A;

    impl std::str::FromStr for A {
        type Err = std::convert::Infallible;

        fn from_str(_: &str) -> Result<A, Self::Err> {
            Ok(A)
        }
    }

    #[derive(Debug, Parser, PartialEq)]
    #[command(args_override_self = true)]
    struct Opt {
        a: Vec<A>,
    }

    assert_eq!(
        Opt { a: Vec::new() },
        Opt::try_parse_from(["test"]).unwrap()
    );
    assert_eq!(
        Opt { a: vec![A] },
        Opt::try_parse_from(["test", "foo"]).unwrap()
    );
}

#[test]
fn option_vec_from_str() {
    #[derive(Clone, Debug, PartialEq)]
    struct A;

    impl std::str::FromStr for A {
        type Err = std::convert::Infallible;

        fn from_str(_: &str) -> Result<A, Self::Err> {
            Ok(A)
        }
    }

    #[derive(Debug, Parser, PartialEq)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short)]
        a: Option<Vec<A>>,
    }

    assert_eq!(Opt { a: None }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(
        Opt { a: Some(vec![A]) },
        Opt::try_parse_from(["test", "-a", "foo"]).unwrap()
    );
}

#[test]
fn option_type_is_optional() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short)]
        arg: Option<i32>,
    }
    assert_eq!(
        Opt { arg: Some(42) },
        Opt::try_parse_from(["test", "-a42"]).unwrap()
    );
    assert_eq!(
        Opt { arg: Some(42) },
        Opt::try_parse_from(["test", "-a", "24", "-a", "42"]).unwrap()
    );
    assert_eq!(Opt { arg: None }, Opt::try_parse_from(["test"]).unwrap());
}

#[test]
fn required_with_option_type() {
    #[derive(Debug, PartialEq, Eq, Parser)]
    #[command(subcommand_negates_reqs = true)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(required = true)]
        req_str: Option<String>,

        #[command(subcommand)]
        cmd: Option<SubCommands>,
    }

    #[derive(Debug, PartialEq, Eq, Subcommand)]
    enum SubCommands {
        ExSub {
            #[arg(short, long, action = clap::ArgAction::Count)]
            verbose: u8,
        },
    }

    assert_eq!(
        Opt {
            req_str: Some(("arg").into()),
            cmd: None,
        },
        Opt::try_parse_from(["test", "arg"]).unwrap()
    );

    assert_eq!(
        Opt {
            req_str: None,
            cmd: Some(SubCommands::ExSub { verbose: 1 }),
        },
        Opt::try_parse_from(["test", "ex-sub", "-v"]).unwrap()
    );

    assert!(Opt::try_parse_from(["test"]).is_err());
}

#[test]
fn ignore_qualified_option_type() {
    fn parser(s: &str) -> Result<Option<String>, std::convert::Infallible> {
        Ok(Some(s.to_string()))
    }

    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(value_parser = parser)]
        arg: ::std::option::Option<String>,
    }

    assert_eq!(
        Opt {
            arg: Some("success".into())
        },
        Opt::try_parse_from(["test", "success"]).unwrap()
    );
}

#[test]
fn option_option_type_is_optional_value() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short)]
        #[allow(clippy::option_option)]
        arg: Option<Option<i32>>,
    }
    assert_eq!(
        Opt {
            arg: Some(Some(42))
        },
        Opt::try_parse_from(["test", "-a42"]).unwrap()
    );
    assert_eq!(
        Opt { arg: Some(None) },
        Opt::try_parse_from(["test", "-a"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: Some(Some(42))
        },
        Opt::try_parse_from(["test", "-a", "24", "-a", "42"]).unwrap()
    );
    assert_eq!(Opt { arg: None }, Opt::try_parse_from(["test"]).unwrap());
}

#[test]
fn option_option_type_help() {
    #[derive(Parser, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(long, value_name = "val")]
        arg: Option<Option<i32>>,
    }
    let help = utils::get_help::<Opt>();
    assert!(help.contains("--arg [<val>]"));
    assert!(!help.contains("--arg [<val>...]"));
}

#[test]
fn two_option_option_types() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short)]
        arg: Option<Option<i32>>,

        #[arg(long)]
        field: Option<Option<String>>,
    }
    assert_eq!(
        Opt {
            arg: Some(Some(42)),
            field: Some(Some("f".into()))
        },
        Opt::try_parse_from(["test", "-a42", "--field", "f"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: Some(Some(42)),
            field: Some(None)
        },
        Opt::try_parse_from(["test", "-a42", "--field"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: Some(None),
            field: Some(None)
        },
        Opt::try_parse_from(["test", "-a", "--field"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: Some(None),
            field: Some(Some("f".into()))
        },
        Opt::try_parse_from(["test", "-a", "--field", "f"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: None,
            field: Some(None)
        },
        Opt::try_parse_from(["test", "--field"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: None,
            field: None
        },
        Opt::try_parse_from(["test"]).unwrap()
    );
}

#[test]
fn vec_type_is_multiple_occurrences() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short, long)]
        arg: Vec<i32>,
    }
    assert_eq!(
        Opt { arg: vec![24] },
        Opt::try_parse_from(["test", "-a24"]).unwrap()
    );
    assert_eq!(Opt { arg: vec![] }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(
        Opt { arg: vec![24, 42] },
        Opt::try_parse_from(["test", "-a", "24", "-a", "42"]).unwrap()
    );
}

#[test]
fn vec_type_with_required() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short, long, required = true)]
        arg: Vec<i32>,
    }
    assert_eq!(
        Opt { arg: vec![24] },
        Opt::try_parse_from(["test", "-a24"]).unwrap()
    );
    assert!(Opt::try_parse_from(["test"]).is_err());
    assert_eq!(
        Opt { arg: vec![24, 42] },
        Opt::try_parse_from(["test", "-a", "24", "-a", "42"]).unwrap()
    );
}

#[test]
fn vec_type_with_multiple_values_only() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short, long, num_args(1..))]
        arg: Vec<i32>,
    }
    assert_eq!(
        Opt { arg: vec![24] },
        Opt::try_parse_from(["test", "-a24"]).unwrap()
    );
    assert_eq!(Opt { arg: vec![] }, Opt::try_parse_from(["test"]).unwrap());
    assert_eq!(
        Opt { arg: vec![24, 42] },
        Opt::try_parse_from(["test", "-a", "24", "42"]).unwrap()
    );
}

#[test]
fn ignore_qualified_vec_type() {
    fn parser(s: &str) -> Result<Vec<String>, std::convert::Infallible> {
        Ok(vec![s.to_string()])
    }

    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(value_parser = parser)]
        arg: ::std::vec::Vec<String>,
    }

    assert_eq!(
        Opt {
            arg: vec!["success".into()]
        },
        Opt::try_parse_from(["test", "success"]).unwrap()
    );
}

#[test]
fn option_vec_type() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short)]
        arg: Option<Vec<i32>>,
    }
    assert_eq!(
        Opt { arg: Some(vec![1]) },
        Opt::try_parse_from(["test", "-a", "1"]).unwrap()
    );

    assert_eq!(
        Opt {
            arg: Some(vec![1, 2])
        },
        Opt::try_parse_from(["test", "-a", "1", "-a", "2"]).unwrap()
    );

    assert_eq!(Opt { arg: None }, Opt::try_parse_from(["test"]).unwrap());
}

#[test]
fn option_vec_type_structopt_behavior() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short, long, num_args(0..))]
        arg: Option<Vec<i32>>,
    }
    assert_eq!(
        Opt { arg: Some(vec![1]) },
        Opt::try_parse_from(["test", "-a", "1"]).unwrap()
    );

    assert_eq!(
        Opt {
            arg: Some(vec![1, 2])
        },
        Opt::try_parse_from(["test", "-a", "1", "2"]).unwrap()
    );

    assert_eq!(
        Opt { arg: Some(vec![]) },
        Opt::try_parse_from(["test", "-a"]).unwrap()
    );

    assert_eq!(Opt { arg: None }, Opt::try_parse_from(["test"]).unwrap());
}

#[test]
fn two_option_vec_types() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(short)]
        arg: Option<Vec<i32>>,

        #[arg(short)]
        b: Option<Vec<i32>>,
    }

    assert_eq!(
        Opt {
            arg: Some(vec![1]),
            b: None,
        },
        Opt::try_parse_from(["test", "-a", "1"]).unwrap()
    );

    assert_eq!(
        Opt {
            arg: Some(vec![1]),
            b: Some(vec![1])
        },
        Opt::try_parse_from(["test", "-a", "1", "-b", "1"]).unwrap()
    );

    assert_eq!(
        Opt {
            arg: Some(vec![1, 2]),
            b: Some(vec![1, 2])
        },
        Opt::try_parse_from(["test", "-a", "1", "-a", "2", "-b", "1", "-b", "2"]).unwrap()
    );

    assert_eq!(
        Opt { arg: None, b: None },
        Opt::try_parse_from(["test"]).unwrap()
    );
}

#[test]
fn explicit_value_parser() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(long, value_parser = clap::value_parser!(i32))]
        arg: i32,
    }
    assert_eq!(
        Opt { arg: 42 },
        Opt::try_parse_from(["test", "--arg", "42"]).unwrap()
    );
}

#[test]
fn implicit_value_parser() {
    #[derive(Parser, PartialEq, Debug)]
    #[command(args_override_self = true)]
    struct Opt {
        #[arg(long)]
        arg: i32,
    }
    assert_eq!(
        Opt { arg: 42 },
        Opt::try_parse_from(["test", "--arg", "42"]).unwrap()
    );
}

```

`clap/tests/derive/privacy.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

mod options {
    use clap::Parser;

    #[derive(Debug, Parser)]
    pub(crate) struct Options {
        #[command(subcommand)]
        pub(crate) subcommand: super::subcommands::SubCommand,
    }
}

mod subcommands {
    use clap::Subcommand;

    #[derive(Debug, Subcommand)]
    pub(crate) enum SubCommand {
        /// foo
        Foo {
            /// foo
            bars: String,
        },
    }
}

```

`clap/tests/derive/raw_bool_literal.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[test]
fn raw_bool_literal() {
    #[derive(Parser, Debug, PartialEq)]
    #[command(name = "raw_bool")]
    struct Opt {
        #[arg(raw(false))]
        a: String,
        #[arg(raw(true))]
        b: String,
    }

    assert_eq!(
        Opt {
            a: "one".into(),
            b: "--help".into()
        },
        Opt::try_parse_from(["test", "one", "--", "--help"]).unwrap()
    );
}

```

`clap/tests/derive/raw_idents.rs`:

```rs
use clap::Parser;

#[test]
fn raw_idents() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short, long)]
        r#type: String,
    }

    assert_eq!(
        Opt {
            r#type: "long".into()
        },
        Opt::try_parse_from(["test", "--type", "long"]).unwrap()
    );

    assert_eq!(
        Opt {
            r#type: "short".into()
        },
        Opt::try_parse_from(["test", "-t", "short"]).unwrap()
    );
}

```

`clap/tests/derive/rename_all_env.rs`:

```rs
#![cfg(feature = "env")]

use crate::utils;

use clap::Parser;

#[test]
fn it_works() {
    #[derive(Debug, PartialEq, Parser)]
    #[command(rename_all_env = "kebab")]
    struct BehaviorModel {
        #[arg(env)]
        be_nice: String,
    }

    let help = utils::get_help::<BehaviorModel>();
    assert!(help.contains("[env: be-nice=]"));
}

#[test]
fn default_is_screaming() {
    #[derive(Debug, PartialEq, Parser)]
    struct BehaviorModel {
        #[arg(env)]
        be_nice: String,
    }

    let help = utils::get_help::<BehaviorModel>();
    assert!(help.contains("[env: BE_NICE=]"));
}

#[test]
fn overridable() {
    #[derive(Debug, PartialEq, Parser)]
    #[command(rename_all_env = "kebab")]
    struct BehaviorModel {
        #[arg(env)]
        be_nice: String,

        #[arg(rename_all_env = "pascal", env)]
        be_aggressive: String,
    }

    let help = utils::get_help::<BehaviorModel>();
    assert!(help.contains("[env: be-nice=]"));
    assert!(help.contains("[env: BeAggressive=]"));
}

```

`clap/tests/derive/skip.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[test]
fn skip_1() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short)]
        x: u32,
        #[arg(skip)]
        s: u32,
    }

    assert!(Opt::try_parse_from(["test", "-x", "10", "20"]).is_err());

    let mut opt = Opt::try_parse_from(["test", "-x", "10"]).unwrap();
    assert_eq!(
        opt,
        Opt {
            x: 10,
            s: 0, // default
        }
    );
    opt.s = 42;

    opt.try_update_from(["test", "-x", "22"]).unwrap();

    assert_eq!(opt, Opt { x: 22, s: 42 });
}

#[test]
fn skip_2() {
    #[derive(Parser, Debug, PartialEq)]
    struct Opt {
        #[arg(short)]
        x: u32,
        #[arg(skip)]
        ss: String,
        #[arg(skip)]
        sn: u8,

        y: u32,
        #[arg(skip)]
        sz: u16,

        t: u32,
    }

    assert_eq!(
        Opt::try_parse_from(["test", "-x", "10", "20", "30"]).unwrap(),
        Opt {
            x: 10,
            ss: String::from(""),
            sn: 0,
            y: 20,
            sz: 0,
            t: 30,
        }
    );
}

#[test]
fn skip_enum() {
    #[derive(Debug, PartialEq)]
    #[allow(unused)]
    #[derive(Default)]
    enum Kind {
        A,
        #[default]
        B,
    }

    #[derive(Parser, Debug, PartialEq)]
    pub(crate) struct Opt {
        #[arg(long, short)]
        number: u32,
        #[arg(skip)]
        k: Kind,
        #[arg(skip)]
        v: Vec<u32>,
    }

    assert_eq!(
        Opt::try_parse_from(["test", "-n", "10"]).unwrap(),
        Opt {
            number: 10,
            k: Kind::B,
            v: vec![],
        }
    );
}

#[test]
fn skip_help_doc_comments() {
    #[derive(Parser, Debug, PartialEq, Eq)]
    pub(crate) struct Opt {
        #[arg(skip, help = "internal_stuff")]
        a: u32,

        #[arg(skip, long_help = "internal_stuff\ndo not touch")]
        b: u32,

        /// Not meant to be used by clap.
        ///
        /// I want a default here.
        #[arg(skip)]
        c: u32,

        #[arg(short)]
        n: u32,
    }

    assert_eq!(
        Opt::try_parse_from(["test", "-n", "10"]).unwrap(),
        Opt {
            n: 10,
            a: 0,
            b: 0,
            c: 0,
        }
    );
}

#[test]
fn skip_val() {
    #[derive(Parser, Debug, PartialEq, Eq)]
    pub(crate) struct Opt {
        #[arg(long, short)]
        number: u32,

        #[arg(skip = "key")]
        k: String,

        #[arg(skip = vec![1, 2, 3])]
        v: Vec<u32>,
    }

    assert_eq!(
        Opt::try_parse_from(["test", "-n", "10"]).unwrap(),
        Opt {
            number: 10,
            k: "key".to_string(),
            v: vec![1, 2, 3]
        }
    );
}

```

`clap/tests/derive/snapshots/blocks.term.svg`:

```svg
<svg width="740px" height="578px" xmlns="http://www.w3.org/2000/svg">
  <style>
    .fg { fill: #AAAAAA }
    .bg { background: #000000 }
    .container {
      padding: 0 10px;
      line-height: 18px;
    }
    .bold { font-weight: bold; }
    .italic { font-style: italic; }
    .underline { text-decoration-line: underline; }
    .strikethrough { text-decoration-line: line-through; }
    tspan {
      font: 14px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
      white-space: pre;
      line-height: 18px;
    }
  </style>

  <rect width="100%" height="100%" y="0" rx="4.5" class="bg" />

  <text xml:space="preserve" class="container fg">
    <tspan x="10px" y="28px"><tspan>  </tspan><tspan class="bold">This is a *fenced* code block.</tspan>
</tspan>
    <tspan x="10px" y="46px"><tspan>  </tspan>
</tspan>
    <tspan x="10px" y="64px"><tspan>  </tspan><tspan class="bold">There is not much going on in terms of **styling**.</tspan>
</tspan>
    <tspan x="10px" y="82px">
</tspan>
    <tspan x="10px" y="100px"><tspan>---</tspan>
</tspan>
    <tspan x="10px" y="118px">
</tspan>
    <tspan x="10px" y="136px"><tspan>  </tspan><tspan class="bold">Code blocks can also be initiated through</tspan>
</tspan>
    <tspan x="10px" y="154px"><tspan>  </tspan><tspan class="bold">Indentation.</tspan>
</tspan>
    <tspan x="10px" y="172px">
</tspan>
    <tspan x="10px" y="190px"><tspan>| This is a block quote. </tspan><tspan class="bold">Regular </tspan><tspan class="strikethrough bold">styling </tspan><tspan class="strikethrough bold italic">should</tspan><tspan class="strikethrough bold"> work</tspan><tspan class="bold"> here.</tspan>
</tspan>
    <tspan x="10px" y="208px"><tspan>| </tspan>
</tspan>
    <tspan x="10px" y="226px"><tspan>| </tspan><tspan class="underline bold">even headings</tspan>
</tspan>
    <tspan x="10px" y="244px"><tspan>| </tspan>
</tspan>
    <tspan x="10px" y="262px"><tspan>| and regular paragraphs.</tspan>
</tspan>
    <tspan x="10px" y="280px"><tspan>| </tspan>
</tspan>
    <tspan x="10px" y="298px"><tspan>| - lists</tspan>
</tspan>
    <tspan x="10px" y="316px"><tspan>|   - are</tspan>
</tspan>
    <tspan x="10px" y="334px"><tspan>| </tspan>
</tspan>
    <tspan x="10px" y="352px"><tspan>| 1. also</tspan>
</tspan>
    <tspan x="10px" y="370px"><tspan>|   1. supported</tspan>
</tspan>
    <tspan x="10px" y="388px"><tspan>| </tspan>
</tspan>
    <tspan x="10px" y="406px"><tspan>| | nesting them</tspan>
</tspan>
    <tspan x="10px" y="424px"><tspan>| | </tspan>
</tspan>
    <tspan x="10px" y="442px"><tspan>| | | also works (not)</tspan>
</tspan>
    <tspan x="10px" y="460px">
</tspan>
    <tspan x="10px" y="478px"><tspan class="underline bold">Usage:</tspan><tspan> </tspan><tspan class="bold">clap</tspan>
</tspan>
    <tspan x="10px" y="496px">
</tspan>
    <tspan x="10px" y="514px"><tspan class="underline bold">Options:</tspan>
</tspan>
    <tspan x="10px" y="532px"><tspan>  </tspan><tspan class="bold">-h</tspan><tspan>, </tspan><tspan class="bold">--help</tspan>
</tspan>
    <tspan x="10px" y="550px"><tspan>          Print help (see a summary with '-h')</tspan>
</tspan>
    <tspan x="10px" y="568px">
</tspan>
  </text>

</svg>

```

`clap/tests/derive/snapshots/headers.term.svg`:

```svg
<svg width="740px" height="272px" xmlns="http://www.w3.org/2000/svg">
  <style>
    .fg { fill: #AAAAAA }
    .bg { background: #000000 }
    .container {
      padding: 0 10px;
      line-height: 18px;
    }
    .bold { font-weight: bold; }
    .italic { font-style: italic; }
    .underline { text-decoration-line: underline; }
    .strikethrough { text-decoration-line: line-through; }
    tspan {
      font: 14px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
      white-space: pre;
      line-height: 18px;
    }
  </style>

  <rect width="100%" height="100%" y="0" rx="4.5" class="bg" />

  <text xml:space="preserve" class="container fg">
    <tspan x="10px" y="28px"><tspan class="underline bold">This is a header</tspan>
</tspan>
    <tspan x="10px" y="46px">
</tspan>
    <tspan x="10px" y="64px"><tspan class="underline bold">second level</tspan>
</tspan>
    <tspan x="10px" y="82px">
</tspan>
    <tspan x="10px" y="100px"><tspan class="underline bold">additional</tspan><tspan class="underline bold"> </tspan><tspan class="underline bold italic">styling on </tspan><tspan class="underline strikethrough bold italic">top</tspan><tspan class="underline bold italic"> of</tspan><tspan class="underline bold italic"> it</tspan>
</tspan>
    <tspan x="10px" y="118px">
</tspan>
    <tspan x="10px" y="136px"><tspan>regular paragraph</tspan>
</tspan>
    <tspan x="10px" y="154px">
</tspan>
    <tspan x="10px" y="172px"><tspan class="underline bold">Usage:</tspan><tspan> </tspan><tspan class="bold">clap</tspan>
</tspan>
    <tspan x="10px" y="190px">
</tspan>
    <tspan x="10px" y="208px"><tspan class="underline bold">Options:</tspan>
</tspan>
    <tspan x="10px" y="226px"><tspan>  </tspan><tspan class="bold">-h</tspan><tspan>, </tspan><tspan class="bold">--help</tspan>
</tspan>
    <tspan x="10px" y="244px"><tspan>          Print help</tspan>
</tspan>
    <tspan x="10px" y="262px">
</tspan>
  </text>

</svg>

```

`clap/tests/derive/snapshots/html.term.svg`:

```svg
<svg width="740px" height="290px" xmlns="http://www.w3.org/2000/svg">
  <style>
    .fg { fill: #AAAAAA }
    .bg { background: #000000 }
    .container {
      padding: 0 10px;
      line-height: 18px;
    }
    .bold { font-weight: bold; }
    .underline { text-decoration-line: underline; }
    tspan {
      font: 14px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
      white-space: pre;
      line-height: 18px;
    }
  </style>

  <rect width="100%" height="100%" y="0" rx="4.5" class="bg" />

  <text xml:space="preserve" class="container fg">
    <tspan x="10px" y="28px"><tspan>&lt;html&gt;</tspan>
</tspan>
    <tspan x="10px" y="46px"><tspan>    &lt;is&gt;</tspan>
</tspan>
    <tspan x="10px" y="64px"><tspan>        &lt;used&gt;</tspan>
</tspan>
    <tspan x="10px" y="82px"><tspan>    &lt;/verbatim&gt;</tspan>
</tspan>
    <tspan x="10px" y="100px"><tspan>&lt;/html&gt;</tspan>
</tspan>
    <tspan x="10px" y="118px">
</tspan>
    <tspan x="10px" y="136px">
</tspan>
    <tspan x="10px" y="154px"><tspan>&lt;inline&gt;html&lt;/as-well&gt;</tspan>
</tspan>
    <tspan x="10px" y="172px">
</tspan>
    <tspan x="10px" y="190px"><tspan class="underline bold">Usage:</tspan><tspan> </tspan><tspan class="bold">clap</tspan>
</tspan>
    <tspan x="10px" y="208px">
</tspan>
    <tspan x="10px" y="226px"><tspan class="underline bold">Options:</tspan>
</tspan>
    <tspan x="10px" y="244px"><tspan>  </tspan><tspan class="bold">-h</tspan><tspan>, </tspan><tspan class="bold">--help</tspan>
</tspan>
    <tspan x="10px" y="262px"><tspan>          Print help</tspan>
</tspan>
    <tspan x="10px" y="280px">
</tspan>
  </text>

</svg>

```

`clap/tests/derive/snapshots/inline_styles.term.svg`:

```svg
<svg width="740px" height="200px" xmlns="http://www.w3.org/2000/svg">
  <style>
    .fg { fill: #AAAAAA }
    .bg { background: #000000 }
    .container {
      padding: 0 10px;
      line-height: 18px;
    }
    .bold { font-weight: bold; }
    .italic { font-style: italic; }
    .underline { text-decoration-line: underline; }
    .strikethrough { text-decoration-line: line-through; }
    tspan {
      font: 14px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
      white-space: pre;
      line-height: 18px;
    }
  </style>

  <rect width="100%" height="100%" y="0" rx="4.5" class="bg" />

  <text xml:space="preserve" class="container fg">
    <tspan x="10px" y="28px"><tspan class="italic">emphasis</tspan><tspan> </tspan><tspan class="bold">bold</tspan><tspan> </tspan><tspan class="strikethrough">strike through</tspan><tspan> </tspan><tspan class="bold">code</tspan>
</tspan>
    <tspan x="10px" y="46px">
</tspan>
    <tspan x="10px" y="64px"><tspan class="italic">all </tspan><tspan class="bold italic">of </tspan><tspan class="strikethrough bold italic">them combined</tspan><tspan class="strikethrough bold italic"> in</tspan><tspan class="bold italic"> one</tspan><tspan class="italic"> line</tspan>
</tspan>
    <tspan x="10px" y="82px">
</tspan>
    <tspan x="10px" y="100px"><tspan class="underline bold">Usage:</tspan><tspan> </tspan><tspan class="bold">clap</tspan>
</tspan>
    <tspan x="10px" y="118px">
</tspan>
    <tspan x="10px" y="136px"><tspan class="underline bold">Options:</tspan>
</tspan>
    <tspan x="10px" y="154px"><tspan>  </tspan><tspan class="bold">-h</tspan><tspan>, </tspan><tspan class="bold">--help</tspan>
</tspan>
    <tspan x="10px" y="172px"><tspan>          Print help (see a summary with '-h')</tspan>
</tspan>
    <tspan x="10px" y="190px">
</tspan>
  </text>

</svg>

```

`clap/tests/derive/snapshots/links.term.svg`:

```svg
<svg width="740px" height="272px" xmlns="http://www.w3.org/2000/svg">
  <style>
    .fg { fill: #AAAAAA }
    .bg { background: #000000 }
    .container {
      padding: 0 10px;
      line-height: 18px;
    }
    .bold { font-weight: bold; }
    .underline { text-decoration-line: underline; }
    tspan {
      font: 14px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
      white-space: pre;
      line-height: 18px;
    }
  </style>

  <rect width="100%" height="100%" y="0" rx="4.5" class="bg" />

  <text xml:space="preserve" class="container fg">
    <tspan x="10px" y="28px"><tspan class="underline">https://example.com/literal</tspan>
</tspan>
    <tspan x="10px" y="46px">
</tspan>
    <tspan x="10px" y="64px"><tspan class="underline">with name</tspan>
</tspan>
    <tspan x="10px" y="82px">
</tspan>
    <tspan x="10px" y="100px"><tspan>image</tspan>
</tspan>
    <tspan x="10px" y="118px">
</tspan>
    <tspan x="10px" y="136px"><tspan class="underline">referencing</tspan>
</tspan>
    <tspan x="10px" y="154px">
</tspan>
    <tspan x="10px" y="172px"><tspan class="underline bold">Usage:</tspan><tspan> </tspan><tspan class="bold">clap</tspan>
</tspan>
    <tspan x="10px" y="190px">
</tspan>
    <tspan x="10px" y="208px"><tspan class="underline bold">Options:</tspan>
</tspan>
    <tspan x="10px" y="226px"><tspan>  </tspan><tspan class="bold">-h</tspan><tspan>, </tspan><tspan class="bold">--help</tspan>
</tspan>
    <tspan x="10px" y="244px"><tspan>          Print help (see a summary with '-h')</tspan>
</tspan>
    <tspan x="10px" y="262px">
</tspan>
  </text>

</svg>

```

`clap/tests/derive/snapshots/lists.term.svg`:

```svg
<svg width="740px" height="416px" xmlns="http://www.w3.org/2000/svg">
  <style>
    .fg { fill: #AAAAAA }
    .bg { background: #000000 }
    .container {
      padding: 0 10px;
      line-height: 18px;
    }
    .bold { font-weight: bold; }
    .underline { text-decoration-line: underline; }
    tspan {
      font: 14px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
      white-space: pre;
      line-height: 18px;
    }
  </style>

  <rect width="100%" height="100%" y="0" rx="4.5" class="bg" />

  <text xml:space="preserve" class="container fg">
    <tspan x="10px" y="28px"><tspan>Lists:</tspan>
</tspan>
    <tspan x="10px" y="46px">
</tspan>
    <tspan x="10px" y="64px"><tspan>- unordered</tspan>
</tspan>
    <tspan x="10px" y="82px"><tspan>  - bullet</tspan>
</tspan>
    <tspan x="10px" y="100px"><tspan>    - lists</tspan>
</tspan>
    <tspan x="10px" y="118px"><tspan>- with multiple</tspan>
</tspan>
    <tspan x="10px" y="136px"><tspan>  - levels</tspan>
</tspan>
    <tspan x="10px" y="154px">
</tspan>
    <tspan x="10px" y="172px"><tspan>0. numeric lists</tspan>
</tspan>
    <tspan x="10px" y="190px"><tspan>1. only care</tspan>
</tspan>
    <tspan x="10px" y="208px"><tspan>  1. about the initial number</tspan>
</tspan>
    <tspan x="10px" y="226px"><tspan>2. </tspan>
</tspan>
    <tspan x="10px" y="244px"><tspan>  5. and count from there</tspan>
</tspan>
    <tspan x="10px" y="262px"><tspan>  6. anything goes</tspan>
</tspan>
    <tspan x="10px" y="280px"><tspan>3. though they need an empty line</tspan>
</tspan>
    <tspan x="10px" y="298px">
</tspan>
    <tspan x="10px" y="316px"><tspan class="underline bold">Usage:</tspan><tspan> </tspan><tspan class="bold">clap</tspan>
</tspan>
    <tspan x="10px" y="334px">
</tspan>
    <tspan x="10px" y="352px"><tspan class="underline bold">Options:</tspan>
</tspan>
    <tspan x="10px" y="370px"><tspan>  </tspan><tspan class="bold">-h</tspan><tspan>, </tspan><tspan class="bold">--help</tspan>
</tspan>
    <tspan x="10px" y="388px"><tspan>          Print help (see a summary with '-h')</tspan>
</tspan>
    <tspan x="10px" y="406px">
</tspan>
  </text>

</svg>

```

`clap/tests/derive/snapshots/paragraphs.term.svg`:

```svg
<svg width="740px" height="398px" xmlns="http://www.w3.org/2000/svg">
  <style>
    .fg { fill: #AAAAAA }
    .bg { background: #000000 }
    .container {
      padding: 0 10px;
      line-height: 18px;
    }
    .bold { font-weight: bold; }
    .underline { text-decoration-line: underline; }
    tspan {
      font: 14px SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
      white-space: pre;
      line-height: 18px;
    }
  </style>

  <rect width="100%" height="100%" y="0" rx="4.5" class="bg" />

  <text xml:space="preserve" class="container fg">
    <tspan x="10px" y="28px"><tspan>Paragraphs are separated by empty lines. All lines will be joined onto one.</tspan>
</tspan>
    <tspan x="10px" y="46px">
</tspan>
    <tspan x="10px" y="64px"><tspan>The first paragraph is used as short help by clap.</tspan>
</tspan>
    <tspan x="10px" y="82px"><tspan>backslashes can be used to insert hard line breaks.</tspan>
</tspan>
    <tspan x="10px" y="100px">
</tspan>
    <tspan x="10px" y="118px"><tspan>| these | can   |</tspan>
</tspan>
    <tspan x="10px" y="136px"><tspan>| ----- | ----- |</tspan>
</tspan>
    <tspan x="10px" y="154px"><tspan>| be    | used  |</tspan>
</tspan>
    <tspan x="10px" y="172px"><tspan>| for   | tables|</tspan>
</tspan>
    <tspan x="10px" y="190px">
</tspan>
    <tspan x="10px" y="208px"><tspan>Because tables are not yet supported.</tspan>
</tspan>
    <tspan x="10px" y="226px">
</tspan>
    <tspan x="10px" y="244px"><tspan>You can also use trailing spaces for hard breaks,</tspan>
</tspan>
    <tspan x="10px" y="262px"><tspan>but this is not really recommended.</tspan>
</tspan>
    <tspan x="10px" y="280px">
</tspan>
    <tspan x="10px" y="298px"><tspan class="underline bold">Usage:</tspan><tspan> </tspan><tspan class="bold">clap</tspan>
</tspan>
    <tspan x="10px" y="316px">
</tspan>
    <tspan x="10px" y="334px"><tspan class="underline bold">Options:</tspan>
</tspan>
    <tspan x="10px" y="352px"><tspan>  </tspan><tspan class="bold">-h</tspan><tspan>, </tspan><tspan class="bold">--help</tspan>
</tspan>
    <tspan x="10px" y="370px"><tspan>          Print help (see a summary with '-h')</tspan>
</tspan>
    <tspan x="10px" y="388px">
</tspan>
  </text>

</svg>

```

`clap/tests/derive/subcommands.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
//
// This work was derived from Structopt (https://github.com/TeXitoi/structopt)
// commit#ea76fa1b1b273e65e3b0b1046643715b49bec51f which is licensed under the
// MIT/Apache 2.0 license.

use crate::utils;

use clap::{Args, Parser, Subcommand};

#[derive(Parser, PartialEq, Eq, Debug)]
enum Opt {
    /// Fetch stuff from GitHub
    Fetch {
        #[arg(long)]
        all: bool,
        /// Overwrite local branches.
        #[arg(short, long)]
        force: bool,

        repo: String,
    },

    Add {
        #[arg(short, long)]
        interactive: bool,
        #[arg(short, long)]
        verbose: bool,
    },
}

#[test]
fn test_fetch() {
    assert_eq!(
        Opt::Fetch {
            all: true,
            force: false,
            repo: "origin".to_string()
        },
        Opt::try_parse_from(["test", "fetch", "--all", "origin"]).unwrap()
    );
    assert_eq!(
        Opt::Fetch {
            all: false,
            force: true,
            repo: "origin".to_string()
        },
        Opt::try_parse_from(["test", "fetch", "-f", "origin"]).unwrap()
    );
}

#[test]
fn test_add() {
    assert_eq!(
        Opt::Add {
            interactive: false,
            verbose: false
        },
        Opt::try_parse_from(["test", "add"]).unwrap()
    );
    assert_eq!(
        Opt::Add {
            interactive: true,
            verbose: true
        },
        Opt::try_parse_from(["test", "add", "-i", "-v"]).unwrap()
    );
}

#[test]
fn test_no_parse() {
    let result = Opt::try_parse_from(["test", "badcmd", "-i", "-v"]);
    assert!(result.is_err());

    let result = Opt::try_parse_from(["test", "add", "--badoption"]);
    assert!(result.is_err());

    let result = Opt::try_parse_from(["test"]);
    assert!(result.is_err());
}

#[derive(Parser, PartialEq, Eq, Debug)]
enum Opt2 {
    DoSomething { arg: String },
}

#[test]
/// This test is specifically to make sure that hyphenated subcommands get
/// processed correctly.
fn test_hyphenated_subcommands() {
    assert_eq!(
        Opt2::DoSomething {
            arg: "blah".to_string()
        },
        Opt2::try_parse_from(["test", "do-something", "blah"]).unwrap()
    );
}

#[derive(Parser, PartialEq, Eq, Debug)]
enum Opt3 {
    Add,
    Init,
    Fetch,
}

#[test]
fn test_null_commands() {
    assert_eq!(Opt3::Add, Opt3::try_parse_from(["test", "add"]).unwrap());
    assert_eq!(Opt3::Init, Opt3::try_parse_from(["test", "init"]).unwrap());
    assert_eq!(
        Opt3::Fetch,
        Opt3::try_parse_from(["test", "fetch"]).unwrap()
    );
}

#[derive(Parser, PartialEq, Eq, Debug)]
#[command(about = "Not shown")]
struct Add {
    file: String,
}
/// Not shown
#[derive(Parser, PartialEq, Eq, Debug)]
struct Fetch {
    remote: String,
}
#[derive(Parser, PartialEq, Eq, Debug)]
enum Opt4 {
    // Not shown
    /// Add a file
    Add(Add),
    Init,
    /// download history from remote
    Fetch(Fetch),
}

#[test]
fn test_tuple_commands() {
    assert_eq!(
        Opt4::Add(Add {
            file: "f".to_string()
        }),
        Opt4::try_parse_from(["test", "add", "f"]).unwrap()
    );
    assert_eq!(Opt4::Init, Opt4::try_parse_from(["test", "init"]).unwrap());
    assert_eq!(
        Opt4::Fetch(Fetch {
            remote: "origin".to_string()
        }),
        Opt4::try_parse_from(["test", "fetch", "origin"]).unwrap()
    );

    let output = utils::get_long_help::<Opt4>();

    assert!(output.contains("download history from remote"));
    assert!(output.contains("Add a file"));
    assert!(!output.contains("Not shown"));
}

#[test]
fn global_passed_down() {
    #[derive(Debug, PartialEq, Eq, Parser)]
    struct Opt {
        #[arg(global = true, long)]
        other: bool,
        #[command(subcommand)]
        sub: Subcommands,
    }

    #[derive(Debug, PartialEq, Eq, Subcommand)]
    enum Subcommands {
        Add,
        Global(GlobalCmd),
    }

    #[derive(Debug, PartialEq, Eq, Args)]
    struct GlobalCmd {
        #[arg(from_global)]
        other: bool,
    }

    assert_eq!(
        Opt::try_parse_from(["test", "global"]).unwrap(),
        Opt {
            other: false,
            sub: Subcommands::Global(GlobalCmd { other: false })
        }
    );

    assert_eq!(
        Opt::try_parse_from(["test", "global", "--other"]).unwrap(),
        Opt {
            other: true,
            sub: Subcommands::Global(GlobalCmd { other: true })
        }
    );
}

#[test]
fn external_subcommand() {
    #[derive(Debug, PartialEq, Eq, Parser)]
    struct Opt {
        #[command(subcommand)]
        sub: Subcommands,
    }

    #[derive(Debug, PartialEq, Eq, Subcommand)]
    enum Subcommands {
        Add,
        Remove,
        #[command(external_subcommand)]
        Other(Vec<String>),
    }

    assert_eq!(
        Opt::try_parse_from(["test", "add"]).unwrap(),
        Opt {
            sub: Subcommands::Add
        }
    );

    assert_eq!(
        Opt::try_parse_from(["test", "remove"]).unwrap(),
        Opt {
            sub: Subcommands::Remove
        }
    );

    assert!(Opt::try_parse_from(["test"]).is_err());

    assert_eq!(
        Opt::try_parse_from(["test", "git", "status"]).unwrap(),
        Opt {
            sub: Subcommands::Other(vec!["git".into(), "status".into()])
        }
    );
}

#[test]
fn external_subcommand_os_string() {
    use std::ffi::OsString;

    #[derive(Debug, PartialEq, Eq, Parser)]
    struct Opt {
        #[command(subcommand)]
        sub: Subcommands,
    }

    #[derive(Debug, PartialEq, Eq, Subcommand)]
    enum Subcommands {
        #[command(external_subcommand)]
        Other(Vec<OsString>),
    }

    assert_eq!(
        Opt::try_parse_from(["test", "git", "status"]).unwrap(),
        Opt {
            sub: Subcommands::Other(vec!["git".into(), "status".into()])
        }
    );

    assert!(Opt::try_parse_from(["test"]).is_err());
}

#[test]
fn external_subcommand_optional() {
    #[derive(Debug, PartialEq, Eq, Parser)]
    struct Opt {
        #[command(subcommand)]
        sub: Option<Subcommands>,
    }

    #[derive(Debug, PartialEq, Eq, Subcommand)]
    enum Subcommands {
        #[command(external_subcommand)]
        Other(Vec<String>),
    }

    assert_eq!(
        Opt::try_parse_from(["test", "git", "status"]).unwrap(),
        Opt {
            sub: Some(Subcommands::Other(vec!["git".into(), "status".into()]))
        }
    );

    assert_eq!(Opt::try_parse_from(["test"]).unwrap(), Opt { sub: None });
}

#[test]
fn enum_in_enum_subsubcommand() {
    #[derive(Parser, Debug, PartialEq, Eq)]
    pub(crate) enum Opt {
        #[command(alias = "l")]
        List,
        #[command(subcommand, alias = "d")]
        Daemon(DaemonCommand),
    }

    #[derive(Subcommand, Debug, PartialEq, Eq)]
    pub(crate) enum DaemonCommand {
        Start,
        Stop,
    }

    let result = Opt::try_parse_from(["test"]);
    assert!(result.is_err());

    let result = Opt::try_parse_from(["test", "list"]).unwrap();
    assert_eq!(Opt::List, result);

    let result = Opt::try_parse_from(["test", "l"]).unwrap();
    assert_eq!(Opt::List, result);

    let result = Opt::try_parse_from(["test", "daemon"]);
    assert!(result.is_err());

    let result = Opt::try_parse_from(["test", "daemon", "start"]).unwrap();
    assert_eq!(Opt::Daemon(DaemonCommand::Start), result);

    let result = Opt::try_parse_from(["test", "d", "start"]).unwrap();
    assert_eq!(Opt::Daemon(DaemonCommand::Start), result);
}

#[test]
fn update_subcommands() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    enum Opt {
        Command1(Command1),
        Command2(Command2),
    }

    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Command1 {
        arg1: i32,

        arg2: i32,
    }

    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Command2 {
        arg2: i32,
    }

    // Full subcommand update
    let mut opt = Opt::Command1(Command1 { arg1: 12, arg2: 14 });
    opt.try_update_from(["test", "command1", "42", "44"])
        .unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "command1", "42", "44"]).unwrap(),
        opt
    );

    // Partial subcommand update
    let mut opt = Opt::Command1(Command1 { arg1: 12, arg2: 14 });
    opt.try_update_from(["test", "command1", "42"]).unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "command1", "42", "14"]).unwrap(),
        opt
    );

    // Change subcommand
    let mut opt = Opt::Command1(Command1 { arg1: 12, arg2: 14 });
    opt.try_update_from(["test", "command2", "43"]).unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "command2", "43"]).unwrap(),
        opt
    );
}

#[test]
fn update_subcommands_explicit_required() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    #[command(subcommand_required = true)]
    enum Opt {
        Command1(Command1),
        Command2(Command2),
    }

    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Command1 {
        arg1: i32,

        arg2: i32,
    }

    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Command2 {
        arg2: i32,
    }

    // Full subcommand update
    let mut opt = Opt::Command1(Command1 { arg1: 12, arg2: 14 });
    opt.try_update_from(["test"]).unwrap();
    assert_eq!(Opt::Command1(Command1 { arg1: 12, arg2: 14 }), opt);
}

#[test]
fn update_sub_subcommands() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    enum Opt {
        #[command(subcommand)]
        Child1(Child1),
        #[command(subcommand)]
        Child2(Child2),
    }

    #[derive(Subcommand, PartialEq, Eq, Debug)]
    enum Child1 {
        Command1(Command1),
        Command2(Command2),
    }

    #[derive(Subcommand, PartialEq, Eq, Debug)]
    enum Child2 {
        Command1(Command1),
        Command2(Command2),
    }

    #[derive(Args, PartialEq, Eq, Debug)]
    struct Command1 {
        arg1: i32,

        arg2: i32,
    }

    #[derive(Args, PartialEq, Eq, Debug)]
    struct Command2 {
        arg2: i32,
    }

    // Full subcommand update
    let mut opt = Opt::Child1(Child1::Command1(Command1 { arg1: 12, arg2: 14 }));
    opt.try_update_from(["test", "child1", "command1", "42", "44"])
        .unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "child1", "command1", "42", "44"]).unwrap(),
        opt
    );

    // Partial subcommand update
    let mut opt = Opt::Child1(Child1::Command1(Command1 { arg1: 12, arg2: 14 }));
    opt.try_update_from(["test", "child1", "command1", "42"])
        .unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "child1", "command1", "42", "14"]).unwrap(),
        opt
    );

    // Partial subcommand update
    let mut opt = Opt::Child1(Child1::Command1(Command1 { arg1: 12, arg2: 14 }));
    opt.try_update_from(["test", "child1", "command2", "43"])
        .unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "child1", "command2", "43"]).unwrap(),
        opt
    );

    // Change subcommand
    let mut opt = Opt::Child1(Child1::Command1(Command1 { arg1: 12, arg2: 14 }));
    opt.try_update_from(["test", "child2", "command2", "43"])
        .unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "child2", "command2", "43"]).unwrap(),
        opt
    );
}

#[test]
fn update_ext_subcommand() {
    #[derive(Parser, PartialEq, Eq, Debug)]
    enum Opt {
        Command1(Command1),
        Command2(Command2),
        #[command(external_subcommand)]
        Ext(Vec<String>),
    }

    #[derive(Args, PartialEq, Eq, Debug)]
    struct Command1 {
        arg1: i32,

        arg2: i32,
    }

    #[derive(Args, PartialEq, Eq, Debug)]
    struct Command2 {
        arg2: i32,
    }

    // Full subcommand update
    let mut opt = Opt::Ext(vec!["12".into(), "14".into()]);
    opt.try_update_from(["test", "ext", "42", "44"]).unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "ext", "42", "44"]).unwrap(),
        opt
    );

    // No partial subcommand update
    let mut opt = Opt::Ext(vec!["12".into(), "14".into()]);
    opt.try_update_from(["test", "ext", "42"]).unwrap();
    assert_eq!(Opt::try_parse_from(["test", "ext", "42"]).unwrap(), opt);

    // Change subcommand
    let mut opt = Opt::Ext(vec!["12".into(), "14".into()]);
    opt.try_update_from(["test", "command2", "43"]).unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "command2", "43"]).unwrap(),
        opt
    );

    let mut opt = Opt::Command1(Command1 { arg1: 12, arg2: 14 });
    opt.try_update_from(["test", "ext", "42", "44"]).unwrap();
    assert_eq!(
        Opt::try_parse_from(["test", "ext", "42", "44"]).unwrap(),
        opt
    );
}
#[test]
fn subcommand_name_not_literal() {
    fn get_name() -> &'static str {
        "renamed"
    }

    #[derive(Parser, PartialEq, Eq, Debug)]
    struct Opt {
        #[command(subcommand)]
        subcmd: SubCmd,
    }

    #[derive(Subcommand, PartialEq, Eq, Debug)]
    enum SubCmd {
        #[command(name = get_name())]
        SubCmd1,
    }

    assert!(Opt::try_parse_from(["test", "renamed"]).is_ok());
}

#[test]
fn skip_subcommand() {
    #[derive(Debug, PartialEq, Eq, Parser)]
    struct Opt {
        #[command(subcommand)]
        sub: Subcommands,
    }

    #[derive(Debug, PartialEq, Eq, Subcommand)]
    enum Subcommands {
        Add,
        Remove,

        #[allow(dead_code)]
        #[command(skip)]
        Skip,

        #[allow(dead_code)]
        #[command(skip)]
        Other(Other),
    }

    #[allow(dead_code)]
    #[derive(Debug, PartialEq, Eq)]
    enum Other {
        One,
        Twp,
    }

    assert!(Subcommands::has_subcommand("add"));
    assert!(Subcommands::has_subcommand("remove"));
    assert!(!Subcommands::has_subcommand("skip"));
    assert!(!Subcommands::has_subcommand("other"));

    assert_eq!(
        Opt::try_parse_from(["test", "add"]).unwrap(),
        Opt {
            sub: Subcommands::Add
        }
    );

    assert_eq!(
        Opt::try_parse_from(["test", "remove"]).unwrap(),
        Opt {
            sub: Subcommands::Remove
        }
    );

    let res = Opt::try_parse_from(["test", "skip"]);
    assert_eq!(
        res.unwrap_err().kind(),
        clap::error::ErrorKind::InvalidSubcommand,
    );

    let res = Opt::try_parse_from(["test", "other"]);
    assert_eq!(
        res.unwrap_err().kind(),
        clap::error::ErrorKind::InvalidSubcommand,
    );
}

#[test]
fn built_in_subcommand_escaped() {
    #[derive(Debug, PartialEq, Eq, Parser)]
    enum Command {
        Install {
            arg: Option<String>,
        },
        #[command(external_subcommand)]
        Custom(Vec<String>),
    }

    assert_eq!(
        Command::try_parse_from(["test", "install", "arg"]).unwrap(),
        Command::Install {
            arg: Some(String::from("arg"))
        }
    );
    assert_eq!(
        Command::try_parse_from(["test", "--", "install"]).unwrap(),
        Command::Custom(vec![String::from("install")])
    );
    assert_eq!(
        Command::try_parse_from(["test", "--", "install", "arg"]).unwrap(),
        Command::Custom(vec![String::from("install"), String::from("arg")])
    );
}

```

`clap/tests/derive/type_alias_regressions.rs`:

```rs
//! Regression test to ensure that type aliases do not cause compilation failures.

use clap::{Parser, Subcommand, ValueEnum};

// Result type alias
#[allow(dead_code)]
type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

type Option<T> = std::option::Option<T>;

#[derive(Parser)]
pub(crate) struct Opts {
    another_string: String,
    #[command(subcommand)]
    command: Command,
    #[arg(short, long, value_enum)]
    choice: ArgChoice,
}

#[derive(Subcommand, PartialEq, Debug)]
enum Command {
    DoSomething { arg: Option<String> },
}

#[derive(ValueEnum, PartialEq, Debug, Clone)]
enum ArgChoice {
    Foo,
    Bar,
}

#[test]
fn type_alias_regressions() {
    Opts::try_parse_from(["test", "value", "--choice=foo", "do-something"]).unwrap();
}

```

`clap/tests/derive/utf8.rs`:

```rs
#![cfg(not(windows))]

use clap::error::ErrorKind;
use clap::Parser;
use std::ffi::OsString;
use std::os::unix::ffi::OsStringExt;

#[derive(Parser, Debug, PartialEq, Eq)]
struct Positional {
    arg: String,
}

#[derive(Parser, Debug, PartialEq, Eq)]
struct Named {
    #[arg(short, long)]
    arg: String,
}

#[test]
fn invalid_utf8_strict_positional() {
    let m = Positional::try_parse_from(vec![OsString::from(""), OsString::from_vec(vec![0xe9])]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_short_space() {
    let m = Named::try_parse_from(vec![
        OsString::from(""),
        OsString::from("-a"),
        OsString::from_vec(vec![0xe9]),
    ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_short_equals() {
    let m = Named::try_parse_from(vec![
        OsString::from(""),
        OsString::from_vec(vec![0x2d, 0x61, 0x3d, 0xe9]),
    ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_short_no_space() {
    let m = Named::try_parse_from(vec![
        OsString::from(""),
        OsString::from_vec(vec![0x2d, 0x61, 0xe9]),
    ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_long_space() {
    let m = Named::try_parse_from(vec![
        OsString::from(""),
        OsString::from("--arg"),
        OsString::from_vec(vec![0xe9]),
    ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn invalid_utf8_strict_option_long_equals() {
    let m = Named::try_parse_from(vec![
        OsString::from(""),
        OsString::from_vec(vec![0x2d, 0x2d, 0x61, 0x72, 0x67, 0x3d, 0xe9]),
    ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[derive(Parser, Debug, PartialEq, Eq)]
struct PositionalOs {
    arg: OsString,
}

#[derive(Parser, Debug, PartialEq, Eq)]
struct NamedOs {
    #[arg(short, long)]
    arg: OsString,
}

#[test]
fn invalid_utf8_positional() {
    let r = PositionalOs::try_parse_from(vec![OsString::from(""), OsString::from_vec(vec![0xe9])]);
    assert_eq!(
        r.unwrap(),
        PositionalOs {
            arg: OsString::from_vec(vec![0xe9])
        }
    );
}

#[test]
fn invalid_utf8_option_short_space() {
    let r = NamedOs::try_parse_from(vec![
        OsString::from(""),
        OsString::from("-a"),
        OsString::from_vec(vec![0xe9]),
    ]);
    assert_eq!(
        r.unwrap(),
        NamedOs {
            arg: OsString::from_vec(vec![0xe9])
        }
    );
}

#[test]
fn invalid_utf8_option_short_equals() {
    let r = NamedOs::try_parse_from(vec![
        OsString::from(""),
        OsString::from_vec(vec![0x2d, 0x61, 0x3d, 0xe9]),
    ]);
    assert_eq!(
        r.unwrap(),
        NamedOs {
            arg: OsString::from_vec(vec![0xe9])
        }
    );
}

#[test]
fn invalid_utf8_option_short_no_space() {
    let r = NamedOs::try_parse_from(vec![
        OsString::from(""),
        OsString::from_vec(vec![0x2d, 0x61, 0xe9]),
    ]);
    assert_eq!(
        r.unwrap(),
        NamedOs {
            arg: OsString::from_vec(vec![0xe9])
        }
    );
}

#[test]
fn invalid_utf8_option_long_space() {
    let r = NamedOs::try_parse_from(vec![
        OsString::from(""),
        OsString::from("--arg"),
        OsString::from_vec(vec![0xe9]),
    ]);
    assert_eq!(
        r.unwrap(),
        NamedOs {
            arg: OsString::from_vec(vec![0xe9])
        }
    );
}

#[test]
fn invalid_utf8_option_long_equals() {
    let r = NamedOs::try_parse_from(vec![
        OsString::from(""),
        OsString::from_vec(vec![0x2d, 0x2d, 0x61, 0x72, 0x67, 0x3d, 0xe9]),
    ]);
    assert_eq!(
        r.unwrap(),
        NamedOs {
            arg: OsString::from_vec(vec![0xe9])
        }
    );
}

#[derive(Debug, PartialEq, Parser)]
enum External {
    #[command(external_subcommand)]
    Other(Vec<String>),
}

#[test]
fn refuse_invalid_utf8_subcommand_with_allow_external_subcommands() {
    let m = External::try_parse_from(vec![
        OsString::from(""),
        OsString::from_vec(vec![0xe9]),
        OsString::from("normal"),
    ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[test]
fn refuse_invalid_utf8_subcommand_args_with_allow_external_subcommands() {
    let m = External::try_parse_from(vec![
        OsString::from(""),
        OsString::from("subcommand"),
        OsString::from("normal"),
        OsString::from_vec(vec![0xe9]),
        OsString::from("--another_normal"),
    ]);
    assert!(m.is_err());
    assert_eq!(m.unwrap_err().kind(), ErrorKind::InvalidUtf8);
}

#[derive(Debug, PartialEq, Parser)]
enum ExternalOs {
    #[command(external_subcommand)]
    Other(Vec<OsString>),
}

#[test]
fn allow_invalid_utf8_subcommand_args_with_allow_external_subcommands() {
    let m = ExternalOs::try_parse_from(vec![
        OsString::from(""),
        OsString::from("subcommand"),
        OsString::from("normal"),
        OsString::from_vec(vec![0xe9]),
        OsString::from("--another_normal"),
    ]);
    assert_eq!(
        m.unwrap(),
        ExternalOs::Other(vec![
            OsString::from("subcommand"),
            OsString::from("normal"),
            OsString::from_vec(vec![0xe9]),
            OsString::from("--another_normal"),
        ])
    );
}

```

`clap/tests/derive/utils.rs`:

```rs
// Hi, future me (or whoever you are)!
//
// Yes, we do need this attr.
// No, the warnings cannot be fixed otherwise.
// Accept and endure. Do not touch.
#![allow(unused)]

use clap::CommandFactory;
use snapbox::assert_data_eq;

pub(crate) const FULL_TEMPLATE: &str = "\
{before-help}{name} {version}
{author-with-newline}{about-with-newline}
{usage-heading} {usage}

{all-args}{after-help}";

pub(crate) fn get_help<T: CommandFactory>() -> String {
    let output = <T as CommandFactory>::command().render_help().to_string();

    eprintln!("\n%%% HELP %%%:=====\n{output}\n=====\n");
    eprintln!("\n%%% HELP (DEBUG) %%%:=====\n{output:?}\n=====\n");

    output
}

pub(crate) fn get_long_help<T: CommandFactory>() -> String {
    let output = <T as CommandFactory>::command()
        .render_long_help()
        .to_string();

    eprintln!("\n%%% LONG_HELP %%%:=====\n{output}\n=====\n");
    eprintln!("\n%%% LONG_HELP (DEBUG) %%%:=====\n{output:?}\n=====\n");

    output
}

pub(crate) fn get_subcommand_long_help<T: CommandFactory>(subcmd: &str) -> String {
    let output = <T as CommandFactory>::command()
        .get_subcommands_mut()
        .find(|s| s.get_name() == subcmd)
        .unwrap()
        .render_long_help()
        .to_string();

    eprintln!("\n%%% SUBCOMMAND `{subcmd}` HELP %%%:=====\n{output}\n=====\n",);
    eprintln!("\n%%% SUBCOMMAND `{subcmd}` HELP (DEBUG) %%%:=====\n{output:?}\n=====\n",);

    output
}

#[track_caller]
pub(crate) fn assert_output<P: clap::Parser + std::fmt::Debug>(
    args: &str,
    expected: impl snapbox::IntoData,
    stderr: bool,
) {
    let res = P::try_parse_from(args.split(' ').collect::<Vec<_>>());
    let err = res.unwrap_err();
    let actual = err.render().to_string();
    assert_eq!(
        stderr,
        err.use_stderr(),
        "Should Use STDERR failed. Should be {} but is {}",
        stderr,
        err.use_stderr()
    );
    assert_data_eq!(actual, expected.raw());
}

```

`clap/tests/derive/value_enum.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>,
// Kevin Knapp (@kbknapp) <kbknapp@gmail.com>, and
// Ana Hobden (@hoverbear) <operator@hoverbear.org>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.
use clap::Parser;

#[test]
fn basic() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
        Bar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum)]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::Foo
        },
        Opt::try_parse_from(["", "foo"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: ArgChoice::Bar
        },
        Opt::try_parse_from(["", "bar"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "fOo"]).is_err());
}

#[test]
fn default_value() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
        Bar,
    }

    impl Default for ArgChoice {
        fn default() -> Self {
            Self::Bar
        }
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, default_value_t)]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::Foo
        },
        Opt::try_parse_from(["", "foo"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: ArgChoice::Bar
        },
        Opt::try_parse_from(["", "bar"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: ArgChoice::Bar
        },
        Opt::try_parse_from([""]).unwrap()
    );
}

#[test]
fn vec_for_default_values_t() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
        Bar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, default_values_t = vec![ArgChoice::Foo, ArgChoice::Bar])]
        arg1: Vec<ArgChoice>,

        #[arg(
            long,
            value_enum,
            default_values_t = clap::ValueEnum::value_variants()
        )]
        arg2: Vec<ArgChoice>,
    }

    assert_eq!(
        Opt {
            arg1: vec![ArgChoice::Foo],
            arg2: vec![ArgChoice::Foo, ArgChoice::Bar]
        },
        Opt::try_parse_from(["", "foo"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg1: vec![ArgChoice::Bar],
            arg2: vec![ArgChoice::Foo, ArgChoice::Bar]
        },
        Opt::try_parse_from(["", "bar"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg1: vec![ArgChoice::Foo, ArgChoice::Bar],
            arg2: vec![ArgChoice::Foo, ArgChoice::Bar]
        },
        Opt::try_parse_from([""]).unwrap()
    );
    assert_eq!(
        Opt {
            arg1: vec![ArgChoice::Foo, ArgChoice::Bar],
            arg2: vec![ArgChoice::Foo]
        },
        Opt::try_parse_from(["", "--arg2", "foo"]).unwrap()
    );
}

#[test]
fn vec_for_default_values_os_t() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
        Bar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, default_values_os_t = vec![ArgChoice::Foo, ArgChoice::Bar])]
        arg: Vec<ArgChoice>,

        #[arg(
            long,
            value_enum,
            default_values_os_t = clap::ValueEnum::value_variants()
        )]
        arg2: Vec<ArgChoice>,
    }

    assert_eq!(
        Opt {
            arg: vec![ArgChoice::Foo],
            arg2: vec![ArgChoice::Foo, ArgChoice::Bar]
        },
        Opt::try_parse_from(["", "foo"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: vec![ArgChoice::Bar],
            arg2: vec![ArgChoice::Foo, ArgChoice::Bar]
        },
        Opt::try_parse_from(["", "bar"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: vec![ArgChoice::Foo, ArgChoice::Bar],
            arg2: vec![ArgChoice::Foo, ArgChoice::Bar]
        },
        Opt::try_parse_from([""]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: vec![ArgChoice::Foo, ArgChoice::Bar],
            arg2: vec![ArgChoice::Foo]
        },
        Opt::try_parse_from(["", "--arg2", "foo"]).unwrap()
    );
}

#[test]
fn multi_word_is_renamed_kebab() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    #[allow(non_camel_case_types)]
    enum ArgChoice {
        FooBar,
        BAR_BAZ,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum)]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::FooBar
        },
        Opt::try_parse_from(["", "foo-bar"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: ArgChoice::BAR_BAZ
        },
        Opt::try_parse_from(["", "bar-baz"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "FooBar"]).is_err());
}

#[test]
fn variant_with_defined_casing() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        #[value(rename_all = "screaming_snake")]
        FooBar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum)]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::FooBar
        },
        Opt::try_parse_from(["", "FOO_BAR"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "FooBar"]).is_err());
}

#[test]
fn casing_is_propagated_from_parent() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    #[value(rename_all = "screaming_snake")]
    enum ArgChoice {
        FooBar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum)]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::FooBar
        },
        Opt::try_parse_from(["", "FOO_BAR"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "FooBar"]).is_err());
}

#[test]
fn casing_propagation_is_overridden() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    #[value(rename_all = "screaming_snake")]
    enum ArgChoice {
        #[value(rename_all = "camel")]
        FooBar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum)]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::FooBar
        },
        Opt::try_parse_from(["", "fooBar"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "FooBar"]).is_err());
    assert!(Opt::try_parse_from(["", "FOO_BAR"]).is_err());
}

#[test]
fn ignore_case() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, ignore_case(true))]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::Foo
        },
        Opt::try_parse_from(["", "foo"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: ArgChoice::Foo
        },
        Opt::try_parse_from(["", "fOo"]).unwrap()
    );
}

#[test]
fn ignore_case_set_to_false() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, ignore_case(false))]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::Foo
        },
        Opt::try_parse_from(["", "foo"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "fOo"]).is_err());
}

#[test]
fn alias() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        #[value(alias = "TOTP")]
        Totp,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, ignore_case(false))]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::Totp
        },
        Opt::try_parse_from(["", "totp"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: ArgChoice::Totp
        },
        Opt::try_parse_from(["", "TOTP"]).unwrap()
    );
}

#[test]
fn multiple_alias() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        #[value(alias = "TOTP", alias = "t")]
        Totp,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, ignore_case(false))]
        arg: ArgChoice,
    }

    assert_eq!(
        Opt {
            arg: ArgChoice::Totp
        },
        Opt::try_parse_from(["", "totp"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: ArgChoice::Totp
        },
        Opt::try_parse_from(["", "TOTP"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: ArgChoice::Totp
        },
        Opt::try_parse_from(["", "t"]).unwrap()
    );
}

#[test]
fn skip_variant() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    #[allow(dead_code)] // silence warning about `Baz` being unused
    enum ArgChoice {
        Foo,
        Bar,
        #[value(skip)]
        Baz,
    }

    assert_eq!(
        <ArgChoice as clap::ValueEnum>::value_variants()
            .iter()
            .map(clap::ValueEnum::to_possible_value)
            .map(Option::unwrap)
            .collect::<Vec<_>>(),
        vec![
            clap::builder::PossibleValue::new("foo"),
            clap::builder::PossibleValue::new("bar")
        ]
    );

    {
        use clap::ValueEnum;
        assert!(ArgChoice::from_str("foo", true).is_ok());
        assert!(ArgChoice::from_str("bar", true).is_ok());
        assert!(ArgChoice::from_str("baz", true).is_err());
    }
}

#[test]
fn skip_non_unit_variant() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    #[allow(dead_code)] // silence warning about `Baz` being unused
    enum ArgChoice {
        Foo,
        Bar,
        #[value(skip)]
        Baz(usize),
    }

    assert_eq!(
        <ArgChoice as clap::ValueEnum>::value_variants()
            .iter()
            .map(clap::ValueEnum::to_possible_value)
            .map(Option::unwrap)
            .collect::<Vec<_>>(),
        vec![
            clap::builder::PossibleValue::new("foo"),
            clap::builder::PossibleValue::new("bar")
        ]
    );

    {
        use clap::ValueEnum;
        assert!(ArgChoice::from_str("foo", true).is_ok());
        assert!(ArgChoice::from_str("bar", true).is_ok());
        assert!(ArgChoice::from_str("baz", true).is_err());
    }
}

#[test]
fn from_str_invalid() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
    }

    {
        use clap::ValueEnum;
        assert!(ArgChoice::from_str("bar", true).is_err());
    }
}

#[test]
fn option_type() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
        Bar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum)]
        arg: Option<ArgChoice>,
    }

    assert_eq!(Opt { arg: None }, Opt::try_parse_from([""]).unwrap());
    assert_eq!(
        Opt {
            arg: Some(ArgChoice::Foo)
        },
        Opt::try_parse_from(["", "foo"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: Some(ArgChoice::Bar)
        },
        Opt::try_parse_from(["", "bar"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "fOo"]).is_err());
}

#[test]
fn option_option_type() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
        Bar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, long)]
        arg: Option<Option<ArgChoice>>,
    }

    assert_eq!(Opt { arg: None }, Opt::try_parse_from([""]).unwrap());
    assert_eq!(
        Opt { arg: Some(None) },
        Opt::try_parse_from(["", "--arg"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: Some(Some(ArgChoice::Foo))
        },
        Opt::try_parse_from(["", "--arg", "foo"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: Some(Some(ArgChoice::Bar))
        },
        Opt::try_parse_from(["", "--arg", "bar"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "--arg", "fOo"]).is_err());
}

#[test]
fn vec_type() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
        Bar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, short, long)]
        arg: Vec<ArgChoice>,
    }

    assert_eq!(Opt { arg: vec![] }, Opt::try_parse_from([""]).unwrap());
    assert_eq!(
        Opt {
            arg: vec![ArgChoice::Foo]
        },
        Opt::try_parse_from(["", "-a", "foo"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: vec![ArgChoice::Foo, ArgChoice::Bar]
        },
        Opt::try_parse_from(["", "-a", "foo", "-a", "bar"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "-a", "fOo"]).is_err());
}

#[test]
fn option_vec_type() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
        Bar,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(value_enum, short, long)]
        arg: Option<Vec<ArgChoice>>,
    }

    assert_eq!(Opt { arg: None }, Opt::try_parse_from([""]).unwrap());
    assert_eq!(
        Opt {
            arg: Some(vec![ArgChoice::Foo])
        },
        Opt::try_parse_from(["", "-a", "foo"]).unwrap()
    );
    assert_eq!(
        Opt {
            arg: Some(vec![ArgChoice::Foo, ArgChoice::Bar])
        },
        Opt::try_parse_from(["", "-a", "foo", "-a", "bar"]).unwrap()
    );
    assert!(Opt::try_parse_from(["", "-a", "fOo"]).is_err());
}

#[test]
fn vec_type_default_value() {
    #[derive(clap::ValueEnum, PartialEq, Debug, Clone)]
    enum ArgChoice {
        Foo,
        Bar,
        Baz,
    }

    #[derive(Parser, PartialEq, Debug)]
    struct Opt {
        #[arg(
            value_enum,
            short,
            long,
            default_value = "foo,bar",
            value_delimiter = ','
        )]
        arg: Vec<ArgChoice>,
    }

    assert_eq!(
        Opt {
            arg: vec![ArgChoice::Foo, ArgChoice::Bar]
        },
        Opt::try_parse_from([""]).unwrap()
    );

    assert_eq!(
        Opt {
            arg: vec![ArgChoice::Foo, ArgChoice::Baz]
        },
        Opt::try_parse_from(["", "-a", "foo,baz"]).unwrap()
    );
}

```

`clap/tests/derive_ui.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed

#![cfg(feature = "unstable-derive-ui-tests")]

#[cfg(feature = "derive")]
#[rustversion::attr(not(stable(1.86)), ignore)] // STABLE
#[test]
fn ui() {
    let t = trybuild::TestCases::new();
    t.compile_fail("tests/derive_ui/*.rs");
}

```

`clap/tests/derive_ui/bool_value_enum.rs`:

```rs
use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "basic")]
struct Opt {
    #[arg(short, value_enum, default_value_t)]
    opts: bool,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/bool_value_enum.stderr`:

```stderr
error[E0277]: the trait bound `bool: ValueEnum` is not satisfied
 --> tests/derive_ui/bool_value_enum.rs:6:30
  |
6 |     #[arg(short, value_enum, default_value_t)]
  |                              ^^^^^^^^^^^^^^^ the trait `ValueEnum` is not implemented for `bool`
  |
  = help: the trait `ValueEnum` is implemented for `ColorChoice`

```

`clap/tests/derive_ui/clap_empty_attr.rs`:

```rs
use clap::Parser;

#[derive(Parser, Debug)]
#[command]
struct Opt {}

#[derive(Parser, Debug)]
struct Opt1 {
    #[arg = "short"]
    foo: u32,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/clap_empty_attr.stderr`:

```stderr
error: expected attribute arguments in parentheses: #[command(...)]
 --> tests/derive_ui/clap_empty_attr.rs:4:3
  |
4 | #[command]
  |   ^^^^^^^

error: expected parentheses: #[arg(...)]
 --> tests/derive_ui/clap_empty_attr.rs:9:11
  |
9 |     #[arg = "short"]
  |           ^

```

`clap/tests/derive_ui/default_value_t_invalid.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "basic")]
struct Opt {
    #[arg(default_value_t = -10)]
    value: u32,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/default_value_t_invalid.stderr`:

```stderr
error[E0600]: cannot apply unary operator `-` to type `u32`
  --> tests/derive_ui/default_value_t_invalid.rs:14:29
   |
14 |     #[arg(default_value_t = -10)]
   |                             ^^^ cannot apply unary operator `-`
   |
   = note: unsigned values cannot be negated

```

`clap/tests/derive_ui/default_values_t_invalid.rs`:

```rs
use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "basic")]
struct Opt {
    #[arg(default_values_t = [1, 2, 3])]
    value: u32,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/default_values_t_invalid.stderr`:

```stderr
error: #[arg(default_values_t)] can be used only on Vec types

       = note: see https://docs.rs/clap/latest/clap/_derive/index.html#arg-attributes

 --> tests/derive_ui/default_values_t_invalid.rs:6:11
  |
6 |     #[arg(default_values_t = [1, 2, 3])]
  |           ^^^^^^^^^^^^^^^^

```

`clap/tests/derive_ui/enum_flatten.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "basic")]
enum Opt {
    #[command(flatten)]
    Variant1,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/enum_flatten.stderr`:

```stderr
error: `flatten` is usable only with single-typed tuple variants
  --> tests/derive_ui/enum_flatten.rs:14:5
   |
14 | /     #[command(flatten)]
15 | |     Variant1,
   | |____________^

```

`clap/tests/derive_ui/enum_variant_not_args.rs`:

```rs
#[derive(clap::Parser)]
enum Opt {
    Sub(SubCmd),
}

#[derive(clap::Parser)]
enum SubCmd {}

fn main() {}

```

`clap/tests/derive_ui/enum_variant_not_args.stderr`:

```stderr
error[E0277]: the trait bound `SubCmd: clap::Args` is not satisfied
 --> tests/derive_ui/enum_variant_not_args.rs:3:9
  |
3 |     Sub(SubCmd),
  |         ^^^^^^ the trait `clap::Args` is not implemented for `SubCmd`
  |
  = help: the trait `clap::Args` is implemented for `Box<T>`

```

`clap/tests/derive_ui/external_subcommand_misuse.rs`:

```rs
use clap::Parser;

#[derive(Parser, Debug)]
struct Opt {
    #[command(external_subcommand)]
    field: String,
}

fn main() {
    let _ = Opt::parse();
}

```

`clap/tests/derive_ui/external_subcommand_misuse.stderr`:

```stderr
error: `external_subcommand` cannot be used with `arg`
 --> tests/derive_ui/external_subcommand_misuse.rs:5:15
  |
5 |     #[command(external_subcommand)]
  |               ^^^^^^^^^^^^^^^^^^^

```

`clap/tests/derive_ui/external_subcommand_wrong_type.rs`:

```rs
use clap::Parser;
use std::ffi::CString;

#[derive(Parser, Debug)]
enum Opt {
    #[command(external_subcommand)]
    Other(Vec<CString>),
}

#[derive(Parser, Debug)]
enum Opt2 {
    #[command(external_subcommand)]
    Other(String),
}

#[derive(Parser, Debug)]
enum Opt3 {
    #[command(external_subcommand)]
    Other { a: String },
}

fn main() {
    let _ = Opt::parse();
    let _ = Opt2::parse();
    let _ = Opt3::parse();
}

```

`clap/tests/derive_ui/external_subcommand_wrong_type.stderr`:

```stderr
error: The type must be either `Vec<String>` or `Vec<OsString>` to be used with `external_subcommand`.
 --> tests/derive_ui/external_subcommand_wrong_type.rs:7:11
  |
7 |     Other(Vec<CString>),
  |           ^^^

error: The type must be either `Vec<String>` or `Vec<OsString>` to be used with `external_subcommand`.
  --> tests/derive_ui/external_subcommand_wrong_type.rs:13:11
   |
13 |     Other(String),
   |           ^^^^^^

error: The enum variant marked with `external_subcommand` must be a single-typed tuple, and the type must be either `Vec<String>` or `Vec<OsString>`.
  --> tests/derive_ui/external_subcommand_wrong_type.rs:18:5
   |
18 | /     #[command(external_subcommand)]
19 | |     Other { a: String },
   | |_______________________^

```

`clap/tests/derive_ui/flatten_and_methods.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
struct DaemonOpts {
    #[arg(short)]
    user: String,
    #[arg(short)]
    group: String,
}

#[derive(Parser, Debug)]
#[command(name = "basic")]
struct Opt {
    #[command(flatten, version = "foo")]
    opts: DaemonOpts,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/flatten_and_methods.stderr`:

```stderr
error: methods are not allowed for flattened entry
  --> tests/derive_ui/flatten_and_methods.rs:22:15
   |
22 |     #[command(flatten, version = "foo")]
   |               ^^^^^^^

```

`clap/tests/derive_ui/flatten_enum_in_struct.rs`:

```rs
#[derive(clap::Parser)]
struct Opt {
    #[command(flatten)]
    sub: SubCmd,
}

#[derive(clap::Parser)]
enum SubCmd {}

fn main() {}

```

`clap/tests/derive_ui/flatten_enum_in_struct.stderr`:

```stderr
error[E0277]: the trait bound `SubCmd: clap::Args` is not satisfied
 --> tests/derive_ui/flatten_enum_in_struct.rs:4:10
  |
4 |     sub: SubCmd,
  |          ^^^^^^ the trait `clap::Args` is not implemented for `SubCmd`
  |
  = help: the following other types implement trait `clap::Args`:
            Box<T>
            Opt

```

`clap/tests/derive_ui/flatten_struct_in_enum.rs`:

```rs
#[derive(clap::Parser)]
enum Opt {
    #[command(flatten)]
    Sub(SubCmd),
}

#[derive(clap::Parser)]
struct SubCmd {}

fn main() {}

```

`clap/tests/derive_ui/flatten_struct_in_enum.stderr`:

```stderr
error[E0277]: the trait bound `SubCmd: Subcommand` is not satisfied
 --> tests/derive_ui/flatten_struct_in_enum.rs:4:9
  |
4 |     Sub(SubCmd),
  |         ^^^^^^ the trait `Subcommand` is not implemented for `SubCmd`
  |
  = help: the following other types implement trait `Subcommand`:
            Box<T>
            Opt

```

`clap/tests/derive_ui/group_name_attribute.rs`:

```rs
use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "basic")]
struct Opt {
    #[command(flatten)]
    source: Source,
}

#[derive(clap::Args, Debug)]
#[group(required = true, name = "src")]
struct Source {
    #[arg(short)]
    git: String,

    #[arg(short)]
    path: String,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/group_name_attribute.stderr`:

```stderr
error[E0599]: no method named `name` found for struct `ArgGroup` in the current scope
  --> tests/derive_ui/group_name_attribute.rs:11:26
   |
11 | #[group(required = true, name = "src")]
   |                          ^^^^
   |
help: there is a method `ne` with a similar name
   |
11 - #[group(required = true, name = "src")]
11 + #[group(required = true, ne = "src")]
   |

```

`clap/tests/derive_ui/multiple_external_subcommand.rs`:

```rs
use clap::Parser;

#[derive(Parser, Debug)]
struct Opt {
    #[command(subcommand)]
    cmd: Command,
}

#[derive(Parser, Debug)]
enum Command {
    #[command(external_subcommand)]
    Run(Vec<String>),

    #[command(external_subcommand)]
    Other(Vec<String>),
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/multiple_external_subcommand.stderr`:

```stderr
error: Only one variant can be marked with `external_subcommand`, this is the second
  --> tests/derive_ui/multiple_external_subcommand.rs:14:15
   |
14 |     #[command(external_subcommand)]
   |               ^^^^^^^^^^^^^^^^^^^

```

`clap/tests/derive_ui/non_existent_attr.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "basic")]
struct Opt {
    #[arg(short, non_existing_attribute = 1)]
    debug: bool,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/non_existent_attr.stderr`:

```stderr
error[E0599]: no method named `non_existing_attribute` found for struct `Arg` in the current scope
  --> tests/derive_ui/non_existent_attr.rs:14:18
   |
14 |     #[arg(short, non_existing_attribute = 1)]
   |                  ^^^^^^^^^^^^^^^^^^^^^^ method not found in `Arg`

```

`clap/tests/derive_ui/rename_all_wrong_casing.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "basic", rename_all = "fail")]
struct Opt {
    #[arg(short)]
    s: String,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/rename_all_wrong_casing.stderr`:

```stderr
error: unsupported casing: `fail`
  --> tests/derive_ui/rename_all_wrong_casing.rs:12:40
   |
12 | #[command(name = "basic", rename_all = "fail")]
   |                                        ^^^^^^

```

`clap/tests/derive_ui/skip_flatten.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "make-cookie")]
struct MakeCookie {
    #[arg(short)]
    s: String,

    #[command(skip, flatten)]
    cmd: Command,
}

#[derive(Parser, Debug)]
enum Command {
    #[command(name = "pound")]
    /// Pound acorns into flour for cookie dough.
    Pound { acorns: u32 },

    Sparkle {
        #[arg(short)]
        color: String,
    },
}

impl Default for Command {
    fn default() -> Self {
        Command::Pound { acorns: 0 }
    }
}

fn main() {
    let opt = MakeCookie::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/skip_flatten.stderr`:

```stderr
error: `flatten` cannot be used with `skip`
  --> tests/derive_ui/skip_flatten.rs:17:21
   |
17 |     #[command(skip, flatten)]
   |                     ^^^^^^^

```

`clap/tests/derive_ui/skip_subcommand.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "make-cookie")]
struct MakeCookie {
    #[arg(short)]
    s: String,

    #[command(subcommand, skip)]
    cmd: Command,
}

#[derive(Parser, Debug)]
enum Command {
    #[command(name = "pound")]
    /// Pound acorns into flour for cookie dough.
    Pound { acorns: u32 },

    Sparkle {
        #[arg(short)]
        color: String,
    },
}

impl Default for Command {
    fn default() -> Self {
        Command::Pound { acorns: 0 }
    }
}

fn main() {
    let opt = MakeCookie::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/skip_subcommand.stderr`:

```stderr
error: `skip` cannot be used with `subcommand`
  --> tests/derive_ui/skip_subcommand.rs:17:27
   |
17 |     #[command(subcommand, skip)]
   |                           ^^^^

```

`clap/tests/derive_ui/skip_with_other_options.rs`:

```rs
use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "test")]
pub struct Opt {
    #[arg(long)]
    a: u32,
    #[arg(skip, long)]
    b: u32,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/skip_with_other_options.stderr`:

```stderr
error: `long` cannot be used with `#[arg(skip)]
 --> tests/derive_ui/skip_with_other_options.rs:8:17
  |
8 |     #[arg(skip, long)]
  |                 ^^^^

```

`clap/tests/derive_ui/skip_without_default.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Debug)]
enum Kind {
    A,
    B,
}

#[derive(Parser, Debug)]
#[command(name = "test")]
pub struct Opt {
    #[arg(short)]
    number: u32,
    #[arg(skip)]
    k: Kind,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/skip_without_default.stderr`:

```stderr
error[E0277]: the trait bound `Kind: Default` is not satisfied
  --> tests/derive_ui/skip_without_default.rs:22:11
   |
22 |     #[arg(skip)]
   |           ^^^^ the trait `Default` is not implemented for `Kind`

```

`clap/tests/derive_ui/struct_subcommand.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "basic", subcommand)]
struct Opt {
    #[arg(short)]
    s: String,
}

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/struct_subcommand.stderr`:

```stderr
error: `subcommand` cannot be used with `command`
  --> tests/derive_ui/struct_subcommand.rs:12:27
   |
12 | #[command(name = "basic", subcommand)]
   |                           ^^^^^^^^^^

```

`clap/tests/derive_ui/subcommand_and_flatten.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
struct MakeCookie {
    #[arg(short)]
    s: String,

    #[command(subcommand, flatten)]
    cmd: Command,
}

#[derive(Parser, Debug)]
enum Command {
    /// Pound acorns into flour for cookie dough.
    Pound { acorns: u32 },

    Sparkle {
        #[arg(short)]
        color: String,
    },
}

fn main() {
    let opt = MakeCookie::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/subcommand_and_flatten.stderr`:

```stderr
error: `flatten` cannot be used with `subcommand`
  --> tests/derive_ui/subcommand_and_flatten.rs:16:27
   |
16 |     #[command(subcommand, flatten)]
   |                           ^^^^^^^

```

`clap/tests/derive_ui/subcommand_and_methods.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
struct MakeCookie {
    #[arg(short)]
    s: String,

    #[command(subcommand, version = "foo")]
    cmd: Command,
}

#[derive(Parser, Debug)]
enum Command {
    /// Pound acorns into flour for cookie dough.
    Pound { acorns: u32 },

    Sparkle {
        #[arg(short)]
        color: String,
    },
}

fn main() {
    let opt = MakeCookie::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/subcommand_and_methods.stderr`:

```stderr
error: methods in attributes are not allowed for subcommand
  --> tests/derive_ui/subcommand_and_methods.rs:16:15
   |
16 |     #[command(subcommand, version = "foo")]
   |               ^^^^^^^^^^

```

`clap/tests/derive_ui/subcommand_on_struct.rs`:

```rs
use clap::Subcommand;

#[derive(Subcommand, Debug)]
struct Opt {}

fn main() {}

```

`clap/tests/derive_ui/subcommand_on_struct.stderr`:

```stderr
error: `#[derive(Subcommand)]` only supports enums
 --> $DIR/subcommand_on_struct.rs:3:10
  |
3 | #[derive(Subcommand, Debug)]
  |          ^^^^^^^^^^
  |
  = note: this error originates in the derive macro `Subcommand` (in Nightly builds, run with -Z macro-backtrace for more info)

```

`clap/tests/derive_ui/subcommand_opt_opt.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
struct MakeCookie {
    #[arg(short)]
    s: String,

    #[command(subcommand)]
    cmd: Option<Option<Command>>,
}

#[derive(Parser, Debug)]
enum Command {
    /// Pound acorns into flour for cookie dough.
    Pound { acorns: u32 },

    Sparkle {
        #[arg(short)]
        color: String,
    },
}

fn main() {
    let opt = MakeCookie::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/subcommand_opt_opt.stderr`:

```stderr
error: Option<Option<T>> types are not supported for subcommand
  --> tests/derive_ui/subcommand_opt_opt.rs:17:10
   |
17 |     cmd: Option<Option<Command>>,
   |          ^^^^^^

```

`clap/tests/derive_ui/subcommand_opt_vec.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
struct MakeCookie {
    #[arg(short)]
    s: String,

    #[command(subcommand)]
    cmd: Option<Vec<Command>>,
}

#[derive(Parser, Debug)]
enum Command {
    /// Pound acorns into flour for cookie dough.
    Pound { acorns: u32 },

    Sparkle {
        #[arg(short)]
        color: String,
    },
}

fn main() {
    let opt = MakeCookie::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/subcommand_opt_vec.stderr`:

```stderr
error: Option<Vec<T>> types are not supported for subcommand
  --> tests/derive_ui/subcommand_opt_vec.rs:17:10
   |
17 |     cmd: Option<Vec<Command>>,
   |          ^^^^^^

```

`clap/tests/derive_ui/tuple_struct.rs`:

```rs
// Copyright 2018 Guillaume Pinot (@TeXitoi) <texitoi@texitoi.eu>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use clap::Parser;

#[derive(Parser, Debug)]
#[command(name = "basic")]
struct Opt(u32);

fn main() {
    let opt = Opt::parse();
    println!("{opt:?}");
}

```

`clap/tests/derive_ui/tuple_struct.stderr`:

```stderr
error: `#[derive(Parser)]` only supports non-tuple structs and enums
  --> tests/derive_ui/tuple_struct.rs:11:10
   |
11 | #[derive(Parser, Debug)]
   |          ^^^^^^
   |
   = note: this error originates in the derive macro `Parser` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no function or associated item named `parse` found for struct `Opt` in the current scope
  --> tests/derive_ui/tuple_struct.rs:16:20
   |
13 | struct Opt(u32);
   | ---------- function or associated item `parse` not found for this struct
...
16 |     let opt = Opt::parse();
   |                    ^^^^^ function or associated item not found in `Opt`
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following traits define an item `parse`, perhaps you need to implement one of them:
           candidate #1: `Parser`
           candidate #2: `TypedValueParser`

```

`clap/tests/derive_ui/value_enum_non_unit.rs`:

```rs
use clap::ValueEnum;

#[derive(ValueEnum, Clone, Debug)]
enum Opt {
    Foo(usize),
}

fn main() {
    println!("{:?}", Opt::Foo(42));
}

```

`clap/tests/derive_ui/value_enum_non_unit.stderr`:

```stderr
error: `#[derive(ValueEnum)]` only supports unit variants. Non-unit variants must be skipped
 --> tests/derive_ui/value_enum_non_unit.rs:5:5
  |
5 |     Foo(usize),
  |     ^^^

```

`clap/tests/derive_ui/value_enum_on_struct.rs`:

```rs
use clap::ValueEnum;

#[derive(ValueEnum, Clone, Debug)]
struct Opt {}

fn main() {
    println!("{:?}", Opt::value_variants());
}

```

`clap/tests/derive_ui/value_enum_on_struct.stderr`:

```stderr
error: `#[derive(ValueEnum)]` only supports enums
 --> tests/derive_ui/value_enum_on_struct.rs:3:10
  |
3 | #[derive(ValueEnum, Clone, Debug)]
  |          ^^^^^^^^^
  |
  = note: this error originates in the derive macro `ValueEnum` (in Nightly builds, run with -Z macro-backtrace for more info)

```

`clap/tests/derive_ui/value_parser_unsupported.rs`:

```rs
use clap::Parser;

#[derive(Parser, Debug)]
struct Cli {
    foo: Custom,
}

#[derive(Clone, Debug)]
struct Custom;

fn main() {
    Cli::parse();
}

```

`clap/tests/derive_ui/value_parser_unsupported.stderr`:

```stderr
error[E0599]: the method `value_parser` exists for reference `&&&&&&_infer_ValueParser_for<Custom>`, but its trait bounds were not satisfied
 --> tests/derive_ui/value_parser_unsupported.rs:5:5
  |
5 |     foo: Custom,
  |     ^^^ method cannot be called on `&&&&&&_infer_ValueParser_for<Custom>` due to unsatisfied trait bounds
...
9 | struct Custom;
  | ------------- doesn't satisfy 7 bounds
  |
 ::: clap_builder/src/builder/value_parser.rs
  |
  | pub struct _infer_ValueParser_for<T>(std::marker::PhantomData<T>);
  | ------------------------------------ doesn't satisfy `_: _impls_FromStr`
  |
  = note: the following trait bounds were not satisfied:
          `Custom: ValueEnum`
          which is required by `&&&&&_infer_ValueParser_for<Custom>: clap::builder::impl_prelude::_impls_ValueEnum`
          `Custom: ValueParserFactory`
          which is required by `&&&&&&_infer_ValueParser_for<Custom>: clap::builder::impl_prelude::_impls_ValueParserFactory`
          `Custom: From<OsString>`
          which is required by `&&&&_infer_ValueParser_for<Custom>: clap::builder::impl_prelude::_impls_From_OsString`
          `Custom: From<&'s std::ffi::OsStr>`
          which is required by `&&&_infer_ValueParser_for<Custom>: clap::builder::impl_prelude::_impls_From_OsStr`
          `Custom: From<std::string::String>`
          which is required by `&&_infer_ValueParser_for<Custom>: clap::builder::impl_prelude::_impls_From_String`
          `Custom: From<&'s str>`
          which is required by `&_infer_ValueParser_for<Custom>: clap::builder::impl_prelude::_impls_From_str`
          `Custom: FromStr`
          which is required by `_infer_ValueParser_for<Custom>: clap::builder::impl_prelude::_impls_FromStr`
note: the traits `From`, `FromStr`, `ValueEnum`,  and `ValueParserFactory` must be implemented
 --> clap_builder/src/builder/value_parser.rs
  |
  | pub trait ValueParserFactory {
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
 ::: clap_builder/src/derive.rs
  |
  | pub trait ValueEnum: Sized + Clone {
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 --> $RUST/core/src/convert/mod.rs
 --> $RUST/core/src/str/traits.rs
  = note: this error originates in the macro `clap::value_parser` (in Nightly builds, run with -Z macro-backtrace for more info)

```

`clap/tests/examples.rs`:

```rs
#[test]
#[cfg(feature = "help")]
#[cfg(feature = "error-context")]
#[cfg(feature = "usage")]
fn example_tests() {
    let t = trycmd::TestCases::new();
    let features = [
        // Default
        #[cfg(feature = "std")]
        "std",
        #[cfg(feature = "color")]
        "color",
        #[cfg(feature = "help")]
        "help",
        #[cfg(feature = "usage")]
        "usage",
        #[cfg(feature = "error-context")]
        "error-context",
        #[cfg(feature = "suggestions")]
        "suggestions",
        // Optional
        #[cfg(feature = "derive")]
        "derive",
        #[cfg(feature = "cargo")]
        "cargo",
        #[cfg(feature = "wrap_help")]
        "wrap_help",
        #[cfg(feature = "env")]
        "env",
        #[cfg(feature = "unicode")]
        "unicode",
        #[cfg(feature = "string")]
        "string",
        // In-work
        //#[cfg(feature = "unstable-v5")]  // Currently has failures
        //"unstable-v5",
    ]
    .join(" ");
    t.register_bins(trycmd::cargo::compile_examples(["--features", &features]).unwrap());
    t.case("examples/**/*.md");
}

```

`clap/tests/macros.rs`:

```rs
mod arg {
    #[test]
    fn name_explicit() {
        let arg = clap::arg!(foo: --bar <NUM>);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_long(), Some("bar"));
        assert_eq!(arg.get_value_names(), Some(vec!["NUM".into()].as_slice()));
        assert!(!arg.is_required_set());
    }

    #[test]
    fn name_from_long() {
        let arg = clap::arg!(--bar <NUM>);
        assert_eq!(arg.get_id(), "bar");
        assert_eq!(arg.get_long(), Some("bar"));
        assert_eq!(arg.get_value_names(), Some(vec!["NUM".into()].as_slice()));
        assert!(!arg.is_required_set());
    }

    #[test]
    fn name_from_value() {
        let arg = clap::arg!(<NUM>);
        assert_eq!(arg.get_id(), "NUM");
        assert_eq!(arg.get_long(), None);
        assert_eq!(arg.get_value_names(), Some(vec!["NUM".into()].as_slice()));
        assert!(arg.is_required_set());
    }

    #[test]
    #[should_panic]
    fn name_none_fails() {
        clap::arg!("Help");
    }

    #[test]
    #[should_panic]
    fn short_only_fails() {
        clap::arg!(-b);
    }

    #[test]
    fn short() {
        let arg = clap::arg!(foo: -b);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: -'b');
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: -b ...);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::Count));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: -b "How to use it");
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(
            arg.get_help().map(|s| s.to_string()),
            Some("How to use it".to_owned())
        );
    }

    #[test]
    fn short_and_long() {
        let arg = clap::arg!(foo: -b --hello);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_long(), Some("hello"));
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: -'b' --hello);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_long(), Some("hello"));
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: -b --hello ...);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_long(), Some("hello"));
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::Count));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: -b --hello "How to use it");
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_long(), Some("hello"));
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(
            arg.get_help().map(|s| s.to_string()),
            Some("How to use it".to_owned())
        );
    }

    #[test]
    fn short_help() {
        let arg = clap::arg!(help: -b);
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));

        let mut cmd = clap::Command::new("cmd")
            .disable_help_flag(true)
            .arg(clap::arg!(help: -b).action(clap::ArgAction::Help));
        cmd.build();
        let arg = cmd
            .get_arguments()
            .find(|arg| arg.get_id() == "help")
            .unwrap();
        assert!(matches!(arg.get_action(), clap::ArgAction::Help));
    }

    #[test]
    fn long_help() {
        let arg = clap::arg!(-'?' - -help);
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));

        let mut cmd = clap::Command::new("cmd")
            .disable_help_flag(true)
            .arg(clap::arg!(-'?' - -help).action(clap::ArgAction::Help));
        cmd.build();
        let arg = cmd
            .get_arguments()
            .find(|arg| arg.get_id() == "help")
            .unwrap();
        assert!(matches!(arg.get_action(), clap::ArgAction::Help));
    }

    #[test]
    fn short_version() {
        let arg = clap::arg!(version: -b);
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));

        let mut cmd = clap::Command::new("cmd")
            .disable_version_flag(true)
            .version("1.0.0")
            .arg(clap::arg!(version: -b).action(clap::ArgAction::Version));
        cmd.build();
        let arg = cmd
            .get_arguments()
            .find(|arg| arg.get_id() == "version")
            .unwrap();
        assert!(matches!(arg.get_action(), clap::ArgAction::Version));
    }

    #[test]
    fn long_version() {
        let arg = clap::arg!(-'?' - -version);
        assert!(matches!(arg.get_action(), clap::ArgAction::SetTrue));

        let mut cmd = clap::Command::new("cmd")
            .disable_version_flag(true)
            .version("1.0.0")
            .arg(clap::arg!(-'?' - -version).action(clap::ArgAction::Version));
        cmd.build();
        let arg = cmd
            .get_arguments()
            .find(|arg| arg.get_id() == "version")
            .unwrap();
        assert!(matches!(arg.get_action(), clap::ArgAction::Version));
    }

    #[test]
    fn short_with_value() {
        let arg = clap::arg!(foo: -b <NUM>);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::Set));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: -'b' <NUM>);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::Set));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: -b  <NUM> ...);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::Append));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: -b  <NUM> "How to use it");
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_short(), Some('b'));
        assert!(matches!(arg.get_action(), clap::ArgAction::Set));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(
            arg.get_help().map(|s| s.to_string()),
            Some("How to use it".to_owned())
        );
    }

    #[test]
    fn positional() {
        let arg = clap::arg!(<NUM>);
        assert_eq!(arg.get_id(), "NUM");
        assert_eq!(arg.get_value_names(), Some(vec!["NUM".into()].as_slice()));
        assert!(matches!(arg.get_action(), clap::ArgAction::Set));
        assert_eq!(arg.get_num_args(), None);
        assert!(arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!([NUM]);
        assert_eq!(arg.get_id(), "NUM");
        assert_eq!(arg.get_value_names(), Some(vec!["NUM".into()].as_slice()));
        assert!(matches!(arg.get_action(), clap::ArgAction::Set));
        assert_eq!(arg.get_num_args(), None);
        assert!(!arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(<NUM>);
        assert_eq!(arg.get_id(), "NUM");
        assert_eq!(arg.get_value_names(), Some(vec!["NUM".into()].as_slice()));
        assert!(matches!(arg.get_action(), clap::ArgAction::Set));
        assert_eq!(arg.get_num_args(), None);
        assert!(arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(foo: <NUM>);
        assert_eq!(arg.get_id(), "foo");
        assert_eq!(arg.get_value_names(), Some(vec!["NUM".into()].as_slice()));
        assert!(matches!(arg.get_action(), clap::ArgAction::Set));
        assert_eq!(arg.get_num_args(), None);
        assert!(arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(<NUM> ...);
        assert_eq!(arg.get_id(), "NUM");
        assert_eq!(arg.get_value_names(), Some(vec!["NUM".into()].as_slice()));
        assert!(matches!(arg.get_action(), clap::ArgAction::Append));
        assert_eq!(arg.get_num_args(), Some((1..).into()));
        assert!(arg.is_required_set());
        assert_eq!(arg.get_help().map(|s| s.to_string()), None);

        let arg = clap::arg!(<NUM> "How to use it");
        assert_eq!(arg.get_id(), "NUM");
        assert_eq!(arg.get_value_names(), Some(vec!["NUM".into()].as_slice()));
        assert!(matches!(arg.get_action(), clap::ArgAction::Set));
        assert_eq!(arg.get_num_args(), None);
        assert!(arg.is_required_set());
        assert_eq!(
            arg.get_help().map(|s| s.to_string()),
            Some("How to use it".to_owned())
        );
    }

    #[test]
    #[cfg(all(feature = "help", feature = "usage"))]
    fn optional_value() {
        let mut cmd = clap::Command::new("test")
            .args_override_self(true)
            .arg(clap::arg!(port: -p [NUM]));

        let r = cmd.try_get_matches_from_mut(["test", "-p42"]);
        assert!(r.is_ok(), "{}", r.unwrap_err());
        let m = r.unwrap();
        assert!(m.contains_id("port"));
        assert_eq!(m.get_one::<String>("port").unwrap(), "42");

        let r = cmd.try_get_matches_from_mut(["test", "-p"]);
        assert!(r.is_ok(), "{}", r.unwrap_err());
        let m = r.unwrap();
        assert!(m.contains_id("port"));
        assert!(m.get_one::<String>("port").is_none());

        let r = cmd.try_get_matches_from_mut(["test", "-p", "24", "-p", "42"]);
        assert!(r.is_ok(), "{}", r.unwrap_err());
        let m = r.unwrap();
        assert!(m.contains_id("port"));
        assert_eq!(m.get_one::<String>("port").unwrap(), "42");

        let help = cmd.render_help().to_string();
        snapbox::assert_data_eq!(
            help,
            snapbox::str![[r#"
Usage: test [OPTIONS]

Options:
  -p [<NUM>]      
  -h, --help      Print help

"#]]
        );
    }
}

mod arg_impl {
    #[test]
    fn string_ident() {
        let expected = "one";
        let actual = clap::arg_impl! { @string one };
        assert_eq!(actual, expected);
    }

    #[test]
    fn string_literal() {
        let expected = "one";
        let actual = clap::arg_impl! { @string "one" };
        assert_eq!(actual, expected);
    }

    #[test]
    fn char_ident() {
        let expected = 'o';
        let actual = clap::arg_impl! { @char o };
        assert_eq!(actual, expected);
    }

    #[test]
    fn char_literal() {
        let expected = 'o';
        let actual = clap::arg_impl! { @char 'o' };
        assert_eq!(actual, expected);
    }

    #[test]
    // allow double quoted dashed arg name in square brackets (e.g ["some-arg"])
    fn arg_name_dashed() {
        let arg = clap::arg!(["some-arg"] "some arg");
        assert_eq!(arg, clap::Arg::new("some-arg").help("some arg"));

        let m = clap::Command::new("flag")
            .arg(arg)
            .try_get_matches_from(vec!["", "some-val"])
            .unwrap();
        assert_eq!(m.get_one::<String>("some-arg").unwrap(), "some-val");
    }

    #[test]
    // allow double quoted dashed arg value in triangle brackets (e.g <"some-val">)
    // test in combination with short argument name (e.g. -v)
    fn arg_value_dashed_with_short_arg() {
        let arg = clap::arg!(-a <"some-val"> "some arg");
        assert_eq!(
            arg,
            clap::Arg::new("some-val")
                .short('a')
                .long("arg")
                .value_name("some-val")
        );

        let m = clap::Command::new("cmd")
            .arg(arg)
            .try_get_matches_from(vec!["", "-a", "val"])
            .unwrap();
        assert_eq!(m.get_one::<String>("some-val").unwrap(), "val");
    }

    #[test]
    // allow double quoted dashed arg value in triangle brackets (e.g <"some-val">)
    // test in combination with long argument name (e.g. --value)
    fn arg_value_dashed_with_long_arg() {
        let arg = clap::arg!(-a --arg <"some-val"> "some arg");
        assert_eq!(
            arg,
            clap::Arg::new("arg")
                .short('a')
                .long("arg")
                .value_name("some-val")
        );

        let m = clap::Command::new("cmd")
            .arg(arg)
            .try_get_matches_from(vec!["", "--arg", "some-val"])
            .unwrap();
        assert_eq!(m.get_one::<String>("arg").unwrap(), "some-val");
    }
}

```

`clap/tests/ui.rs`:

```rs
#[test]
#[cfg(feature = "help")]
#[cfg(feature = "error-context")]
#[cfg(feature = "usage")]
fn ui_tests() {
    let t = trycmd::TestCases::new();
    let features = [
        // Default
        #[cfg(feature = "std")]
        "std",
        #[cfg(feature = "color")]
        "color",
        #[cfg(feature = "help")]
        "help",
        #[cfg(feature = "usage")]
        "usage",
        #[cfg(feature = "error-context")]
        "error-context",
        #[cfg(feature = "suggestions")]
        "suggestions",
        // Optional
        #[cfg(feature = "derive")]
        "derive",
        #[cfg(feature = "cargo")]
        "cargo",
        #[cfg(feature = "wrap_help")]
        "wrap_help",
        #[cfg(feature = "env")]
        "env",
        #[cfg(feature = "unicode")]
        "unicode",
        #[cfg(feature = "string")]
        "string",
        // In-work
        //#[cfg(feature = "unstable-v5")]  // Currently has failures
        //"unstable-v5",
    ]
    .join(" ");
    t.register_bins(trycmd::cargo::compile_examples(["--features", &features]).unwrap());
    t.case("tests/ui/*.toml");
}

```

`clap/tests/ui/V_flag_stdout.toml`:

```toml
bin.name = "stdio-fixture"
args = ["-V"]
status.code = 0
stdout = """
stdio-fixture 1.0
"""
stderr = ""

```

`clap/tests/ui/arg_required_else_help_stderr.toml`:

```toml
bin.name = "stdio-fixture"
args = []
status.code = 2
stdout = ""
stderr = """
Usage: stdio-fixture[EXE] [OPTIONS] [COMMAND]

Commands:
  more  
  help  Print this message or the help of the given subcommand(s)

Options:
      --verbose  log
  -h, --help     Print help (see more with '--help')
  -V, --version  Print version
"""

```

`clap/tests/ui/error_stderr.toml`:

```toml
bin.name = "stdio-fixture"
args = ["--unknown-argument"]
status.code = 2
stdout = ""
stderr = """
error: unexpected argument '--unknown-argument' found

Usage: stdio-fixture[EXE] [OPTIONS] [COMMAND]

For more information, try '--help'.
"""

```

`clap/tests/ui/h_flag_stdout.toml`:

```toml
bin.name = "stdio-fixture"
args = ["-h"]
status.code = 0
stdout = """
Usage: stdio-fixture[EXE] [OPTIONS] [COMMAND]

Commands:
  more  
  help  Print this message or the help of the given subcommand(s)

Options:
      --verbose  log
  -h, --help     Print help (see more with '--help')
  -V, --version  Print version
"""
stderr = ""

```

`clap/tests/ui/help_cmd_stdout.toml`:

```toml
bin.name = "stdio-fixture"
args = ["help"]
status.code = 0
stdout = """
Usage: stdio-fixture[EXE] [OPTIONS] [COMMAND]

Commands:
  more  
  help  Print this message or the help of the given subcommand(s)

Options:
      --verbose
          more log

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version
"""
stderr = ""

```

`clap/tests/ui/help_flag_stdout.toml`:

```toml
bin.name = "stdio-fixture"
args = ["--help"]
status.code = 0
stdout = """
Usage: stdio-fixture[EXE] [OPTIONS] [COMMAND]

Commands:
  more  
  help  Print this message or the help of the given subcommand(s)

Options:
      --verbose
          more log

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version
"""
stderr = ""

```

`clap/tests/ui/version_flag_stdout.toml`:

```toml
bin.name = "stdio-fixture"
args = ["--version"]
status.code = 0
stdout = """
stdio-fixture 1.0 - a2132c
"""
stderr = ""

```

`clap/typos.toml`:

```toml
files.extend-exclude = [
  "CHANGELOG.md",
  "tests",
]
[default.extend-words]
# Acronyms
als = "als"
lits = "lits"

```